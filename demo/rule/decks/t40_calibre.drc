//****************************************************************************************************
//* CALIBRE DRC COMMAND FILE - CN45_10M_7X2Z.13_1a (12/15/2010)
//* FOR TSMC N45LP/LPG,N40LP/LPG,N40G(N45GS) LOGIC/MS/RF 1P10M PROCESS WITH 7X2Z METAL OPTION
//* DRC COMMAND FILE DOCUMENT: T-N45-CL-DR-001-C1 VER 1.3_1a
//* DESIGN RULE DOCUMENT: T-N45-CL-DR-001 VER 1.3_1
//****************************************************************************************************
//************************************************************************************
//* TSMC developed this deck using Mentor Graphics proprietary SVRF and TVF formats.
//* The deck is to be used only in Calibre tools.
//************************************************************************************



//  OPTION SETUP
//================
//#DEFINE SANITY_CHECKER_FOR_PDE_AND_CO_PLACEMENT  //Turn on to check DOD.R.2R/CO.S.7R/OD.DN.4-9R/PO.DN.4-9R for layout effect
#DEFINE GUIDELINE_ESD        // Turn on to check ESD protection guidelines
#DEFINE DATATYPE_WARNING     // Turn on to flag NW/OD/PO warning datatype
//#DEFINE NW_SUGGESTED       // Turn on to use conservative way to check NW.S.3/NW.S.4  
#DEFINE FRONT_END            // Turn on to check Front-End rules
#DEFINE BACK_END             // Turn on to check Back-End rules
#DEFINE FULL_CHIP            // Turn on for chip level design
#DEFINE WITH_SEALRING        // Turn on if sealring is assembled in chip
 //#DEFINE P3_SEALRING       // Turn on if using old sealring (Phase 3) 
 //#DEFINE P3R_SEALRING      // Turn on if using old sealring (Phase 3R)
 //#DEFINE P4_SEALRING       // Turn on if using old sealring (Phase 4)
#DEFINE WITH_POLYIMIDE       // Turn off when process without Polyimide
//#DEFINE SINGLE_PASSIVATION // Turn on for single passivation process  
//#DEFINE COMPATIBLE_MODE    // Turn on if you want to run your product for both N45LP and N40LP process
#DEFINE HALF_NODE          // Turn on for N40LP/LPG process. Turn off for N45LP/LPG process.
#DEFINE GS                 // Turn on for N45GS(N40G) process. Turn off for N45LP/LPG,N40LP/LPG process
#DEFINE eDRAM                // Turn on if using eDRAM process
//#DEFINE AP_20K_THICKNESS   //Turn on for 20K AP-RDL. Turn off for 14.5K AP-RDL.
//#DEFINE AP_28K_THICKNESS   //Turn on for 28K AP-RDL. Turn off for 14.5K AP-RDL.
//#DEFINE AP_36K_THICKNESS   //Turn on for 36K AP-RDL. Turn off for 14.5K AP-RDL.
//#DEFINE MIXED_SCHEME       // Turn on to allow datatype 0 for M(y,z,r,u)/VIA(y,z,r,u) and datatype 1 for DM(y,z,r,u)
#DEFINE CHECK_LOW_DENSITY    // Turn on to check OD/PO/Metal local low density. 
//#DEFINE SKIP_POS2_BOUNDARY // Turn on to skip PO/OD boundary in PO.S.2 check in cell level.
//#DEFINE Mx_S_8_IO_NET      // Turn on to check all I/O metal net in Mx.S.8
//#DEFINE IND_INTER_MET_VIA  // Turn on to allow inter metal/via in inductor
#DEFINE DVIAxR3_For_NonFlipChip  // DVIAx.R.3 is must for Flip-Chip PAD application and also strongly recommended for Non Flip-Chip PAD
			     	 // Turn off can skip DVIAx.R.3 check for Non Flip-Chip PAD application without UBM 
#DEFINE VERTICAL_TCD_PATTERN // Turn on if gate direction in dummy TCDs is vertical. Turn off for horizontal.
//#DEFINE CYBER_SHUTTLE      // Turn on to check DTCD.R.5 for cyber shuttle.
//#DEFINE ICOVL              // Turn on to check ICOVL (In Chip Overlay) Rules
//#DEFINE TSMC_ROTATE        // Turn on if you know your tapeout will be rotated in TSMC
#DEFINE CHECK_LATCHUP_BY_PAD_CONNECTION // Turn off to disable PAD connection method for Latch-Up rule check.
//#DEFINE DISCONNECT_ALL_RESISTOR  // Turn on to disconnect all resistors between pad and device for Latch-Up rule check.
//#DEFINE CONNECT_ALL_RESISTOR     // Turn on to connect all resistors between pad and device for Latch-Up rule check.
//#DEFINE DEFINE_PAD_BY_TEXT // Turn on to recognize IO PAD by following text  
VARIABLE PAD_TEXT  "?"       // pin name of PAD
VARIABLE VDD_TEXT  "VDD?"    // pin name of VDD
VARIABLE VSS_TEXT  "VSS?"    // pin name of VSS
//#DEFINE CHECK_FLOATING_GATE_BY_TEXT // Turn on to waive PO.R.8 false error in cell or chip with empty IP by following text
VARIABLE IP_PIN_TEXT  "?"    // pin name of IP 
//#DEFINE ChipWindowUsed  // Turn on to specify chip boundary directly by following variables  
VARIABLE xLB   0.0        // x-coordinate of left-bottom corner for user defined chip window 
VARIABLE yLB   0.0        // y-coordinate of left-bottom corner for user defined chip window 
VARIABLE xRT   1000.0     // x-coordinate of right-top corner for user defined chip window  
VARIABLE yRT   1000.0     // y-coordinate of right-top corner for user defined chip window 

//  OPTION SETUP OF DFM RULES
//===============================
//#DEFINE DFM               // Turn on to check DFM rules
//#DEFINE DFM_ONLY          // Turn on to check DFM rules only
 #DEFINE Required           // Turn on to check Action-Required rules
 #DEFINE Recommended        // Turn on to check Recommendations
    #DEFINE First_priority  // Turn on to check First priority recommendations  
    #DEFINE Parametric      // Turn on to check SPICE related recommendations 
    #DEFINE Systematic      // Turn on to check Systematic related recommendations
    #DEFINE Defect          // Turn on to check Defect related recommendations
 #DEFINE Analog             // Turn on to check Analog Recommendations(must select by layer RRuleAnalog or cell CellsForRRuleAnalog)
 #DEFINE Guideline          // Turn on to check Guidelines

VARIABLE CellsForRRuleRequired "*"         // include cell in Action-Required rules check 
VARIABLE CellsForRRuleRecommended "*"      // include cell in Recommendations check
VARIABLE CellsForRRuleAnalog " "           // include cell in Analog rules check (default is empty)
VARIABLE CellsForRRuleGuideline "*"        // include cell in Guidleline check
VARIABLE ExclCellsForRRuleRequired " "     // exclude cell from Action-Required rules check
VARIABLE ExclCellsForRRuleRecommended " "  // exclude cell from Recommendations check
VARIABLE ExclCellsForRRuleAnalog " "       // exclude cell from Analog rules check
VARIABLE ExclCellsForRRuleGuideline " "    // exclude cell from Guideline check

// Action-required rules
//===================================
  #DEFINE _POEX2_
  #DEFINE _POS5_
  #DEFINE _POS6_
// Recommendations 
//===============================
  #DEFINE _ODW1_        // SPICE related
  #DEFINE _ODS1_        // Defect related
  #DEFINE _ODS6_        // Systematic related
  #DEFINE _ODDN4_       // SPICE related
  #DEFINE _ODDN5_       // SPICE related
  #DEFINE _ODDN6_       // SPICE related
  #DEFINE _ODDN7_       // SPICE related
  #DEFINE _ODDN8_       // SPICE related
  #DEFINE _ODDN9_       // SPICE related
  #DEFINE _DODR2_       // SPICE related 
  #DEFINE _SRDODS3_     // Systematic Others
  #DEFINE _SRDODDN1_    // 1st priority related
  #DEFINE _DNWEN1_      // Systematic related
  #DEFINE _NWRODS3_     // SPICE related
  #DEFINE _NWRSTIEN2_   // SPICE related
  #DEFINE _POS1_        // Defect related
  #DEFINE _POS2_        // Systematic and SPICE related (for LP only)
  #DEFINE _POS4_1_      // SPICE related
  #DEFINE _POS17_       // Systematic and SPICE related 
  #DEFINE _POS18_       // SPICE related (for GS only)  
  #DEFINE _POEX1_       // Systematic and SPICE related
  #DEFINE _PODN4_       // SPICE related
  #DEFINE _PODN5_       // SPICE related 
  #DEFINE _PODN6_       // SPICE related
  #DEFINE _PODN7_       // SPICE related
  #DEFINE _PODN8_       // SPICE related
  #DEFINE _PODN9_       // SPICE related
  #DEFINE _SRDPOS1_     // Systematic SPICE  
  #DEFINE _SRDPOL1_     // Systematic Litho,OPC
  #DEFINE _SRDPOL3_     // Systematic Litho, OPC
  #DEFINE _SRDPODN1_    // 1st priority related
  #DEFINE _ESDIMPEN1_   // Systematic related
  #DEFINE _COS3_        // Systematic and Defect related
  #DEFINE _COEN1_       // Systematic and SPICE related
  #DEFINE _COEN11_      // Systematic and SPICE related
  #DEFINE _COEN3_       // Systematic and SPICE related
  #DEFINE _COS7_        // SPICE related
  #DEFINE _M1S1_        // Defect related
  #DEFINE _M1S7_        // Systematic related
  #DEFINE _M1A1_        // Systematic and Defect related
  #DEFINE _M1EN1_M1EN2_ // 1st priority, Systematic, and SPICE related
  #DEFINE _M1EN5_       // Defect related
  #DEFINE _M1DN6_     // Systematic related
  #DEFINE _VIA1EN1_VIA1EN2_    // 1st priority, Systematic, and SPICE related
  #DEFINE _M2S1_               // Defect related
  #DEFINE _M2S7_               // Systematic related
  #DEFINE _M2A1_               // Systematic and Defect related
  #DEFINE _M2EN1_M2EN2_        // 1st priority, Systematic, and SPICE related
  #DEFINE _M2DN6_              // Systematic related

  #DEFINE _VIA2EN1_VIA2EN2_    // 1st priority, Systematic, and SPICE related
  #DEFINE _M3S1_               // Defect related
  #DEFINE _M3S7_               // Systematic related
  #DEFINE _M3A1_               // Systematic and Defect related
  #DEFINE _M3EN1_M3EN2_        // 1st priority, Systematic, and SPICE related
  #DEFINE _M3DN6_              // Systematic related
  #DEFINE _MxDN7_M1_M2_M3_    // Systematic related

  #DEFINE _VIA3EN1_VIA3EN2_    // 1st priority, Systematic, and SPICE related
  #DEFINE _M4S1_               // Defect related
  #DEFINE _M4S7_               // Systematic related
  #DEFINE _M4A1_               // Systematic and Defect related
  #DEFINE _M4EN1_M4EN2_        // 1st priority, Systematic, and SPICE related
  #DEFINE _M4DN6_              // Systematic related
  #DEFINE _MxDN7_M2_M3_M4_    // Systematic related

  #DEFINE _VIA4EN1_VIA4EN2_    // 1st priority, Systematic, and SPICE related
  #DEFINE _M5S1_               // Defect related
  #DEFINE _M5S7_               // Systematic related
  #DEFINE _M5A1_               // Systematic and Defect related
  #DEFINE _M5EN1_M5EN2_        // 1st priority, Systematic, and SPICE related
  #DEFINE _M5DN6_              // Systematic related
  #DEFINE _MxDN7_M3_M4_M5_    // Systematic related

  #DEFINE _VIA5EN1_VIA5EN2_    // 1st priority, Systematic, and SPICE related
  #DEFINE _M6S1_               // Defect related
  #DEFINE _M6S7_               // Systematic related
  #DEFINE _M6A1_               // Systematic and Defect related
  #DEFINE _M6EN1_M6EN2_        // 1st priority, Systematic, and SPICE related
  #DEFINE _M6DN6_              // Systematic related
  #DEFINE _MxDN7_M4_M5_M6_    // Systematic related

  #DEFINE _VIA6EN1_VIA6EN2_    // 1st priority, Systematic, and SPICE related
  #DEFINE _M7S1_               // Defect related
  #DEFINE _M7S7_               // Systematic related
  #DEFINE _M7A1_               // Systematic and Defect related
  #DEFINE _M7EN1_M7EN2_        // 1st priority, Systematic, and SPICE related
  #DEFINE _M7DN6_              // Systematic related
  #DEFINE _MxDN7_M5_M6_M7_    // Systematic related

  #DEFINE _VIA7EN1_VIA7EN2_    // 1st priority, Systematic, and SPICE related
  #DEFINE _M8S1_               // Defect related
  #DEFINE _M8S7_               // Systematic related
  #DEFINE _M8A1_               // Systematic and Defect related
  #DEFINE _M8EN1_M8EN2_        // 1st priority, Systematic, and SPICE related
  #DEFINE _M8DN6_              // Systematic related
  #DEFINE _MxDN7_M6_M7_M8_    // Systematic related

  #DEFINE _VIAxR8_             // Systematic related
  #DEFINE _MxDN8_              // 1st priority related
  #DEFINE _M9W3_               // Systematic related
  #DEFINE _M10W3_               // Systematic related
  #DEFINE _ROMR3_              // 1st priority related
  #DEFINE _DTCDDN1_ 
   

// Analog Recommendations 
//==========================
  #DEFINE _POS14m_
  #DEFINE _POEN1m_
  #DEFINE _POEN2m_
  #DEFINE _POEN3m_
  #DEFINE _POS5m_
  #DEFINE _POS6m_
  #DEFINE _POS61m_
  #DEFINE _POEX1m_
  #DEFINE _BJTR2_
  #DEFINE _BJTR7_
  #DEFINE _ANR17_
  #DEFINE _ANR20_
// Guidelines 
//==========================
  #DEFINE _NWR1_            
  #DEFINE _DNWR6_           
  #DEFINE _NWRODR3_NWRSTIR3_
  #DEFINE _RESR15_           
  #DEFINE _COS6_            
  #DEFINE _COR5_             
  #DEFINE _VIA1R9_                               
  #DEFINE _VIA2R9_                               
  #DEFINE _VIA3R9_                               
  #DEFINE _VIA4R9_                               
  #DEFINE _VIA5R9_                               
  #DEFINE _VIA6R9_                               
  #DEFINE _VIA7R9_                               
  #DEFINE _VIA8R5_   
  #DEFINE _VIA9R5_   




// ENVIRONMENT SETUP
//---------------------

PRECISION    1000
RESOLUTION      5    // For 0.005um layout grid  

LAYOUT SYSTEM GDSII
LAYOUT PATH "GDSFILENAME"
LAYOUT PRIMARY "TOPCELLNAME"

DRC RESULTS DATABASE "DRC_RES.db"
DRC SUMMARY REPORT "DRC.rep"  // HIER
DRC KEEP EMPTY NO
DRC CHECK TEXT ALL
DRC MAXIMUM RESULTS ALL
//DRC INCREMENTAL CONNECT YES

FLAG OFFGRID YES     // For layout grid check. default grid value is resolution size
FLAG ACUTE YES
FLAG SKEW YES
FLAG NONSIMPLE YES
//LAYOUT ALLOW DUPLICATE CELL YES
//LAYOUT ERROR ON INPUT NO
LAYOUT PROCESS BOX RECORD YES


//OPTION DEPENDENCE
//=========================

#IFDEF FULL_CHIP
#DEFINE CHECK_LOW_DENSITY
#ENDIF

#IFDEF GS
#DEFINE HALF_NODE
#ENDIF

#IFDEF HALF_NODE
#IFNDEF GS
#DEFINE WIDE_ADJUST
#ENDIF
#ENDIF

#IFDEF P3_SEALRING
#DEFINE OLD_SEALRING
#ENDIF
#IFDEF P3R_SEALRING
#DEFINE OLD_SEALRING
#ENDIF

#IFDEF DFM_ONLY
#DEFINE DFM
#ENDIF

#IFDEF DEFINE_PAD_BY_TEXT
#DEFINE CHECK_LATCHUP_BY_PAD_CONNECTION 
#ENDIF

//RULES VALUE VARIABLES
//=======================
VARIABLE METAL_LOW_DEN_WINDOW_SIZE 125
VARIABLE METAL_LOW_DEN_WINDOW_STEP 62.5
VARIABLE METAL_HIGH_DEN_WINDOW_SIZE 125
VARIABLE METAL_HIGH_DEN_WINDOW_STEP 62.5



VARIABLE  GRID      0.005
VARIABLE  BIG_AREA  4000000

VARIABLE  DNW_W_1   3.0 
VARIABLE  DNW_S_1   3.5 
VARIABLE  DNW_S_2   2.5 
VARIABLE  DNW_S_3   1.65 
VARIABLE  DNW_S_4   0.8
VARIABLE  DNW_S_5   1.0
VARIABLE  DNW_EN_3  0.48
VARIABLE  DNW_O_1   0.4 

VARIABLE  OD_W_1    0.06 
VARIABLE  OD_W_2    0.12 
VARIABLE  OD_W_2_1  10.0 
#IFDEF GS
VARIABLE  OD_W_2_2  1.50 
#ENDIF
VARIABLE  OD_W_3    0.32
VARIABLE  OD_W_4    0.17
VARIABLE  OD_S_1    0.08 
VARIABLE  OD_S_2    0.15 
VARIABLE  OD_S_3    0.10
VARIABLE  OD_S_3_L  0.14 
VARIABLE  OD_S_3_W  0.12 
VARIABLE  OD_S_3_1    0.11
VARIABLE  OD_S_3_1_L  0.14
VARIABLE  OD_S_3_1_W  0.12
VARIABLE  OD_S_4    0.17
VARIABLE  OD_S_5    0.15 
VARIABLE  OD_A_1    0.035
VARIABLE  OD_A_1_W  0.06
VARIABLE  OD_A_1_L  0.26
VARIABLE  OD_A_2    0.055
VARIABLE  OD_A_2_L  0.21
VARIABLE  OD_A_3    0.04 
VARIABLE  OD_A_4    0.077 
VARIABLE  OD_A_4_L  0.21 
#IFDEF GS
VARIABLE  OD_A_5    300
VARIABLE  OD_A_5_S1 0.22
VARIABLE  OD_A_5_S2 0.08
#ENDIF
#IFNDEF WIDE_ADJUST
VARIABLE  OD_L_1    0.4
VARIABLE  OD_L_2    60  
#ELSE
VARIABLE  OD_L_1    0.44
VARIABLE  OD_L_2    66  
#ENDIF
VARIABLE  OD_L_1_W  0.12
VARIABLE  OD_L_2_W  0.12  
VARIABLE  OD_DN_1    0.25
VARIABLE  OD_DN_1_1  0.75
VARIABLE  OD_DN_2    0.2
VARIABLE  OD_DN_2_W  150
VARIABLE  OD_DN_2_S  75
VARIABLE  OD_DN_2_E  37.5
VARIABLE  OD_DN_2_1 0.8
VARIABLE  OD_DN_2_1_W 150
VARIABLE  OD_DN_2_1_S 75
VARIABLE  OD_DN_2_1_E 37.5
VARIABLE  OD_DN_2_2 0.9
VARIABLE  OD_DN_2_2_W 150
VARIABLE  OD_DN_2_2_S 75
VARIABLE  OD_DN_2_2_E 37.5
VARIABLE  OD_DN_3 0.2
VARIABLE  OD_DN_3_W 150
VARIABLE  OD_DN_3_S 75
VARIABLE  OD_DN_3_E 37.5
VARIABLE  OD_DN_3_1 0.8
VARIABLE  OD_DN_3_1_W 150
VARIABLE  OD_DN_3_1_S 75
VARIABLE  OD_DN_3_1_E 37.5
VARIABLE  OD_DN_3_2 0.9
VARIABLE  OD_DN_3_2_W 150
VARIABLE  OD_DN_3_2_S 75
VARIABLE  OD_DN_3_2_E 37.5

VARIABLE  ODRZ_X    0.11
VARIABLE  ODRZ_Y    0.08
VARIABLE  ODRZ_S    0.16

VARIABLE  SRDOD_W_1     0.1
VARIABLE  SRDOD_W_2	0.5
VARIABLE  SRDOD_S_1     0.12
VARIABLE  SRDOD_S_1_1   0.12
VARIABLE  SRDOD_S_2     0.05
VARIABLE  SRDOD_S_3     0.03
VARIABLE  SRDOD_S_4     0.17
VARIABLE  SRDOD_S_5     0.15
VARIABLE  SRDOD_S_6R    0.35
VARIABLE  SRDOD_S_7     0.08
VARIABLE  SRDOD_S_8     0.60
VARIABLE  SRDOD_S_9     0.00
VARIABLE  SRDOD_S_10    1.20
VARIABLE  SRDOD_S_11    0.14
VARIABLE  SRDOD_EN_1    0.08 
VARIABLE  SRDOD_EN_2    0.60 
VARIABLE  SRDOD_A_1     0.05
VARIABLE  SRDOD_A_1_W   0.06
VARIABLE  SRDOD_A_1_L   0.26
VARIABLE  SRDOD_A_3     0.04
VARIABLE  SRDOD_A_4     0.077
VARIABLE  SRDOD_A_4_L   0.21
VARIABLE  SRDOD_L_1	0.5
VARIABLE  SRDOD_L_2	10

VARIABLE  NW_W_1    0.34 
VARIABLE  NW_S_1    0.34 
VARIABLE  NW_S_2    0.80 
VARIABLE  NW_S_3    1.0 
VARIABLE  NW_S_4    1.0 
VARIABLE  NW_S_5    0.08
VARIABLE  NW_S_6    0.08
VARIABLE  NW_S_6_1  0.16 
VARIABLE  NW_S_7    0.22
VARIABLE  NW_EN_1   0.08
VARIABLE  NW_EN_2   0.08
VARIABLE  NW_EN_2_1 0.16
VARIABLE  NW_EN_3   0.22
VARIABLE  NW_A_1    0.64 
VARIABLE  NW_A_2    0.64 

VARIABLE  NWROD_W_1   1.8 
VARIABLE  NWROD_S_1   1.0
VARIABLE  NWROD_S_2   0.3 
VARIABLE  NWROD_EN_1  1.0 
VARIABLE  NWROD_EN_2  0.3 
VARIABLE  NWROD_O_1   0.4 
VARIABLE  NWRSTI_W_1  1.8 
VARIABLE  NWRSTI_S_1  1.0
VARIABLE  NWRSTI_EN_1 0.4 
VARIABLE  NWRSTI_EN_2 0.3 
VARIABLE  NWRSTI_EN_3 0.3 
VARIABLE  NWRSTI_EX_1 0.3 
VARIABLE  NWROD_R_1_L_M	20
VARIABLE  NWROD_R_1_W_M	1.8
VARIABLE  NWROD_R_1_S_M	5
VARIABLE  NWRSTI_R_1_L_M 20	
VARIABLE  NWRSTI_R_1_W_M 1.8
VARIABLE  NWRSTI_R_1_S_M 5

VARIABLE  NTN_W_1    0.34 
VARIABLE  NTN_W_2    0.30
VARIABLE  NTN_W_3    1.20 
VARIABLE  NTN_W_4    0.8 
VARIABLE  NTN_W_5    0.5 
VARIABLE  NTN_S_1    0.34 
VARIABLE  NTN_S_2    0.38 
VARIABLE  NTN_S_3    1.0 
VARIABLE  NTN_EN_1   0.26
VARIABLE  NTN_EX_1   0.35 
VARIABLE  NTN_A_1    0.64 
VARIABLE  NTN_A_2    0.64 

VARIABLE  OD2_W_1     0.34 
VARIABLE  OD2_W_2     0.34
VARIABLE  OD2_S_1     0.34 
VARIABLE  OD2_S_2     0.20 
VARIABLE  OD2_S_3     0.25
VARIABLE  OD2_S_4     0.34 
VARIABLE  OD2_S_5     0.34
VARIABLE  OD2_S_6     0.34
VARIABLE  OD2_S_7     0.34
VARIABLE  OD2_EN_1    0.25 
VARIABLE  OD2_EX_1    0.34 
VARIABLE  OD2_EX_2    0.34 
VARIABLE  OD2_EX_3    0.20 
VARIABLE  OD2_O_1     0.34 

VARIABLE  DCO_W_1     0.34
VARIABLE  DCO_W_2     0.34
VARIABLE  DCO_S_1     0.34
VARIABLE  DCO_S_2     0.05
VARIABLE  DCO_S_3     0.16
VARIABLE  DCO_S_4     0.09
VARIABLE  DCO_S_5     0.34
VARIABLE  DCO_S_6     0.34
VARIABLE  DCO_S_8     0.34
VARIABLE  DCO_S_9     0.34
VARIABLE  DCO_S_10    0.34
VARIABLE  DCO_EN_1    0.16
VARIABLE  DCO_EN_2    0.09
VARIABLE  DCO_EX_1    0.34
VARIABLE  DCO_EX_2    0.34
VARIABLE  DCO_EX_3    0.05
VARIABLE  DCO_A_1     0.7
VARIABLE  DCO_A_2     0.7
VARIABLE  DCO_O_1     0.34

VARIABLE  OD12_W_1     0.34
VARIABLE  OD12_W_3     0.07
VARIABLE  OD12_S_1     0.34
VARIABLE  OD12_S_2     0.05
VARIABLE  OD12_S_3     0.16
VARIABLE  OD12_S_4     0.09
VARIABLE  OD12_S_6     0.18
VARIABLE  OD12_EN_1    0.16
VARIABLE  OD12_EN_2    0.09
VARIABLE  OD12_EX_3    0.05
VARIABLE  OD12_A_1     0.64
VARIABLE  OD12_A_2     0.64
VARIABLE  OD12_R_4     0.14


#IFDEF COMPATIBLE_MODE
VARIABLE  OD25_33_W_1 0.55
VARIABLE  OD25_33_W_2 0.44
#ELSE
#IFDEF HALF_NODE
VARIABLE  OD25_33_W_1 0.55
VARIABLE  OD25_33_W_2 0.44
#ELSE
VARIABLE  OD25_33_W_1 0.50
VARIABLE  OD25_33_W_2 0.40
#ENDIF
#ENDIF
#IFDEF GS
VARIABLE  OD25_18_W_1GS 0.27
#ENDIF
VARIABLE  OD25_18_W_1 0.25

VARIABLE  OD25_33_W_3 1.2
VARIABLE  OD25_18_W_2 1.2

#IFDEF GS
VARIABLE  OD18_15_W_1 0.105
#ELSE
VARIABLE  OD18_15_W_1 0.125
#ENDIF

VARIABLE  PO_W_1        0.04 
VARIABLE  PO_W_2        0.27
VARIABLE  PO_W_3        0.42

VARIABLE  PO_W_4        0.15
#IFDEF GS
VARIABLE  PO_W_6A       0.04
VARIABLE  PO_W_6B       0.045
VARIABLE  PO_W_6C       0.05
VARIABLE  PO_W_6D       0.06
VARIABLE  PO_W_6E       0.07
VARIABLE  PO_W_6F       0.08
VARIABLE  PO_W_6G       10
#ENDIF
VARIABLE  PO_W_7        0.17
#IFNDEF GS
VARIABLE  PO_W_8        10
#ENDIF
VARIABLE  PO_S_1        0.10 
#IFDEF GS
VARIABLE  PO_S_2_W      0.08
VARIABLE  PO_S_2A      0.14
VARIABLE  PO_S_2B      0.16
VARIABLE  PO_S_2C      0.20
VARIABLE  PO_S_2_1      0.14
VARIABLE  PO_S_2_1_W    0.08
VARIABLE  PO_S_2_1_1    0.32
VARIABLE  PO_S_2_1_1_W  0.08
#ELSE
VARIABLE  PO_S_2_W      0.06
#IFDEF COMPATIBLE_MODE
VARIABLE  PO_S_2A     0.13
#ELSE
#IFDEF HALF_NODE
VARIABLE  PO_S_2A     0.13
#ELSE
VARIABLE  PO_S_2A     0.12
#ENDIF
#ENDIF
VARIABLE  PO_S_2B     0.22   
VARIABLE  PO_S_2C     0.32   
VARIABLE  PO_S_2_1      0.14   
VARIABLE  PO_S_2_1_W    0.06 
#ENDIF
VARIABLE  PO_S_3        0.22
VARIABLE  PO_S_4        0.03
VARIABLE  PO_S_4_1      0.11 
VARIABLE  PO_S_4_1_A    0.0121
VARIABLE  PO_S_6        0.04
VARIABLE  PO_S_6_L      0.06
VARIABLE  PO_S_6_1      0.05
VARIABLE  PO_S_6_1_L1   0.06
VARIABLE  PO_S_6_1_L2   0.1
VARIABLE  PO_S_7        0.16 
VARIABLE  PO_S_7_L      0.14 
VARIABLE  PO_S_7_W      0.12 
VARIABLE  PO_S_9        0.18 
VARIABLE  PO_S_10       0.11 
VARIABLE  PO_S_10_Q     0.07 
VARIABLE  PO_S_10_E     0.035
VARIABLE  PO_S_10_L	0.04
VARIABLE  PO_S_15       1.0
VARIABLE  PO_S_15_W1     0.08
VARIABLE  PO_S_15_A     630
VARIABLE  PO_S_15_D     0.7   // density
VARIABLE  PO_S_15_W2     30    // window size  
VARIABLE  PO_S_15_S     15    // window step
VARIABLE  PO_S_16       0.17
VARIABLE  PO_EX_1       0.09
VARIABLE  PO_EX_2       0.09
VARIABLE  PO_EX_3       0.11
VARIABLE  PO_EX_3_S     0.10
VARIABLE  PO_EX_3_J     0.02
#IFNDEF WIDE_ADJUST
VARIABLE  PO_L_1        18.0
#ELSE
VARIABLE  PO_L_1        19.8
#ENDIF
VARIABLE  PO_L_1_W      0.08
VARIABLE  PO_L_2        0.26
VARIABLE  PO_A_1        0.022
VARIABLE  PO_A_1_L      0.3
VARIABLE  PO_A_2        0.055
VARIABLE  PO_A_2_L      0.21
VARIABLE  PO_A_3        0.04
VARIABLE  PO_A_4        0.077
VARIABLE  PO_A_4_L      0.21
VARIABLE  PO_DN_1  	0.14
VARIABLE  PO_DN_1_1     0.40
VARIABLE  PO_DN_2       0.001 
VARIABLE  PO_DN_2_W     20
VARIABLE  PO_DN_2_S     10
VARIABLE  PO_DN_2_E     5
VARIABLE  PO_DN_3       0.14
VARIABLE  PO_R_6_S      0.43
VARIABLE  PO_R_6_W1      0.10
VARIABLE  PO_R_6_W2      0.25
VARIABLE  PO_R_6_L      0.065

VARIABLE  SRDPO_W_1     0.04 
VARIABLE  SRDPO_W_2     0.10 
VARIABLE  SRDPO_W_6     0.17 
VARIABLE  SRDPO_S_1     0.10 
VARIABLE  SRDPO_S_2     0.14 
VARIABLE  SRDPO_S_3     0.22
VARIABLE  SRDPO_S_4     0.03
VARIABLE  SRDPO_S_9     0.18 
VARIABLE  SRDPO_S_16    0.17 
VARIABLE  SRDPO_S_17    0.05 
VARIABLE  SRDPO_S_18    0.38 
VARIABLE  SRDPO_S_19    0.04 
VARIABLE  SRDPO_S_20    0.08 
VARIABLE  SRDPO_EN_1    0.01 
VARIABLE  SRDPO_EN_2    0.02 
VARIABLE  SRDPO_EX_1    0.09 
VARIABLE  SRDPO_EX_2    0.03 
VARIABLE  SRDPO_L_2     0.26
VARIABLE  SRDPO_A_1     0.022
VARIABLE  SRDPO_A_1_L   0.3
VARIABLE  SRDPO_A_2     0.055
VARIABLE  SRDPO_A_2_L   0.21
VARIABLE  SRDPO_A_3     0.04
VARIABLE  SRDPO_A_4     0.077
VARIABLE  SRDPO_A_4_L   0.21

VARIABLE  VTHN_W_1   0.18
VARIABLE  VTHN_S_1   0.18 
VARIABLE  VTHN_S_2   0.08
VARIABLE  VTHN_S_2_1 0.14 
VARIABLE  VTHN_S_3   0.18   
VARIABLE  VTHN_EN_1  0.14 
VARIABLE  VTHN_EN_2  0.08
VARIABLE  VTHN_A_1   0.19 
VARIABLE  VTHN_A_2   0.19 
VARIABLE  VTHN_R_3   0.14
VARIABLE  VTHN_L_1   0.50
VARIABLE  VTHP_W_1   0.18
VARIABLE  VTHP_S_1   0.18
VARIABLE  VTHP_S_2   0.08
VARIABLE  VTHP_S_2_1 0.14
VARIABLE  VTHP_S_3   0.18
VARIABLE  VTHP_EN_1  0.14
VARIABLE  VTHP_EN_2  0.08
VARIABLE  VTHP_A_1   0.19
VARIABLE  VTHP_A_2   0.19
VARIABLE  VTHP_R_3   0.14
VARIABLE  VTHP_L_1   0.50
VARIABLE  VTLN_W_1   0.18   
VARIABLE  VTLN_S_1   0.18 
VARIABLE  VTLN_S_2   0.08
VARIABLE  VTLN_S_2_1 0.14 
VARIABLE  VTLN_S_3   0.18 
VARIABLE  VTLN_EN_1  0.14 
VARIABLE  VTLN_EN_2  0.08
VARIABLE  VTLN_A_1   0.19 
VARIABLE  VTLN_A_2   0.19 
VARIABLE  VTLN_R_3   0.14
VARIABLE  VTLN_L_1   0.50
VARIABLE  VTLP_W_1   0.18  
VARIABLE  VTLP_S_1   0.18 
VARIABLE  VTLP_S_2   0.08
VARIABLE  VTLP_S_2_1 0.14
VARIABLE  VTLP_S_3   0.18   
VARIABLE  VTLP_EN_1  0.14 
VARIABLE  VTLP_EN_2  0.08
VARIABLE  VTLP_A_1   0.19 
VARIABLE  VTLP_A_2   0.19
VARIABLE  VTLP_R_3   0.14
VARIABLE  VTLP_L_1   0.50


VARIABLE VTLN18_W_1    0.2
VARIABLE VTLN18_W_1_1  1.2
VARIABLE VTLN18_W_1_2  0.11
VARIABLE VTLN18_W_2    0.54
VARIABLE VTLN18_W_3    1
VARIABLE VTLN18_S_1    0.22
VARIABLE VTLN18_S_2    0.22
VARIABLE VTLN18_S_3    0.08
VARIABLE VTLN18_S_4    0.03
VARIABLE VTLN18_EN_1   0.1
VARIABLE VTLN18_EN_2   0.52
VARIABLE VTLN18_EN_3   0.19
VARIABLE VTLN18_EN_4   0
VARIABLE VTLN18_EX_1   0.09

VARIABLE  PP_W_1   0.18
VARIABLE  PP_S_1   0.18
VARIABLE  PP_S_2   0.08
VARIABLE  PP_S_4   0.02 
VARIABLE  PP_S_5   0.23 
VARIABLE  PP_S_6   0.23 
VARIABLE  PP_S_6_J 0.13 
VARIABLE  PP_S_7   0.14 
VARIABLE  PP_EN_1  0.11 
VARIABLE  PP_EX_1  0.08
VARIABLE  PP_EX_2  0.02 
VARIABLE  PP_EX_3  0.14 
VARIABLE  PP_EX_4  0.23 
VARIABLE  PP_O_1   0.10 
VARIABLE  PP_A_1   0.11 
VARIABLE  PP_A_2   0.11 
VARIABLE  PP_A_3   0.021 
VARIABLE  PP_R_1   0.08
VARIABLE  PP_L_1   0.50

VARIABLE  NP_W_1   0.18
VARIABLE  NP_S_1   0.18
VARIABLE  NP_S_2   0.08
VARIABLE  NP_S_4   0.02 
VARIABLE  NP_S_5   0.23 
VARIABLE  NP_S_6   0.23 
VARIABLE  NP_S_6_J 0.13
VARIABLE  NP_S_7   0.14 
VARIABLE  NP_EN_1  0.11
VARIABLE  NP_EX_1  0.08
VARIABLE  NP_EX_2  0.02 
VARIABLE  NP_EX_3  0.14 
VARIABLE  NP_EX_4  0.23 
VARIABLE  NP_O_1   0.10
VARIABLE  NP_A_1   0.11 
VARIABLE  NP_A_2   0.11 
VARIABLE  NP_A_3   0.021 
VARIABLE  NP_R_1   0.08
VARIABLE  NP_L_1   0.50

VARIABLE  LDN_EX_1  0.18 
VARIABLE  LDP_EX_1  0.18 
VARIABLE  LDP_EX_2  0.18 
VARIABLE  LDN_O_1   0.18 
VARIABLE  LDP_O_2   0.18 
VARIABLE  VT_S_1    0.18 
VARIABLE  VT_EX_2   0.18 

VARIABLE  ESDIMP_W_1  0.5 
VARIABLE  ESDIMP_S_1  0.5 
VARIABLE  ESDIMP_EN_1 0.4 
VARIABLE  ESDIMP_A_1  1.0 
VARIABLE  ESDIMP_A_2  1.0 

VARIABLE  RPO_W_1    0.4 
VARIABLE  RPO_S_1    0.4 
VARIABLE  RPO_S_2    0.22 
VARIABLE  RPO_S_3    0.22 
VARIABLE  RPO_S_4    0.38 
VARIABLE  RPO_S_5    0.30
VARIABLE  RPO_EX_1   0.22 
VARIABLE  RPO_EX_1_1   0.30 
VARIABLE  RPO_EX_1_1_W 10.0 
VARIABLE  RPO_EX_1_2   0.30 
VARIABLE  RPO_EX_1_2_W 0.43
VARIABLE  RPO_EX_2   0.22 
VARIABLE  RPO_A_1    1.00 
VARIABLE  RPO_A_2    1.00

VARIABLE  RES_W_1    0.4
VARIABLE  RES_L_1    0.4
VARIABLE  RES_R_1    1.0
VARIABLE  RES_S_1    0.16
VARIABLE  RES_S_2    0.08
VARIABLE  RES_EN_1   0.19

VARIABLE  VAR_W_1    0.20
VARIABLE  VAR_W_3    0.40
VARIABLE  VAR_W_4    0.32
VARIABLE  VAR_W_5    0.35
VARIABLE  VAR_S_1    0.13
VARIABLE  VAR_EN_1   0.16
VARIABLE  VAR_R_4    0.16
VARIABLE  VAR_R_5_X  0.19
VARIABLE  VAR_R_5_Y  0.13
VARIABLE  VAR_R_5_1_X  0.19
VARIABLE  VAR_R_5_1_Y  0.13
VARIABLE  VAR_A_1      25

VARIABLE  HVD_N_W_1     0.47 
VARIABLE  HVD_N_S_1     0.47 
VARIABLE  HVD_N_S_2     1.37 
VARIABLE  HVD_N_S_3     1.6 
VARIABLE  HVD_N_S_4     0.3
VARIABLE  HVD_N_S_5     0.6 
VARIABLE  HVD_N_S_6     3.0
VARIABLE  HVD_N_EX_1    0.24
#IFDEF HALF_NODE
VARIABLE  HVD_N_O_1     0.33
VARIABLE  HVD_N_L_1     0.875
#ELSE
VARIABLE  HVD_N_O_1     0.3
VARIABLE  HVD_N_L_1     0.8
#ENDIF
VARIABLE  HVD_N_A_1     0.64 
VARIABLE  HVD_N_A_2     0.64

VARIABLE  HVD_P_W_1     0.47 
VARIABLE  HVD_P_S_1     0.47 
VARIABLE  HVD_P_S_2     1.2 
VARIABLE  HVD_P_S_4     0.24
VARIABLE  HVD_P_S_5     0.48
VARIABLE  HVD_P_EX_1    0.24 
VARIABLE  HVD_P_EN_1    0.6
VARIABLE  HVD_P_EN_2    0.6
#IFDEF HALF_NODE
VARIABLE  HVD_P_O_1     0.28 
VARIABLE  HVD_P_L_1     0.655 
#ELSE
VARIABLE  HVD_P_O_1     0.25 
VARIABLE  HVD_P_L_1     0.6 
#ENDIF
VARIABLE  HVD_P_A_1     0.64 
VARIABLE  HVD_P_A_2     0.64

VARIABLE  CO_W_1     0.06 
VARIABLE  CO_S_1     0.08
VARIABLE  CO_S_2     0.10
VARIABLE  CO_S_2_D   0.11
VARIABLE  CO_S_2_1   0.11
VARIABLE  CO_S_3     0.04 
VARIABLE  CO_S_3_S   0.035
VARIABLE  CO_S_4     0.05 
VARIABLE  CO_S_5     0.08 
#IFDEF HALF_NODE
VARIABLE  CO_S_5_1   0.6 
#ELSE
VARIABLE  CO_S_5_1   0.54 
#ENDIF
VARIABLE  CO_S_6     0.04 
VARIABLE  CO_EN_1    0.01 
VARIABLE  CO_EN_1_1  0.03
VARIABLE  CO_EN_1_2  0.02
VARIABLE  CO_EN_1_3  0.02
VARIABLE  CO_EN_2    0.01
VARIABLE  CO_EN_3    0.02
VARIABLE  CO_EN_5A    0.005
VARIABLE  CO_EN_5B  0.015
VARIABLE  CO_EN_6    0.03

VARIABLE  M1_W_1     0.07
VARIABLE  M1_W_2     0.17
VARIABLE  M1_S_1     0.07 
#IFNDEF WIDE_ADJUST
VARIABLE  M1_W_3     4.50  	
VARIABLE  M1_S_2     0.08 
VARIABLE  M1_S_2_W   0.17 
VARIABLE  M1_S_2_L   0.27
VARIABLE  M1_S_2_1   0.12 
VARIABLE  M1_S_2_1_W 0.24  
VARIABLE  M1_S_2_1_L 0.27
VARIABLE  M1_S_2_2   0.14 
VARIABLE  M1_S_2_2_W 0.31  
VARIABLE  M1_S_2_2_L 0.40
VARIABLE  M1_S_2_3   0.21
VARIABLE  M1_S_2_3_W 0.62  
VARIABLE  M1_S_2_3_L 0.62
VARIABLE  M1_S_3     0.50 
VARIABLE  M1_S_3_W   1.50 
VARIABLE  M1_S_3_L   1.50
#ELSE
VARIABLE  M1_W_3     4.95  	
VARIABLE  M1_S_2     0.08
VARIABLE  M1_S_2_W   0.19
VARIABLE  M1_S_2_L   0.30
VARIABLE  M1_S_2_1   0.12
VARIABLE  M1_S_2_1_W 0.265
VARIABLE  M1_S_2_1_L 0.30
VARIABLE  M1_S_2_2   0.14
VARIABLE  M1_S_2_2_W 0.345
VARIABLE  M1_S_2_2_L 0.44
VARIABLE  M1_S_2_3   0.21
VARIABLE  M1_S_2_3_W 0.685
VARIABLE  M1_S_2_3_L 0.685
VARIABLE  M1_S_2_4   0.075
VARIABLE  M1_S_2_4_W 0.17
VARIABLE  M1_S_2_4_L 0.30
VARIABLE  M1_S_2_5   0.085
VARIABLE  M1_S_2_5_W 0.24
VARIABLE  M1_S_2_5_L 0.30
VARIABLE  M1_S_2_6   0.13
VARIABLE  M1_S_2_6_W 0.31
VARIABLE  M1_S_2_6_L 0.44
VARIABLE  M1_S_2_7   0.15
VARIABLE  M1_S_2_7_W 0.62
VARIABLE  M1_S_2_7_L 0.685
VARIABLE  M1_S_3     0.50
VARIABLE  M1_S_3_W   1.65
VARIABLE  M1_S_3_L   1.65
#ENDIF
VARIABLE  M1_S_5     0.08
VARIABLE  M1_S_5_W   0.09 
VARIABLE  M1_S_5_Q   0.07
VARIABLE  M1_S_5_T   0.025
VARIABLE  M1_S_6     0.17
VARIABLE  M1_S_8     0.1
VARIABLE  M1_S_8_1   0.08 
VARIABLE  M1_S_1_1   0.09
VARIABLE  M1_S_8_2   0.18
VARIABLE  M1_S_9     0.15
VARIABLE  M1_S_9_A   0.06
VARIABLE  M1_S_9_B   0.12
VARIABLE  M1_S_9_C   0.13
VARIABLE  M1_S_9_D   0.01
VARIABLE  M1_EN_1    0
VARIABLE  M1_EN_2    0.03 
VARIABLE  M1_EN_3    0.02 
VARIABLE  M1_EN_3_1  0.005 
VARIABLE  M1_EN_3_2  0.025 
VARIABLE  M1_EN_4    0.03
VARIABLE  M1_EN_4_W  0.7 
VARIABLE  M1_EN_5    0.015 
VARIABLE  M1_EN_5_W  0.11
VARIABLE  M1_EN_5_L  0.27
VARIABLE  M1_EN_5_S  0.08

VARIABLE  M1_A_1     0.0215
VARIABLE  M1_A_2     0.055
VARIABLE  M1_A_2_W   0.07
VARIABLE  M1_A_2_L1   0.17
VARIABLE  M1_A_2_L2   0.17
VARIABLE  M1_A_3     0.2 
VARIABLE  M1_DN_1    0.1
VARIABLE  M1_DN_1_W  METAL_LOW_DEN_WINDOW_SIZE 
VARIABLE  M1_DN_1_S  METAL_LOW_DEN_WINDOW_STEP
VARIABLE  M1_DN_1_E  M1_DN_1_W/4
VARIABLE  M1_DN_1_1  0.85
VARIABLE  M1_DN_1_1_W  METAL_HIGH_DEN_WINDOW_SIZE 
VARIABLE  M1_DN_1_1_S  METAL_HIGH_DEN_WINDOW_STEP
VARIABLE  M1_DN_1_1_E  M1_DN_1_1_W/4
VARIABLE  M1_DN_4_W  200
VARIABLE  M1_DN_4    0.5	
VARIABLE  M1_DN_6_W_A 80  
VARIABLE  M1_DN_6_S_A 40  
VARIABLE  M1_DN_6_E_A 40  
VARIABLE  M1_DN_6     0.01 
VARIABLE  M1_DN_6_W_BC 10
VARIABLE  M1_DN_6_S_BC 5  
VARIABLE  M1_DN_6_E_BC 5
VARIABLE  M1_DN_6_A_B 6400
VARIABLE  M1_DN_6_A_C 18000
VARIABLE  M1_DN_6_U   30
VARIABLE  M1_DN_6_W_A_R 40  
VARIABLE  M1_DN_6_S_A_R 40  
VARIABLE  M1_DN_6_E_A_R 20  
VARIABLE  M1_DN_6_R     0.01 
VARIABLE  M1_DN_6_W_BC_R 10
VARIABLE  M1_DN_6_S_BC_R 5  
VARIABLE  M1_DN_6_E_BC_R 5
VARIABLE  M1_DN_6_A_B_R 1600
VARIABLE  M1_DN_6_A_C_R 4500
VARIABLE  M1_DN_6_U_R   30


VARIABLE  VIA1_W_1     0.07 
VARIABLE  VIA1_S_1     0.07 
VARIABLE  VIA1_S_1_1   0.2
VARIABLE  VIA1_S_2     0.09 
VARIABLE  VIA1_S_2_D   0.098 
VARIABLE  VIA1_S_3     0.095  
VARIABLE  VIA1_S_3_1   0.11 
VARIABLE  VIA1_EN_1    0
VARIABLE  VIA1_EN_2    0.03 
VARIABLE  VIA1_EN_3_1    0.015
VARIABLE  VIA1_EN_3_1_W  0.11
VARIABLE  VIA1_EN_3_1_L  0.27
VARIABLE  VIA1_EN_3_1_S  0.08
VARIABLE  VIA1_EN_4    0.01
VARIABLE  VIA1_EN_4_1  0.02 
#IFNDEF WIDE_ADJUST
VARIABLE  VIA1_R_2_S1  0.14 
VARIABLE  VIA1_R_2_S2  0.63 
VARIABLE  VIA1_R_2_W   0.21 
VARIABLE  VIA1_R_3_S1  0.14 
VARIABLE  VIA1_R_3_S2  0.83 
VARIABLE  VIA1_R_3_W   0.55 
VARIABLE  VIA1_R_4_W   0.21
VARIABLE  VIA1_R_4_D   1.14
VARIABLE  VIA1_R_5_W   1.4
VARIABLE  VIA1_R_5_D   2.8
VARIABLE  VIA1_R_6_W   2.1
VARIABLE  VIA1_R_6_L   7.0
VARIABLE  VIA1_R_6_D   7.1
VARIABLE  VIA1_R_11_L1 5.0
VARIABLE  VIA1_R_11_A  5.0
VARIABLE  VIA1_R_11_L2  1.0
VARIABLE  VIA1_R_11_W  0.21
#ELSE
VARIABLE  VIA1_R_2_S1  0.16
VARIABLE  VIA1_R_2_S2  0.70
VARIABLE  VIA1_R_2_W   0.235
VARIABLE  VIA1_R_3_S1  0.16
VARIABLE  VIA1_R_3_S2  0.92
VARIABLE  VIA1_R_3_W   0.605
VARIABLE  VIA1_R_4_W   0.235
VARIABLE  VIA1_R_4_D   1.14
VARIABLE  VIA1_R_5_W   1.54
VARIABLE  VIA1_R_5_D   2.80
VARIABLE  VIA1_R_6_W   2.31
VARIABLE  VIA1_R_6_L   7.70
VARIABLE  VIA1_R_6_D   7.10
VARIABLE  VIA1_R_11_L2  1.00
VARIABLE  VIA1_R_11_W  0.235
VARIABLE  VIA1_R_11_A  5.00
VARIABLE  VIA1_R_11_L1 5.00
#ENDIF

VARIABLE  M2_W_1      0.07 
VARIABLE  M2_W_2      0.17
VARIABLE  M2_S_1      0.07 
#IFNDEF WIDE_ADJUST
VARIABLE  M2_W_3      4.50
VARIABLE  M2_S_2      0.10 
VARIABLE  M2_S_2_W    0.17 
VARIABLE  M2_S_2_L    0.27
VARIABLE  M2_S_2_1    0.12 
VARIABLE  M2_S_2_1_W  0.24 
VARIABLE  M2_S_2_1_L  0.27
VARIABLE  M2_S_2_2    0.15 
VARIABLE  M2_S_2_2_W  0.31 
VARIABLE  M2_S_2_2_L  0.40
VARIABLE  M2_S_2_3    0.21 
VARIABLE  M2_S_2_3_W  0.62 
VARIABLE  M2_S_2_3_L  0.62
VARIABLE  M2_S_3      0.50 
VARIABLE  M2_S_3_W    1.50 
VARIABLE  M2_S_3_L    1.50 
#ELSE
VARIABLE  M2_W_3      4.95 
VARIABLE  M2_S_2      0.10
VARIABLE  M2_S_2_W    0.19
VARIABLE  M2_S_2_L    0.30
VARIABLE  M2_S_2_1    0.12
VARIABLE  M2_S_2_1_W  0.265
VARIABLE  M2_S_2_1_L  0.30
VARIABLE  M2_S_2_2    0.15
VARIABLE  M2_S_2_2_W  0.345
VARIABLE  M2_S_2_2_L  0.44
VARIABLE  M2_S_2_3    0.21
VARIABLE  M2_S_2_3_W  0.685
VARIABLE  M2_S_2_3_L  0.685
VARIABLE  M2_S_2_4    0.075
VARIABLE  M2_S_2_4_W  0.17
VARIABLE  M2_S_2_4_L  0.30
VARIABLE  M2_S_2_5    0.11
VARIABLE  M2_S_2_5_W  0.24
VARIABLE  M2_S_2_5_L  0.30
VARIABLE  M2_S_2_6    0.13
VARIABLE  M2_S_2_6_W  0.31
VARIABLE  M2_S_2_6_L  0.44
VARIABLE  M2_S_2_7    0.165
VARIABLE  M2_S_2_7_W  0.62
VARIABLE  M2_S_2_7_L  0.685
VARIABLE  M2_S_3      0.50
VARIABLE  M2_S_3_W    1.65
VARIABLE  M2_S_3_L    1.65
#ENDIF
VARIABLE  M2_S_5      0.10 
VARIABLE  M2_S_5_W    0.10 
VARIABLE  M2_S_5_T    0.035 
VARIABLE  M2_S_5_L    0.07	
VARIABLE  M2_S_5_1    0.12
//VARIABLE  M2_S_5_1_L  0.07
VARIABLE  M2_S_5_1_W  0.10 
VARIABLE  M2_S_5_1_T  0.035
VARIABLE  M2_S_5_1_E  0.05 
VARIABLE  M2_S_5_1_E2 0.035
VARIABLE  M2_S_5_1_E3 0.040
VARIABLE  M2_S_5_1_E4 0.045
VARIABLE  M2_S_5_1_S2 0.115
VARIABLE  M2_S_5_1_S3 0.110
VARIABLE  M2_S_5_1_S4 0.105
VARIABLE  M2_S_6      0.17
VARIABLE  M2_S_8      0.1 
VARIABLE  M2_S_8_1    0.08 
VARIABLE  M2_S_1_1    0.09
VARIABLE  M2_S_8_2    0.18
VARIABLE  M2_S_9      0.15
VARIABLE  M2_S_9_A   0.06
VARIABLE  M2_S_9_B   0.12
VARIABLE  M2_S_9_C   0.13
VARIABLE  M2_S_9_D   0.01
VARIABLE  M2_EN_1     0
VARIABLE  M2_EN_2     0.03 
VARIABLE  M2_EN_3     0.01
VARIABLE  M2_EN_3_1   0.02 
VARIABLE  M2_A_1      0.027 
VARIABLE  M2_A_2      0.06 
VARIABLE  M2_A_2_W    0.07 
VARIABLE  M2_A_2_L1    0.17
VARIABLE  M2_A_2_L2    0.17
VARIABLE  M2_A_3      0.20 
VARIABLE  M2_DN_1    0.1 
VARIABLE  M2_DN_1_W  METAL_LOW_DEN_WINDOW_SIZE 
VARIABLE  M2_DN_1_S  METAL_LOW_DEN_WINDOW_STEP
VARIABLE  M2_DN_1_E  M2_DN_1_W/4
VARIABLE  M2_DN_1_1  0.85
VARIABLE  M2_DN_1_1_W  METAL_HIGH_DEN_WINDOW_SIZE 
VARIABLE  M2_DN_1_1_S  METAL_HIGH_DEN_WINDOW_STEP
VARIABLE  M2_DN_1_1_E  M2_DN_1_1_W/4
VARIABLE  M2_DN_4     0.5
VARIABLE  M2_DN_4_W   200 
VARIABLE  M2_DN_6_W_A 80  
VARIABLE  M2_DN_6_S_A 40  
VARIABLE  M2_DN_6_E_A 40  
VARIABLE  M2_DN_6     0.01 
VARIABLE  M2_DN_6_W_BC 10
VARIABLE  M2_DN_6_S_BC 5  
VARIABLE  M2_DN_6_E_BC 5
VARIABLE  M2_DN_6_A_B 6400
VARIABLE  M2_DN_6_A_C 18000
VARIABLE  M2_DN_6_U   30
VARIABLE  M2_DN_6_W_A_R 40  
VARIABLE  M2_DN_6_S_A_R 40  
VARIABLE  M2_DN_6_E_A_R 20  
VARIABLE  M2_DN_6_R     0.01 
VARIABLE  M2_DN_6_W_BC_R 10
VARIABLE  M2_DN_6_S_BC_R 5  
VARIABLE  M2_DN_6_E_BC_R 5
VARIABLE  M2_DN_6_A_B_R 1600
VARIABLE  M2_DN_6_A_C_R 4500
VARIABLE  M2_DN_6_U_R   30

VARIABLE  VIA2_W_1     0.07 
VARIABLE  VIA2_S_1     0.07 
VARIABLE  VIA2_S_1_1   0.2
VARIABLE  VIA2_S_2     0.09 
VARIABLE  VIA2_S_2_D   0.098 
VARIABLE  VIA2_S_3     0.095  
VARIABLE  VIA2_S_3_1   0.11 
VARIABLE  VIA2_EN_1    0
VARIABLE  VIA2_EN_2    0.03 
VARIABLE  VIA2_EN_4    0.01
VARIABLE  VIA2_EN_4_1  0.02 
#IFNDEF WIDE_ADJUST
VARIABLE  VIA2_R_2_S1  0.14 
VARIABLE  VIA2_R_2_S2  0.63 
VARIABLE  VIA2_R_2_W   0.21 
VARIABLE  VIA2_R_3_S1  0.14 
VARIABLE  VIA2_R_3_S2  0.83 
VARIABLE  VIA2_R_3_W   0.55 
VARIABLE  VIA2_R_4_W   0.21
VARIABLE  VIA2_R_4_D   1.14
VARIABLE  VIA2_R_5_W   1.4
VARIABLE  VIA2_R_5_D   2.8
VARIABLE  VIA2_R_6_W   2.1
VARIABLE  VIA2_R_6_L   7.0
VARIABLE  VIA2_R_6_D   7.1
VARIABLE  VIA2_R_11_L1 5.0
VARIABLE  VIA2_R_11_A  5.0
VARIABLE  VIA2_R_11_L2  1.0
VARIABLE  VIA2_R_11_W  0.21
#ELSE
VARIABLE  VIA2_R_2_S1  0.16
VARIABLE  VIA2_R_2_S2  0.70
VARIABLE  VIA2_R_2_W   0.235
VARIABLE  VIA2_R_3_S1  0.16
VARIABLE  VIA2_R_3_S2  0.92
VARIABLE  VIA2_R_3_W   0.605
VARIABLE  VIA2_R_4_W   0.235
VARIABLE  VIA2_R_4_D   1.14
VARIABLE  VIA2_R_5_W   1.54
VARIABLE  VIA2_R_5_D   2.80
VARIABLE  VIA2_R_6_W   2.31
VARIABLE  VIA2_R_6_L   7.70
VARIABLE  VIA2_R_6_D   7.10
VARIABLE  VIA2_R_11_L2  1.00
VARIABLE  VIA2_R_11_W  0.235
VARIABLE  VIA2_R_11_A  5.00
VARIABLE  VIA2_R_11_L1 5.00
#ENDIF

VARIABLE  M3_W_1      0.07 
VARIABLE  M3_W_2      0.17
VARIABLE  M3_S_1      0.07 
#IFNDEF WIDE_ADJUST
VARIABLE  M3_W_3      4.50
VARIABLE  M3_S_2      0.10 
VARIABLE  M3_S_2_W    0.17 
VARIABLE  M3_S_2_L    0.27
VARIABLE  M3_S_2_1    0.12 
VARIABLE  M3_S_2_1_W  0.24 
VARIABLE  M3_S_2_1_L  0.27
VARIABLE  M3_S_2_2    0.15 
VARIABLE  M3_S_2_2_W  0.31 
VARIABLE  M3_S_2_2_L  0.40
VARIABLE  M3_S_2_3    0.21 
VARIABLE  M3_S_2_3_W  0.62 
VARIABLE  M3_S_2_3_L  0.62
VARIABLE  M3_S_3      0.50 
VARIABLE  M3_S_3_W    1.50 
VARIABLE  M3_S_3_L    1.50 
#ELSE
VARIABLE  M3_W_3      4.95 
VARIABLE  M3_S_2      0.10
VARIABLE  M3_S_2_W    0.19
VARIABLE  M3_S_2_L    0.30
VARIABLE  M3_S_2_1    0.12
VARIABLE  M3_S_2_1_W  0.265
VARIABLE  M3_S_2_1_L  0.30
VARIABLE  M3_S_2_2    0.15
VARIABLE  M3_S_2_2_W  0.345
VARIABLE  M3_S_2_2_L  0.44
VARIABLE  M3_S_2_3    0.21
VARIABLE  M3_S_2_3_W  0.685
VARIABLE  M3_S_2_3_L  0.685
VARIABLE  M3_S_2_4    0.075
VARIABLE  M3_S_2_4_W  0.17
VARIABLE  M3_S_2_4_L  0.30
VARIABLE  M3_S_2_5    0.11
VARIABLE  M3_S_2_5_W  0.24
VARIABLE  M3_S_2_5_L  0.30
VARIABLE  M3_S_2_6    0.13
VARIABLE  M3_S_2_6_W  0.31
VARIABLE  M3_S_2_6_L  0.44
VARIABLE  M3_S_2_7    0.165
VARIABLE  M3_S_2_7_W  0.62
VARIABLE  M3_S_2_7_L  0.685
VARIABLE  M3_S_3      0.50
VARIABLE  M3_S_3_W    1.65
VARIABLE  M3_S_3_L    1.65
#ENDIF
VARIABLE  M3_S_5      0.10 
VARIABLE  M3_S_5_W    0.10 
VARIABLE  M3_S_5_T    0.035 
VARIABLE  M3_S_5_L    0.07	
VARIABLE  M3_S_5_1    0.12
//VARIABLE  M3_S_5_1_L  0.07
VARIABLE  M3_S_5_1_W  0.10 
VARIABLE  M3_S_5_1_T  0.035
VARIABLE  M3_S_5_1_E  0.05 
VARIABLE  M3_S_5_1_E2 0.035
VARIABLE  M3_S_5_1_E3 0.040
VARIABLE  M3_S_5_1_E4 0.045
VARIABLE  M3_S_5_1_S2 0.115
VARIABLE  M3_S_5_1_S3 0.110
VARIABLE  M3_S_5_1_S4 0.105
VARIABLE  M3_S_6      0.17
VARIABLE  M3_S_8      0.1 
VARIABLE  M3_S_8_1    0.08 
VARIABLE  M3_S_1_1    0.09
VARIABLE  M3_S_8_2    0.18
VARIABLE  M3_S_9      0.15
VARIABLE  M3_S_9_A   0.06
VARIABLE  M3_S_9_B   0.12
VARIABLE  M3_S_9_C   0.13
VARIABLE  M3_S_9_D   0.01
VARIABLE  M3_EN_1     0
VARIABLE  M3_EN_2     0.03 
VARIABLE  M3_EN_3     0.01
VARIABLE  M3_EN_3_1   0.02 
VARIABLE  M3_A_1      0.027 
VARIABLE  M3_A_2      0.06 
VARIABLE  M3_A_2_W    0.07 
VARIABLE  M3_A_2_L1    0.17
VARIABLE  M3_A_2_L2    0.17
VARIABLE  M3_A_3      0.20 
VARIABLE  M3_DN_1    0.1 
VARIABLE  M3_DN_1_W  METAL_LOW_DEN_WINDOW_SIZE 
VARIABLE  M3_DN_1_S  METAL_LOW_DEN_WINDOW_STEP
VARIABLE  M3_DN_1_E  M3_DN_1_W/4
VARIABLE  M3_DN_1_1  0.85
VARIABLE  M3_DN_1_1_W  METAL_HIGH_DEN_WINDOW_SIZE 
VARIABLE  M3_DN_1_1_S  METAL_HIGH_DEN_WINDOW_STEP
VARIABLE  M3_DN_1_1_E  M3_DN_1_1_W/4
VARIABLE  M3_DN_4     0.5
VARIABLE  M3_DN_4_W   200 
VARIABLE  M3_DN_6_W_A 80  
VARIABLE  M3_DN_6_S_A 40  
VARIABLE  M3_DN_6_E_A 40  
VARIABLE  M3_DN_6     0.01 
VARIABLE  M3_DN_6_W_BC 10
VARIABLE  M3_DN_6_S_BC 5  
VARIABLE  M3_DN_6_E_BC 5
VARIABLE  M3_DN_6_A_B 6400
VARIABLE  M3_DN_6_A_C 18000
VARIABLE  M3_DN_6_U   30
VARIABLE  M3_DN_6_W_A_R 40  
VARIABLE  M3_DN_6_S_A_R 40  
VARIABLE  M3_DN_6_E_A_R 20  
VARIABLE  M3_DN_6_R     0.01 
VARIABLE  M3_DN_6_W_BC_R 10
VARIABLE  M3_DN_6_S_BC_R 5  
VARIABLE  M3_DN_6_E_BC_R 5
VARIABLE  M3_DN_6_A_B_R 1600
VARIABLE  M3_DN_6_A_C_R 4500
VARIABLE  M3_DN_6_U_R   30
VARIABLE  M1_DN_5_W   62.5
VARIABLE  M1_DN_5_S   31.25
VARIABLE  M1_DN_5     0.85
VARIABLE  M1_DN_7_W   30  
VARIABLE  M1_DN_7_S   15 
VARIABLE  M1_DN_7_E   15 
VARIABLE  M1_DN_7     0.05 
VARIABLE  M1_DN_7_W_R 15  
VARIABLE  M1_DN_7_S_R 15 
VARIABLE  M1_DN_7_E_R 7.5
VARIABLE  M1_DN_7_R   0.05 

VARIABLE  VIA3_W_1     0.07 
VARIABLE  VIA3_S_1     0.07 
VARIABLE  VIA3_S_1_1   0.2
VARIABLE  VIA3_S_2     0.09 
VARIABLE  VIA3_S_2_D   0.098 
VARIABLE  VIA3_S_3     0.095  
VARIABLE  VIA3_S_3_1   0.11 
VARIABLE  VIA3_EN_1    0
VARIABLE  VIA3_EN_2    0.03 
VARIABLE  VIA3_EN_4    0.01
VARIABLE  VIA3_EN_4_1  0.02 
#IFNDEF WIDE_ADJUST
VARIABLE  VIA3_R_2_S1  0.14 
VARIABLE  VIA3_R_2_S2  0.63 
VARIABLE  VIA3_R_2_W   0.21 
VARIABLE  VIA3_R_3_S1  0.14 
VARIABLE  VIA3_R_3_S2  0.83 
VARIABLE  VIA3_R_3_W   0.55 
VARIABLE  VIA3_R_4_W   0.21
VARIABLE  VIA3_R_4_D   1.14
VARIABLE  VIA3_R_5_W   1.4
VARIABLE  VIA3_R_5_D   2.8
VARIABLE  VIA3_R_6_W   2.1
VARIABLE  VIA3_R_6_L   7.0
VARIABLE  VIA3_R_6_D   7.1
VARIABLE  VIA3_R_11_L1 5.0
VARIABLE  VIA3_R_11_A  5.0
VARIABLE  VIA3_R_11_L2  1.0
VARIABLE  VIA3_R_11_W  0.21
#ELSE
VARIABLE  VIA3_R_2_S1  0.16
VARIABLE  VIA3_R_2_S2  0.70
VARIABLE  VIA3_R_2_W   0.235
VARIABLE  VIA3_R_3_S1  0.16
VARIABLE  VIA3_R_3_S2  0.92
VARIABLE  VIA3_R_3_W   0.605
VARIABLE  VIA3_R_4_W   0.235
VARIABLE  VIA3_R_4_D   1.14
VARIABLE  VIA3_R_5_W   1.54
VARIABLE  VIA3_R_5_D   2.80
VARIABLE  VIA3_R_6_W   2.31
VARIABLE  VIA3_R_6_L   7.70
VARIABLE  VIA3_R_6_D   7.10
VARIABLE  VIA3_R_11_L2  1.00
VARIABLE  VIA3_R_11_W  0.235
VARIABLE  VIA3_R_11_A  5.00
VARIABLE  VIA3_R_11_L1 5.00
#ENDIF

VARIABLE  M4_W_1      0.07 
VARIABLE  M4_W_2      0.17
VARIABLE  M4_S_1      0.07 
#IFNDEF WIDE_ADJUST
VARIABLE  M4_W_3      4.50
VARIABLE  M4_S_2      0.10 
VARIABLE  M4_S_2_W    0.17 
VARIABLE  M4_S_2_L    0.27
VARIABLE  M4_S_2_1    0.12 
VARIABLE  M4_S_2_1_W  0.24 
VARIABLE  M4_S_2_1_L  0.27
VARIABLE  M4_S_2_2    0.15 
VARIABLE  M4_S_2_2_W  0.31 
VARIABLE  M4_S_2_2_L  0.40
VARIABLE  M4_S_2_3    0.21 
VARIABLE  M4_S_2_3_W  0.62 
VARIABLE  M4_S_2_3_L  0.62
VARIABLE  M4_S_3      0.50 
VARIABLE  M4_S_3_W    1.50 
VARIABLE  M4_S_3_L    1.50 
#ELSE
VARIABLE  M4_W_3      4.95 
VARIABLE  M4_S_2      0.10
VARIABLE  M4_S_2_W    0.19
VARIABLE  M4_S_2_L    0.30
VARIABLE  M4_S_2_1    0.12
VARIABLE  M4_S_2_1_W  0.265
VARIABLE  M4_S_2_1_L  0.30
VARIABLE  M4_S_2_2    0.15
VARIABLE  M4_S_2_2_W  0.345
VARIABLE  M4_S_2_2_L  0.44
VARIABLE  M4_S_2_3    0.21
VARIABLE  M4_S_2_3_W  0.685
VARIABLE  M4_S_2_3_L  0.685
VARIABLE  M4_S_2_4    0.075
VARIABLE  M4_S_2_4_W  0.17
VARIABLE  M4_S_2_4_L  0.30
VARIABLE  M4_S_2_5    0.11
VARIABLE  M4_S_2_5_W  0.24
VARIABLE  M4_S_2_5_L  0.30
VARIABLE  M4_S_2_6    0.13
VARIABLE  M4_S_2_6_W  0.31
VARIABLE  M4_S_2_6_L  0.44
VARIABLE  M4_S_2_7    0.165
VARIABLE  M4_S_2_7_W  0.62
VARIABLE  M4_S_2_7_L  0.685
VARIABLE  M4_S_3      0.50
VARIABLE  M4_S_3_W    1.65
VARIABLE  M4_S_3_L    1.65
#ENDIF
VARIABLE  M4_S_5      0.10 
VARIABLE  M4_S_5_W    0.10 
VARIABLE  M4_S_5_T    0.035 
VARIABLE  M4_S_5_L    0.07	
VARIABLE  M4_S_5_1    0.12
//VARIABLE  M4_S_5_1_L  0.07
VARIABLE  M4_S_5_1_W  0.10 
VARIABLE  M4_S_5_1_T  0.035
VARIABLE  M4_S_5_1_E  0.05 
VARIABLE  M4_S_5_1_E2 0.035
VARIABLE  M4_S_5_1_E3 0.040
VARIABLE  M4_S_5_1_E4 0.045
VARIABLE  M4_S_5_1_S2 0.115
VARIABLE  M4_S_5_1_S3 0.110
VARIABLE  M4_S_5_1_S4 0.105
VARIABLE  M4_S_6      0.17
VARIABLE  M4_S_8      0.1 
VARIABLE  M4_S_8_1    0.08 
VARIABLE  M4_S_1_1    0.09
VARIABLE  M4_S_8_2    0.18
VARIABLE  M4_S_9      0.15
VARIABLE  M4_S_9_A   0.06
VARIABLE  M4_S_9_B   0.12
VARIABLE  M4_S_9_C   0.13
VARIABLE  M4_S_9_D   0.01
VARIABLE  M4_EN_1     0
VARIABLE  M4_EN_2     0.03 
VARIABLE  M4_EN_3     0.01
VARIABLE  M4_EN_3_1   0.02 
VARIABLE  M4_A_1      0.027 
VARIABLE  M4_A_2      0.06 
VARIABLE  M4_A_2_W    0.07 
VARIABLE  M4_A_2_L1    0.17
VARIABLE  M4_A_2_L2    0.17
VARIABLE  M4_A_3      0.20 
VARIABLE  M4_DN_1    0.1 
VARIABLE  M4_DN_1_W  METAL_LOW_DEN_WINDOW_SIZE 
VARIABLE  M4_DN_1_S  METAL_LOW_DEN_WINDOW_STEP
VARIABLE  M4_DN_1_E  M4_DN_1_W/4
VARIABLE  M4_DN_1_1  0.85
VARIABLE  M4_DN_1_1_W  METAL_HIGH_DEN_WINDOW_SIZE 
VARIABLE  M4_DN_1_1_S  METAL_HIGH_DEN_WINDOW_STEP
VARIABLE  M4_DN_1_1_E  M4_DN_1_1_W/4
VARIABLE  M4_DN_4     0.5
VARIABLE  M4_DN_4_W   200 
VARIABLE  M4_DN_6_W_A 80  
VARIABLE  M4_DN_6_S_A 40  
VARIABLE  M4_DN_6_E_A 40  
VARIABLE  M4_DN_6     0.01 
VARIABLE  M4_DN_6_W_BC 10
VARIABLE  M4_DN_6_S_BC 5  
VARIABLE  M4_DN_6_E_BC 5
VARIABLE  M4_DN_6_A_B 6400
VARIABLE  M4_DN_6_A_C 18000
VARIABLE  M4_DN_6_U   30
VARIABLE  M4_DN_6_W_A_R 40  
VARIABLE  M4_DN_6_S_A_R 40  
VARIABLE  M4_DN_6_E_A_R 20  
VARIABLE  M4_DN_6_R     0.01 
VARIABLE  M4_DN_6_W_BC_R 10
VARIABLE  M4_DN_6_S_BC_R 5  
VARIABLE  M4_DN_6_E_BC_R 5
VARIABLE  M4_DN_6_A_B_R 1600
VARIABLE  M4_DN_6_A_C_R 4500
VARIABLE  M4_DN_6_U_R   30
VARIABLE  M2_DN_5_W   62.5
VARIABLE  M2_DN_5_S   31.25
VARIABLE  M2_DN_5     0.85
VARIABLE  M2_DN_7_W   30  
VARIABLE  M2_DN_7_S   15 
VARIABLE  M2_DN_7_E   15 
VARIABLE  M2_DN_7     0.05 
VARIABLE  M2_DN_7_W_R 15  
VARIABLE  M2_DN_7_S_R 15 
VARIABLE  M2_DN_7_E_R 7.5
VARIABLE  M2_DN_7_R   0.05 

VARIABLE  VIA4_W_1     0.07 
VARIABLE  VIA4_S_1     0.07 
VARIABLE  VIA4_S_1_1   0.2
VARIABLE  VIA4_S_2     0.09 
VARIABLE  VIA4_S_2_D   0.098 
VARIABLE  VIA4_S_3     0.095  
VARIABLE  VIA4_S_3_1   0.11 
VARIABLE  VIA4_EN_1    0
VARIABLE  VIA4_EN_2    0.03 
VARIABLE  VIA4_EN_4    0.01
VARIABLE  VIA4_EN_4_1  0.02 
#IFNDEF WIDE_ADJUST
VARIABLE  VIA4_R_2_S1  0.14 
VARIABLE  VIA4_R_2_S2  0.63 
VARIABLE  VIA4_R_2_W   0.21 
VARIABLE  VIA4_R_3_S1  0.14 
VARIABLE  VIA4_R_3_S2  0.83 
VARIABLE  VIA4_R_3_W   0.55 
VARIABLE  VIA4_R_4_W   0.21
VARIABLE  VIA4_R_4_D   1.14
VARIABLE  VIA4_R_5_W   1.4
VARIABLE  VIA4_R_5_D   2.8
VARIABLE  VIA4_R_6_W   2.1
VARIABLE  VIA4_R_6_L   7.0
VARIABLE  VIA4_R_6_D   7.1
VARIABLE  VIA4_R_11_L1 5.0
VARIABLE  VIA4_R_11_A  5.0
VARIABLE  VIA4_R_11_L2  1.0
VARIABLE  VIA4_R_11_W  0.21
#ELSE
VARIABLE  VIA4_R_2_S1  0.16
VARIABLE  VIA4_R_2_S2  0.70
VARIABLE  VIA4_R_2_W   0.235
VARIABLE  VIA4_R_3_S1  0.16
VARIABLE  VIA4_R_3_S2  0.92
VARIABLE  VIA4_R_3_W   0.605
VARIABLE  VIA4_R_4_W   0.235
VARIABLE  VIA4_R_4_D   1.14
VARIABLE  VIA4_R_5_W   1.54
VARIABLE  VIA4_R_5_D   2.80
VARIABLE  VIA4_R_6_W   2.31
VARIABLE  VIA4_R_6_L   7.70
VARIABLE  VIA4_R_6_D   7.10
VARIABLE  VIA4_R_11_L2  1.00
VARIABLE  VIA4_R_11_W  0.235
VARIABLE  VIA4_R_11_A  5.00
VARIABLE  VIA4_R_11_L1 5.00
#ENDIF

VARIABLE  M5_W_1      0.07 
VARIABLE  M5_W_2      0.17
VARIABLE  M5_S_1      0.07 
#IFNDEF WIDE_ADJUST
VARIABLE  M5_W_3      4.50
VARIABLE  M5_S_2      0.10 
VARIABLE  M5_S_2_W    0.17 
VARIABLE  M5_S_2_L    0.27
VARIABLE  M5_S_2_1    0.12 
VARIABLE  M5_S_2_1_W  0.24 
VARIABLE  M5_S_2_1_L  0.27
VARIABLE  M5_S_2_2    0.15 
VARIABLE  M5_S_2_2_W  0.31 
VARIABLE  M5_S_2_2_L  0.40
VARIABLE  M5_S_2_3    0.21 
VARIABLE  M5_S_2_3_W  0.62 
VARIABLE  M5_S_2_3_L  0.62
VARIABLE  M5_S_3      0.50 
VARIABLE  M5_S_3_W    1.50 
VARIABLE  M5_S_3_L    1.50 
#ELSE
VARIABLE  M5_W_3      4.95 
VARIABLE  M5_S_2      0.10
VARIABLE  M5_S_2_W    0.19
VARIABLE  M5_S_2_L    0.30
VARIABLE  M5_S_2_1    0.12
VARIABLE  M5_S_2_1_W  0.265
VARIABLE  M5_S_2_1_L  0.30
VARIABLE  M5_S_2_2    0.15
VARIABLE  M5_S_2_2_W  0.345
VARIABLE  M5_S_2_2_L  0.44
VARIABLE  M5_S_2_3    0.21
VARIABLE  M5_S_2_3_W  0.685
VARIABLE  M5_S_2_3_L  0.685
VARIABLE  M5_S_2_4    0.075
VARIABLE  M5_S_2_4_W  0.17
VARIABLE  M5_S_2_4_L  0.30
VARIABLE  M5_S_2_5    0.11
VARIABLE  M5_S_2_5_W  0.24
VARIABLE  M5_S_2_5_L  0.30
VARIABLE  M5_S_2_6    0.13
VARIABLE  M5_S_2_6_W  0.31
VARIABLE  M5_S_2_6_L  0.44
VARIABLE  M5_S_2_7    0.165
VARIABLE  M5_S_2_7_W  0.62
VARIABLE  M5_S_2_7_L  0.685
VARIABLE  M5_S_3      0.50
VARIABLE  M5_S_3_W    1.65
VARIABLE  M5_S_3_L    1.65
#ENDIF
VARIABLE  M5_S_5      0.10 
VARIABLE  M5_S_5_W    0.10 
VARIABLE  M5_S_5_T    0.035 
VARIABLE  M5_S_5_L    0.07	
VARIABLE  M5_S_5_1    0.12
//VARIABLE  M5_S_5_1_L  0.07
VARIABLE  M5_S_5_1_W  0.10 
VARIABLE  M5_S_5_1_T  0.035
VARIABLE  M5_S_5_1_E  0.05 
VARIABLE  M5_S_5_1_E2 0.035
VARIABLE  M5_S_5_1_E3 0.040
VARIABLE  M5_S_5_1_E4 0.045
VARIABLE  M5_S_5_1_S2 0.115
VARIABLE  M5_S_5_1_S3 0.110
VARIABLE  M5_S_5_1_S4 0.105
VARIABLE  M5_S_6      0.17
VARIABLE  M5_S_8      0.1 
VARIABLE  M5_S_8_1    0.08 
VARIABLE  M5_S_1_1    0.09
VARIABLE  M5_S_8_2    0.18
VARIABLE  M5_S_9      0.15
VARIABLE  M5_S_9_A   0.06
VARIABLE  M5_S_9_B   0.12
VARIABLE  M5_S_9_C   0.13
VARIABLE  M5_S_9_D   0.01
VARIABLE  M5_EN_1     0
VARIABLE  M5_EN_2     0.03 
VARIABLE  M5_EN_3     0.01
VARIABLE  M5_EN_3_1   0.02 
VARIABLE  M5_A_1      0.027 
VARIABLE  M5_A_2      0.06 
VARIABLE  M5_A_2_W    0.07 
VARIABLE  M5_A_2_L1    0.17
VARIABLE  M5_A_2_L2    0.17
VARIABLE  M5_A_3      0.20 
VARIABLE  M5_DN_1    0.1 
VARIABLE  M5_DN_1_W  METAL_LOW_DEN_WINDOW_SIZE 
VARIABLE  M5_DN_1_S  METAL_LOW_DEN_WINDOW_STEP
VARIABLE  M5_DN_1_E  M5_DN_1_W/4
VARIABLE  M5_DN_1_1  0.85
VARIABLE  M5_DN_1_1_W  METAL_HIGH_DEN_WINDOW_SIZE 
VARIABLE  M5_DN_1_1_S  METAL_HIGH_DEN_WINDOW_STEP
VARIABLE  M5_DN_1_1_E  M5_DN_1_1_W/4
VARIABLE  M5_DN_4     0.5
VARIABLE  M5_DN_4_W   200 
VARIABLE  M5_DN_6_W_A 80  
VARIABLE  M5_DN_6_S_A 40  
VARIABLE  M5_DN_6_E_A 40  
VARIABLE  M5_DN_6     0.01 
VARIABLE  M5_DN_6_W_BC 10
VARIABLE  M5_DN_6_S_BC 5  
VARIABLE  M5_DN_6_E_BC 5
VARIABLE  M5_DN_6_A_B 6400
VARIABLE  M5_DN_6_A_C 18000
VARIABLE  M5_DN_6_U   30
VARIABLE  M5_DN_6_W_A_R 40  
VARIABLE  M5_DN_6_S_A_R 40  
VARIABLE  M5_DN_6_E_A_R 20  
VARIABLE  M5_DN_6_R     0.01 
VARIABLE  M5_DN_6_W_BC_R 10
VARIABLE  M5_DN_6_S_BC_R 5  
VARIABLE  M5_DN_6_E_BC_R 5
VARIABLE  M5_DN_6_A_B_R 1600
VARIABLE  M5_DN_6_A_C_R 4500
VARIABLE  M5_DN_6_U_R   30
VARIABLE  M3_DN_5_W   62.5
VARIABLE  M3_DN_5_S   31.25
VARIABLE  M3_DN_5     0.85
VARIABLE  M3_DN_7_W   30  
VARIABLE  M3_DN_7_S   15 
VARIABLE  M3_DN_7_E   15 
VARIABLE  M3_DN_7     0.05 
VARIABLE  M3_DN_7_W_R 15  
VARIABLE  M3_DN_7_S_R 15 
VARIABLE  M3_DN_7_E_R 7.5
VARIABLE  M3_DN_7_R   0.05 

VARIABLE  VIA5_W_1     0.07 
VARIABLE  VIA5_S_1     0.07 
VARIABLE  VIA5_S_1_1   0.2
VARIABLE  VIA5_S_2     0.09 
VARIABLE  VIA5_S_2_D   0.098 
VARIABLE  VIA5_S_3     0.095  
VARIABLE  VIA5_S_3_1   0.11 
VARIABLE  VIA5_EN_1    0
VARIABLE  VIA5_EN_2    0.03 
VARIABLE  VIA5_EN_4    0.01
VARIABLE  VIA5_EN_4_1  0.02 
#IFNDEF WIDE_ADJUST
VARIABLE  VIA5_R_2_S1  0.14 
VARIABLE  VIA5_R_2_S2  0.63 
VARIABLE  VIA5_R_2_W   0.21 
VARIABLE  VIA5_R_3_S1  0.14 
VARIABLE  VIA5_R_3_S2  0.83 
VARIABLE  VIA5_R_3_W   0.55 
VARIABLE  VIA5_R_4_W   0.21
VARIABLE  VIA5_R_4_D   1.14
VARIABLE  VIA5_R_5_W   1.4
VARIABLE  VIA5_R_5_D   2.8
VARIABLE  VIA5_R_6_W   2.1
VARIABLE  VIA5_R_6_L   7.0
VARIABLE  VIA5_R_6_D   7.1
VARIABLE  VIA5_R_11_L1 5.0
VARIABLE  VIA5_R_11_A  5.0
VARIABLE  VIA5_R_11_L2  1.0
VARIABLE  VIA5_R_11_W  0.21
#ELSE
VARIABLE  VIA5_R_2_S1  0.16
VARIABLE  VIA5_R_2_S2  0.70
VARIABLE  VIA5_R_2_W   0.235
VARIABLE  VIA5_R_3_S1  0.16
VARIABLE  VIA5_R_3_S2  0.92
VARIABLE  VIA5_R_3_W   0.605
VARIABLE  VIA5_R_4_W   0.235
VARIABLE  VIA5_R_4_D   1.14
VARIABLE  VIA5_R_5_W   1.54
VARIABLE  VIA5_R_5_D   2.80
VARIABLE  VIA5_R_6_W   2.31
VARIABLE  VIA5_R_6_L   7.70
VARIABLE  VIA5_R_6_D   7.10
VARIABLE  VIA5_R_11_L2  1.00
VARIABLE  VIA5_R_11_W  0.235
VARIABLE  VIA5_R_11_A  5.00
VARIABLE  VIA5_R_11_L1 5.00
#ENDIF

VARIABLE  M6_W_1      0.07 
VARIABLE  M6_W_2      0.17
VARIABLE  M6_S_1      0.07 
#IFNDEF WIDE_ADJUST
VARIABLE  M6_W_3      4.50
VARIABLE  M6_S_2      0.10 
VARIABLE  M6_S_2_W    0.17 
VARIABLE  M6_S_2_L    0.27
VARIABLE  M6_S_2_1    0.12 
VARIABLE  M6_S_2_1_W  0.24 
VARIABLE  M6_S_2_1_L  0.27
VARIABLE  M6_S_2_2    0.15 
VARIABLE  M6_S_2_2_W  0.31 
VARIABLE  M6_S_2_2_L  0.40
VARIABLE  M6_S_2_3    0.21 
VARIABLE  M6_S_2_3_W  0.62 
VARIABLE  M6_S_2_3_L  0.62
VARIABLE  M6_S_3      0.50 
VARIABLE  M6_S_3_W    1.50 
VARIABLE  M6_S_3_L    1.50 
#ELSE
VARIABLE  M6_W_3      4.95 
VARIABLE  M6_S_2      0.10
VARIABLE  M6_S_2_W    0.19
VARIABLE  M6_S_2_L    0.30
VARIABLE  M6_S_2_1    0.12
VARIABLE  M6_S_2_1_W  0.265
VARIABLE  M6_S_2_1_L  0.30
VARIABLE  M6_S_2_2    0.15
VARIABLE  M6_S_2_2_W  0.345
VARIABLE  M6_S_2_2_L  0.44
VARIABLE  M6_S_2_3    0.21
VARIABLE  M6_S_2_3_W  0.685
VARIABLE  M6_S_2_3_L  0.685
VARIABLE  M6_S_2_4    0.075
VARIABLE  M6_S_2_4_W  0.17
VARIABLE  M6_S_2_4_L  0.30
VARIABLE  M6_S_2_5    0.11
VARIABLE  M6_S_2_5_W  0.24
VARIABLE  M6_S_2_5_L  0.30
VARIABLE  M6_S_2_6    0.13
VARIABLE  M6_S_2_6_W  0.31
VARIABLE  M6_S_2_6_L  0.44
VARIABLE  M6_S_2_7    0.165
VARIABLE  M6_S_2_7_W  0.62
VARIABLE  M6_S_2_7_L  0.685
VARIABLE  M6_S_3      0.50
VARIABLE  M6_S_3_W    1.65
VARIABLE  M6_S_3_L    1.65
#ENDIF
VARIABLE  M6_S_5      0.10 
VARIABLE  M6_S_5_W    0.10 
VARIABLE  M6_S_5_T    0.035 
VARIABLE  M6_S_5_L    0.07	
VARIABLE  M6_S_5_1    0.12
//VARIABLE  M6_S_5_1_L  0.07
VARIABLE  M6_S_5_1_W  0.10 
VARIABLE  M6_S_5_1_T  0.035
VARIABLE  M6_S_5_1_E  0.05 
VARIABLE  M6_S_5_1_E2 0.035
VARIABLE  M6_S_5_1_E3 0.040
VARIABLE  M6_S_5_1_E4 0.045
VARIABLE  M6_S_5_1_S2 0.115
VARIABLE  M6_S_5_1_S3 0.110
VARIABLE  M6_S_5_1_S4 0.105
VARIABLE  M6_S_6      0.17
VARIABLE  M6_S_8      0.1 
VARIABLE  M6_S_8_1    0.08 
VARIABLE  M6_S_1_1    0.09
VARIABLE  M6_S_8_2    0.18
VARIABLE  M6_S_9      0.15
VARIABLE  M6_S_9_A   0.06
VARIABLE  M6_S_9_B   0.12
VARIABLE  M6_S_9_C   0.13
VARIABLE  M6_S_9_D   0.01
VARIABLE  M6_EN_1     0
VARIABLE  M6_EN_2     0.03 
VARIABLE  M6_EN_3     0.01
VARIABLE  M6_EN_3_1   0.02 
VARIABLE  M6_A_1      0.027 
VARIABLE  M6_A_2      0.06 
VARIABLE  M6_A_2_W    0.07 
VARIABLE  M6_A_2_L1    0.17
VARIABLE  M6_A_2_L2    0.17
VARIABLE  M6_A_3      0.20 
VARIABLE  M6_DN_1    0.1 
VARIABLE  M6_DN_1_W  METAL_LOW_DEN_WINDOW_SIZE 
VARIABLE  M6_DN_1_S  METAL_LOW_DEN_WINDOW_STEP
VARIABLE  M6_DN_1_E  M6_DN_1_W/4
VARIABLE  M6_DN_1_1  0.85
VARIABLE  M6_DN_1_1_W  METAL_HIGH_DEN_WINDOW_SIZE 
VARIABLE  M6_DN_1_1_S  METAL_HIGH_DEN_WINDOW_STEP
VARIABLE  M6_DN_1_1_E  M6_DN_1_1_W/4
VARIABLE  M6_DN_4     0.5
VARIABLE  M6_DN_4_W   200 
VARIABLE  M6_DN_6_W_A 80  
VARIABLE  M6_DN_6_S_A 40  
VARIABLE  M6_DN_6_E_A 40  
VARIABLE  M6_DN_6     0.01 
VARIABLE  M6_DN_6_W_BC 10
VARIABLE  M6_DN_6_S_BC 5  
VARIABLE  M6_DN_6_E_BC 5
VARIABLE  M6_DN_6_A_B 6400
VARIABLE  M6_DN_6_A_C 18000
VARIABLE  M6_DN_6_U   30
VARIABLE  M6_DN_6_W_A_R 40  
VARIABLE  M6_DN_6_S_A_R 40  
VARIABLE  M6_DN_6_E_A_R 20  
VARIABLE  M6_DN_6_R     0.01 
VARIABLE  M6_DN_6_W_BC_R 10
VARIABLE  M6_DN_6_S_BC_R 5  
VARIABLE  M6_DN_6_E_BC_R 5
VARIABLE  M6_DN_6_A_B_R 1600
VARIABLE  M6_DN_6_A_C_R 4500
VARIABLE  M6_DN_6_U_R   30
VARIABLE  M4_DN_5_W   62.5
VARIABLE  M4_DN_5_S   31.25
VARIABLE  M4_DN_5     0.85
VARIABLE  M4_DN_7_W   30  
VARIABLE  M4_DN_7_S   15 
VARIABLE  M4_DN_7_E   15 
VARIABLE  M4_DN_7     0.05 
VARIABLE  M4_DN_7_W_R 15  
VARIABLE  M4_DN_7_S_R 15 
VARIABLE  M4_DN_7_E_R 7.5
VARIABLE  M4_DN_7_R   0.05 

VARIABLE  VIA6_W_1     0.07 
VARIABLE  VIA6_S_1     0.07 
VARIABLE  VIA6_S_1_1   0.2
VARIABLE  VIA6_S_2     0.09 
VARIABLE  VIA6_S_2_D   0.098 
VARIABLE  VIA6_S_3     0.095  
VARIABLE  VIA6_S_3_1   0.11 
VARIABLE  VIA6_EN_1    0
VARIABLE  VIA6_EN_2    0.03 
VARIABLE  VIA6_EN_4    0.01
VARIABLE  VIA6_EN_4_1  0.02 
#IFNDEF WIDE_ADJUST
VARIABLE  VIA6_R_2_S1  0.14 
VARIABLE  VIA6_R_2_S2  0.63 
VARIABLE  VIA6_R_2_W   0.21 
VARIABLE  VIA6_R_3_S1  0.14 
VARIABLE  VIA6_R_3_S2  0.83 
VARIABLE  VIA6_R_3_W   0.55 
VARIABLE  VIA6_R_4_W   0.21
VARIABLE  VIA6_R_4_D   1.14
VARIABLE  VIA6_R_5_W   1.4
VARIABLE  VIA6_R_5_D   2.8
VARIABLE  VIA6_R_6_W   2.1
VARIABLE  VIA6_R_6_L   7.0
VARIABLE  VIA6_R_6_D   7.1
VARIABLE  VIA6_R_11_L1 5.0
VARIABLE  VIA6_R_11_A  5.0
VARIABLE  VIA6_R_11_L2  1.0
VARIABLE  VIA6_R_11_W  0.21
#ELSE
VARIABLE  VIA6_R_2_S1  0.16
VARIABLE  VIA6_R_2_S2  0.70
VARIABLE  VIA6_R_2_W   0.235
VARIABLE  VIA6_R_3_S1  0.16
VARIABLE  VIA6_R_3_S2  0.92
VARIABLE  VIA6_R_3_W   0.605
VARIABLE  VIA6_R_4_W   0.235
VARIABLE  VIA6_R_4_D   1.14
VARIABLE  VIA6_R_5_W   1.54
VARIABLE  VIA6_R_5_D   2.80
VARIABLE  VIA6_R_6_W   2.31
VARIABLE  VIA6_R_6_L   7.70
VARIABLE  VIA6_R_6_D   7.10
VARIABLE  VIA6_R_11_L2  1.00
VARIABLE  VIA6_R_11_W  0.235
VARIABLE  VIA6_R_11_A  5.00
VARIABLE  VIA6_R_11_L1 5.00
#ENDIF

VARIABLE  M7_W_1      0.07 
VARIABLE  M7_W_2      0.17
VARIABLE  M7_S_1      0.07 
#IFNDEF WIDE_ADJUST
VARIABLE  M7_W_3      4.50
VARIABLE  M7_S_2      0.10 
VARIABLE  M7_S_2_W    0.17 
VARIABLE  M7_S_2_L    0.27
VARIABLE  M7_S_2_1    0.12 
VARIABLE  M7_S_2_1_W  0.24 
VARIABLE  M7_S_2_1_L  0.27
VARIABLE  M7_S_2_2    0.15 
VARIABLE  M7_S_2_2_W  0.31 
VARIABLE  M7_S_2_2_L  0.40
VARIABLE  M7_S_2_3    0.21 
VARIABLE  M7_S_2_3_W  0.62 
VARIABLE  M7_S_2_3_L  0.62
VARIABLE  M7_S_3      0.50 
VARIABLE  M7_S_3_W    1.50 
VARIABLE  M7_S_3_L    1.50 
#ELSE
VARIABLE  M7_W_3      4.95 
VARIABLE  M7_S_2      0.10
VARIABLE  M7_S_2_W    0.19
VARIABLE  M7_S_2_L    0.30
VARIABLE  M7_S_2_1    0.12
VARIABLE  M7_S_2_1_W  0.265
VARIABLE  M7_S_2_1_L  0.30
VARIABLE  M7_S_2_2    0.15
VARIABLE  M7_S_2_2_W  0.345
VARIABLE  M7_S_2_2_L  0.44
VARIABLE  M7_S_2_3    0.21
VARIABLE  M7_S_2_3_W  0.685
VARIABLE  M7_S_2_3_L  0.685
VARIABLE  M7_S_2_4    0.075
VARIABLE  M7_S_2_4_W  0.17
VARIABLE  M7_S_2_4_L  0.30
VARIABLE  M7_S_2_5    0.11
VARIABLE  M7_S_2_5_W  0.24
VARIABLE  M7_S_2_5_L  0.30
VARIABLE  M7_S_2_6    0.13
VARIABLE  M7_S_2_6_W  0.31
VARIABLE  M7_S_2_6_L  0.44
VARIABLE  M7_S_2_7    0.165
VARIABLE  M7_S_2_7_W  0.62
VARIABLE  M7_S_2_7_L  0.685
VARIABLE  M7_S_3      0.50
VARIABLE  M7_S_3_W    1.65
VARIABLE  M7_S_3_L    1.65
#ENDIF
VARIABLE  M7_S_5      0.10 
VARIABLE  M7_S_5_W    0.10 
VARIABLE  M7_S_5_T    0.035 
VARIABLE  M7_S_5_L    0.07	
VARIABLE  M7_S_5_1    0.12
//VARIABLE  M7_S_5_1_L  0.07
VARIABLE  M7_S_5_1_W  0.10 
VARIABLE  M7_S_5_1_T  0.035
VARIABLE  M7_S_5_1_E  0.05 
VARIABLE  M7_S_5_1_E2 0.035
VARIABLE  M7_S_5_1_E3 0.040
VARIABLE  M7_S_5_1_E4 0.045
VARIABLE  M7_S_5_1_S2 0.115
VARIABLE  M7_S_5_1_S3 0.110
VARIABLE  M7_S_5_1_S4 0.105
VARIABLE  M7_S_6      0.17
VARIABLE  M7_S_8      0.1 
VARIABLE  M7_S_8_1    0.08 
VARIABLE  M7_S_1_1    0.09
VARIABLE  M7_S_8_2    0.18
VARIABLE  M7_S_9      0.15
VARIABLE  M7_S_9_A   0.06
VARIABLE  M7_S_9_B   0.12
VARIABLE  M7_S_9_C   0.13
VARIABLE  M7_S_9_D   0.01
VARIABLE  M7_EN_1     0
VARIABLE  M7_EN_2     0.03 
VARIABLE  M7_EN_3     0.01
VARIABLE  M7_EN_3_1   0.02 
VARIABLE  M7_A_1      0.027 
VARIABLE  M7_A_2      0.06 
VARIABLE  M7_A_2_W    0.07 
VARIABLE  M7_A_2_L1    0.17
VARIABLE  M7_A_2_L2    0.17
VARIABLE  M7_A_3      0.20 
VARIABLE  M7_DN_1    0.1 
VARIABLE  M7_DN_1_W  METAL_LOW_DEN_WINDOW_SIZE 
VARIABLE  M7_DN_1_S  METAL_LOW_DEN_WINDOW_STEP
VARIABLE  M7_DN_1_E  M7_DN_1_W/4
VARIABLE  M7_DN_1_1  0.85
VARIABLE  M7_DN_1_1_W  METAL_HIGH_DEN_WINDOW_SIZE 
VARIABLE  M7_DN_1_1_S  METAL_HIGH_DEN_WINDOW_STEP
VARIABLE  M7_DN_1_1_E  M7_DN_1_1_W/4
VARIABLE  M7_DN_4     0.5
VARIABLE  M7_DN_4_W   200 
VARIABLE  M7_DN_6_W_A 80  
VARIABLE  M7_DN_6_S_A 40  
VARIABLE  M7_DN_6_E_A 40  
VARIABLE  M7_DN_6     0.01 
VARIABLE  M7_DN_6_W_BC 10
VARIABLE  M7_DN_6_S_BC 5  
VARIABLE  M7_DN_6_E_BC 5
VARIABLE  M7_DN_6_A_B 6400
VARIABLE  M7_DN_6_A_C 18000
VARIABLE  M7_DN_6_U   30
VARIABLE  M7_DN_6_W_A_R 40  
VARIABLE  M7_DN_6_S_A_R 40  
VARIABLE  M7_DN_6_E_A_R 20  
VARIABLE  M7_DN_6_R     0.01 
VARIABLE  M7_DN_6_W_BC_R 10
VARIABLE  M7_DN_6_S_BC_R 5  
VARIABLE  M7_DN_6_E_BC_R 5
VARIABLE  M7_DN_6_A_B_R 1600
VARIABLE  M7_DN_6_A_C_R 4500
VARIABLE  M7_DN_6_U_R   30
VARIABLE  M5_DN_5_W   62.5
VARIABLE  M5_DN_5_S   31.25
VARIABLE  M5_DN_5     0.85
VARIABLE  M5_DN_7_W   30  
VARIABLE  M5_DN_7_S   15 
VARIABLE  M5_DN_7_E   15 
VARIABLE  M5_DN_7     0.05 
VARIABLE  M5_DN_7_W_R 15  
VARIABLE  M5_DN_7_S_R 15 
VARIABLE  M5_DN_7_E_R 7.5
VARIABLE  M5_DN_7_R   0.05 

VARIABLE  VIA7_W_1     0.07 
VARIABLE  VIA7_S_1     0.07 
VARIABLE  VIA7_S_1_1   0.2
VARIABLE  VIA7_S_2     0.09 
VARIABLE  VIA7_S_2_D   0.098 
VARIABLE  VIA7_S_3     0.095  
VARIABLE  VIA7_S_3_1   0.11 
VARIABLE  VIA7_EN_1    0
VARIABLE  VIA7_EN_2    0.03 
VARIABLE  VIA7_EN_4    0.01
VARIABLE  VIA7_EN_4_1  0.02 
#IFNDEF WIDE_ADJUST
VARIABLE  VIA7_R_2_S1  0.14 
VARIABLE  VIA7_R_2_S2  0.63 
VARIABLE  VIA7_R_2_W   0.21 
VARIABLE  VIA7_R_3_S1  0.14 
VARIABLE  VIA7_R_3_S2  0.83 
VARIABLE  VIA7_R_3_W   0.55 
VARIABLE  VIA7_R_4_W   0.21
VARIABLE  VIA7_R_4_D   1.14
VARIABLE  VIA7_R_5_W   1.4
VARIABLE  VIA7_R_5_D   2.8
VARIABLE  VIA7_R_6_W   2.1
VARIABLE  VIA7_R_6_L   7.0
VARIABLE  VIA7_R_6_D   7.1
VARIABLE  VIA7_R_11_L1 5.0
VARIABLE  VIA7_R_11_A  5.0
VARIABLE  VIA7_R_11_L2  1.0
VARIABLE  VIA7_R_11_W  0.21
#ELSE
VARIABLE  VIA7_R_2_S1  0.16
VARIABLE  VIA7_R_2_S2  0.70
VARIABLE  VIA7_R_2_W   0.235
VARIABLE  VIA7_R_3_S1  0.16
VARIABLE  VIA7_R_3_S2  0.92
VARIABLE  VIA7_R_3_W   0.605
VARIABLE  VIA7_R_4_W   0.235
VARIABLE  VIA7_R_4_D   1.14
VARIABLE  VIA7_R_5_W   1.54
VARIABLE  VIA7_R_5_D   2.80
VARIABLE  VIA7_R_6_W   2.31
VARIABLE  VIA7_R_6_L   7.70
VARIABLE  VIA7_R_6_D   7.10
VARIABLE  VIA7_R_11_L2  1.00
VARIABLE  VIA7_R_11_W  0.235
VARIABLE  VIA7_R_11_A  5.00
VARIABLE  VIA7_R_11_L1 5.00
#ENDIF

VARIABLE  M8_W_1      0.07 
VARIABLE  M8_W_2      0.17
VARIABLE  M8_S_1      0.07 
#IFNDEF WIDE_ADJUST
VARIABLE  M8_W_3      4.50
VARIABLE  M8_S_2      0.10 
VARIABLE  M8_S_2_W    0.17 
VARIABLE  M8_S_2_L    0.27
VARIABLE  M8_S_2_1    0.12 
VARIABLE  M8_S_2_1_W  0.24 
VARIABLE  M8_S_2_1_L  0.27
VARIABLE  M8_S_2_2    0.15 
VARIABLE  M8_S_2_2_W  0.31 
VARIABLE  M8_S_2_2_L  0.40
VARIABLE  M8_S_2_3    0.21 
VARIABLE  M8_S_2_3_W  0.62 
VARIABLE  M8_S_2_3_L  0.62
VARIABLE  M8_S_3      0.50 
VARIABLE  M8_S_3_W    1.50 
VARIABLE  M8_S_3_L    1.50 
#ELSE
VARIABLE  M8_W_3      4.95 
VARIABLE  M8_S_2      0.10
VARIABLE  M8_S_2_W    0.19
VARIABLE  M8_S_2_L    0.30
VARIABLE  M8_S_2_1    0.12
VARIABLE  M8_S_2_1_W  0.265
VARIABLE  M8_S_2_1_L  0.30
VARIABLE  M8_S_2_2    0.15
VARIABLE  M8_S_2_2_W  0.345
VARIABLE  M8_S_2_2_L  0.44
VARIABLE  M8_S_2_3    0.21
VARIABLE  M8_S_2_3_W  0.685
VARIABLE  M8_S_2_3_L  0.685
VARIABLE  M8_S_2_4    0.075
VARIABLE  M8_S_2_4_W  0.17
VARIABLE  M8_S_2_4_L  0.30
VARIABLE  M8_S_2_5    0.11
VARIABLE  M8_S_2_5_W  0.24
VARIABLE  M8_S_2_5_L  0.30
VARIABLE  M8_S_2_6    0.13
VARIABLE  M8_S_2_6_W  0.31
VARIABLE  M8_S_2_6_L  0.44
VARIABLE  M8_S_2_7    0.165
VARIABLE  M8_S_2_7_W  0.62
VARIABLE  M8_S_2_7_L  0.685
VARIABLE  M8_S_3      0.50
VARIABLE  M8_S_3_W    1.65
VARIABLE  M8_S_3_L    1.65
#ENDIF
VARIABLE  M8_S_5      0.10 
VARIABLE  M8_S_5_W    0.10 
VARIABLE  M8_S_5_T    0.035 
VARIABLE  M8_S_5_L    0.07	
VARIABLE  M8_S_5_1    0.12
//VARIABLE  M8_S_5_1_L  0.07
VARIABLE  M8_S_5_1_W  0.10 
VARIABLE  M8_S_5_1_T  0.035
VARIABLE  M8_S_5_1_E  0.05 
VARIABLE  M8_S_5_1_E2 0.035
VARIABLE  M8_S_5_1_E3 0.040
VARIABLE  M8_S_5_1_E4 0.045
VARIABLE  M8_S_5_1_S2 0.115
VARIABLE  M8_S_5_1_S3 0.110
VARIABLE  M8_S_5_1_S4 0.105
VARIABLE  M8_S_6      0.17
VARIABLE  M8_S_8      0.1 
VARIABLE  M8_S_8_1    0.08 
VARIABLE  M8_S_1_1    0.09
VARIABLE  M8_S_8_2    0.18
VARIABLE  M8_S_9      0.15
VARIABLE  M8_S_9_A   0.06
VARIABLE  M8_S_9_B   0.12
VARIABLE  M8_S_9_C   0.13
VARIABLE  M8_S_9_D   0.01
VARIABLE  M8_EN_1     0
VARIABLE  M8_EN_2     0.03 
VARIABLE  M8_EN_3     0.01
VARIABLE  M8_EN_3_1   0.02 
VARIABLE  M8_A_1      0.027 
VARIABLE  M8_A_2      0.06 
VARIABLE  M8_A_2_W    0.07 
VARIABLE  M8_A_2_L1    0.17
VARIABLE  M8_A_2_L2    0.17
VARIABLE  M8_A_3      0.20 
VARIABLE  M8_DN_1    0.1 
VARIABLE  M8_DN_1_W  METAL_LOW_DEN_WINDOW_SIZE 
VARIABLE  M8_DN_1_S  METAL_LOW_DEN_WINDOW_STEP
VARIABLE  M8_DN_1_E  M8_DN_1_W/4
VARIABLE  M8_DN_1_1  0.85
VARIABLE  M8_DN_1_1_W  METAL_HIGH_DEN_WINDOW_SIZE 
VARIABLE  M8_DN_1_1_S  METAL_HIGH_DEN_WINDOW_STEP
VARIABLE  M8_DN_1_1_E  M8_DN_1_1_W/4
VARIABLE  M8_DN_4     0.5
VARIABLE  M8_DN_4_W   200 
VARIABLE  M8_DN_6_W_A 80  
VARIABLE  M8_DN_6_S_A 40  
VARIABLE  M8_DN_6_E_A 40  
VARIABLE  M8_DN_6     0.01 
VARIABLE  M8_DN_6_W_BC 10
VARIABLE  M8_DN_6_S_BC 5  
VARIABLE  M8_DN_6_E_BC 5
VARIABLE  M8_DN_6_A_B 6400
VARIABLE  M8_DN_6_A_C 18000
VARIABLE  M8_DN_6_U   30
VARIABLE  M8_DN_6_W_A_R 40  
VARIABLE  M8_DN_6_S_A_R 40  
VARIABLE  M8_DN_6_E_A_R 20  
VARIABLE  M8_DN_6_R     0.01 
VARIABLE  M8_DN_6_W_BC_R 10
VARIABLE  M8_DN_6_S_BC_R 5  
VARIABLE  M8_DN_6_E_BC_R 5
VARIABLE  M8_DN_6_A_B_R 1600
VARIABLE  M8_DN_6_A_C_R 4500
VARIABLE  M8_DN_6_U_R   30
VARIABLE  M6_DN_5_W   62.5
VARIABLE  M6_DN_5_S   31.25
VARIABLE  M6_DN_5     0.85
VARIABLE  M6_DN_7_W   30  
VARIABLE  M6_DN_7_S   15 
VARIABLE  M6_DN_7_E   15 
VARIABLE  M6_DN_7     0.05 
VARIABLE  M6_DN_7_W_R 15  
VARIABLE  M6_DN_7_S_R 15 
VARIABLE  M6_DN_7_E_R 7.5
VARIABLE  M6_DN_7_R   0.05 

VARIABLE  VIA8_W_1   0.36 
VARIABLE  VIA8_S_1   0.34 
VARIABLE  VIA8_S_2   0.54 
VARIABLE  VIA8_S_2_D 0.56
VARIABLE  VIA8_EN_1  0.02 
VARIABLE  VIA8_EN_2  0.08 
#IFNDEF  WIDE_ADJUST
VARIABLE  VIA8_R_2_S 1.7 
VARIABLE  VIA8_R_2_W 1.8 
VARIABLE  VIA8_R_3_W 3.0
VARIABLE  VIA8_R_3_L 10.0
VARIABLE  VIA8_R_3_D 5.0
#ELSE
VARIABLE  VIA8_R_2_S 1.87
VARIABLE  VIA8_R_2_W 1.98
VARIABLE  VIA8_R_3_W 3.3
VARIABLE  VIA8_R_3_L 11.0
VARIABLE  VIA8_R_3_D 5.0
#ENDIF
VARIABLE  M9_W_1   0.40
VARIABLE  M9_S_1   0.40
#IFNDEF WIDE_ADJUST
VARIABLE  M9_W_2   12.0 
VARIABLE  M9_S_2   0.5 
VARIABLE  M9_S_2_W 1.5 
VARIABLE  M9_S_2_L 1.5 
VARIABLE  M9_S_3   1.5 
VARIABLE  M9_S_3_W 4.5 
VARIABLE  M9_S_3_L 4.5 
#ELSE
VARIABLE  M9_W_2   13.2 
VARIABLE  M9_S_2   0.50
VARIABLE  M9_S_2_W 1.65
VARIABLE  M9_S_2_L 1.65
VARIABLE  M9_S_3   1.50
VARIABLE  M9_S_3_W 4.95
VARIABLE  M9_S_3_L 4.95
#ENDIF
VARIABLE  M9_EN_1  0.02 
VARIABLE  M9_EN_2  0.08 
VARIABLE  M9_A_1   0.565 
VARIABLE  M9_A_2   0.565 
VARIABLE  M9_DN_1    0.1 
VARIABLE  M9_DN_1_W  METAL_LOW_DEN_WINDOW_SIZE 
VARIABLE  M9_DN_1_S  METAL_LOW_DEN_WINDOW_STEP
VARIABLE  M9_DN_1_E  M9_DN_1_W/4
VARIABLE  M9_DN_1_1  0.85
VARIABLE  M9_DN_1_1_W  METAL_HIGH_DEN_WINDOW_SIZE 
VARIABLE  M9_DN_1_1_S  METAL_HIGH_DEN_WINDOW_STEP
VARIABLE  M9_DN_1_1_E  M9_DN_1_1_W/4
VARIABLE  M9_DN_4     0.5
VARIABLE  M9_DN_4_W   200 


VARIABLE  VIA9_W_1   0.36 
VARIABLE  VIA9_S_1   0.34 
VARIABLE  VIA9_S_2   0.54 
VARIABLE  VIA9_S_2_D 0.56
VARIABLE  VIA9_EN_1  0.02 
VARIABLE  VIA9_EN_2  0.08 
#IFNDEF  WIDE_ADJUST
VARIABLE  VIA9_R_2_S 1.7 
VARIABLE  VIA9_R_2_W 1.8 
VARIABLE  VIA9_R_3_W 3.0
VARIABLE  VIA9_R_3_L 10.0
VARIABLE  VIA9_R_3_D 5.0
#ELSE
VARIABLE  VIA9_R_2_S 1.87
VARIABLE  VIA9_R_2_W 1.98
VARIABLE  VIA9_R_3_W 3.3
VARIABLE  VIA9_R_3_L 11.0
VARIABLE  VIA9_R_3_D 5.0
#ENDIF
VARIABLE  M10_W_1   0.40
VARIABLE  M10_S_1   0.40
#IFNDEF WIDE_ADJUST
VARIABLE  M10_W_2   12.0 
VARIABLE  M10_S_2   0.5 
VARIABLE  M10_S_2_W 1.5 
VARIABLE  M10_S_2_L 1.5 
VARIABLE  M10_S_3   1.5 
VARIABLE  M10_S_3_W 4.5 
VARIABLE  M10_S_3_L 4.5 
#ELSE
VARIABLE  M10_W_2   13.2 
VARIABLE  M10_S_2   0.50
VARIABLE  M10_S_2_W 1.65
VARIABLE  M10_S_2_L 1.65
VARIABLE  M10_S_3   1.50
VARIABLE  M10_S_3_W 4.95
VARIABLE  M10_S_3_L 4.95
#ENDIF
VARIABLE  M10_EN_1  0.02 
VARIABLE  M10_EN_2  0.08 
VARIABLE  M10_A_1   0.565 
VARIABLE  M10_A_2   0.565 
VARIABLE  M10_DN_1    0.1 
VARIABLE  M10_DN_1_W  METAL_LOW_DEN_WINDOW_SIZE 
VARIABLE  M10_DN_1_S  METAL_LOW_DEN_WINDOW_STEP
VARIABLE  M10_DN_1_E  M10_DN_1_W/4
VARIABLE  M10_DN_1_1  0.85
VARIABLE  M10_DN_1_1_W  METAL_HIGH_DEN_WINDOW_SIZE 
VARIABLE  M10_DN_1_1_S  METAL_HIGH_DEN_WINDOW_STEP
VARIABLE  M10_DN_1_1_E  M10_DN_1_1_W/4
VARIABLE  M10_DN_4     0.5
VARIABLE  M10_DN_4_W   200 



VARIABLE LOWMEDN_W_1 0.14
VARIABLE LOWMEDN_W_2 0.14
VARIABLE LOWMEDN_S_1 0.14
VARIABLE LOWMEDN_S_2 0.14
VARIABLE LOWMEDN_R_5 4 
VARIABLE VIAx_W_6  0.07
VARIABLE VIAx_S_7  0.365
VARIABLE VIAx_S_8  0.74
VARIABLE VIAx_EN_8 0.21
VARIABLE Mx_EN_4   0.21

VARIABLE  RV_W_1A    3.0
VARIABLE  RV_W_1B    2.0
VARIABLE  RV_S_1     2.0
VARIABLE  RV_EN_1    0.5

#IFDEF AP_36K_THICKNESS
VARIABLE  AP_W_1     3.0
#ELSE
VARIABLE  AP_W_1     2.0
#ENDIF
VARIABLE  AP_W_2     35.0
VARIABLE  AP_S_1     2.0
VARIABLE  AP_EN_1    0.5
VARIABLE  AP_EN_1I   0.5
VARIABLE  AP_DN_1    0.1
#IFDEF AP_36K_THICKNESS
VARIABLE  AP_DN_1_1  0.85
#ELSE
VARIABLE  AP_DN_1_1  0.7
#ENDIF

VARIABLE  MOM_S_2    0.1
VARIABLE  MOM_A_1    1.31E6



VARIABLE  PO_EX_2_R	0.13
VARIABLE  PO_EX_2_PS    0.16

#IFDEF GS
VARIABLE  PO_S_5_R	0.06
VARIABLE  PO_S_6_R	0.07
#ELSE
VARIABLE  PO_S_5_R	0.10
VARIABLE  PO_S_6_R	0.10
#ENDIF

VARIABLE  OD_S_6_R	0.35
VARIABLE  DOD_R_2_R	1.8
VARIABLE  OD_DN_4_R     0.10
VARIABLE  OD_DN_5_R     0.55
VARIABLE  OD_DN_6_R     0.20
VARIABLE  OD_DN_7_R     0.55
VARIABLE  OD_DN_8_R     0.2
VARIABLE  OD_DN_9_R     0.6
VARIABLE  DNW_EN_1_R	1.00
#IFNDEF GS
VARIABLE  PO_S_2_R	0.14
#ENDIF
VARIABLE  PO_S_17_R	0.16
VARIABLE  PO_S_17_R_GL	0.04
VARIABLE  PO_S_17_R_GW	0.2
VARIABLE  PO_S_17_R_W	0.12
VARIABLE  PO_S_17_R_L	0.1
VARIABLE  PO_S_18_R_1   0.14
VARIABLE  PO_S_18_R_2   0.2
VARIABLE  PO_S_18_R_GL	0.08
VARIABLE  PO_S_18_R_S	0.2
VARIABLE  PO_S_18_R_W	0.08
VARIABLE  PO_EX_1_R	0.11
VARIABLE  PO_DN_4_R     0.05
VARIABLE  PO_DN_5_R     0.35
VARIABLE  PO_DN_6_R     0.15
VARIABLE  PO_DN_7_R     0.35
VARIABLE  PO_DN_8_R     0.15
VARIABLE  PO_DN_9_R     0.40
VARIABLE  ESDIMP_EN_1R  0.4 
VARIABLE  SRDPO_W_1_R	0.04
VARIABLE  SRDPO_W_1_S_R  0.32
VARIABLE  SRDPO_S_1_R	0.12
VARIABLE  SRDPO_L_3_R	10
VARIABLE  SRDPO_L_1_R	0.5
VARIABLE  SRDPO_DN_1_R   0.04
VARIABLE  SRDOD_W_1_R     0.1
VARIABLE  SRDOD_S_3_R    0.05
VARIABLE  SRDOD_DN_1_R   0.08
VARIABLE  SRDOD_DN_1_R_S1 2.5
VARIABLE  SRDOD_DN_1_R_S2 0.4

VARIABLE  NWROD_S_3_R	0.30
VARIABLE  NWRSTI_EN_2_R	0.30
VARIABLE  OD_W_1_R	0.08
VARIABLE  PO_S_4_1_R	0.14
VARIABLE  PO_S_4_1_A_R	0.0196
VARIABLE  CO_EN_1_R	0.03
VARIABLE  CO_EN_1_1_R	0.04
VARIABLE  CO_EN_3_R	0.04
VARIABLE  CO_S_7_R_L    0.05
VARIABLE  CO_S_7_R_W    1.0
VARIABLE  CO_S_7_R_S    0.22
VARIABLE  CO_S_7_R      0.29

VARIABLE  OD_S_1_R	0.10
VARIABLE  PO_S_1_R	0.12
VARIABLE  CO_S_3_R	0.05
VARIABLE  M1_S_1_R	0.09
VARIABLE  M2_S_1_R	0.09
VARIABLE  M3_S_1_R	0.09
VARIABLE  M4_S_1_R	0.09
VARIABLE  M5_S_1_R	0.09
VARIABLE  M6_S_1_R	0.09
VARIABLE  M7_S_1_R	0.09
VARIABLE  M8_S_1_R	0.09

VARIABLE  M1_EN_1_R	0.03
VARIABLE  M1_EN_2_R	0.05
VARIABLE  M1_EN_5_R     0.015
VARIABLE  M1_EN_5_R_W   0.11
VARIABLE  M1_EN_5_R_S   0.08
VARIABLE  M1_A_1_R      0.0351
VARIABLE  VIA1_EN_1_R	0.03
VARIABLE  VIA1_EN_2_R	0.05
VARIABLE  M2_EN_1_R	0.03
VARIABLE  M2_EN_2_R	0.05
VARIABLE  M2_A_1_R     0.0351
VARIABLE  VIA2_EN_1_R	0.03
VARIABLE  VIA2_EN_2_R	0.05
VARIABLE  M3_EN_1_R	0.03
VARIABLE  M3_EN_2_R	0.05
VARIABLE  M3_A_1_R     0.0351
VARIABLE  VIA3_EN_1_R	0.03
VARIABLE  VIA3_EN_2_R	0.05
VARIABLE  M4_EN_1_R	0.03
VARIABLE  M4_EN_2_R	0.05
VARIABLE  M4_A_1_R     0.0351
VARIABLE  VIA4_EN_1_R	0.03
VARIABLE  VIA4_EN_2_R	0.05
VARIABLE  M5_EN_1_R	0.03
VARIABLE  M5_EN_2_R	0.05
VARIABLE  M5_A_1_R     0.0351
VARIABLE  VIA5_EN_1_R	0.03
VARIABLE  VIA5_EN_2_R	0.05
VARIABLE  M6_EN_1_R	0.03
VARIABLE  M6_EN_2_R	0.05
VARIABLE  M6_A_1_R     0.0351
VARIABLE  VIA6_EN_1_R	0.03
VARIABLE  VIA6_EN_2_R	0.05
VARIABLE  M7_EN_1_R	0.03
VARIABLE  M7_EN_2_R	0.05
VARIABLE  M7_A_1_R     0.0351
VARIABLE  VIA7_EN_1_R	0.03
VARIABLE  VIA7_EN_2_R	0.05
VARIABLE  M8_EN_1_R	0.03
VARIABLE  M8_EN_2_R	0.05
VARIABLE  M8_A_1_R     0.0351

VARIABLE  M1_S_7_R	0.35
VARIABLE  M2_S_7_R	0.35
VARIABLE  M3_S_7_R	0.35
VARIABLE  M4_S_7_R	0.35
VARIABLE  M5_S_7_R	0.35
VARIABLE  M6_S_7_R	0.35
VARIABLE  M7_S_7_R	0.35
VARIABLE  M8_S_7_R	0.35
VARIABLE  M9_W_3_R	0.42
VARIABLE  M9_W_3_S_R	5.00
VARIABLE  M9_W_3_G_R	1.00
VARIABLE  M10_W_3_R	0.42
VARIABLE  M10_W_3_S_R	5.00
VARIABLE  M10_W_3_G_R	1.00

VARIABLE  Mx_DN_8_W   0.07 
VARIABLE  Mx_DN_8_L   0.52
VARIABLE  Mx_DN_8_S   0.07 
VARIABLE  Mx_DN_8_R1  0.209 
VARIABLE  Mx_DN_8_R2  0.52
VARIABLE  Mx_DN_8     0.065

#IFDEF GS
VARIABLE  PO_S_14_MR	0.8
VARIABLE  PO_EN_1_MR	1.0
VARIABLE  PO_EN_2_MR	3.7
VARIABLE  PO_EN_3_MR	2.3
#ELSE
VARIABLE  PO_S_14_MR	1.40
VARIABLE  PO_EN_1_MR	1.40
VARIABLE  PO_EN_2_MR	2.00
VARIABLE  PO_EN_3_MR	1.80
#ENDIF
VARIABLE  PO_S_5_MR	0.20
VARIABLE  PO_S_6_MR	0.10
VARIABLE  PO_S_6_1_MR	0.18
VARIABLE  PO_S_6_1_W_MR	0.3
VARIABLE  PO_S_6_1_L_MR	0.1
VARIABLE  PO_EX_1_MR	0.11
VARIABLE  PO_EX_2_L_MR	0.29
VARIABLE  PO_EX_2_H_MR	0.48
VARIABLE  BJT_R_2_S_R	2.00
VARIABLE  BJT_R_2_M_R	5.00
VARIABLE  BJT_R_2_B_R	10.0

VARIABLE  DTCD_DN_1_R   0.7
VARIABLE  DTCD_DN_1_WR  2000


VARIABLE ICOVL_S_1  40
VARIABLE ICOVL_S_3  2
VARIABLE ICOVL_R_7  8
VARIABLE ICOVL_R_8  4


VARIABLE  LOGO_S_1   10.0

VARIABLE  DTCD_W_1A 12.0
VARIABLE  DTCD_W_1B 9.245
VARIABLE  DTCD_W_2A 0.43
VARIABLE  DTCD_W_2B 4.0
VARIABLE  DTCD_W_2C 5.0
VARIABLE  DTCD_W_3  0.04
VARIABLE  DTCD_S_1  0.14
VARIABLE  DTCD_W_1_1A 5.71
VARIABLE  DTCD_W_1_1B 3.57
VARIABLE  DTCD_W_1_2A 3.6
VARIABLE  DTCD_W_1_2B 6.33
VARIABLE  DTCD_W_2_1A 0.31
VARIABLE  DTCD_W_2_1B 0.41
VARIABLE  DTCD_W_2_1C 2.4
VARIABLE  DTCD_S_1_1A 0.14
VARIABLE  DTCD_S_1_1B 0.2
VARIABLE  DTCD_S_1_1W 2.0
VARIABLE  DTCD_S_1_2  0.14
VARIABLE  DTCD_S_1_2W 2.0
VARIABLE  DTCD_R_4    0.5

VARIABLE  DOD_W_1   0.5 
VARIABLE  DOD_S_1   0.4 
VARIABLE  DOD_S_2   0.34 
VARIABLE  DOD_S_3   0.3 
VARIABLE  DOD_S_5   0.3 
VARIABLE  DOD_S_8   0.6 
VARIABLE  DOD_S_10  1.2 
VARIABLE  DOD_EN_1  0.3 
VARIABLE  DOD_EN_2  0.6 

VARIABLE  DPO_W_1   0.4 
VARIABLE  DPO_S_1   0.3 
VARIABLE  DPO_S_2   0.2 
VARIABLE  DPO_S_3   0.5 
VARIABLE  DPO_S_9   1.2 
VARIABLE  DPO_EN_1  0.6 

VARIABLE  DM1_W_2     3.0 
VARIABLE  DM1_S_3     1.5 
VARIABLE  DM1_S_3_W   4.5
VARIABLE  DM1_S_3_L   4.5
VARIABLE  DM1_EN_1    2.5 
VARIABLE  DM2_W_2     3.0 
VARIABLE  DM2_S_3     1.5 
VARIABLE  DM2_S_3_W   4.5
VARIABLE  DM2_S_3_L   4.5
VARIABLE  DM2_EN_1    2.5 
VARIABLE  DM3_W_2     3.0 
VARIABLE  DM3_S_3     1.5 
VARIABLE  DM3_S_3_W   4.5
VARIABLE  DM3_S_3_L   4.5
VARIABLE  DM3_EN_1    2.5 
VARIABLE  DM4_W_2     3.0 
VARIABLE  DM4_S_3     1.5 
VARIABLE  DM4_S_3_W   4.5
VARIABLE  DM4_S_3_L   4.5
VARIABLE  DM4_EN_1    2.5 
VARIABLE  DM5_W_2     3.0 
VARIABLE  DM5_S_3     1.5 
VARIABLE  DM5_S_3_W   4.5
VARIABLE  DM5_S_3_L   4.5
VARIABLE  DM5_EN_1    2.5 
VARIABLE  DM6_W_2     3.0 
VARIABLE  DM6_S_3     1.5 
VARIABLE  DM6_S_3_W   4.5
VARIABLE  DM6_S_3_L   4.5
VARIABLE  DM6_EN_1    2.5 
VARIABLE  DM7_W_2     3.0 
VARIABLE  DM7_S_3     1.5 
VARIABLE  DM7_S_3_W   4.5
VARIABLE  DM7_S_3_L   4.5
VARIABLE  DM7_EN_1    2.5 
VARIABLE  DM8_W_2     3.0 
VARIABLE  DM8_S_3     1.5 
VARIABLE  DM8_S_3_W   4.5
VARIABLE  DM8_S_3_L   4.5
VARIABLE  DM8_EN_1    2.5 
VARIABLE  DM9_W_2     3.0 
VARIABLE  DM9_S_3     1.5 
VARIABLE  DM9_S_3_W   4.5
VARIABLE  DM9_S_3_L   4.5
VARIABLE  DM9_EN_1    2.5 
VARIABLE  DM10_W_2     3.0 
VARIABLE  DM10_S_3     1.5 
VARIABLE  DM10_S_3_W   4.5
VARIABLE  DM10_S_3_L   4.5
VARIABLE  DM10_EN_1    2.5 

VARIABLE  DM1_W_1   0.14
VARIABLE  DM1_S_1   0.14
VARIABLE  DM1_S_2a  0.6 
VARIABLE  DM1_S_2b  1.5 
VARIABLE  DM1_A_1   0.16
VARIABLE  DM1_A_2   80.0
VARIABLE  DM1_EN_2  0.01 
VARIABLE  DM2_W_1   0.14
VARIABLE  DM2_S_1   0.14
VARIABLE  DM2_S_2a  0.6 
VARIABLE  DM2_S_2b  1.5 
VARIABLE  DM2_A_1   0.16
VARIABLE  DM2_A_2   80.0
VARIABLE  DM2_EN_2  0.01 
VARIABLE  DM3_W_1   0.14
VARIABLE  DM3_S_1   0.14
VARIABLE  DM3_S_2a  0.6 
VARIABLE  DM3_S_2b  1.5 
VARIABLE  DM3_A_1   0.16
VARIABLE  DM3_A_2   80.0
VARIABLE  DM3_EN_2  0.01 
VARIABLE  DM4_W_1   0.14
VARIABLE  DM4_S_1   0.14
VARIABLE  DM4_S_2a  0.6 
VARIABLE  DM4_S_2b  1.5 
VARIABLE  DM4_A_1   0.16
VARIABLE  DM4_A_2   80.0
VARIABLE  DM4_EN_2  0.01 
VARIABLE  DM5_W_1   0.14
VARIABLE  DM5_S_1   0.14
VARIABLE  DM5_S_2a  0.6 
VARIABLE  DM5_S_2b  1.5 
VARIABLE  DM5_A_1   0.16
VARIABLE  DM5_A_2   80.0
VARIABLE  DM5_EN_2  0.01 
VARIABLE  DM6_W_1   0.14
VARIABLE  DM6_S_1   0.14
VARIABLE  DM6_S_2a  0.6 
VARIABLE  DM6_S_2b  1.5 
VARIABLE  DM6_A_1   0.16
VARIABLE  DM6_A_2   80.0
VARIABLE  DM6_EN_2  0.01 
VARIABLE  DM7_W_1   0.14
VARIABLE  DM7_S_1   0.14
VARIABLE  DM7_S_2a  0.6 
VARIABLE  DM7_S_2b  1.5 
VARIABLE  DM7_A_1   0.16
VARIABLE  DM7_A_2   80.0
VARIABLE  DM7_EN_2  0.01 
VARIABLE  DM8_W_1   0.14
VARIABLE  DM8_S_1   0.14
VARIABLE  DM8_S_2a  0.6 
VARIABLE  DM8_S_2b  1.5 
VARIABLE  DM8_A_1   0.16
VARIABLE  DM8_A_2   80.0
VARIABLE  DM8_EN_2  0.01 
VARIABLE  DM9_W_1  0.4
VARIABLE  DM9_S_1  0.4
VARIABLE  DM9_S_2  0.6 
VARIABLE  DM9_A_1  0.565
VARIABLE  DM9_A_2  160.0

VARIABLE  DM10_W_1  0.4
VARIABLE  DM10_S_1  0.4
VARIABLE  DM10_S_2  0.6 
VARIABLE  DM10_A_1  0.565
VARIABLE  DM10_A_2  160.0


VARIABLE  DVIA1_W_1   0.12    
VARIABLE  DVIA1_S_1   0.2   
VARIABLE  DVIA1_S_2   0.2 
VARIABLE  DVIA1_EN_1  0.01 
VARIABLE  DVIA1_R_3   0.01   
VARIABLE  DVIA2_W_1   0.12    
VARIABLE  DVIA2_S_1   0.2   
VARIABLE  DVIA2_S_2   0.2 
VARIABLE  DVIA2_EN_1  0.01 
VARIABLE  DVIA2_R_3   0.01   
VARIABLE  DVIA3_W_1   0.12    
VARIABLE  DVIA3_S_1   0.2   
VARIABLE  DVIA3_S_2   0.2 
VARIABLE  DVIA3_EN_1  0.01 
VARIABLE  DVIA3_R_3   0.01   
VARIABLE  DVIA4_W_1   0.12    
VARIABLE  DVIA4_S_1   0.2   
VARIABLE  DVIA4_S_2   0.2 
VARIABLE  DVIA4_EN_1  0.01 
VARIABLE  DVIA4_R_3   0.01   
VARIABLE  DVIA5_W_1   0.12    
VARIABLE  DVIA5_S_1   0.2   
VARIABLE  DVIA5_S_2   0.2 
VARIABLE  DVIA5_EN_1  0.01 
VARIABLE  DVIA5_R_3   0.01   
VARIABLE  DVIA6_W_1   0.12    
VARIABLE  DVIA6_S_1   0.2   
VARIABLE  DVIA6_S_2   0.2 
VARIABLE  DVIA6_EN_1  0.01 
VARIABLE  DVIA6_R_3   0.01   
VARIABLE  DVIA7_W_1   0.12    
VARIABLE  DVIA7_S_1   0.2   
VARIABLE  DVIA7_S_2   0.2 
VARIABLE  DVIA7_EN_1  0.01 
VARIABLE  DVIA7_R_3   0.01   

VARIABLE  LUP_2       15.0
VARIABLE  LUP_2_S     5.0
VARIABLE  LUP_3_W     0.2
VARIABLE  LUP_3_1_1   2.0
VARIABLE  LUP_3_1_2   3.0
VARIABLE  LUP_3_2_1   2.3
VARIABLE  LUP_3_2_2   4.0
VARIABLE  LUP_3_3_1   2.6
VARIABLE  LUP_3_3_2   5.0
VARIABLE  LUP_3_4_1   4.0
VARIABLE  LUP_3_4_2   8.0
VARIABLE  LUP_3_5_1   10
VARIABLE  LUP_3_5_2   15
VARIABLE  LUP_4       0.12
VARIABLE  LUP_5_1_1   2.0
VARIABLE  LUP_5_1_2   3.0
VARIABLE  LUP_5_2_1   2.3
VARIABLE  LUP_5_2_2   4.0
VARIABLE  LUP_5_3_1   2.6
VARIABLE  LUP_5_3_2   5.0
VARIABLE  LUP_5_4_1   4.0
VARIABLE  LUP_5_4_2   8.0
VARIABLE  LUP_5_5_1   10
VARIABLE  LUP_5_5_2   15
VARIABLE  LUP_6       30.0
VARIABLE  LUP_6_SRAM  40.0

VARIABLE  ESD_3g_MIN  15.0
VARIABLE  ESD_3g_MAX  60.0
VARIABLE  ESD_6g      2.00
VARIABLE  ESD_7g      1.20
VARIABLE  ESD_16g      360
VARIABLE  ESD_17g      480
VARIABLE  ESD_18g_33V 0.42
VARIABLE  ESD_18g_25V 0.35
VARIABLE  ESD_18g_18V 0.20
VARIABLE  ESD_18g_LV  0.10
VARIABLE  ESD_20g     0.06
VARIABLE  ESD_21g     1.00
VARIABLE  ESD_22g     0.60
VARIABLE  ESD_23g     0.22
VARIABLE  ESD_24g      360
VARIABLE  ESD_25g      480
VARIABLE  ESD_26g_5V  0.42
VARIABLE  ESD_26g_33V 0.35
VARIABLE  ESD_26g_25V 0.20
VARIABLE  ESD_28g     0.06
VARIABLE  ESD_29g     0.06
VARIABLE  ESD_30g     1.00
VARIABLE  ESD_31g     0.60
VARIABLE  ESD_32g     0.22
VARIABLE  ESD_33g     0.25
VARIABLE  ESD_33g_MIN  0.22 
VARIABLE  ESD_37g_HV  1000
VARIABLE  ESD_37g_LV  1900
VARIABLE  ESD_38g_33V 0.42
VARIABLE  ESD_38g_25V 0.35
VARIABLE  ESD_38g_18V 0.20
VARIABLE  ESD_38g_LV  0.10
VARIABLE  ESD_48g  360
VARIABLE  ESD_49g  360
VARIABLE  ESD_50g  0.35
VARIABLE  ESD_51g_MIN 15
VARIABLE  ESD_51g_MAX 60
VARIABLE  ESD_53g  0.86
VARIABLE  ESD_54g  1.95
VARIABLE  ESD_55g  0.1
VARIABLE  ESD_56g  0.22
VARIABLE  ESD_57g  2.4

VARIABLE  SRESD_W_1   0.18
VARIABLE  SRESD_W_2   0.10
VARIABLE  SRESD_W_3a  15
VARIABLE  SRESD_W_3b  60
VARIABLE  SRESD_S_1   0.18
VARIABLE  SRESD_EX_1  0.02
VARIABLE  SRESD_L_1   60



VARIABLE  SRAM_W_1     0.19
VARIABLE  SRAM_S_1     0.19
VARIABLE  SRAM_S_2     0.14
VARIABLE  SRAM_EN_1    0.14
VARIABLE  SRAM_EN_2    0.09
VARIABLE  SRAM_EX_1    0.19
VARIABLE  SRAM_O_1     0.19
VARIABLE  SRAM_A_1     11
VARIABLE  SRAM_R_31_W   0.3
VARIABLE  SRAM_R_31_S1  0.14 
VARIABLE  SRAM_R_31_S2  0.63 
VARIABLE  SRAM_R_32_W  0.3
VARIABLE  SRAM_R_32_D  1.14

VARIABLE  NPre_W_1   0.2
VARIABLE  NPre_S_1   0.18
VARIABLE  NPre_S_2   0.08 
VARIABLE  NPre_S_4   0.02 
VARIABLE  NPre_S_5   0.23 
VARIABLE  NPre_S_7   0.14 
VARIABLE  NPre_EX_4  0.03 
VARIABLE  NPre_O_1   0.01
VARIABLE  NPre_A_1   0.11 
VARIABLE  NPre_A_2   0.11 
VARIABLE  NPre_L_1   0.50

VARIABLE  WLD_R_2   0.035 
VARIABLE  WLD_R_3   0.1
VARIABLE  WLD_R_7   100
VARIABLE  WLD_R_9   2

VARIABLE  CO2_W_1   0.06
VARIABLE  CO2_R_2   0.015*0.005 

VARIABLE  ROM_W_1A  0.12
VARIABLE  ROM_W_1B  0.35
VARIABLE  ROM_W_2A  0.045
VARIABLE  ROM_W_2B  0.05

VARIABLE  IND_W_1   0.28-2*GRID
VARIABLE  IND_W_2   0.28-2*GRID
VARIABLE  IND_W_3   0.40-2*GRID
VARIABLE  IND_W_4   0.40-2*GRID
VARIABLE  IND_W_5   0.55-2*GRID
VARIABLE  IND_W_6   2.00-2*GRID
VARIABLE  IND_W_7   4.50+2*GRID
VARIABLE  IND_W_8   12.0+2*GRID
VARIABLE  IND_W_9   30.0+2*GRID
VARIABLE  IND_W_10  600+2*GRID
VARIABLE  IND_S_1   0.28-2*GRID
VARIABLE  IND_S_2   0.28-2*GRID
VARIABLE  IND_S_3   0.40-2*GRID
VARIABLE  IND_S_4   0.40-2*GRID
VARIABLE  IND_S_5   0.55-2*GRID
VARIABLE  IND_S_6   1.00-2*GRID
VARIABLE  IND_S_7   0.50-2*GRID
VARIABLE  IND_S_7_W 1.50
VARIABLE  IND_S_7_L 1.50
VARIABLE  IND_S_8   0.65-2*GRID
VARIABLE  IND_S_8_W 1.50
VARIABLE  IND_S_8_L 1.50
VARIABLE  IND_S_9   1.50-2*GRID
VARIABLE  IND_S_9_W 4.50
VARIABLE  IND_S_9_L 4.50
VARIABLE  IND_S_10   2.0-2*GRID
VARIABLE  IND_S_10_W 12.0
VARIABLE  IND_S_10_L 12.0
VARIABLE  IND_R_2    1.7
VARIABLE  IND_R_3    1.7
VARIABLE  IND_R_4    1.7
VARIABLE  IND_DN_1   0.05
VARIABLE  IND_DN_2   0.85
VARIABLE  IND_DN_2_W 125
VARIABLE  IND_DN_2_S 62.5
VARIABLE  IND_DN_3   0.20
VARIABLE  IND_DN_7   0.14
VARIABLE  IND_DN_7_W 1600
VARIABLE  IND_DN_7_S  800
#IFDEF IND_INTER_MET_VIA
VARIABLE  IND_DN_6   0.15
VARIABLE  IND_DN_6R  4
VARIABLE  IND_DN_6W  125
VARIABLE  IND_R_11   0.14
VARIABLE  IND_R_11C  100
VARIABLE  IND_R_12   0.29
VARIABLE  IND_R_12C  81
VARIABLE  IND_R_13   0.57
VARIABLE  IND_R_13C  36	
#ENDIF 


VARIABLE OD_SEx_eDRAM  0.05
VARIABLE OD_SEy_eDRAM  0.002


// for analog variable
VARIABLE BJT_R_1_G1	0.3
VARIABLE BJT_R_8	0.13

VARIABLE  CSR_R_1    74
VARIABLE  CSR_W_1A   9
VARIABLE  CSR_W_1B   10
VARIABLE  CSR_L_1A   24
VARIABLE  CSR_L_1B   25
VARIABLE  CSR_R_3A   18
VARIABLE  CSR_R_3B   20
VARIABLE  SR_S_1     6

VARIABLE CSR_DM1_W_1    0.8
VARIABLE CSR_DM1_S_1    0.4
VARIABLE CSR_DM1_S_2    0.5
VARIABLE CSR_DM1_O_1    0.7
VARIABLE SR_DM1_W_1    0.8
VARIABLE SR_DM1_S_1    0.4
VARIABLE SR_DM1_S_2    0.4
VARIABLE SR_DM1_O_1    0.7
VARIABLE CSR_DM2_W_1    0.8
VARIABLE CSR_DM2_S_1    0.4
VARIABLE CSR_DM2_S_2    0.5
VARIABLE CSR_DM2_O_1    0.7
VARIABLE SR_DM2_W_1    0.8
VARIABLE SR_DM2_S_1    0.4
VARIABLE SR_DM2_S_2    0.4
VARIABLE SR_DM2_O_1    0.7
VARIABLE CSR_DM3_W_1    0.8
VARIABLE CSR_DM3_S_1    0.4
VARIABLE CSR_DM3_S_2    0.5
VARIABLE CSR_DM3_O_1    0.7
VARIABLE SR_DM3_W_1    0.8
VARIABLE SR_DM3_S_1    0.4
VARIABLE SR_DM3_S_2    0.4
VARIABLE SR_DM3_O_1    0.7
VARIABLE CSR_DM4_W_1    0.8
VARIABLE CSR_DM4_S_1    0.4
VARIABLE CSR_DM4_S_2    0.5
VARIABLE CSR_DM4_O_1    0.7
VARIABLE SR_DM4_W_1    0.8
VARIABLE SR_DM4_S_1    0.4
VARIABLE SR_DM4_S_2    0.4
VARIABLE SR_DM4_O_1    0.7
VARIABLE CSR_DM5_W_1    0.8
VARIABLE CSR_DM5_S_1    0.4
VARIABLE CSR_DM5_S_2    0.5
VARIABLE CSR_DM5_O_1    0.7
VARIABLE SR_DM5_W_1    0.8
VARIABLE SR_DM5_S_1    0.4
VARIABLE SR_DM5_S_2    0.4
VARIABLE SR_DM5_O_1    0.7
VARIABLE CSR_DM6_W_1    0.8
VARIABLE CSR_DM6_S_1    0.4
VARIABLE CSR_DM6_S_2    0.5
VARIABLE CSR_DM6_O_1    0.7
VARIABLE SR_DM6_W_1    0.8
VARIABLE SR_DM6_S_1    0.4
VARIABLE SR_DM6_S_2    0.4
VARIABLE SR_DM6_O_1    0.7
VARIABLE CSR_DM7_W_1    0.8
VARIABLE CSR_DM7_S_1    0.4
VARIABLE CSR_DM7_S_2    0.5
VARIABLE CSR_DM7_O_1    0.7
VARIABLE SR_DM7_W_1    0.8
VARIABLE SR_DM7_S_1    0.4
VARIABLE SR_DM7_S_2    0.4
VARIABLE SR_DM7_O_1    0.7
VARIABLE CSR_DM8_W_1    0.8
VARIABLE CSR_DM8_S_1    0.4
VARIABLE CSR_DM8_S_2    0.5
VARIABLE CSR_DM8_O_1    0.7
VARIABLE SR_DM8_W_1    0.8
VARIABLE SR_DM8_S_1    0.4
VARIABLE SR_DM8_S_2    0.4
VARIABLE SR_DM8_O_1    0.7
VARIABLE CSR_DM9_W_1    0.8
VARIABLE CSR_DM9_S_1    0.4
VARIABLE CSR_DM9_S_2    0.5
VARIABLE CSR_DM9_O_1    0.7
VARIABLE SR_DM9_W_1    0.8
VARIABLE SR_DM9_S_1    0.4
VARIABLE SR_DM9_S_2    0.4
VARIABLE SR_DM9_O_1    0.7
VARIABLE CSR_DM10_W_1    0.8
VARIABLE CSR_DM10_S_1    0.4
VARIABLE CSR_DM10_S_2    0.5
VARIABLE CSR_DM10_O_1    0.7
VARIABLE SR_DM10_W_1    0.8
VARIABLE SR_DM10_S_1    0.4
VARIABLE SR_DM10_S_2    0.4
VARIABLE SR_DM10_O_1    0.7

VARIABLE CSR_DV1_W_1    0.07
VARIABLE CSR_DV1_S_1    0.11
VARIABLE CSR_DV1_EN_1   0.135
VARIABLE SR_DV1_W_1    0.07
VARIABLE SR_DV1_S_1    0.11
VARIABLE SR_DV1_EN_1   0.135
VARIABLE CSR_DV2_W_1    0.07
VARIABLE CSR_DV2_S_1    0.11
VARIABLE CSR_DV2_EN_1   0.135
VARIABLE SR_DV2_W_1    0.07
VARIABLE SR_DV2_S_1    0.11
VARIABLE SR_DV2_EN_1   0.135
VARIABLE CSR_DV3_W_1    0.07
VARIABLE CSR_DV3_S_1    0.11
VARIABLE CSR_DV3_EN_1   0.135
VARIABLE SR_DV3_W_1    0.07
VARIABLE SR_DV3_S_1    0.11
VARIABLE SR_DV3_EN_1   0.135
VARIABLE CSR_DV4_W_1    0.07
VARIABLE CSR_DV4_S_1    0.11
VARIABLE CSR_DV4_EN_1   0.135
VARIABLE SR_DV4_W_1    0.07
VARIABLE SR_DV4_S_1    0.11
VARIABLE SR_DV4_EN_1   0.135
VARIABLE CSR_DV5_W_1    0.07
VARIABLE CSR_DV5_S_1    0.11
VARIABLE CSR_DV5_EN_1   0.135
VARIABLE SR_DV5_W_1    0.07
VARIABLE SR_DV5_S_1    0.11
VARIABLE SR_DV5_EN_1   0.135
VARIABLE CSR_DV6_W_1    0.07
VARIABLE CSR_DV6_S_1    0.11
VARIABLE CSR_DV6_EN_1   0.135
VARIABLE SR_DV6_W_1    0.07
VARIABLE SR_DV6_S_1    0.11
VARIABLE SR_DV6_EN_1   0.135
VARIABLE CSR_DV7_W_1    0.07
VARIABLE CSR_DV7_S_1    0.11
VARIABLE CSR_DV7_EN_1   0.135
VARIABLE SR_DV7_W_1    0.07
VARIABLE SR_DV7_S_1    0.11
VARIABLE SR_DV7_EN_1   0.135
VARIABLE CSR_DV8_W_1    0.36
VARIABLE CSR_DV8_S_1    0.84
VARIABLE CSR_DV8_EN_1   0.17
VARIABLE SR_DV8_W_1    0.36
VARIABLE SR_DV8_S_1    0.84
VARIABLE SR_DV8_EN_1   0.17
VARIABLE CSR_DV9_W_1    0.36
VARIABLE CSR_DV9_S_1    0.84
VARIABLE CSR_DV9_EN_1   0.17
VARIABLE SR_DV9_W_1    0.36
VARIABLE SR_DV9_S_1    0.84
VARIABLE SR_DV9_EN_1   0.17

// for box in box variable
VARIABLE BIB_S_1        4
VARIABLE BIB_S_2        0.4
#IFDEF P4_SEALRING
VARIABLE BIB_W_1        2
VARIABLE BIB_W_2        0.35
VARIABLE BIB_S_3        0.36
VARIABLE BIB_L_1        16
VARIABLE BIB_L_2        6
VARIABLE BIB_L_3        16
VARIABLE BIB_EN_1       3
VARIABLE BIB_EN_2       3
VARIABLE BIB_EN_3       3
#ELSE
VARIABLE BIB_W_1        1.1
VARIABLE BIB_W_2        0.17
VARIABLE BIB_W_3        0.965  
VARIABLE BIB_S_3        0.095
VARIABLE BIB_L_1        16.5
VARIABLE BIB_L_2        7.7
VARIABLE BIB_L_3        16.5
VARIABLE BIB_L_4_1      6.265
VARIABLE BIB_L_4_2      6.53
VARIABLE BIB_EN_1       3.3
VARIABLE BIB_EN_2       4
VARIABLE BIB_EN_3       4
#ENDIF
VARIABLE BIB_EN_4       5
VARIABLE BIB_EN_5       5
VARIABLE BIB_R_2        52
VARIABLE BIB_R_3        28

VARIABLE CB_O_1         1
VARIABLE CB_W_3         2
VARIABLE CB_EN_2        1
VARIABLE AP_W_3         4
VARIABLE CB2_W_5        2
VARIABLE CB_W_4         2
VARIABLE CB_EN_3        1
VARIABLE AP_W_4         4
VARIABLE CB2_W_6        2

VARIABLE  CO_W_2        0.06
VARIABLE  M1_W_4        2
VARIABLE  M1_W_5        6
VARIABLE  M1_W_6        0.5

VARIABLE  VIA1_W_2      0.5
VARIABLE  VIA1_W_3      0.07
VARIABLE  VIA1_W_4      0.5
VARIABLE  VIA1_W_5      0.07
VARIABLE  VIA1_S_4      0.35
VARIABLE  VIA1_S_5      0.365
VARIABLE  VIA1_S_6      0.35
VARIABLE  VIA1_EN_5     0.21
VARIABLE  VIA1_EN_6     0.22
VARIABLE  VIA1_EN_7     0.015
VARIABLE  M2_W_4       2
VARIABLE  M2_W_5       6
VARIABLE  M2_W_6       0.5

VARIABLE  VIA2_W_2      0.5
VARIABLE  VIA2_W_3      0.07
VARIABLE  VIA2_W_4      0.5
VARIABLE  VIA2_W_5      0.07
VARIABLE  VIA2_S_4      0.35
VARIABLE  VIA2_S_5      0.365
VARIABLE  VIA2_S_6      0.35
VARIABLE  VIA2_EN_5     0.21
VARIABLE  VIA2_EN_6     0.22
VARIABLE  VIA2_EN_7     0.015
VARIABLE  M3_W_4       2
VARIABLE  M3_W_5       6
VARIABLE  M3_W_6       0.5

VARIABLE  VIA3_W_2      0.5
VARIABLE  VIA3_W_3      0.07
VARIABLE  VIA3_W_4      0.5
VARIABLE  VIA3_W_5      0.07
VARIABLE  VIA3_S_4      0.35
VARIABLE  VIA3_S_5      0.365
VARIABLE  VIA3_S_6      0.35
VARIABLE  VIA3_EN_5     0.21
VARIABLE  VIA3_EN_6     0.22
VARIABLE  VIA3_EN_7     0.015
VARIABLE  M4_W_4       2
VARIABLE  M4_W_5       6
VARIABLE  M4_W_6       0.5

VARIABLE  VIA4_W_2      0.5
VARIABLE  VIA4_W_3      0.07
VARIABLE  VIA4_W_4      0.5
VARIABLE  VIA4_W_5      0.07
VARIABLE  VIA4_S_4      0.35
VARIABLE  VIA4_S_5      0.365
VARIABLE  VIA4_S_6      0.35
VARIABLE  VIA4_EN_5     0.21
VARIABLE  VIA4_EN_6     0.22
VARIABLE  VIA4_EN_7     0.015
VARIABLE  M5_W_4       2
VARIABLE  M5_W_5       6
VARIABLE  M5_W_6       0.5

VARIABLE  VIA5_W_2      0.5
VARIABLE  VIA5_W_3      0.07
VARIABLE  VIA5_W_4      0.5
VARIABLE  VIA5_W_5      0.07
VARIABLE  VIA5_S_4      0.35
VARIABLE  VIA5_S_5      0.365
VARIABLE  VIA5_S_6      0.35
VARIABLE  VIA5_EN_5     0.21
VARIABLE  VIA5_EN_6     0.22
VARIABLE  VIA5_EN_7     0.015
VARIABLE  M6_W_4       2
VARIABLE  M6_W_5       6
VARIABLE  M6_W_6       0.5

VARIABLE  VIA6_W_2      0.5
VARIABLE  VIA6_W_3      0.07
VARIABLE  VIA6_W_4      0.5
VARIABLE  VIA6_W_5      0.07
VARIABLE  VIA6_S_4      0.35
VARIABLE  VIA6_S_5      0.365
VARIABLE  VIA6_S_6      0.35
VARIABLE  VIA6_EN_5     0.21
VARIABLE  VIA6_EN_6     0.22
VARIABLE  VIA6_EN_7     0.015
VARIABLE  M7_W_4       2
VARIABLE  M7_W_5       6
VARIABLE  M7_W_6       0.5

VARIABLE  VIA7_W_2      0.5
VARIABLE  VIA7_W_3      0.07
VARIABLE  VIA7_W_4      0.5
VARIABLE  VIA7_W_5      0.07
VARIABLE  VIA7_S_4      0.35
VARIABLE  VIA7_S_5      0.365
VARIABLE  VIA7_S_6      0.35
VARIABLE  VIA7_EN_5     0.21
VARIABLE  VIA7_EN_6     0.22
VARIABLE  VIA7_EN_7     0.015
VARIABLE  M8_W_4       2
VARIABLE  M8_W_5       6
VARIABLE  M8_W_6       0.5

VARIABLE  VIA8_W_2   0.5 
VARIABLE  VIA8_W_3   0.36 
#IFDEF P3_SEALRING
VARIABLE  VIA8_W_2_P3   2
VARIABLE  VIA8_W_3_P3   6
#ENDIF
VARIABLE  VIA8_W_4   0.5 
VARIABLE  VIA8_W_5   0.36 
VARIABLE  VIA8_S_4   0.54 
VARIABLE  VIA8_S_5   0.34 
VARIABLE  VIA8_S_6   0.54 
VARIABLE  VIA8_S_7   0.54 
VARIABLE  VIA8_EN_5  0.21 
VARIABLE  VIA8_EN_5_1 0.3
VARIABLE  VIA8_EN_6  0.21 
VARIABLE  M9_W_4    2
VARIABLE  M9_W_5    6
VARIABLE  M9_W_6    3.5

VARIABLE  VIA9_W_2   0.5 
VARIABLE  VIA9_W_3   0.36 
#IFDEF P3_SEALRING
VARIABLE  VIA9_W_2_P3   2
VARIABLE  VIA9_W_3_P3   6
#ENDIF
VARIABLE  VIA9_W_4   0.5 
VARIABLE  VIA9_W_5   0.36 
VARIABLE  VIA9_S_4   0.54 
VARIABLE  VIA9_S_5   0.34 
VARIABLE  VIA9_S_6   0.54 
VARIABLE  VIA9_S_7   0.54 
VARIABLE  VIA9_EN_5  0.21 
VARIABLE  VIA9_EN_5_1 0.3
VARIABLE  VIA9_EN_6  0.21 
VARIABLE  M10_W_4    2
VARIABLE  M10_W_5    6
VARIABLE  M10_W_6    3.5




LAYER RESOLUTION COi 1	// inside SRAM periphrial regions only
LAYER RESOLUTION POi 1	// inside SRAM periphrial regions only

// DRAWN LAYER DEFINITIONS
//------------------------
LAYER DNWi       1       // deep-nwell
LAYER NWi        3000    // nwell technology
LAYER MAP 3 DATATYPE >=0 <=255 3000
LAYER NWiOTHERS 3001     
LAYER MAP 3 DATATYPE >=1 <=255 3001
LAYER OD12i      1401    // define 1.2V core oxides
LAYER MAP 14 DATATYPE 1 1401
LAYER OD18i      16      // define 1.8V thick gate oxides
LAYER OD1815     442     // define 1.8V thick gate oxides underdrive 1.5v, drc dummy layer
LAYER MAP 16 DATATYPE 4 442
LAYER OD25i      18      // define 2.5V thick gate oxides
LAYER OD2533     451     // define 2.5V thick gate oxides overdrive 3.3v, drc dummy layer
LAYER MAP 18 DATATYPE 3 451
LAYER OD2518     452     // define 2.5V thick gate oxides underdrive 1.8v, drc dummy layer
LAYER MAP 18 DATATYPE 4 452
LAYER OD25_LK    453     // Low gate oxide leakage, reserve for N45 process
LAYER MAP 18 DATATYPE 6 453
LAYER OD33i      15      // define 3.3V thick gate oxides
LAYER ODDECAP    118     // decoupling capacitor device region
LAYER PPi        25      // P+ S/D imlant
LAYER NPi        26      // N+ S/D imlant
LAYER HVD_N      9101	// Define N-HVMOS drain side where sustains high voltage
LAYER MAP 91 DATATYPE 1 9101 
LAYER HVD_P      9102	// Define P-HVMOS drain side where sustains high voltage
LAYER MAP 91 DATATYPE 2 9102 
LAYER COi        30      // Define connect for M1 to S/D and Gate
LAYER COPUSH     3011    // rule pushed contact in SRAM cell
LAYER MAP 30 DATATYPE 11 3011
LAYER COiSRAM 3012
LAYER MAP 30 DATATYPE >=11 <=13 3012
LAYER COiOTHERS 3013
LAYER MAP 30 DATATYPE >=1 <=10 3013
LAYER MAP 30 DATATYPE >=12 <=255 3013
LAYER CBi        76      // Passivation opening for Bond Pad
LAYER CB2Fi      8600    // Passivation-2 opening for Flip-Chip
LAYER MAP 86 DATATYPE 0  8600
LAYER CB2Wi      8620    // Passivation-2 opening for Wire-Bond
LAYER MAP 86 DATATYPE 20 8620
LAYER RPOi       29      // Silicided Block Layer
LAYER NTNi       11000   // Native NMOS blocked implant
LAYER MAP 11 DATATYPE 0  11000
LAYER NCapNTNi   11020   // connected NMOS capacitors within same NT_N region
LAYER MAP 11 DATATYPE 20 11020
LAYER LPP_NTNi	 11010         // for LP+ NMOS native device
LAYER MAP 11 DATATYPE 10 11010
LAYER LPP_NTN_21i 11021
LAYER MAP 11 DATATYPE 21 11021
LAYER LPP_NTN_DPOi 11022
LAYER MAP 11 DATATYPE 22 11022
LAYER LPP_NTN_120i 11120
LAYER MAP 11 DATATYPE 120 11120
LAYER POFUSE     648     // Poly fuse implant layer, cover all poly fuse region    
LAYER MAP 156 DATATYPE 0 648
LAYER FUSELINK 649       // Dummy layer to cover poly fuse link region.   
LAYER MAP 156 DATATYPE 1 649
LAYER PMi        5       // Polymide (if drawn)
LAYER PM1i   	 5001    // polyimide 1 window for WLCSP
LAYER MAP 5 DATATYPE 1 5001
LAYER PM2i   	 5002    // polyimide 2 window for WLCSP
LAYER MAP 5 DATATYPE 2 5002
LAYER SEALRING_ORI 1620         // INITIAL SR Region
LAYER MAP 162 DATATYPE 0 1620
LAYER SEALRING_DB 1621          // SLDB Region
LAYER MAP 162 DATATYPE 1 1621
LAYER SEALRING_ALL 1622         // SLDB+SR_ISO Region
LAYER MAP 162 DATATYPE 2 1622
LAYER VTHNi      67      // High Vt NMOS Implant for core device
LAYER VTHPi      68      // High Vt PMOS Implant for core device
LAYER VTLNi      12      // Low Vt NMOS Implant for core device
LAYER VTLPi      13      // Low Vt PMOS Implant for core device
LAYER VTULNi     1510     // Ultra low Vt NMOS Implant for eDRAM
LAYER MAP 151 DATATYPE 0 1510
LAYER VTULPi     1520     // Ultra low Vt PMOS Implant for eDRAM
LAYER MAP 152 DATATYPE 0 1520
LAYER VTLN18      7901   // I/O 1.8V LVT device
LAYER MAP 79 DATATYPE 1 7901
LAYER CBDi       169     // CBD For solder Bump and RDL layer 
LAYER CBDB       16910   // Back-Side passivation window for bump (TSV)
LAYER MAP 169 DATATYPE 100 16910
LAYER UBMi       170     // UBM For solder Bump and RDL layer 
LAYER UBMB       17010   // Back-Side under bump metal (TSV)
LAYER MAP 170 DATATYPE 100 17010
LAYER RH         117     // block NLDD/PLDD in OD/POLY resistor
LAYER ESDIMP     1890    // ESD Implant layer
LAYER MAP 189 DATATYPE 0 1890
LAYER VARi       14300    // For both MOS and junction type varactor
LAYER MAP 143 DATATYPE 0 14300 
LAYER DVAR       14310   // For differential MOS varactor  
LAYER MAP 143 DATATYPE 10 14310  
LAYER APi        74
LAYER Cu_PPIi    7410    // Cu_PPI interconnection between Polymide1 and Polymide2 for WLCSP
LAYER MAP 74 DATATYPE 10 7410
LAYER AP_BSL     7411    // Back-Side AlCu Redistributional layer (Al RDL) (TSV)
LAYER MAP 74 DATATYPE 100 7411
LAYER AP_BSP     7412    // Back-Side AP pin for text layer (TSV)
LAYER MAP 74 DATATYPE 102 7412
LAYER CBMi       88
LAYER CTMi       77
LAYER RVi        85
LAYER RV_BSL     8510    // Back-Side Via hole for AlCu Redistributional layer (Al RDL) (TSV)
LAYER MAP 85 DATATYPE 100 8510
LAYER DCOi       90      // Dual Core oxide layer used to cover G core device
LAYER LMARK      109     // Alignment Mark Rule for Laser Repair
// SRAM LAYERS
LAYER SRM        5000
LAYER MAP 50 DATATYPE 0  5000 
LAYER SRMN       5010    // define SRAM NMOS cell implant
LAYER MAP 50 DATATYPE 1  5010 
LAYER SRMP       5020    // define SRAM PMOS cell implant
LAYER MAP 50 DATATYPE 2  5020 
LAYER SRMRP      5050    // to identify read port in 8T 2 port SRAM 
LAYER MAP 50 DATATYPE 5  5050 
LAYER NPreDOSRM  5021    // SRAM drawing layer for N+ Predoping area
LAYER MAP 50 DATATYPE 21 5021 
LAYER ROM        5006    // define ROM cell
LAYER MAP 50 DATATYPE 6  5006 
LAYER SRM_HS     5007    // Identify HS cell
LAYER MAP 50 DATATYPE 7  5007 
LAYER SRAMDMY            1860  // SRAM DRC violations waive layer		
LAYER MAP 186 DATATYPE 0 1860  		
LAYER SRAMDMY_PAS        1861  // SRAM pass gate region
LAYER MAP 186 DATATYPE 1 1861  		
LAYER SRAMDMY_PERI_LP    1864  // SRAM periphrial region for LP
LAYER MAP 186 DATATYPE 4 1864 
LAYER SRAMDMY_PERI_G     1865  // SRAM periphrial region for G
LAYER MAP 186 DATATYPE 5 1865 
SRAMDMY_PERI = SRAMDMY_PERI_G OR SRAMDMY_PERI_LP
LAYER CO2         1000
LAYER MAP 100 DATATYPE 0 1000
LAYER DPSRM       8000            // 0.589
LAYER MAP 80 DATATYPE 0 8000       
LAYER PRSRM       8011    // bit-cell only area
LAYER MAP 80 DATATYPE 11 8011 
LAYER SRMLOP12    8012            // 0.252
LAYER MAP 80 DATATYPE 12 8012 
LAYER SRMLOP13    8013            // 0.374
LAYER MAP 80 DATATYPE 13 8013     
LAYER SRMLOP14    8014            // 0.299
LAYER MAP 80 DATATYPE 14 8014 
LAYER LVLOP       8015
LAYER MAP 80 DATATYPE 15 8015 
LAYER HCDPLOP     8016            // 0.741
LAYER MAP 80 DATATYPE 16 8016 
LAYER TPLOP_8T    8017
LAYER MAP 80 DATATYPE 17 8017 
LAYER TPLOP_10T   8018
LAYER MAP 80 DATATYPE 18 8018 

LAYER DUMMYOD1    8201
LAYER MAP 82 DATATYPE 1 8201
LAYER DUMMYOD2    8202
LAYER MAP 82 DATATYPE 2 8202
LAYER DUMMYOD3    8203
LAYER MAP 82 DATATYPE 3 8203
LAYER DUMMYOD4    8204
LAYER MAP 82 DATATYPE 4 8204
LAYER DUMMYOD5    8205
LAYER MAP 82 DATATYPE 5 8205
LAYER DUMMYOD6    8206
LAYER MAP 82 DATATYPE 6 8206
LAYER DUMMYOD7    8207
LAYER MAP 82 DATATYPE 7 8207
LAYER DUMMYOD8    8208
LAYER MAP 82 DATATYPE 8 8208
LAYER DUMMYOD9    8209
LAYER MAP 82 DATATYPE 9 8209
LAYER DUMMYOD10   8210
LAYER MAP 82 DATATYPE 10 8210
LAYER DUMMYOD11   8211
LAYER MAP 82 DATATYPE 11 8211
LAYER DUMMYOD12   8212
LAYER MAP 82 DATATYPE 12 8212
LAYER DUMMYOD13   8213
LAYER MAP 82 DATATYPE 13 8213
LAYER DUMMYOD14   8214
LAYER MAP 82 DATATYPE 14 8214
LAYER DUMMYOD15   8215
LAYER MAP 82 DATATYPE 15 8215
LAYER DUMMYOD16   8216
LAYER MAP 82 DATATYPE 16 8216

LAYER DUMMYPO1    8301
LAYER MAP 83 DATATYPE 1 8301
LAYER DUMMYPO2    8302
LAYER MAP 83 DATATYPE 2 8302
LAYER DUMMYPO3    8303
LAYER MAP 83 DATATYPE 3 8303
LAYER DUMMYPO4    8304
LAYER MAP 83 DATATYPE 4 8304
LAYER DUMMYPO5    8305
LAYER MAP 83 DATATYPE 5 8305
LAYER DUMMYPO6    8306
LAYER MAP 83 DATATYPE 6 8306
LAYER DUMMYPO7    8307
LAYER MAP 83 DATATYPE 7 8307
//eDRAM layers
LAYER RAM1TDMY   1600          // dummy layer to define eDRAM region
LAYER MAP 160 DATATYPE 0 1600 
LAYER OD1T       2700          // cell array oxide
LAYER MAP 27  DATATYPE 0 2700 
LAYER OD1TH      2701          // cell array oxide
LAYER MAP 27  DATATYPE 1 2701 
LAYER OD1TM      2702          // cell array oxide
LAYER MAP 27  DATATYPE 2 2702 
LAYER OD1T_WLD     2703          // cell array oxide
LAYER MAP 27  DATATYPE 3 2703 
LAYER OD1T_MOSCAP  2704          // cell array oxide
LAYER MAP 27  DATATYPE 4 2704 
LAYER OD1T_CP      2705          // cell array oxide
LAYER MAP 27  DATATYPE 5 2705 
LAYER OD1T_20      2706          // define OD1T device with the max operate DC bias >2.0V 
LAYER MAP 27  DATATYPE 6 2706 
LAYER OD1T_18      2707          // define OD1T device with the max operate DC bias >1.8V 
LAYER MAP 27  DATATYPE 7 2707 
LAYER OD1T_16      2708          // define OD1T device with the max operate DC bias >1.6V 
LAYER MAP 27  DATATYPE 8 2708 
LAYER CLDD       9200            // CLDD,1TRAM cell array region
LAYER MAP 92  DATATYPE 0 9200 
LAYER EDRAM_DECAP      9201      // Layer for drawing decoupling capacitor in EDRAM process
LAYER MAP 92  DATATYPE 1 9201 
LAYER SNCT       101           // NOde contact (bottom electrode contact)
LAYER CROWN      102           // capacitor bottom electrode
LAYER P3         103           // capacitor top electrode
LAYER LDDBLK     1040      
LAYER MAP 104 DATATYPE 0 1040

//
// Dummy Layers
//
LAYER NWDMY      114     // NWEL resistor dummy layer
LAYER RPDMY      115     // dummy layer to cover OD/PO resistor
LAYER SDI        122     // cover IO ESD area
LAYER CSRDMY	 1660     // Layer to cover chip corner areas
LAYER MAP 166 DATATYPE 0 1660
LAYER CSRBIB1DMY 1661
LAYER MAP 166 DATATYPE 1 1661
LAYER CSRBIB2DMY 1662
LAYER MAP 166 DATATYPE 2 1662
LAYER CDUDMY     1650    // CDUDMY Dummy layer to cover CDU pattern in assembly isolation
LAYER MAP 165 DATATYPE 0  1650
LAYER TCDDMY     1651    // Dummy layer to cover TCD pattern
LAYER MAP 165 DATATYPE 1  1651
LAYER TCDDMY_H   1654    // Dummy layer to cover Horizontal TCD pattern
LAYER MAP 165 DATATYPE 4  1654
LAYER TCDDMY_V   1655    // Dummy layer to cover Vertical TCD pattern
LAYER MAP 165 DATATYPE 5  1655
LAYER ICOVL     1653     // Dummy layer for ICOVL pattern.
LAYER MAP 165 DATATYPE 3  1653
LAYER LOGO       158     // Dummy layer for product labels and LOGO
LAYER INDDMY     1440    // Dummy layer for inductor
LAYER MAP 144 DATATYPE >=0 <=14 1440
LAYER TLDMY     11630     // Dummy layer for Transmission Lines
LAYER MAP 116 DATATYPE 30 11630
LAYER MOMDMY_1   1551    // Dummy layer for M1 MOM region
LAYER MAP 155 DATATYPE 1 1551
LAYER MOMDMY_2   1552    // Dummy layer for M2 MOM region
LAYER MAP 155 DATATYPE 2 1552
LAYER MOMDMY_3   1553    // Dummy layer for M3 MOM region
LAYER MAP 155 DATATYPE 3 1553
LAYER MOMDMY_4   1554    // Dummy layer for M4 MOM region
LAYER MAP 155 DATATYPE 4 1554
LAYER MOMDMY_5   1555    // Dummy layer for M5 MOM region
LAYER MAP 155 DATATYPE 5 1555
LAYER MOMDMY_6   1556    // Dummy layer for M6 MOM region
LAYER MAP 155 DATATYPE 6 1556
LAYER MOMDMY_7   1557    // Dummy layer for M7 MOM region
LAYER MAP 155 DATATYPE 7 1557
LAYER MOMDMY_8   1558    // Dummy layer for M8 MOM region
LAYER MAP 155 DATATYPE 8 1558
LAYER MOMDMY_9   1559    // Dummy layer for M9 MOM region
LAYER MAP 155 DATATYPE 9 1559
LAYER MOMDMY_10   1560    // Dummy layer for M10 MOM region
LAYER MAP 155 DATATYPE 10 1560
LAYER MOMDMY_AP  1570    // Dummy layer for AP MOM region
LAYER MAP 155 DATATYPE 20 1570
LAYER MOMDMY   1571     // Dummy layer for MOM
LAYER MAP 155 DATATYPE 21 1571
LAYER MOMDMY_0  1572     // Dummy layer for RTMOM
LAYER MAP 155 DATATYPE 0 1572
LAYER MOMDMY_100  1573   // Dummy layer for FMOM
LAYER MAP 155 DATATYPE 100 1573

LAYER WBDMY      157     // For CUP purpose
LAYER DIODMY     119     // Dummy layer for diode
LAYER SRESD      1210     // Dummy layer for ESD device
LAYER MAP 121 DATATYPE 0 1210
LAYER RODMY      49      // Dummy layer to exclude OD area in SRAM bit cell
LAYER RFDMY      1610    // For RF IP circuit
LAYER MAP 161 DATATYPE 0 1610
LAYER RFIPDMY    1611    // For RF IP circuit
LAYER MAP 161 DATATYPE 1 1611
LAYER LUPWDMY    2551    // DRC dummy layer to waive Latch-Up rules for verified IP.
LAYER MAP 255 DATATYPE 1 2551


LAYER M1i         501			// Metal1 layer
LAYER MAP 31 DATATYPE 0  501		// Mapping (31;0) to 501 for M1i
LAYER MAP 31 DATATYPE 7  501		// Mapping (DM1_O, 31;7) to 501 for M1i, OPC dummy metal
LAYER DM1_O       781 
LAYER MAP 31 DATATYPE 7  781		// Mapping (DM1_O, 31;7) to 781 for DM1_O, OPC dummy metal
LAYER M1i_R       761			// Metal1 layer for real metal
LAYER MAP 31 DATATYPE 0  761	// Mapping (31;0) to 761 for M1i_R, real metal
LAYER DUM1        541			// dummy Metal1
LAYER MAP 31 DATATYPE 1  541		// Mapping (31;1) to 541 for DUM1
LAYER NOUSEM1     581                 
LAYER MAP 31 DATATYPE 20 581		// Mapping (31;20) to 581 for forbidden
LAYER MAP 31 DATATYPE 21 581		// Mapping (31;21) to 581 for forbidden
LAYER MAP 31 DATATYPE 40 581		// Mapping (31;40) to 581 for forbidden
LAYER MAP 31 DATATYPE 41 581		// Mapping (31;41) to 581 for forbidden
LAYER MAP 31 DATATYPE 60 581		// Mapping (31;60) to 581 for forbidden
LAYER MAP 31 DATATYPE 61 581		// Mapping (31;61) to 581 for forbidden
LAYER MAP 31 DATATYPE 80 581		// Mapping (31;80) to 581 for forbidden
LAYER MAP 31 DATATYPE 81 581		// Mapping (31;81) to 581 for forbidden
LAYER NOTUSEM1   621                       
LAYER MAP 31 DATATYPE >=161 <=165 621	// TSMC internal mask making layer (31;161-165)
LAYER DM1EXCL  371
LAYER MAP 150 DATATYPE 1 371
LAYER M1_LVi      901			// Metal1 LV Marker Layer
LAYER MAP 31 DATATYPE >= 200 < 215 901	// Mapping (31;200~214) to 901 for M1 LV Marker Layer
LAYER M1_MVi      921			// Metal1 MV Marker Layer
LAYER MAP 31 DATATYPE >= 215 < 218 921	// Mapping (31;215~217) to 921 for M1 MV Marker Layer
LAYER M1_HVi      961			// Metal1 HV Marker Layer
LAYER MAP 31 DATATYPE >= 218 <= 220 961	// Mapping (31;218~220) to 961 for M1 HV Marker Layer
LAYER M1_HV_5Vi   981		 // Metal1 HV_5V Marker Layer
LAYER MAP 31 DATATYPE 221 981 // Mapping (31;221) to 981 for M1 HV_5V Marker Layer

LAYER M2i         502			// Metal2 layer
LAYER MAP 32 DATATYPE 0  502		// Mapping (32;0) to 502 for M2i
LAYER MAP 32 DATATYPE 7  502		// Mapping (DM2_O, 32;7) to 502 for M2i, OPC dummy metal
LAYER DM2_O       782 
LAYER MAP 32 DATATYPE 7  782		// Mapping (DM2_O, 32;7) to 782 for DM2_O, OPC dummy metal
LAYER M2i_R       762			// Metal2 layer for real metal
LAYER MAP 32 DATATYPE 0  762	// Mapping (32;0) to 762 for M2i_R, real metal
LAYER DUM2        542			// dummy Metal2
LAYER MAP 32 DATATYPE 1  542		// Mapping (32;1) to 542 for DUM2
LAYER NOUSEM2     582                 
LAYER MAP 32 DATATYPE 20 582		// Mapping (32;20) to 582 for forbidden
LAYER MAP 32 DATATYPE 21 582		// Mapping (32;21) to 582 for forbidden
LAYER MAP 32 DATATYPE 40 582		// Mapping (32;40) to 582 for forbidden
LAYER MAP 32 DATATYPE 41 582		// Mapping (32;41) to 582 for forbidden
LAYER MAP 32 DATATYPE 60 582		// Mapping (32;60) to 582 for forbidden
LAYER MAP 32 DATATYPE 61 582		// Mapping (32;61) to 582 for forbidden
LAYER MAP 32 DATATYPE 80 582		// Mapping (32;80) to 582 for forbidden
LAYER MAP 32 DATATYPE 81 582		// Mapping (32;81) to 582 for forbidden
LAYER NOTUSEM2   622                       
LAYER MAP 32 DATATYPE >=161 <=165 622	// TSMC internal mask making layer (32;161-165)
LAYER DM2EXCL  372
LAYER MAP 150 DATATYPE 2 372
LAYER M2_LVi      902			// Metal2 LV Marker Layer
LAYER MAP 32 DATATYPE >= 200 < 215 902	// Mapping (32;200~214) to 902 for M2 LV Marker Layer
LAYER M2_MVi      922			// Metal2 MV Marker Layer
LAYER MAP 32 DATATYPE >= 215 < 218 922	// Mapping (32;215~217) to 922 for M2 MV Marker Layer
LAYER M2_HVi      962			// Metal2 HV Marker Layer
LAYER MAP 32 DATATYPE >= 218 <= 220 962	// Mapping (32;218~220) to 962 for M2 HV Marker Layer
LAYER M2_HV_5Vi   982		 // Metal2 HV_5V Marker Layer
LAYER MAP 32 DATATYPE 221 982 // Mapping (32;221) to 982 for M2 HV_5V Marker Layer

LAYER M3i         503			// Metal3 layer
LAYER MAP 33 DATATYPE 0  503		// Mapping (33;0) to 503 for M3i
LAYER MAP 33 DATATYPE 7  503		// Mapping (DM3_O, 33;7) to 503 for M3i, OPC dummy metal
LAYER DM3_O       783 
LAYER MAP 33 DATATYPE 7  783		// Mapping (DM3_O, 33;7) to 783 for DM3_O, OPC dummy metal
LAYER M3i_R       763			// Metal3 layer for real metal
LAYER MAP 33 DATATYPE 0  763	// Mapping (33;0) to 763 for M3i_R, real metal
LAYER DUM3        543			// dummy Metal3
LAYER MAP 33 DATATYPE 1  543		// Mapping (33;1) to 543 for DUM3
LAYER NOUSEM3     583                 
LAYER MAP 33 DATATYPE 20 583		// Mapping (33;20) to 583 for forbidden
LAYER MAP 33 DATATYPE 21 583		// Mapping (33;21) to 583 for forbidden
LAYER MAP 33 DATATYPE 40 583		// Mapping (33;40) to 583 for forbidden
LAYER MAP 33 DATATYPE 41 583		// Mapping (33;41) to 583 for forbidden
LAYER MAP 33 DATATYPE 60 583		// Mapping (33;60) to 583 for forbidden
LAYER MAP 33 DATATYPE 61 583		// Mapping (33;61) to 583 for forbidden
LAYER MAP 33 DATATYPE 80 583		// Mapping (33;80) to 583 for forbidden
LAYER MAP 33 DATATYPE 81 583		// Mapping (33;81) to 583 for forbidden
LAYER NOTUSEM3   623                       
LAYER MAP 33 DATATYPE >=161 <=165 623	// TSMC internal mask making layer (33;161-165)
LAYER DM3EXCL  373
LAYER MAP 150 DATATYPE 3 373
LAYER M3_LVi      903			// Metal3 LV Marker Layer
LAYER MAP 33 DATATYPE >= 200 < 215 903	// Mapping (33;200~214) to 903 for M3 LV Marker Layer
LAYER M3_MVi      923			// Metal3 MV Marker Layer
LAYER MAP 33 DATATYPE >= 215 < 218 923	// Mapping (33;215~217) to 923 for M3 MV Marker Layer
LAYER M3_HVi      963			// Metal3 HV Marker Layer
LAYER MAP 33 DATATYPE >= 218 <= 220 963	// Mapping (33;218~220) to 963 for M3 HV Marker Layer
LAYER M3_HV_5Vi   983		 // Metal3 HV_5V Marker Layer
LAYER MAP 33 DATATYPE 221 983 // Mapping (33;221) to 983 for M3 HV_5V Marker Layer

LAYER M4i         504			// Metal4 layer
LAYER MAP 34 DATATYPE 0  504		// Mapping (34;0) to 504 for M4i
LAYER MAP 34 DATATYPE 7  504		// Mapping (DM4_O, 34;7) to 504 for M4i, OPC dummy metal
LAYER DM4_O       784 
LAYER MAP 34 DATATYPE 7  784		// Mapping (DM4_O, 34;7) to 784 for DM4_O, OPC dummy metal
LAYER M4i_R       764			// Metal4 layer for real metal
LAYER MAP 34 DATATYPE 0  764	// Mapping (34;0) to 764 for M4i_R, real metal
LAYER DUM4        544			// dummy Metal4
LAYER MAP 34 DATATYPE 1  544		// Mapping (34;1) to 544 for DUM4
LAYER NOUSEM4     584                 
LAYER MAP 34 DATATYPE 20 584		// Mapping (34;20) to 584 for forbidden
LAYER MAP 34 DATATYPE 21 584		// Mapping (34;21) to 584 for forbidden
LAYER MAP 34 DATATYPE 40 584		// Mapping (34;40) to 584 for forbidden
LAYER MAP 34 DATATYPE 41 584		// Mapping (34;41) to 584 for forbidden
LAYER MAP 34 DATATYPE 60 584		// Mapping (34;60) to 584 for forbidden
LAYER MAP 34 DATATYPE 61 584		// Mapping (34;61) to 584 for forbidden
LAYER MAP 34 DATATYPE 80 584		// Mapping (34;80) to 584 for forbidden
LAYER MAP 34 DATATYPE 81 584		// Mapping (34;81) to 584 for forbidden
LAYER NOTUSEM4   624                       
LAYER MAP 34 DATATYPE >=161 <=165 624	// TSMC internal mask making layer (34;161-165)
LAYER DM4EXCL  374
LAYER MAP 150 DATATYPE 4 374
LAYER M4_LVi      904			// Metal4 LV Marker Layer
LAYER MAP 34 DATATYPE >= 200 < 215 904	// Mapping (34;200~214) to 904 for M4 LV Marker Layer
LAYER M4_MVi      924			// Metal4 MV Marker Layer
LAYER MAP 34 DATATYPE >= 215 < 218 924	// Mapping (34;215~217) to 924 for M4 MV Marker Layer
LAYER M4_HVi      964			// Metal4 HV Marker Layer
LAYER MAP 34 DATATYPE >= 218 <= 220 964	// Mapping (34;218~220) to 964 for M4 HV Marker Layer
LAYER M4_HV_5Vi   984		 // Metal4 HV_5V Marker Layer
LAYER MAP 34 DATATYPE 221 984 // Mapping (34;221) to 984 for M4 HV_5V Marker Layer

LAYER M5i         505			// Metal5 layer
LAYER MAP 35 DATATYPE 0  505		// Mapping (35;0) to 505 for M5i
LAYER MAP 35 DATATYPE 7  505		// Mapping (DM5_O, 35;7) to 505 for M5i, OPC dummy metal
LAYER DM5_O       785 
LAYER MAP 35 DATATYPE 7  785		// Mapping (DM5_O, 35;7) to 785 for DM5_O, OPC dummy metal
LAYER M5i_R       765			// Metal5 layer for real metal
LAYER MAP 35 DATATYPE 0  765	// Mapping (35;0) to 765 for M5i_R, real metal
LAYER DUM5        545			// dummy Metal5
LAYER MAP 35 DATATYPE 1  545		// Mapping (35;1) to 545 for DUM5
LAYER NOUSEM5     585                 
LAYER MAP 35 DATATYPE 20 585		// Mapping (35;20) to 585 for forbidden
LAYER MAP 35 DATATYPE 21 585		// Mapping (35;21) to 585 for forbidden
LAYER MAP 35 DATATYPE 40 585		// Mapping (35;40) to 585 for forbidden
LAYER MAP 35 DATATYPE 41 585		// Mapping (35;41) to 585 for forbidden
LAYER MAP 35 DATATYPE 60 585		// Mapping (35;60) to 585 for forbidden
LAYER MAP 35 DATATYPE 61 585		// Mapping (35;61) to 585 for forbidden
LAYER MAP 35 DATATYPE 80 585		// Mapping (35;80) to 585 for forbidden
LAYER MAP 35 DATATYPE 81 585		// Mapping (35;81) to 585 for forbidden
LAYER NOTUSEM5   625                       
LAYER MAP 35 DATATYPE >=161 <=165 625	// TSMC internal mask making layer (35;161-165)
LAYER DM5EXCL  375
LAYER MAP 150 DATATYPE 5 375
LAYER M5_LVi      905			// Metal5 LV Marker Layer
LAYER MAP 35 DATATYPE >= 200 < 215 905	// Mapping (35;200~214) to 905 for M5 LV Marker Layer
LAYER M5_MVi      925			// Metal5 MV Marker Layer
LAYER MAP 35 DATATYPE >= 215 < 218 925	// Mapping (35;215~217) to 925 for M5 MV Marker Layer
LAYER M5_HVi      965			// Metal5 HV Marker Layer
LAYER MAP 35 DATATYPE >= 218 <= 220 965	// Mapping (35;218~220) to 965 for M5 HV Marker Layer
LAYER M5_HV_5Vi   985		 // Metal5 HV_5V Marker Layer
LAYER MAP 35 DATATYPE 221 985 // Mapping (35;221) to 985 for M5 HV_5V Marker Layer

LAYER M6i         506			// Metal6 layer
LAYER MAP 36 DATATYPE 0  506		// Mapping (36;0) to 506 for M6i
LAYER MAP 36 DATATYPE 7  506		// Mapping (DM6_O, 36;7) to 506 for M6i, OPC dummy metal
LAYER DM6_O       786 
LAYER MAP 36 DATATYPE 7  786		// Mapping (DM6_O, 36;7) to 786 for DM6_O, OPC dummy metal
LAYER M6i_R       766			// Metal6 layer for real metal
LAYER MAP 36 DATATYPE 0  766	// Mapping (36;0) to 766 for M6i_R, real metal
LAYER DUM6        546			// dummy Metal6
LAYER MAP 36 DATATYPE 1  546		// Mapping (36;1) to 546 for DUM6
LAYER NOUSEM6     586                 
LAYER MAP 36 DATATYPE 20 586		// Mapping (36;20) to 586 for forbidden
LAYER MAP 36 DATATYPE 21 586		// Mapping (36;21) to 586 for forbidden
LAYER MAP 36 DATATYPE 40 586		// Mapping (36;40) to 586 for forbidden
LAYER MAP 36 DATATYPE 41 586		// Mapping (36;41) to 586 for forbidden
LAYER MAP 36 DATATYPE 60 586		// Mapping (36;60) to 586 for forbidden
LAYER MAP 36 DATATYPE 61 586		// Mapping (36;61) to 586 for forbidden
LAYER MAP 36 DATATYPE 80 586		// Mapping (36;80) to 586 for forbidden
LAYER MAP 36 DATATYPE 81 586		// Mapping (36;81) to 586 for forbidden
LAYER NOTUSEM6   626                       
LAYER MAP 36 DATATYPE >=161 <=165 626	// TSMC internal mask making layer (36;161-165)
LAYER DM6EXCL  376
LAYER MAP 150 DATATYPE 6 376
LAYER M6_LVi      906			// Metal6 LV Marker Layer
LAYER MAP 36 DATATYPE >= 200 < 215 906	// Mapping (36;200~214) to 906 for M6 LV Marker Layer
LAYER M6_MVi      926			// Metal6 MV Marker Layer
LAYER MAP 36 DATATYPE >= 215 < 218 926	// Mapping (36;215~217) to 926 for M6 MV Marker Layer
LAYER M6_HVi      966			// Metal6 HV Marker Layer
LAYER MAP 36 DATATYPE >= 218 <= 220 966	// Mapping (36;218~220) to 966 for M6 HV Marker Layer
LAYER M6_HV_5Vi   986		 // Metal6 HV_5V Marker Layer
LAYER MAP 36 DATATYPE 221 986 // Mapping (36;221) to 986 for M6 HV_5V Marker Layer

LAYER M7i         507			// Metal7 layer
LAYER MAP 37 DATATYPE 0  507		// Mapping (37;0) to 507 for M7i
LAYER MAP 37 DATATYPE 7  507		// Mapping (DM7_O, 37;7) to 507 for M7i, OPC dummy metal
LAYER DM7_O       787 
LAYER MAP 37 DATATYPE 7  787		// Mapping (DM7_O, 37;7) to 787 for DM7_O, OPC dummy metal
LAYER M7i_R       767			// Metal7 layer for real metal
LAYER MAP 37 DATATYPE 0  767	// Mapping (37;0) to 767 for M7i_R, real metal
LAYER DUM7        547			// dummy Metal7
LAYER MAP 37 DATATYPE 1  547		// Mapping (37;1) to 547 for DUM7
LAYER NOUSEM7     587                 
LAYER MAP 37 DATATYPE 20 587		// Mapping (37;20) to 587 for forbidden
LAYER MAP 37 DATATYPE 21 587		// Mapping (37;21) to 587 for forbidden
LAYER MAP 37 DATATYPE 40 587		// Mapping (37;40) to 587 for forbidden
LAYER MAP 37 DATATYPE 41 587		// Mapping (37;41) to 587 for forbidden
LAYER MAP 37 DATATYPE 60 587		// Mapping (37;60) to 587 for forbidden
LAYER MAP 37 DATATYPE 61 587		// Mapping (37;61) to 587 for forbidden
LAYER MAP 37 DATATYPE 80 587		// Mapping (37;80) to 587 for forbidden
LAYER MAP 37 DATATYPE 81 587		// Mapping (37;81) to 587 for forbidden
LAYER NOTUSEM7   627                       
LAYER MAP 37 DATATYPE >=161 <=165 627	// TSMC internal mask making layer (37;161-165)
LAYER DM7EXCL  377
LAYER MAP 150 DATATYPE 7 377
LAYER M7_LVi      907			// Metal7 LV Marker Layer
LAYER MAP 37 DATATYPE >= 200 < 215 907	// Mapping (37;200~214) to 907 for M7 LV Marker Layer
LAYER M7_MVi      927			// Metal7 MV Marker Layer
LAYER MAP 37 DATATYPE >= 215 < 218 927	// Mapping (37;215~217) to 927 for M7 MV Marker Layer
LAYER M7_HVi      967			// Metal7 HV Marker Layer
LAYER MAP 37 DATATYPE >= 218 <= 220 967	// Mapping (37;218~220) to 967 for M7 HV Marker Layer
LAYER M7_HV_5Vi   987		 // Metal7 HV_5V Marker Layer
LAYER MAP 37 DATATYPE 221 987 // Mapping (37;221) to 987 for M7 HV_5V Marker Layer

LAYER M8i         508			// Metal8 layer
LAYER MAP 38 DATATYPE 0  508		// Mapping (38;0) to 508 for M8i
LAYER MAP 38 DATATYPE 7  508		// Mapping (DM8_O, 38;7) to 508 for M8i, OPC dummy metal
LAYER DM8_O       788 
LAYER MAP 38 DATATYPE 7  788		// Mapping (DM8_O, 38;7) to 788 for DM8_O, OPC dummy metal
LAYER M8i_R       768			// Metal8 layer for real metal
LAYER MAP 38 DATATYPE 0  768	// Mapping (38;0) to 768 for M8i_R, real metal
LAYER DUM8        548			// dummy Metal8
LAYER MAP 38 DATATYPE 1  548		// Mapping (38;1) to 548 for DUM8
LAYER NOUSEM8     588                 
LAYER MAP 38 DATATYPE 20 588		// Mapping (38;20) to 588 for forbidden
LAYER MAP 38 DATATYPE 21 588		// Mapping (38;21) to 588 for forbidden
LAYER MAP 38 DATATYPE 40 588		// Mapping (38;40) to 588 for forbidden
LAYER MAP 38 DATATYPE 41 588		// Mapping (38;41) to 588 for forbidden
LAYER MAP 38 DATATYPE 60 588		// Mapping (38;60) to 588 for forbidden
LAYER MAP 38 DATATYPE 61 588		// Mapping (38;61) to 588 for forbidden
LAYER MAP 38 DATATYPE 80 588		// Mapping (38;80) to 588 for forbidden
LAYER MAP 38 DATATYPE 81 588		// Mapping (38;81) to 588 for forbidden
LAYER NOTUSEM8   628                       
LAYER MAP 38 DATATYPE >=161 <=165 628	// TSMC internal mask making layer (38;161-165)
LAYER DM8EXCL  378
LAYER MAP 150 DATATYPE 8 378
LAYER M8_LVi      908			// Metal8 LV Marker Layer
LAYER MAP 38 DATATYPE >= 200 < 215 908	// Mapping (38;200~214) to 908 for M8 LV Marker Layer
LAYER M8_MVi      928			// Metal8 MV Marker Layer
LAYER MAP 38 DATATYPE >= 215 < 218 928	// Mapping (38;215~217) to 928 for M8 MV Marker Layer
LAYER M8_HVi      968			// Metal8 HV Marker Layer
LAYER MAP 38 DATATYPE >= 218 <= 220 968	// Mapping (38;218~220) to 968 for M8 HV Marker Layer
LAYER M8_HV_5Vi   988		 // Metal8 HV_5V Marker Layer
LAYER MAP 38 DATATYPE 221 988 // Mapping (38;221) to 988 for M8 HV_5V Marker Layer

LAYER M9_OLD      509			// Metal9 layer
LAYER MAP 39 DATATYPE 0  509		// Mapping (39;0) to 509 for M9i
LAYER M9_NEW      529			// Metal9 layer
LAYER MAP 39 DATATYPE 40 529		// Mapping (39;40) to 529 for M9i
#IFDEF MIXED_SCHEME
M9i = M9_OLD OR M9_NEW
#ELSE
M9i = COPY M9_NEW
#ENDIF
LAYER DUM9_OLD    549         
LAYER MAP 39 DATATYPE 1  549
LAYER DUM9_NEW    569
LAYER MAP 39 DATATYPE 41 569
#IFDEF MIXED_SCHEME
DUM9 = DUM9_OLD OR DUM9_NEW
#ELSE
DUM9 = COPY DUM9_NEW
#ENDIF
LAYER NOUSEM9_NEW 589
LAYER MAP 39 DATATYPE 0  589
LAYER MAP 39 DATATYPE 1  589
LAYER NOUSEM9_OLD 609
LAYER MAP 39 DATATYPE 20 609
LAYER MAP 39 DATATYPE 21 609
LAYER MAP 39 DATATYPE 60 609
LAYER MAP 39 DATATYPE 61 609
LAYER MAP 39 DATATYPE 80 609
LAYER MAP 39 DATATYPE 81 609
#IFDEF MIXED_SCHEME
NOUSEM9 = COPY NOUSEM9_OLD
#ELSE
NOUSEM9 = NOUSEM9_NEW OR NOUSEM9_OLD
#ENDIF
LAYER NOTUSEM9   629                       
LAYER MAP 39 DATATYPE >=161 <=165 629	// TSMC internal mask making layer (39;161-165)
LAYER DM9EXCL  379
LAYER MAP 150 DATATYPE 9 379
LAYER M9_LVi      909			// Metal9 LV Marker Layer
LAYER MAP 39 DATATYPE >= 200 < 215 909	// Mapping (39;200~214) to 909 for M9 LV Marker Layer
LAYER M9_MVi      929			// Metal9 MV Marker Layer
LAYER MAP 39 DATATYPE >= 215 < 218 929	// Mapping (39;215~217) to 929 for M9 MV Marker Layer
LAYER M9_HVi      969			// Metal9 HV Marker Layer
LAYER MAP 39 DATATYPE >= 218 <= 220 969	// Mapping (39;218~220) to 969 for M9 HV Marker Layer
LAYER M9_HV_5Vi   989		 // Metal9 HV_5V Marker Layer
LAYER MAP 39 DATATYPE 221 989 // Mapping (39;221) to 989 for M9 HV_5V Marker Layer

LAYER M10_OLD      510			// Metal10 layer
LAYER MAP 40 DATATYPE 0  510		// Mapping (40;0) to 510 for M10i
LAYER M10_NEW      530			// Metal10 layer
LAYER MAP 40 DATATYPE 40 530		// Mapping (40;40) to 530 for M10i
#IFDEF MIXED_SCHEME
M10i = M10_OLD OR M10_NEW
#ELSE
M10i = COPY M10_NEW
#ENDIF
LAYER DUM10_OLD    550         
LAYER MAP 40 DATATYPE 1  550
LAYER DUM10_NEW    570
LAYER MAP 40 DATATYPE 41 570
#IFDEF MIXED_SCHEME
DUM10 = DUM10_OLD OR DUM10_NEW
#ELSE
DUM10 = COPY DUM10_NEW
#ENDIF
LAYER NOUSEM10_NEW 590
LAYER MAP 40 DATATYPE 0  590
LAYER MAP 40 DATATYPE 1  590
LAYER NOUSEM10_OLD 610
LAYER MAP 40 DATATYPE 20 610
LAYER MAP 40 DATATYPE 21 610
LAYER MAP 40 DATATYPE 60 610
LAYER MAP 40 DATATYPE 61 610
LAYER MAP 40 DATATYPE 80 610
LAYER MAP 40 DATATYPE 81 610
#IFDEF MIXED_SCHEME
NOUSEM10 = COPY NOUSEM10_OLD
#ELSE
NOUSEM10 = NOUSEM10_NEW OR NOUSEM10_OLD
#ENDIF
LAYER NOTUSEM10   630                       
LAYER MAP 40 DATATYPE >=161 <=165 630	// TSMC internal mask making layer (40;161-165)
LAYER DM10EXCL  380
LAYER MAP 150 DATATYPE 10 380
LAYER M10_LVi      910			// Metal10 LV Marker Layer
LAYER MAP 40 DATATYPE >= 200 < 215 910	// Mapping (40;200~214) to 910 for M10 LV Marker Layer
LAYER M10_MVi      930			// Metal10 MV Marker Layer
LAYER MAP 40 DATATYPE >= 215 < 218 930	// Mapping (40;215~217) to 930 for M10 MV Marker Layer
LAYER M10_HVi      970			// Metal10 HV Marker Layer
LAYER MAP 40 DATATYPE >= 218 <= 220 970	// Mapping (40;218~220) to 970 for M10 HV Marker Layer
LAYER M10_HV_5Vi   990		 // Metal10 HV_5V Marker Layer
LAYER MAP 40 DATATYPE 221 990 // Mapping (40;221) to 990 for M10 HV_5V Marker Layer

LAYER VIA1i      801
LAYER MAP 51 DATATYPE 0  801
LAYER DVIA1      401
LAYER MAP 51 DATATYPE 1  401
LAYER NOUSEV1    841  
LAYER MAP 51 DATATYPE 20 841    // Mapping (51;20) to 841 for forbidden
LAYER MAP 51 DATATYPE 40 841    // Mapping (51;40) to 841 for forbidden
LAYER MAP 51 DATATYPE 60 841    // Mapping (51;60) to 841 for forbidden
LAYER MAP 51 DATATYPE 80 841    // Mapping (51;80) to 841 for forbidden

LAYER VIA2i      802
LAYER MAP 52 DATATYPE 0  802
LAYER DVIA2      402
LAYER MAP 52 DATATYPE 1  402
LAYER NOUSEV2    842  
LAYER MAP 52 DATATYPE 20 842    // Mapping (52;20) to 842 for forbidden
LAYER MAP 52 DATATYPE 40 842    // Mapping (52;40) to 842 for forbidden
LAYER MAP 52 DATATYPE 60 842    // Mapping (52;60) to 842 for forbidden
LAYER MAP 52 DATATYPE 80 842    // Mapping (52;80) to 842 for forbidden

LAYER VIA3i      803
LAYER MAP 53 DATATYPE 0  803
LAYER DVIA3      403
LAYER MAP 53 DATATYPE 1  403
LAYER NOUSEV3    843  
LAYER MAP 53 DATATYPE 20 843    // Mapping (53;20) to 843 for forbidden
LAYER MAP 53 DATATYPE 40 843    // Mapping (53;40) to 843 for forbidden
LAYER MAP 53 DATATYPE 60 843    // Mapping (53;60) to 843 for forbidden
LAYER MAP 53 DATATYPE 80 843    // Mapping (53;80) to 843 for forbidden

LAYER VIA4i      804
LAYER MAP 54 DATATYPE 0  804
LAYER DVIA4      404
LAYER MAP 54 DATATYPE 1  404
LAYER NOUSEV4    844  
LAYER MAP 54 DATATYPE 20 844    // Mapping (54;20) to 844 for forbidden
LAYER MAP 54 DATATYPE 40 844    // Mapping (54;40) to 844 for forbidden
LAYER MAP 54 DATATYPE 60 844    // Mapping (54;60) to 844 for forbidden
LAYER MAP 54 DATATYPE 80 844    // Mapping (54;80) to 844 for forbidden

LAYER VIA5i      805
LAYER MAP 55 DATATYPE 0  805
LAYER DVIA5      405
LAYER MAP 55 DATATYPE 1  405
LAYER NOUSEV5    845  
LAYER MAP 55 DATATYPE 20 845    // Mapping (55;20) to 845 for forbidden
LAYER MAP 55 DATATYPE 40 845    // Mapping (55;40) to 845 for forbidden
LAYER MAP 55 DATATYPE 60 845    // Mapping (55;60) to 845 for forbidden
LAYER MAP 55 DATATYPE 80 845    // Mapping (55;80) to 845 for forbidden

LAYER VIA6i      806
LAYER MAP 56 DATATYPE 0  806
LAYER DVIA6      406
LAYER MAP 56 DATATYPE 1  406
LAYER NOUSEV6    846  
LAYER MAP 56 DATATYPE 20 846    // Mapping (56;20) to 846 for forbidden
LAYER MAP 56 DATATYPE 40 846    // Mapping (56;40) to 846 for forbidden
LAYER MAP 56 DATATYPE 60 846    // Mapping (56;60) to 846 for forbidden
LAYER MAP 56 DATATYPE 80 846    // Mapping (56;80) to 846 for forbidden

LAYER VIA7i      807
LAYER MAP 57 DATATYPE 0  807
LAYER DVIA7      407
LAYER MAP 57 DATATYPE 1  407
LAYER NOUSEV7    847  
LAYER MAP 57 DATATYPE 20 847    // Mapping (57;20) to 847 for forbidden
LAYER MAP 57 DATATYPE 40 847    // Mapping (57;40) to 847 for forbidden
LAYER MAP 57 DATATYPE 60 847    // Mapping (57;60) to 847 for forbidden
LAYER MAP 57 DATATYPE 80 847    // Mapping (57;80) to 847 for forbidden

LAYER VIA8_OLD      808               
LAYER MAP 58 DATATYPE 0 808
LAYER VIA8_NEW      828
LAYER MAP 58 DATATYPE 40  828
#IFDEF MIXED_SCHEME
VIA8i = VIA8_OLD OR VIA8_NEW
#ELSE
VIA8i = COPY VIA8_NEW
#ENDIF
LAYER NOUSEV8_NEW    848
LAYER MAP 58 DATATYPE 0 848
LAYER NOUSEV8_OLD    868
LAYER MAP 58 DATATYPE 20 868
LAYER MAP 58 DATATYPE 60 868
LAYER MAP 58 DATATYPE 80 868
LAYER MAP 58 DATATYPE 1  868
#IFDEF MIXED_SCHEME
NOUSEV8 = COPY NOUSEV8_OLD
#ELSE
NOUSEV8 = NOUSEV8_NEW OR NOUSEV8_OLD
#ENDIF

LAYER VIA9_OLD      809               
LAYER MAP 59 DATATYPE 0 809
LAYER VIA9_NEW      829
LAYER MAP 59 DATATYPE 40  829
#IFDEF MIXED_SCHEME
VIA9i = VIA9_OLD OR VIA9_NEW
#ELSE
VIA9i = COPY VIA9_NEW
#ENDIF
LAYER NOUSEV9_NEW    849
LAYER MAP 59 DATATYPE 0 849
LAYER NOUSEV9_OLD    869
LAYER MAP 59 DATATYPE 20 869
LAYER MAP 59 DATATYPE 60 869
LAYER MAP 59 DATATYPE 80 869
LAYER MAP 59 DATATYPE 1  869
#IFDEF MIXED_SCHEME
NOUSEV9 = COPY NOUSEV9_OLD
#ELSE
NOUSEV9 = NOUSEV9_NEW OR NOUSEV9_OLD
#ENDIF


LAYER METAL_ABOVE_TOP 41
LAYER VIA_ABOVE_TOP 60


LAYER M1_PIN     1301
LAYER MAP 131 DATATYPE 0 1301 
LAYER M1_PIN_TEXT   11301
LAYER MAP 131 TEXTTYPE 0 11301
LAYER M2_PIN     1302
LAYER MAP 132 DATATYPE 0 1302 
LAYER M2_PIN_TEXT   11302
LAYER MAP 132 TEXTTYPE 0 11302
LAYER M3_PIN     1303
LAYER MAP 133 DATATYPE 0 1303 
LAYER M3_PIN_TEXT   11303
LAYER MAP 133 TEXTTYPE 0 11303
LAYER M4_PIN     1304
LAYER MAP 134 DATATYPE 0 1304 
LAYER M4_PIN_TEXT   11304
LAYER MAP 134 TEXTTYPE 0 11304
LAYER M5_PIN     1305
LAYER MAP 135 DATATYPE 0 1305 
LAYER M5_PIN_TEXT   11305
LAYER MAP 135 TEXTTYPE 0 11305
LAYER M6_PIN     1306
LAYER MAP 136 DATATYPE 0 1306 
LAYER M6_PIN_TEXT   11306
LAYER MAP 136 TEXTTYPE 0 11306
LAYER M7_PIN     1307
LAYER MAP 137 DATATYPE 0 1307 
LAYER M7_PIN_TEXT   11307
LAYER MAP 137 TEXTTYPE 0 11307
LAYER M8_PIN     1308
LAYER MAP 138 DATATYPE 0 1308 
LAYER M8_PIN_TEXT   11308
LAYER MAP 138 TEXTTYPE 0 11308
LAYER M9_PIN     1309
LAYER MAP 139 DATATYPE 0 1309 
LAYER M9_PIN_TEXT   11309
LAYER MAP 139 TEXTTYPE 0 11309
LAYER M10_PIN     1310
LAYER MAP 140 DATATYPE 0 1310 
LAYER M10_PIN_TEXT   11310
LAYER MAP 140 TEXTTYPE 0 11310
LAYER AP_PIN 1260
LAYER MAP 126 DATATYPE 0 1260
LAYER AP_PIN_TEXT 11260
LAYER MAP 126 TEXTTYPE 0 11260

LAYER ODi 350 7 8
LAYER MAP 6 DATATYPE 0           350
LAYER MAP 6 DATATYPE 2           350
LAYER MAP 6 DATATYPE >=4   <=6   350
LAYER MAP 6 DATATYPE >=8   <=160 350
LAYER MAP 6 DATATYPE >=166 <=255 350
LAYER ODiRFDRAIN 351 
LAYER MAP 6 DATATYPE 3 351  // for mixed-mode process to recognize RF MOS region
LAYER ODiSRAM    352 
LAYER MAP 6 DATATYPE 11 352 // for SRAM only
LAYER MAP 6 DATATYPE 12 352 // for SRAM only
LAYER MAP 6 DATATYPE 13 352 // for SRAM only
LAYER ODiOTHERS  353 7 8
LAYER MAP 6 DATATYPE 2           353
LAYER MAP 6 DATATYPE >=4 <=6     353
LAYER MAP 6 DATATYPE >=8 <=160   353
LAYER MAP 6 DATATYPE >=166 <=255 353
LAYER DOD 354
LAYER MAP 6 DATATYPE 1 354  // Mapping (6;1) to 354 for dummy OD
LAYER SRDOD     357
LAYER MAP 6 DATATYPE 7 357  // Mapping (6;7) to 357 for SR_DOD
LAYER NOTUSEOD 355
LAYER MAP 6 DATATYPE >=161 <=165 355  // TSMC internal mask making layer (6;161-165)

LAYER POi 364
LAYER MAP 17 DATATYPE 0           364
LAYER MAP 17 DATATYPE >=2   <=6   364
LAYER MAP 17 DATATYPE >=8   <=50  364
LAYER MAP 17 DATATYPE >=52  <=160 364
LAYER MAP 17 DATATYPE >=166 <=255 364
LAYER POiSRAM 365            
LAYER MAP 17 DATATYPE 11 365 // for SRAM only
LAYER MAP 17 DATATYPE 12 365 // for SRAM only 
LAYER MAP 17 DATATYPE 13 365 // for SRAM only
LAYER POiOTHERS 366
LAYER MAP 17 DATATYPE >=2   <=6   366
LAYER MAP 17 DATATYPE >=8   <=50  366
LAYER MAP 17 DATATYPE >=52  <=160 366
LAYER MAP 17 DATATYPE >=166 <=255 366
LAYER DPO        361
LAYER MAP 17 DATATYPE 1 361  // Mapping (17;1) to 361 for dummy PO
LAYER SRDPO     367
LAYER MAP 17 DATATYPE 7 367  // Mapping (17;7) to 367 for SR_DPO
LAYER mVTLi      362         // Used to generate poly logical operation in LVT process
LAYER MAP 17 DATATYPE 51 362 // Mapping (17;51, layer PO, purpose rule1) to 362 for mVTLi
LAYER NOTUSEPO   363
LAYER MAP 17 DATATYPE >=161 <=165 363   // TSMC internal mask making layer (17;161-165)

LAYER ODBLK      392
LAYER MAP 150 DATATYPE 20 392
LAYER POBLK      393
LAYER MAP 150 DATATYPE 21 393

LAYER RRuleRequired      1821	// marker layer for action-required DFM rules
LAYER MAP 182 DATATYPE 1 1821
LAYER RRuleRecommended   1822	// marker layer for recommended DFM rule
LAYER MAP 182 DATATYPE 2 1822
LAYER RRuleAnalog        1823	// marker layer for analog rules and recommendations
LAYER MAP 182 DATATYPE 3 1823
LAYER RRuleGuideline     1824	// marker layer for DFM guidelines
LAYER MAP 182 DATATYPE 4 1824
LAYER excludeRRuleRequired    1831  // marker layer for excluding DFM action-required rules
LAYER MAP 182 DATATYPE 11     1831
LAYER excludeRRuleRecommended 1832  // marker layer for excluding DFM recommendations
LAYER MAP 182 DATATYPE 12     1832
LAYER excludeRRuleAnalog      1833  // marker layer for excluding analog rules and recommendations
LAYER MAP 182 DATATYPE 13     1833
LAYER excludeRRuleGuideline   1834  // marker layer for excluding DFM guidelines
LAYER MAP 182 DATATYPE 14     1834

LAYER BJTDMY  110	        // BJT dummy layer


LAYER VDDDMY 2554             // Dummy layer for Pewer(VDD) pad
LAYER MAP 255 DATATYPE 4 2554
LAYER VSSDMY 2555             // Dummy layer for Ground(VSS) pad
LAYER MAP 255 DATATYPE 5 2555
LAYER SENDMY 2558             // Dummy layer to define the sensitive devices for local OD/PO density check
LAYER MAP 255 DATATYPE 8 2558
LAYER RES200 2559             // Recognize resistor over 200ohm for ESD/LUP check
LAYER MAP 255 DATATYPE 9 2559
LAYER LOWMEDN 2560            // Dummy layer for low metal density region
LAYER MAP 255 DATATYPE 15 2560


LAYER POS1        2541          // GATE CD size-up 1nm/side
LAYER MAP 254 DATATYPE 1 2541
LAYER POS2        2542          // GATE CD size-up 2nm/side
LAYER MAP 254 DATATYPE 2 2542
LAYER POS_OTHERS  2543
LAYER MAP 254 DATATYPE >=3 <=255 2543






LAYOUT BASE LAYER OD18i OD25i OD33i NTNi NcapNTNi VTHNi VTHPi VTLNi VTLPi
LAYOUT BASE LAYER DNWi NWi ODi POi PPi NPi COi RPOi RH COPUSH



// GLOBAL DERIVED LAYERS FOR RULE CHECKS
//--------------------------------------
#IFDEF ChipWindowUsed
LAYER ChipWindow 500 // layer number for constructing chip boundary
POLYGON xLB yLB xRT yRT ChipWindow
CHIP       = PUSH ChipWindow
#ELSE
 CHIP  = EXTENT ( EXTENT DRAWN DNWi NWi OD12i OD18i OD25i OD25_LK OD33i ODDECAP PPi NPi HVD_N HVD_P CBi CB2Fi CB2Wi RPOi NTNi LPP_NTNi LPP_NTN_21i LPP_NTN_DPOi LPP_NTN_120i POFUSE FUSELINK PMi PM1i PM2i VTHNi VTHPi VTLNi VTLPi VTULNi VTULPi VTLN18 CBDi CBDB UBMi UBMB RH ESDIMP VARi DVAR APi Cu_PPIi AP_BSL AP_BSP CBMi CTMi RVi RV_BSL DCOi LMARK SRM SRMN SRMP SRMRP NPreDOSRM ROM SRM_HS SRAMDMY SRAMDMY_PAS SRAMDMY_PERI_LP SRAMDMY_PERI_G CO2 DPSRM PRSRM SRMLOP12 SRMLOP13 SRMLOP14 LVLOP HCDPLOP TPLOP_8T TPLOP_10T RAM1TDMY OD1T OD1TH OD1TM OD1T_WLD OD1T_MOSCAP OD1T_CP OD1T_20 OD1T_18 OD1T_16 CLDD EDRAM_DECAP SNCT CROWN P3 LDDBLK ICOVL TLDMY RODMY M1i DM1_O DUM1 M2i DM2_O DUM2 M3i DM3_O DUM3 M4i DM4_O DUM4 M5i DM5_O DUM5 M6i DM6_O DUM6 M7i DM7_O DUM7 M8i DM8_O DUM8 M9_OLD M9_NEW DUM9_OLD DUM9_NEW M10_OLD M10_NEW DUM10_OLD DUM10_NEW DVIA1 DVIA2 DVIA3 DVIA4 DVIA5 DVIA6 DVIA7 ODi ODiSRAM DOD SRDOD POi POiSRAM DPO SRDPO mVTLi BJTDMY POS1 POS2 POS_OTHERS )
//CHIP       = EXTENT 
//CHIP       = EXTENT CELL "*" ORIGINAL 
#ENDIF

CHIPx        = MERGE CHIP
BULK         = SIZE CHIP BY 1.0
PWELi        = BULK NOT NWi
EMPTYi       = CHIP NOT BULK // for DRC coding

#IFDEF FULL_CHIP
#IFDEF WITH_SEALRING
#IFDEF OLD_SEALRING
SR_EDGE = CHIP NOT (SIZE CHIP BY -16)
SR_EXC  = EXT SR_EDGE < 73.715 ABUT == 90 REGION INTERSECTING ONLY 
SRCSR   = SR_EDGE OR SR_EXC   // Sealring + CSR Corner + Assembly isolation
#ELSE
SRCSR   = COPY SEALRING_ALL   // Sealring + SRDB + CSR Corner + Assembly isolation
#ENDIF
EMPTY_AREA = COPY EMPTYi
CHIP_EDGE_a = CHIP NOT SRCSR
ISO_REGION = (SIZE CHIP_EDGE_a BY SR_S_1) NOT CHIP_EDGE_a
CHIP_EDGE  = EXTENT CHIP_EDGE_a
#ELSE
SRCSR = COPY EMPTYi
EMPTY_AREA = INT CHIP < CSR_R_1 ABUT == 90 REGION INTERSECTING ONLY
CHIP_EDGE_a = CHIP NOT EMPTY_AREA
CHIP_EDGE = COPY CHIP
#ENDIF
#ELSE
EMPTY_AREA = COPY EMPTYi
SRCSR = COPY EMPTYi
#ENDIF

SEALRING_EXCLUDE = (SRCSR OR SEALRING_ALL) OR SEALRING_ORI

SRAM_EXCLUDE = COPY EMPTYi
SRAM_REGION  = SRAMDMY NOT RAM1TDMY // new SRAM exclude layer

ALL_OD = (ODi OR SRDOD) OR DOD
ALL_POLY = (POi OR SRDPO) OR DPO
M1x = M1i OR DUM1 
M2x = M2i OR DUM2 
M3x = M3i OR DUM3 
M4x = M4i OR DUM4 
M5x = M5i OR DUM5 
M6x = M6i OR DUM6 
M7x = M7i OR DUM7 
M8x = M8i OR DUM8 
M9x = M9i OR DUM9 
M10x = M10i OR DUM10 

// EXCLUDE UNCHECKED REGIONS
//--------------------------
PWEL    = PWELi   NOT SRAM_EXCLUDE
DNW     = DNWi    NOT INSIDE SRAM_EXCLUDE
NWEL    = NWi     NOT INSIDE SRAM_EXCLUDE
OD      = ODi     NOT SRAM_EXCLUDE
ODs     = ODi     NOT INSIDE SRAM_EXCLUDE
OD12    = OD12i   NOT SRAM_EXCLUDE
OD12s   = OD12i   NOT INSIDE SRAM_EXCLUDE
OD18    = OD18i   NOT SRAM_EXCLUDE
OD25    = OD25i   NOT SRAM_EXCLUDE
OD33    = OD33i   NOT SRAM_EXCLUDE
POLY    = POi     NOT SRAM_EXCLUDE
POLYs   = POi     NOT INSIDE SRAM_EXCLUDE
PP      = PPi     NOT INSIDE SRAM_EXCLUDE
NP      = NPi     NOT INSIDE SRAM_EXCLUDE
VTHN    = VTHNi   NOT SRAM_EXCLUDE
VTHNs   = VTHNi   NOT INSIDE SRAM_EXCLUDE
VTHP    = VTHPi   NOT SRAM_EXCLUDE
VTHPs   = VTHPi   NOT INSIDE SRAM_EXCLUDE
VTLN    = VTLNi   NOT SRAM_EXCLUDE
VTLNs   = VTLNi   NOT INSIDE SRAM_EXCLUDE
VTLP    = VTLPi   NOT SRAM_EXCLUDE
VTLPs   = VTLPi   NOT INSIDE SRAM_EXCLUDE
RPO     = RPOi    NOT SRAM_EXCLUDE
RPOs    = RPOi    NOT INSIDE SRAM_EXCLUDE
NTN     = NTNi    NOT SRAM_EXCLUDE
NTNs    = NTNi    NOT INSIDE SRAM_EXCLUDE
NCapNTN = NCapNTNi NOT SRAM_EXCLUDE  
CO      = COi     NOT SRAM_EXCLUDE
COs     = COi     NOT INSIDE SRAM_EXCLUDE
M1      = M1i     NOT SRAM_EXCLUDE
M1s     = M1i     NOT INSIDE SRAM_EXCLUDE
VIA1    = VIA1i   NOT SRAM_EXCLUDE
VIA1s   = VIA1i   NOT INSIDE SRAM_EXCLUDE
DCO     = DCOi    NOT SRAM_EXCLUDE
DCOs    = DCOi    NOT INSIDE SRAM_EXCLUDE

M2      = COPY M2i 
VIA2    = COPY VIA2i
M3      = COPY M3i 
VIA3    = COPY VIA3i
M4      = COPY M4i 
VIA4    = COPY VIA4i
M5      = COPY M5i 
VIA5    = COPY VIA5i
M6      = COPY M6i 
VIA6    = COPY VIA6i
M7      = COPY M7i 
VIA7    = COPY VIA7i
M8      = COPY M8i 
VIA8    = COPY VIA8i
M9      = COPY M9i 
VIA9    = COPY VIA9i
M10      = COPY M10i 

RV      = COPY RVi
AP      = COPY APi
CB      = COPY CBi  
PM      = COPY PMi  
CBM     = COPY CBMi
CTM     = COPY CTMi
VAR	= COPY VARi
mVTL    = COPY mVTLi

UBM_MT = SIZE (UBMi INTERACT CBDi) BY 5 INSIDE OF M10i STEP M10_S_1*0.7 // groud-up flip-chip
CB_MT = SIZE ((CBi OR CB2Wi) NOT SEALRING_EXCLUDE) BY 5 INSIDE OF M10i STEP M10_S_1*0.7 // wire-bond

MTOP_EXC = UBM_MT OR CB_MT	// For high density and max width rule

VIA1_HOLE = RECTANGLE VIA1i == VIA1_W_1 BY == VIA1_W_1 ORTHOGONAL ONLY
VIA1_BAR = VIA1i NOT VIA1_HOLE
VIA2_HOLE = RECTANGLE VIA2i == VIA2_W_1 BY == VIA2_W_1 ORTHOGONAL ONLY
VIA2_BAR = VIA2i NOT VIA2_HOLE
VIA3_HOLE = RECTANGLE VIA3i == VIA3_W_1 BY == VIA3_W_1 ORTHOGONAL ONLY
VIA3_BAR = VIA3i NOT VIA3_HOLE
VIA4_HOLE = RECTANGLE VIA4i == VIA4_W_1 BY == VIA4_W_1 ORTHOGONAL ONLY
VIA4_BAR = VIA4i NOT VIA4_HOLE
VIA5_HOLE = RECTANGLE VIA5i == VIA5_W_1 BY == VIA5_W_1 ORTHOGONAL ONLY
VIA5_BAR = VIA5i NOT VIA5_HOLE
VIA6_HOLE = RECTANGLE VIA6i == VIA6_W_1 BY == VIA6_W_1 ORTHOGONAL ONLY
VIA6_BAR = VIA6i NOT VIA6_HOLE
VIA7_HOLE = RECTANGLE VIA7i == VIA7_W_1 BY == VIA7_W_1 ORTHOGONAL ONLY
VIA7_BAR = VIA7i NOT VIA7_HOLE
LOWMEDN_CORE1 = SIZE LOWMEDN BY -1
LOWMEDN_CORE2 = SIZE LOWMEDN BY -4
LOWMEDN_CORE3 = SIZE LOWMEDN BY -5
P_RING_REGION1 = LOWMEDN NOT LOWMEDN_CORE1
P_RING_REGION = LOWMEDN NOT LOWMEDN_CORE2
P_RING_REGION2 = LOWMEDN NOT LOWMEDN_CORE3
LOWMEDN_IND = LOWMEDN INTERACT INDDMY
P_RING_VIA1 = P_RING_REGION AND VIA1_BAR
P_RING_VIA1_IND = P_RING_VIA1 INTERACT LOWMEDN_IND
P_RING_VIA1_noIND = P_RING_VIA1 NOT INTERACT LOWMEDN_IND
P_RING_VIA2 = P_RING_REGION AND VIA2_BAR
P_RING_VIA2_IND = P_RING_VIA2 INTERACT LOWMEDN_IND
P_RING_VIA2_noIND = P_RING_VIA2 NOT INTERACT LOWMEDN_IND
P_RING_VIA3 = P_RING_REGION AND VIA3_BAR
P_RING_VIA3_IND = P_RING_VIA3 INTERACT LOWMEDN_IND
P_RING_VIA3_noIND = P_RING_VIA3 NOT INTERACT LOWMEDN_IND
P_RING_VIA4 = P_RING_REGION AND VIA4_BAR
P_RING_VIA4_IND = P_RING_VIA4 INTERACT LOWMEDN_IND
P_RING_VIA4_noIND = P_RING_VIA4 NOT INTERACT LOWMEDN_IND
P_RING_VIA5 = P_RING_REGION AND VIA5_BAR
P_RING_VIA5_IND = P_RING_VIA5 INTERACT LOWMEDN_IND
P_RING_VIA5_noIND = P_RING_VIA5 NOT INTERACT LOWMEDN_IND
P_RING_VIA6 = P_RING_REGION AND VIA6_BAR
P_RING_VIA6_IND = P_RING_VIA6 INTERACT LOWMEDN_IND
P_RING_VIA6_noIND = P_RING_VIA6 NOT INTERACT LOWMEDN_IND
P_RING_VIA7 = P_RING_REGION AND VIA7_BAR
P_RING_VIA7_IND = P_RING_VIA7 INTERACT LOWMEDN_IND
P_RING_VIA7_noIND = P_RING_VIA7 NOT INTERACT LOWMEDN_IND

VIA_EXD = SEALRING_ORI OR SEALRING_DB
VIA1_EXD = (VIA1 NOT VIA_EXD) NOT P_RING_VIA1

VIA2_EXD = (VIA2 NOT VIA_EXD) NOT P_RING_VIA2

VIA3_EXD = (VIA3 NOT VIA_EXD) NOT P_RING_VIA3

VIA4_EXD = (VIA4 NOT VIA_EXD) NOT P_RING_VIA4

VIA5_EXD = (VIA5 NOT VIA_EXD) NOT P_RING_VIA5

VIA6_EXD = (VIA6 NOT VIA_EXD) NOT P_RING_VIA6

VIA7_EXD = (VIA7 NOT VIA_EXD) NOT P_RING_VIA7

VIA8_EXD = VIA8 NOT VIA_EXD

VIA9_EXD = VIA9 NOT VIA_EXD


IND_REGION = SIZE INDDMY BY 16
IND_EXD = SIZE INDDMY BY 22

//Metal Maximum Width Waive
M1_MAX_WIDTH_EXC_a = (SEALRING_ORI OR CSRDMY) OR IND_REGION
M1_MAX_WIDTH_EXC_b = COPY EMPTYi
M1_MAX_WIDTH = M1 NOT (M1_MAX_WIDTH_EXC_a OR M1_MAX_WIDTH_EXC_b)
M2_MAX_WIDTH_EXC_a = (SEALRING_ORI OR CSRDMY) OR IND_REGION
M2_MAX_WIDTH_EXC_b = COPY EMPTYi
M2_MAX_WIDTH = M2 NOT (M2_MAX_WIDTH_EXC_a OR M2_MAX_WIDTH_EXC_b)
M3_MAX_WIDTH_EXC_a = (SEALRING_ORI OR CSRDMY) OR IND_REGION
M3_MAX_WIDTH_EXC_b = COPY EMPTYi
M3_MAX_WIDTH = M3 NOT (M3_MAX_WIDTH_EXC_a OR M3_MAX_WIDTH_EXC_b)
M4_MAX_WIDTH_EXC_a = (SEALRING_ORI OR CSRDMY) OR IND_REGION
M4_MAX_WIDTH_EXC_b = COPY EMPTYi
M4_MAX_WIDTH = M4 NOT (M4_MAX_WIDTH_EXC_a OR M4_MAX_WIDTH_EXC_b)
M5_MAX_WIDTH_EXC_a = (SEALRING_ORI OR CSRDMY) OR IND_REGION
M5_MAX_WIDTH_EXC_b = COPY EMPTYi
M5_MAX_WIDTH = M5 NOT (M5_MAX_WIDTH_EXC_a OR M5_MAX_WIDTH_EXC_b)
M6_MAX_WIDTH_EXC_a = (SEALRING_ORI OR CSRDMY) OR IND_REGION
M6_MAX_WIDTH_EXC_b = COPY EMPTYi
M6_MAX_WIDTH = M6 NOT (M6_MAX_WIDTH_EXC_a OR M6_MAX_WIDTH_EXC_b)
M7_MAX_WIDTH_EXC_a = (SEALRING_ORI OR CSRDMY) OR IND_REGION
M7_MAX_WIDTH_EXC_b = COPY EMPTYi
M7_MAX_WIDTH = M7 NOT (M7_MAX_WIDTH_EXC_a OR M7_MAX_WIDTH_EXC_b)
M8_MAX_WIDTH_EXC_a = (SEALRING_ORI OR CSRDMY) OR IND_REGION
M8_MAX_WIDTH_EXC_b = COPY EMPTYi
M8_MAX_WIDTH = M8 NOT (M8_MAX_WIDTH_EXC_a OR M8_MAX_WIDTH_EXC_b)
M9_MAX_WIDTH_EXC_a = COPY IND_EXD
M9_MAX_WIDTH_EXC_b = WBDMY OR CB_MT
M9_MAX_WIDTH = M9 NOT (M9_MAX_WIDTH_EXC_a OR M9_MAX_WIDTH_EXC_b)
M10_MAX_WIDTH_EXC_a = COPY IND_EXD
M10_MAX_WIDTH_EXC_b = MTOP_EXC OR LMARK 
M10_MAX_WIDTH = M10 NOT (M10_MAX_WIDTH_EXC_a OR M10_MAX_WIDTH_EXC_b)

//Density Waive
#IFDEF FULL_CHIP
DEN_EXC_LOW =  ((LOGO OR INDDMY) OR SEALRING_EXCLUDE) OR EMPTY_AREA    // exclude region for low density
DEN_EXC_HIGH =  SEALRING_EXCLUDE OR INDDMY 
#ELSE
DEN_EXC_LOW = LOGO OR INDDMY                // exclude region for low density
DEN_EXC_HIGH = CSRDMY OR INDDMY
#ENDIF
M1_EXC_LOW  = COPY DEN_EXC_LOW
M1_EXC_HIGH = COPY DEN_EXC_HIGH

M2_EXC_LOW  = COPY DEN_EXC_LOW
M2_EXC_HIGH = COPY DEN_EXC_HIGH

M3_EXC_LOW  = COPY DEN_EXC_LOW
M3_EXC_HIGH = COPY DEN_EXC_HIGH

M4_EXC_LOW  = COPY DEN_EXC_LOW
M4_EXC_HIGH = COPY DEN_EXC_HIGH

M5_EXC_LOW  = COPY DEN_EXC_LOW
M5_EXC_HIGH = COPY DEN_EXC_HIGH

M6_EXC_LOW  = COPY DEN_EXC_LOW
M6_EXC_HIGH = COPY DEN_EXC_HIGH

M7_EXC_LOW  = COPY DEN_EXC_LOW
M7_EXC_HIGH = COPY DEN_EXC_HIGH

M8_EXC_LOW  = COPY DEN_EXC_LOW
M8_EXC_HIGH = COPY DEN_EXC_HIGH

M9_EXC_LOW  = COPY DEN_EXC_LOW
M9_EXC_HIGH = DEN_EXC_HIGH OR (WBDMY OR CB_MT) 

M10_EXC_LOW  = COPY DEN_EXC_LOW
M10_EXC_HIGH = DEN_EXC_HIGH OR MTOP_EXC


NEW_DEN_EXC = EMPTY_AREA OR LOWMEDN


    
OD2 = (OD18 OR OD25) OR OD33
OD2i = (OD18i OR OD25i) OR OD33i


IMP          = NPi OR PPi
NPOD         = OD AND NP
PPOD         = OD AND PP
COOD         = CO AND OD        // Diffusion contacts 
SR_COPO      = CO AND SRDPO     // SR_DPO contacts
COPO         = (CO NOT OD) NOT SRDPO // POLY contacts + floating contacts

RNWEL = NWEL INTERACT NWDMY	// NWEL resistor (Within OD & STI)
NWRES = RNWEL INTERACT RPO	// NWEL resistor (Within OD)
NONWR = NWEL NOT RNWEL		// NWEL exclude resistor area (Within OD)
ODWR  = OD INTERACT NWRES	// OD area of NW resistor (Within OD)
NPWR  = NP INTERACT NWRES	// N+ implant on NW resistor terminals (Within OD)
COWR  = COOD INTERACT NWRES	// Contact on NW resistor terminals (Within OD)
RHWR  = ODWR NOT RPO		// Silicided terminal of NW resistor (Within OD)
NWRES_STI = RNWEL NOT INTERACT RPO	// NWEL resistor (Under STI)
ODWR_STI = OD INTERACT NWRES_STI	// OD area of NW resistor (Under STI)
NPWR_STI = NP INTERACT NWRES_STI
COWR_STI = COOD INTERACT NWRES_STI	// Contact on NW resistor terminals (Under STI)

NSTP         = NPOD AND NONWR          // NWEL tap diffusion
NACT         = NPOD NOT NWEL           // NMOS device active diffusion
PACT         = PPOD AND NWEL           // PMOS device active diffusion
NACT2        = NACT INTERACT OD2
PACT2        = PACT INTERACT OD2
PSTP         = PPOD NOT NWEL           // Substrate (pwell) tap diffusion
DACT         = NACT OR PACT            // NMOS/PMOS device active diffusion
DSTP         = NSTP OR PSTP

GATE         = POLY AND OD	       // Gate regions for NMOS and PMOS
GATEi        = POi AND ODi	       // Gate regions for NMOS and PMOS
SD           = (DACT ENCLOSE GATE) NOT GATE  // Source, drain areas
FPO1         = POLY NOT OD             // Field poly
HV_GATE      = GATE AND OD2
LV_GATE      = GATE NOT OD2
GATE_NP      = GATE AND NP
GATE_PP      = GATE AND PP
GATE_W       = POLY COIN INSIDE EDGE GATE      // Gate width
GATE_Wi      = POi COIN INSIDE EDGE GATEi
GATE_L       = GATE NOT TOUCH EDGE GATE_W
GATE_Li      = GATEi NOT TOUCH EDGE GATE_Wi
GATEN_W      = GATE_W INSIDE EDGE NP
GATEP_W      = GATE_W INSIDE EDGE PP
HV_GATE_W    = GATE_W INSIDE EDGE OD2         // 2.5V/1.8V MOS gates
LV_GATE_W    = GATE_W NOT INSIDE EDGE OD2
HV_GATE_L    = GATE_L INSIDE EDGE OD2         // 2.5V/1.8V MOS gates
LV_GATE_L    = GATE_L NOT INSIDE EDGE OD2
18V_GATE_W   = HV_GATE_W INSIDE EDGE OD18
25V_GATE_W   = HV_GATE_W INSIDE EDGE OD25
33V_GATE_W   = HV_GATE_W INSIDE EDGE OD33

HVD_NMOS_DRAIN = SD INTERACT HVD_N
HVD_NGATE = HV_GATE INTERACT HVD_N
HVD_PMOS_DRAIN = SD INTERACT HVD_P
HVD_PGATE = HV_GATE INTERACT HVD_P
HVD_GATE  = HVD_NGATE OR HVD_PGATE

SR_POLY      = SRDPO OR POLY
SR_GATE      = SRDPO AND OD
SR_GATE_W    = SRDPO COIN INSIDE EDGE SR_GATE
SR_GATE_L    = SR_GATE NOT TOUCH EDGE SR_GATE_W
SR_HV_GATE   = SR_GATE AND OD2


RPDMYi        = RPDMY NOT INTERACT RPOi	 // silicided od/poly resistor dummy layer
RPO_RPDMY     = RPOi OR RPDMYi           // unsilicided/silicided od/poly resistor
ILP1          = POLY NOT RPO_RPDMY       // interconnect poly
INOD          = OD NOT RPO_RPDMY
FOD           = (OD OUTSIDE NWDMY) NOT GATE

//resistor definition
OD_RES_RPO    = ((RPDMY AND OD) AND RH) AND RPO
OD_RES_noRPO  = ((RPDMY AND OD) AND RH) NOT RPO
OD_RES        =  OD_RES_RPO OR OD_RES_noRPO
PO_RES_RPO    = ((RPDMY AND POLY) AND RH) AND RPO
PO_RES_noRPO  = ((RPDMY AND POLY) AND RH) NOT RPO
PO_RES        =  PO_RES_RPO OR PO_RES_noRPO
OD_RES_RPO_PP = PP AND OD_RES_RPO
OD_RES_RPO_NP = NP AND OD_RES_RPO 
PO_RES_RPO_PP = PP AND PO_RES_RPO 
PO_RES_RPO_NP = NP AND PO_RES_RPO 
ODPO_RES_RPO_PP = OD_RES_RPO_PP OR PO_RES_RPO_PP 
ODPO_RES_RPO_NP = OD_RES_RPO_NP OR PO_RES_RPO_NP 
ODPO_RES_RPO    = OD_RES_RPO OR PO_RES_RPO 

NW_RES = NWEL AND NWDMY
NW_RES_underOD  = NW_RES AND OD
NW_RES_underSTI = NW_RES NOT OD
NWROD  = NWEL INTERACT NW_RES_underOD
NWRSTI = NWEL INTERACT NW_RES_underSTI
NWROD_or_NWRSTI = NWROD OR NWRSTI

OD_RES_200ohm = OD_RES AND RES200  
PO_RES_200ohm = PO_RES AND RES200
NW_RES_200ohm = NW_RES AND RES200

SEN_GATE = ((((GATE INTERACT SENDMY) NOT LOGO) NOT CSRDMY) NOT (SRAMDMY AND RODMY)) WITH EDGE (LENGTH GATE_L <= 0.05)
SEN_PO_RES_RPO = SENDMY AND PO_RES_RPO
    
NP_PP_BTE     = NPOD COIN OUTSIDE EDGE PPOD
BUTT_PSTP     = PSTP TOUCH NACT
BUTT_NSTP     = NSTP TOUCH PACT

// For BJT Device
PP_EMOD = PACT AND BJTDMY
NP_EMOD = NACT AND BJTDMY
EMOD = PP_EMOD OR NP_EMOD


// DFM
Block = LOGO OR SRCSR 


// Nodal NWEL connectivity checks
ILP1i = POi NOT RPO_RPDMY	// Interconnect poly
NONWRi = NWi NOT INTERACT NWDMY 
NWRiT = (NWi INTERACT NWDMY) NOT NWDMY // NWR terminal  
//RWi   = DNWi NOT NWi
RWi = PWELi INSIDE DNWi
NPODi = NPi AND ODi
PPODi = PPi AND ODi
NACTi = NPODi NOT NWi
PACTi = PPODi AND NWi
NSDi  = NACTi NOT POi		// NMOS source/drain
PSDi  = PACTi NOT POi		// PMOS source/drain
NSDc  = NSDi NOT RPO_RPDMY	// NMOS source/drain for connection
PSDc  = PSDi NOT RPO_RPDMY	// PMOS source/drain for connection
NSTPi = NPODi AND NONWRi        // Break the connection at NWR  
PSTPi = PPODi NOT NWi

//======================================
CONNECT NWEL DNW 	// For DNW.S.2 check only, not for electrical connection.
CONNECT NSTPi NWi                 
CONNECT NSTPi PSDc	// For butted pickup
CONNECT PSTPi RWi	// For DNW connection
CONNECT PSTPi PWELi     // For DNW connection
CONNECT PSTPi NSDc	// For butted pickup
CONNECT COi PSDc        // For butted CO
CONNECT COi NSDc        // For butted CO
CONNECT COi ILP1i       // For butted CO
CONNECT COi SRDPO       // To fix CO.S.2.1 error 
CONNECT M1i ILP1i NSTPi PSTPi PSDc NSDc NWRiT BY COi
CONNECT M1i M2i BY VIA1i
CONNECT M2i M3i BY VIA2i
CONNECT M3i M4i BY VIA3i
CONNECT M4i M5i BY VIA4i
CONNECT M5i M6i BY VIA5i
CONNECT M6i M7i BY VIA6i
CONNECT M7i M8i BY VIA7i
CONNECT M8i M9i BY VIA8i
CONNECT M9i M10i BY VIA9i
CONNECT CBi M10i
CONNECT M10i APi  BY RVi
CONNECT M10i APi  BY CBi
CONNECT M10i APi  BY CBDi
CONNECT CB2Wi APi
CONNECT UBMi APi BY CB2Fi
CONNECT UBMi M10i BY CBDi


//======================================
NWu   = COPY NWi
RWu   = COPY RWi
PWELu = COPY PWELi
NWRuT = COPY NWRiT
POu   = COPY POi
NSDu  = COPY NSDi
PSDu  = COPY PSDi
NSTPu = NPODi AND NWi
PSTPu = COPY PSTPi
COu   = COPY COi
M1u   = COPY M1i
VIA1u = COPY VIA1i
M2u   = COPY M2i
VIA2u = COPY VIA2i
M3u   = COPY M3i
VIA3u = COPY VIA3i
M4u   = COPY M4i
VIA4u = COPY VIA4i
M5u   = COPY M5i
VIA5u = COPY VIA5i
M6u   = COPY M6i
VIA6u = COPY VIA6i
M7u   = COPY M7i
VIA7u = COPY VIA7i
M8u   = COPY M8i
VIA8u = COPY VIA8i
M9u   = COPY M9i
VIA9u = COPY VIA9i
M10u   = COPY M10i
RVu   = COPY RVi
CBu   = COPY CBi
CBDu  = COPY CBDi
CB2Fu = COPY CB2Fi
CB2Wu = COPY CB2Wi
APu   = COPY APi
UBMu  = COPY UBMi

CONNECT NSTPu NWu
CONNECT NSTPu PSDu	// For butted pickup
CONNECT PSTPu RWu	// For DNW connection
CONNECT PSTPu PWELu	// For DNW connection
CONNECT PSTPu NSDu	// For butted pickup
CONNECT COu PSDu        // For butted CO
CONNECT COu NSDu        // For butted CO
CONNECT COu POu         // For butted CO
CONNECT M1u POu NSTPu PSTPu PSDu NSDu BY COu
CONNECT M1u NWRuT BY COu // prevent from connection shielding
CONNECT M1u M2u BY VIA1u
CONNECT M2u M3u BY VIA2u
CONNECT M3u M4u BY VIA3u
CONNECT M4u M5u BY VIA4u
CONNECT M5u M6u BY VIA5u
CONNECT M6u M7u BY VIA6u
CONNECT M7u M8u BY VIA7u
CONNECT M8u M9u BY VIA8u
CONNECT M9u M10u BY VIA9u
CONNECT CBu M10u
CONNECT M10u APu  BY RVu
CONNECT M10u APu  BY CBu
CONNECT M10u APu  BY CBDu
CONNECT CB2Wu APu
CONNECT UBMu APu BY CB2Fu
CONNECT UBMu M10u BY CBDu

//======================================
NWj   = NWi NOT NW_RES_200ohm
RWj   = EMPTYi OR RWi
PWELj = EMPTYi OR PWELi
POj   = POi NOT PO_RES_200ohm
NSDj  = NSDi NOT OD_RES_200ohm
PSDj  = PSDi NOT OD_RES_200ohm
NSTPj = EMPTYi OR (NPODi AND NWi)
PSTPj = EMPTYi OR PSTPi
COj   = EMPTYi OR COi
M1j   = EMPTYi OR M1i
VIA1j = EMPTYi OR VIA1i
M2j   = EMPTYi OR M2i
VIA2j = EMPTYi OR VIA2i
M3j   = EMPTYi OR M3i
VIA3j = EMPTYi OR VIA3i
M4j   = EMPTYi OR M4i
VIA4j = EMPTYi OR VIA4i
M5j   = EMPTYi OR M5i
VIA5j = EMPTYi OR VIA5i
M6j   = EMPTYi OR M6i
VIA6j = EMPTYi OR VIA6i
M7j   = EMPTYi OR M7i
VIA7j = EMPTYi OR VIA7i
M8j   = EMPTYi OR M8i
VIA8j = EMPTYi OR VIA8i
M9j   = EMPTYi OR M9i
VIA9j = EMPTYi OR VIA9i
M10j   = EMPTYi OR M10i
RVj   = EMPTYi OR RVi
CBj   = EMPTYi OR CBi
CBDj  = EMPTYi OR CBDi
CB2Fj = EMPTYi OR CB2Fi
CB2Wj = EMPTYi OR CB2Wi
APj   = EMPTYi OR APi
UBMj  = EMPTYi OR UBMi

CONNECT NSTPj NWj
CONNECT NSTPj PSDj	// For butted pickup
CONNECT PSTPj RWj	// For DNW connection
CONNECT PSTPj PWELj	// For DNW connection
CONNECT PSTPj NSDj	// For butted pickup
CONNECT COj PSDj        // For butted CO
CONNECT COj NSDj        // For butted CO
CONNECT COj POj         // For butted CO
CONNECT M1j POj NSTPj PSTPj PSDj NSDj BY COj
CONNECT M1j M2j BY VIA1j
CONNECT M2j M3j BY VIA2j
CONNECT M3j M4j BY VIA3j
CONNECT M4j M5j BY VIA4j
CONNECT M5j M6j BY VIA5j
CONNECT M6j M7j BY VIA6j
CONNECT M7j M8j BY VIA7j
CONNECT M8j M9j BY VIA8j
CONNECT M9j M10j BY VIA9j
CONNECT CBj M10j
CONNECT M10j APj  BY RVj
CONNECT M10j APj  BY CBj
CONNECT M10j APj  BY CBDj
CONNECT CB2Wj APj
CONNECT UBMj APj BY CB2Fj
CONNECT UBMj M10j BY CBDj

SD_HVD    = SD AND (HVD_N OR HVD_P)
SD_OD2    = (SD AND (OD2i NOT OD1815)) NOT SD_HVD 
SD_UD15   = SD AND (OD2i AND OD1815)
SD_CORE   = SD NOT OD2i
PSD_HVD   = STAMP SD_HVD BY PSDc
NSD_HVD   = STAMP SD_HVD BY NSDc
S_HVD_GATE = STAMP HVD_GATE BY ILP1i
PSD_OD2   = STAMP SD_OD2 BY PSDc
NSD_OD2   = STAMP SD_OD2 BY NSDc
S_HV_GATE = STAMP (HV_GATE NOT OD1815) BY ILP1i
PSD_UD15  = STAMP SD_UD15 BY PSDc
NSD_UD15  = STAMP SD_UD15 BY NSDc
S_MV_GATE = STAMP (HV_GATE AND OD1815) BY ILP1i
PSD_CORE  = STAMP SD_CORE BY PSDc
NSD_CORE  = STAMP SD_CORE BY NSDc
S_LV_GATE = STAMP LV_GATE BY ILP1i

M1_HV_5V = STAMP (M1_HV_5Vi AND M1i) BY M1i
M1_HV = STAMP (M1_HVi AND M1i) BY M1i
M1_MV = STAMP (M1_MVi AND M1i) BY M1i
M1_LV = STAMP (M1_LVi AND M1i) BY M1i

M2_HV_5V = STAMP (M2_HV_5Vi AND M2i) BY M2i
M2_HV = STAMP (M2_HVi AND M2i) BY M2i
M2_MV = STAMP (M2_MVi AND M2i) BY M2i
M2_LV = STAMP (M2_LVi AND M2i) BY M2i

M3_HV_5V = STAMP (M3_HV_5Vi AND M3i) BY M3i
M3_HV = STAMP (M3_HVi AND M3i) BY M3i
M3_MV = STAMP (M3_MVi AND M3i) BY M3i
M3_LV = STAMP (M3_LVi AND M3i) BY M3i

M4_HV_5V = STAMP (M4_HV_5Vi AND M4i) BY M4i
M4_HV = STAMP (M4_HVi AND M4i) BY M4i
M4_MV = STAMP (M4_MVi AND M4i) BY M4i
M4_LV = STAMP (M4_LVi AND M4i) BY M4i

M5_HV_5V = STAMP (M5_HV_5Vi AND M5i) BY M5i
M5_HV = STAMP (M5_HVi AND M5i) BY M5i
M5_MV = STAMP (M5_MVi AND M5i) BY M5i
M5_LV = STAMP (M5_LVi AND M5i) BY M5i

M6_HV_5V = STAMP (M6_HV_5Vi AND M6i) BY M6i
M6_HV = STAMP (M6_HVi AND M6i) BY M6i
M6_MV = STAMP (M6_MVi AND M6i) BY M6i
M6_LV = STAMP (M6_LVi AND M6i) BY M6i

M7_HV_5V = STAMP (M7_HV_5Vi AND M7i) BY M7i
M7_HV = STAMP (M7_HVi AND M7i) BY M7i
M7_MV = STAMP (M7_MVi AND M7i) BY M7i
M7_LV = STAMP (M7_LVi AND M7i) BY M7i

M8_HV_5V = STAMP (M8_HV_5Vi AND M8i) BY M8i
M8_HV = STAMP (M8_HVi AND M8i) BY M8i
M8_MV = STAMP (M8_MVi AND M8i) BY M8i
M8_LV = STAMP (M8_LVi AND M8i) BY M8i

M9_HV_5V = STAMP (M9_HV_5Vi AND M9i) BY M9i
M9_HV = STAMP (M9_HVi AND M9i) BY M9i
M9_MV = STAMP (M9_MVi AND M9i) BY M9i
M9_LV = STAMP (M9_LVi AND M9i) BY M9i

M10_HV_5V = STAMP (M10_HV_5Vi AND M10i) BY M10i
M10_HV = STAMP (M10_HVi AND M10i) BY M10i
M10_MV = STAMP (M10_MVi AND M10i) BY M10i
M10_LV = STAMP (M10_LVi AND M10i) BY M10i



RFIP = RFDMY AND RFIPDMY
// waive for eDRAM
OD_RAM = OD INSIDE RAM1TDMY
OD_SF1 = OD_RAM WITH WIDTH == OD_SEx_eDRAM
OD_SF2 = (OD_RAM TOUCH EDGE OD_SF1) NOT COIN INSIDE EDGE OD_SF1
OD_SF3 = EXPAND EDGE OD_SF2 INSIDE BY OD_SEy_eDRAM
OD_NSF = (OD NOT OD_SF1) NOT OD_SF3
OD_DMY = (OD_RAM NOT INTERACT CO) NOT INTERACT SNCT

RAM_OD = OD NOT OUTSIDE RAM1TDMY
RAM_POLY = POLY NOT OUTSIDE RAM1TDMY
RAM_GATE_W = GATE_W INSIDE EDGE RAM1TDMY
RAM_GATE = GATE INSIDE RAM1TDMY






#IFDEF P3_SEALRING
#IFDEF P3R_SEALRING
OPTION.SEALRING.ERROR1 {@ 'P3_SEALRING' and 'P3R_SEALRING' option can not be turn on at same time
   COPY CHIP
}
#ENDIF
#ENDIF

#IFDEF P3_SEALRING
#IFDEF P4_SEALRING
OPTION.SEALRING.ERROR2 {@ 'P3_SEALRING' and 'P4_SEALRING' option can not be turn on at same time
   COPY CHIP
}
#ENDIF
#ENDIF

#IFDEF P3R_SEALRING
#IFDEF P4_SEALRING
OPTION.SEALRING.ERROR3 {@ 'P3R_SEALRING' and 'P4_SEALRING' option can not be turn on at same time
   COPY CHIP
}
#ENDIF
#ENDIF

#IFDEF WITH_SEALRING
#IFNDEF FULL_CHIP
OPTION.SEALRING.ERROR4 {@ If you turn on 'WITH_SEALRING' option, please turn on 'FULL_CHIP' option also.
   COPY CHIP
}
#ENDIF
#ENDIF


#IFDEF P3_SEALRING
#IFNDEF WITH_SEALRING
OPTION.SEALRING.ERROR5 {@ If you turn on 'P3_SEALRING' option, please turn on 'WITH_SEALRING' option also.
   COPY CHIP
}
#ENDIF
#ENDIF

#IFDEF P3R_SEALRING
#IFNDEF WITH_SEALRING
OPTION.SEALRING.ERROR6 {@ If you turn on 'P3R_SEALRING' option, please turn on 'WITH_SEALRING' option also.
   COPY CHIP
}
#ENDIF
#ENDIF

#IFDEF P4_SEALRING
#IFNDEF WITH_SEALRING
OPTION.SEALRING.ERROR7 {@ If you turn on 'P4_SEALRING' option, please turn on 'WITH_SEALRING' option also.
   COPY CHIP
}
#ENDIF
#ENDIF


#IFDEF COMPATIBLE_MODE
#IFDEF HALF_NODE
OPTION.COMPATIBLE_MODE.WARNING { @ 'COMPATIBLE_MODE' option and 'HALF_NODE' option should not be enabled at the same time.
                 @ If these two options are all enabled, only 'HALF_NODE' option will be effective.
  COPY CHIP
}
#ENDIF
#IFDEF GS
OPTION.COMPATIBLE_MODE.ERROR { @ 'COMPATIBLE_MODE' option is only for N45LP/N40LP, please turn off this option in N45GS(N40G).
  COPY CHIP
}
#ENDIF
#ENDIF



#IFDEF GS
3.3V_IO.WARN1{@ 3.3V IO is not standard offer in N45GS(N40G)
   COPY OD33i
}
DCO.WARN {@ DCO layer is not standard offer in N45GS(N40G)
   COPY DCOi 
}
5V_HVMOS.WARN {@ 5V HVMOS is not standard offer in N45GS(N40G) 
   COPY HVD_N
   COPY HVD_P
}
#ELSE
#IFNDEF HALF_NODE
3.3V_IO.WARN2{@ 3.3V IO is not standard offer in N45LP/N45LPG
   COPY OD33i
}
OD18_15.WARN{@ 1.8V underdrive to 1.5V is not standard offer in N45LP/N45LPG
   COPY OD1815
}
#ENDIF
OD12.WARN{@ 1.2V Core Oxide is not standard offer in N45LP/N45LPG/N40LP/N40LPG 
   COPY  OD12i
}
#ENDIF


#IFDEF OLD_SEALRING
SEALRING.WARN1{@ Phase3 and Phase3R Sealring were phased out. Please use Phase4R Sealring.
   COPY CHIPx
}
#ENDIF

#IFDEF P4_SEALRING
SEALRING.WARN2{@ Phase4 sealring was phased out. Please use Phase4R Sealring with updated BIB/CDU pattern. 
   COPY CHIPx
}
#ENDIF

M11_VIA10.WARN { @ This is 10M DRC. If customer wants to check M11. Please use M11 DRC command file.
  COPY METAL_ABOVE_TOP
  COPY VIA_ABOVE_TOP
}


#IFNDEF DFM_ONLY


G.1.DNWi { @ grid must be an integer multiple of ^Grid um
  OFFGRID DNWi 5
}
G.1.NWi { @ grid must be an integer multiple of ^Grid um
  OFFGRID NWi 5
}
G.1.OD12i { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD12i 5
}
G.1.OD18i { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD18i 5
}
G.1.OD1815 { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD1815 5
}
G.1.OD25i { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD25i 5
}
G.1.OD2533 { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD2533 5
}
G.1.OD2518 { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD2518 5
}
G.1.OD25_LK { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD25_LK 5
}
G.1.OD33i { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD33i 5
}
G.1.ODDECAP { @ grid must be an integer multiple of ^Grid um
  OFFGRID ODDECAP 5
}
G.1.PPi { @ grid must be an integer multiple of ^Grid um
  OFFGRID PPi 5
}
G.1.NPi { @ grid must be an integer multiple of ^Grid um
  OFFGRID NPi 5
}
G.1.HVD_N { @ grid must be an integer multiple of ^Grid um
  OFFGRID HVD_N 5
}
G.1.HVD_P { @ grid must be an integer multiple of ^Grid um
  OFFGRID HVD_P 5
}
G.1.CBi { @ grid must be an integer multiple of ^Grid um
  OFFGRID CBi 5
}
G.1.CB2Wi { @ grid must be an integer multiple of ^Grid um
  OFFGRID CB2Wi 5
}
G.1.RPOi { @ grid must be an integer multiple of ^Grid um
  OFFGRID RPOi 5
}
G.1.NTNi { @ grid must be an integer multiple of ^Grid um
  OFFGRID NTNi 5
}
G.1.LPP_NTNi { @ grid must be an integer multiple of ^Grid um
  OFFGRID LPP_NTNi 5
}
G.1.LPP_NTN_21i { @ grid must be an integer multiple of ^Grid um
  OFFGRID LPP_NTN_21i 5
}
G.1.LPP_NTN_DPOi { @ grid must be an integer multiple of ^Grid um
  OFFGRID LPP_NTN_DPOi 5
}
G.1.LPP_NTN_120i { @ grid must be an integer multiple of ^Grid um
  OFFGRID LPP_NTN_120i 5
}
G.1.POFUSE { @ grid must be an integer multiple of ^Grid um
  OFFGRID POFUSE 5
}
G.1.FUSELINK { @ grid must be an integer multiple of ^Grid um
  OFFGRID FUSELINK 5
}
G.1.PM1i { @ grid must be an integer multiple of ^Grid um
  OFFGRID PM1i 5
}
G.1.PM2i { @ grid must be an integer multiple of ^Grid um
  OFFGRID PM2i 5
}
G.1.SEALRING_ORI { @ grid must be an integer multiple of ^Grid um
  OFFGRID SEALRING_ORI 5
}
G.1.SEALRING_DB { @ grid must be an integer multiple of ^Grid um
  OFFGRID SEALRING_DB 5
}
G.1.SEALRING_ALL { @ grid must be an integer multiple of ^Grid um
  OFFGRID SEALRING_ALL 5
}
G.1.VTHNi { @ grid must be an integer multiple of ^Grid um
  OFFGRID VTHNi 5
}
G.1.VTHPi { @ grid must be an integer multiple of ^Grid um
  OFFGRID VTHPi 5
}
G.1.VTLNi { @ grid must be an integer multiple of ^Grid um
  OFFGRID VTLNi 5
}
G.1.VTLPi { @ grid must be an integer multiple of ^Grid um
  OFFGRID VTLPi 5
}
G.1.VTULNi { @ grid must be an integer multiple of ^Grid um
  OFFGRID VTULNi 5
}
G.1.VTULPi { @ grid must be an integer multiple of ^Grid um
  OFFGRID VTULPi 5
}
G.1.VTLN18 { @ grid must be an integer multiple of ^Grid um
  OFFGRID VTLN18 5
}
G.1.CBDB { @ grid must be an integer multiple of ^Grid um
  OFFGRID CBDB 5
}
G.1.UBMB { @ grid must be an integer multiple of ^Grid um
  OFFGRID UBMB 5
}
G.1.RH { @ grid must be an integer multiple of ^Grid um
  OFFGRID RH 5
}
G.1.ESDIMP { @ grid must be an integer multiple of ^Grid um
  OFFGRID ESDIMP 5
}
G.1.VARi { @ grid must be an integer multiple of ^Grid um
  OFFGRID VARi 5
}
G.1.DVAR { @ grid must be an integer multiple of ^Grid um
  OFFGRID DVAR 5
}
G.1.APi { @ grid must be an integer multiple of ^Grid um
  OFFGRID APi 5
}
G.1.Cu_PPIi { @ grid must be an integer multiple of ^Grid um
  OFFGRID Cu_PPIi 5
}
G.1.AP_BSL { @ grid must be an integer multiple of ^Grid um
  OFFGRID AP_BSL 5
}
G.1.AP_BSP { @ grid must be an integer multiple of ^Grid um
  OFFGRID AP_BSP 5
}
G.1.CBMi { @ grid must be an integer multiple of ^Grid um
  OFFGRID CBMi 5
}
G.1.CTMi { @ grid must be an integer multiple of ^Grid um
  OFFGRID CTMi 5
}
G.1.RVi { @ grid must be an integer multiple of ^Grid um
  OFFGRID RVi 5
}
G.1.RV_BSL { @ grid must be an integer multiple of ^Grid um
  OFFGRID RV_BSL 5
}
G.1.DCOi { @ grid must be an integer multiple of ^Grid um
  OFFGRID DCOi 5
}
G.1.LMARK { @ grid must be an integer multiple of ^Grid um
  OFFGRID LMARK 5
}
G.1.SRM { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRM 5
}
G.1.SRMN { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRMN 5
}
G.1.SRMP { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRMP 5
}
G.1.SRMRP { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRMRP 5
}
G.1.NPreDOSRM { @ grid must be an integer multiple of ^Grid um
  OFFGRID NPreDOSRM 5
}
G.1.ROM { @ grid must be an integer multiple of ^Grid um
  OFFGRID ROM 5
}
G.1.SRM_HS { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRM_HS 5
}
G.1.SRAMDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRAMDMY 5
}
G.1.SRAMDMY_PAS { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRAMDMY_PAS 5
}
G.1.SRAMDMY_PERI_LP { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRAMDMY_PERI_LP 5
}
G.1.SRAMDMY_PERI_G { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRAMDMY_PERI_G 5
}
G.1.CO2 { @ grid must be an integer multiple of ^Grid um
  OFFGRID CO2 5
}
G.1.DPSRM { @ grid must be an integer multiple of ^Grid um
  OFFGRID DPSRM 5
}
G.1.PRSRM { @ grid must be an integer multiple of ^Grid um
  OFFGRID PRSRM 5
}
G.1.SRMLOP12 { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRMLOP12 5
}
G.1.SRMLOP13 { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRMLOP13 5
}
G.1.SRMLOP14 { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRMLOP14 5
}
G.1.LVLOP { @ grid must be an integer multiple of ^Grid um
  OFFGRID LVLOP 5
}
G.1.HCDPLOP { @ grid must be an integer multiple of ^Grid um
  OFFGRID HCDPLOP 5
}
G.1.TPLOP_8T { @ grid must be an integer multiple of ^Grid um
  OFFGRID TPLOP_8T 5
}
G.1.TPLOP_10T { @ grid must be an integer multiple of ^Grid um
  OFFGRID TPLOP_10T 5
}
G.1.RAM1TDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID RAM1TDMY 5
}
G.1.OD1T { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD1T 5
}
G.1.OD1TH { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD1TH 5
}
G.1.OD1TM { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD1TM 5
}
G.1.OD1T_WLD { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD1T_WLD 5
}
G.1.OD1T_MOSCAP { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD1T_MOSCAP 5
}
G.1.OD1T_CP { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD1T_CP 5
}
G.1.OD1T_20 { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD1T_20 5
}
G.1.OD1T_18 { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD1T_18 5
}
G.1.OD1T_16 { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD1T_16 5
}
G.1.CLDD { @ grid must be an integer multiple of ^Grid um
  OFFGRID CLDD 5
}
G.1.EDRAM_DECAP { @ grid must be an integer multiple of ^Grid um
  OFFGRID EDRAM_DECAP 5
}
G.1.SNCT { @ grid must be an integer multiple of ^Grid um
  OFFGRID SNCT 5
}
G.1.LDDBLK { @ grid must be an integer multiple of ^Grid um
  OFFGRID LDDBLK 5
}
G.1.CDUDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID CDUDMY 5
}
G.1.TCDDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID TCDDMY 5
}
G.1.TCDDMY_H { @ grid must be an integer multiple of ^Grid um
  OFFGRID TCDDMY_H 5
}
G.1.TCDDMY_V { @ grid must be an integer multiple of ^Grid um
  OFFGRID TCDDMY_V 5
}
G.1.ICOVL { @ grid must be an integer multiple of ^Grid um
  OFFGRID ICOVL 5
}
G.1.LOGO { @ grid must be an integer multiple of ^Grid um
  OFFGRID LOGO 5
}
G.1.TLDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID TLDMY 5
}
G.1.DIODMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID DIODMY 5
}
G.1.RFDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID RFDMY 5
}
G.1.RFIPDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID RFIPDMY 5
}
G.1.LUPWDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID LUPWDMY 5
}
G.1.M1i { @ grid must be an integer multiple of ^Grid um
  OFFGRID M1i 5
}
G.1.DM1_O { @ grid must be an integer multiple of ^Grid um
  OFFGRID DM1_O 5
}
G.1.DUM1 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM1 5
}
G.1.M2i { @ grid must be an integer multiple of ^Grid um
  OFFGRID M2i 5
}
G.1.DM2_O { @ grid must be an integer multiple of ^Grid um
  OFFGRID DM2_O 5
}
G.1.DUM2 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM2 5
}
G.1.M3i { @ grid must be an integer multiple of ^Grid um
  OFFGRID M3i 5
}
G.1.DM3_O { @ grid must be an integer multiple of ^Grid um
  OFFGRID DM3_O 5
}
G.1.DUM3 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM3 5
}
G.1.M4i { @ grid must be an integer multiple of ^Grid um
  OFFGRID M4i 5
}
G.1.DM4_O { @ grid must be an integer multiple of ^Grid um
  OFFGRID DM4_O 5
}
G.1.DUM4 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM4 5
}
G.1.M5i { @ grid must be an integer multiple of ^Grid um
  OFFGRID M5i 5
}
G.1.DM5_O { @ grid must be an integer multiple of ^Grid um
  OFFGRID DM5_O 5
}
G.1.DUM5 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM5 5
}
G.1.M6i { @ grid must be an integer multiple of ^Grid um
  OFFGRID M6i 5
}
G.1.DM6_O { @ grid must be an integer multiple of ^Grid um
  OFFGRID DM6_O 5
}
G.1.DUM6 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM6 5
}
G.1.M7i { @ grid must be an integer multiple of ^Grid um
  OFFGRID M7i 5
}
G.1.DM7_O { @ grid must be an integer multiple of ^Grid um
  OFFGRID DM7_O 5
}
G.1.DUM7 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM7 5
}
G.1.M8i { @ grid must be an integer multiple of ^Grid um
  OFFGRID M8i 5
}
G.1.DM8_O { @ grid must be an integer multiple of ^Grid um
  OFFGRID DM8_O 5
}
G.1.DUM8 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM8 5
}
G.1.M9_OLD { @ grid must be an integer multiple of ^Grid um
  OFFGRID M9_OLD 5
}
G.1.M9_NEW { @ grid must be an integer multiple of ^Grid um
  OFFGRID M9_NEW 5
}
G.1.DUM9_OLD { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM9_OLD 5
}
G.1.DUM9_NEW { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM9_NEW 5
}
G.1.M10_OLD { @ grid must be an integer multiple of ^Grid um
  OFFGRID M10_OLD 5
}
G.1.M10_NEW { @ grid must be an integer multiple of ^Grid um
  OFFGRID M10_NEW 5
}
G.1.DUM10_OLD { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM10_OLD 5
}
G.1.DUM10_NEW { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM10_NEW 5
}
G.1.VIA1i { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA1i 5
}
G.1.DVIA1 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DVIA1 5
}
G.1.VIA2i { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA2i 5
}
G.1.DVIA2 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DVIA2 5
}
G.1.VIA3i { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA3i 5
}
G.1.DVIA3 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DVIA3 5
}
G.1.VIA4i { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA4i 5
}
G.1.DVIA4 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DVIA4 5
}
G.1.VIA5i { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA5i 5
}
G.1.DVIA5 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DVIA5 5
}
G.1.VIA6i { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA6i 5
}
G.1.DVIA6 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DVIA6 5
}
G.1.VIA7i { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA7i 5
}
G.1.DVIA7 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DVIA7 5
}
G.1.VIA8_OLD { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA8_OLD 5
}
G.1.VIA8_NEW { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA8_NEW 5
}
G.1.VIA9_OLD { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA9_OLD 5
}
G.1.VIA9_NEW { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA9_NEW 5
}
G.1.DOD { @ grid must be an integer multiple of ^Grid um
  OFFGRID DOD 5
}
G.1.SRDOD { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRDOD 5
}
G.1.DPO { @ grid must be an integer multiple of ^Grid um
  OFFGRID DPO 5
}
G.1.SRDPO { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRDPO 5
}
G.1.mVTLi { @ grid must be an integer multiple of ^Grid um
  OFFGRID mVTLi 5
}
G.1.BJTDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID BJTDMY 5
}
G.1.POS1 { @ grid must be an integer multiple of ^Grid um
  OFFGRID POS1 5
}
G.1.POS2 { @ grid must be an integer multiple of ^Grid um
  OFFGRID POS2 5
}
G.1.POS_OTHERS { @ grid must be an integer multiple of ^Grid um
  OFFGRID POS_OTHERS 5
}
G.1.CO { @ ^Grid um grid is required for CO outside SRAM periphrial regions
  X = COi NOT SRAMDMY_PERI
  OFFGRID X 5	
}
G.1.PO { @ ^Grid um grid is required for PO outside SRAM periphrial regions
  X = POi NOT SRAMDMY_PERI
  OFFGRID X 5	
}
G.1.OD { @ grid must be an integer multiple of 0.005 um
  OFFGRID OD_NSF 5
}
G.1.CBD { @ grid must be an integer multiple of 0.005 um
  X = CBDi NOT UBMi
  OFFGRID X 5	
}
G.1.CB2F { @ grid must be an integer multiple of 0.005 um
  X = CB2Fi NOT UBMi
  OFFGRID X 5	
}
G.1.PM { @ grid must be an integer multiple of 0.005 um
  X = PMi NOT UBMi
  OFFGRID X 5	
}
G.2.DNWi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DNWi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DNWi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.NWi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT NWi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NWi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD12i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD12i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD12i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD18i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD18i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD18i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD1815 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD1815 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD1815 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD25i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD25i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD25i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD2533 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD2533 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD2533 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD2518 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD2518 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD2518 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD25_LK { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD25_LK < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD25_LK < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD33i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD33i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD33i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.ODDECAP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ODDECAP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ODDECAP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.PPi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT PPi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PPi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.NPi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT NPi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NPi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.HVD_N { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT HVD_N < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT HVD_N < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.HVD_P { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT HVD_P < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT HVD_P < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.COi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT COi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT COi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.COPUSH { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT COPUSH < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT COPUSH < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.COiSRAM { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT COiSRAM < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT COiSRAM < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CBi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CBi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CBi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CB2Wi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CB2Wi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CB2Wi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RPOi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RPOi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RPOi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.NTNi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT NTNi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NTNi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.LPP_NTNi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT LPP_NTNi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LPP_NTNi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.LPP_NTN_21i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT LPP_NTN_21i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LPP_NTN_21i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.LPP_NTN_DPOi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT LPP_NTN_DPOi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LPP_NTN_DPOi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.LPP_NTN_120i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT LPP_NTN_120i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LPP_NTN_120i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.POFUSE { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT POFUSE < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT POFUSE < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.FUSELINK { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT FUSELINK < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT FUSELINK < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.PM1i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT PM1i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PM1i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.PM2i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT PM2i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PM2i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SEALRING_ORI { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SEALRING_ORI < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SEALRING_ORI < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SEALRING_DB { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SEALRING_DB < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SEALRING_DB < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SEALRING_ALL { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SEALRING_ALL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SEALRING_ALL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VTHNi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VTHNi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTHNi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VTHPi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VTHPi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTHPi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VTLNi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VTLNi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTLNi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VTLPi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VTLPi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTLPi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VTULNi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VTULNi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTULNi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VTULPi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VTULPi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTULPi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VTLN18 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VTLN18 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTLN18 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CBDB { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CBDB < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CBDB < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.UBMB { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT UBMB < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT UBMB < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RH { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RH < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RH < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.ESDIMP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ESDIMP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ESDIMP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VARi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VARi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VARi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DVAR { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DVAR < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DVAR < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.APi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT APi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT APi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.Cu_PPIi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT Cu_PPIi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT Cu_PPIi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.AP_BSL { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT AP_BSL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT AP_BSL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.AP_BSP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT AP_BSP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT AP_BSP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CBMi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CBMi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CBMi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CTMi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CTMi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CTMi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RVi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RVi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RVi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RV_BSL { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RV_BSL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RV_BSL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DCOi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DCOi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DCOi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SRM { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRM < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRM < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SRMN { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRMN < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRMN < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SRMP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRMP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRMP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SRMRP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRMRP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRMRP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.NPreDOSRM { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT NPreDOSRM < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NPreDOSRM < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.ROM { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ROM < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ROM < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SRM_HS { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRM_HS < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRM_HS < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SRAMDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRAMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRAMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SRAMDMY_PAS { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRAMDMY_PAS < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRAMDMY_PAS < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SRAMDMY_PERI_LP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRAMDMY_PERI_LP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRAMDMY_PERI_LP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SRAMDMY_PERI_G { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRAMDMY_PERI_G < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRAMDMY_PERI_G < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CO2 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CO2 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CO2 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DPSRM { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DPSRM < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DPSRM < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.PRSRM { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT PRSRM < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PRSRM < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SRMLOP12 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRMLOP12 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRMLOP12 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SRMLOP13 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRMLOP13 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRMLOP13 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SRMLOP14 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRMLOP14 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRMLOP14 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.LVLOP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT LVLOP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LVLOP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.HCDPLOP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT HCDPLOP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT HCDPLOP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.TPLOP_8T { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT TPLOP_8T < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT TPLOP_8T < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.TPLOP_10T { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT TPLOP_10T < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT TPLOP_10T < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RAM1TDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RAM1TDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RAM1TDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD1T { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD1T < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD1T < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD1TH { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD1TH < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD1TH < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD1TM { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD1TM < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD1TM < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD1T_WLD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD1T_WLD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD1T_WLD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD1T_MOSCAP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD1T_MOSCAP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD1T_MOSCAP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD1T_CP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD1T_CP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD1T_CP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD1T_20 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD1T_20 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD1T_20 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD1T_18 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD1T_18 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD1T_18 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD1T_16 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD1T_16 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD1T_16 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CLDD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CLDD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CLDD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.EDRAM_DECAP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT EDRAM_DECAP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT EDRAM_DECAP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SNCT { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SNCT < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SNCT < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CROWN { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CROWN < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CROWN < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.P3 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT P3 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT P3 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.LDDBLK { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT LDDBLK < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LDDBLK < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CDUDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CDUDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CDUDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.TCDDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT TCDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT TCDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.TCDDMY_H { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT TCDDMY_H < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT TCDDMY_H < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.TCDDMY_V { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT TCDDMY_V < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT TCDDMY_V < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.ICOVL { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ICOVL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ICOVL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.LOGO { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT LOGO < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LOGO < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.TLDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT TLDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT TLDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DIODMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DIODMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DIODMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RFDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RFDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RFDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RFIPDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RFIPDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RFIPDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.LUPWDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT LUPWDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LUPWDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M1i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M1i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M1i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM1_O { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DM1_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM1_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM1 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM1 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM1 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M2i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M2i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M2i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM2_O { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DM2_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM2_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM2 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM2 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM2 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M3i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M3i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M3i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM3_O { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DM3_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM3_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM3 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM3 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM3 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M4i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M4i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M4i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM4_O { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DM4_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM4_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM4 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM4 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM4 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M5i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M5i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M5i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM5_O { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DM5_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM5_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM5 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM5 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM5 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M6i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M6i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M6i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM6_O { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DM6_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM6_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM6 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM6 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM6 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M7i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M7i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M7i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM7_O { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DM7_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM7_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM7 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM7 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM7 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M8i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M8i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M8i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM8_O { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DM8_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM8_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM8 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM8 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM8 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M9_OLD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M9_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M9_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M9_NEW { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M9_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M9_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM9_OLD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM9_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM9_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM9_NEW { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM9_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM9_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M10_OLD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M10_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M10_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M10_NEW { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M10_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M10_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM10_OLD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM10_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM10_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM10_NEW { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM10_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM10_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA1i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA1i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA1i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DVIA1 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DVIA1 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DVIA1 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA2i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA2i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA2i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DVIA2 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DVIA2 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DVIA2 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA3i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA3i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA3i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DVIA3 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DVIA3 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DVIA3 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA4i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA4i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA4i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DVIA4 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DVIA4 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DVIA4 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA5i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA5i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA5i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DVIA5 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DVIA5 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DVIA5 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA6i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA6i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA6i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DVIA6 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DVIA6 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DVIA6 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA7i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA7i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA7i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DVIA7 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DVIA7 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DVIA7 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA8_OLD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA8_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA8_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA8_NEW { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA8_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA8_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA9_OLD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA9_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA9_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA9_NEW { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA9_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA9_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.ODi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ODi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ODi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.ODiRFDRAIN { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ODiRFDRAIN < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ODiRFDRAIN < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.ODiSRAM { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ODiSRAM < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ODiSRAM < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DOD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DOD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DOD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SRDOD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRDOD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRDOD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.POi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT POi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT POi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.POiSRAM { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT POiSRAM < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT POiSRAM < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DPO { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DPO < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DPO < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SRDPO { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRDPO < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRDPO < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.mVTLi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT mVTLi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT mVTLi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.BJTDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT BJTDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT BJTDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.POS1 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT POS1 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT POS1 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.POS2 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT POS2 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT POS2 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.POS_OTHERS { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT POS_OTHERS < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT POS_OTHERS < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CBD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  X = CBDi NOT UBMi
  INT X < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT X < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CB2F { @ LAYERS Shapes with acute angles between line segments are not allowed.
  X = CB2Fi NOT UBMi
  INT X < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT X < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.PM { @ LAYERS Shapes with acute angles between line segments are not allowed.
  X = PMi NOT UBMi
  INT X < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT X < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.3.DNWi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DNWi >0  <45    
  ANGLE DNWi >45 <90    
}
G.3.NWi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE NWi >0  <45    
  ANGLE NWi >45 <90    
}
G.3.OD12i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD12i >0  <45    
  ANGLE OD12i >45 <90    
}
G.3.OD18i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD18i >0  <45    
  ANGLE OD18i >45 <90    
}
G.3.OD1815 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD1815 >0  <45    
  ANGLE OD1815 >45 <90    
}
G.3.OD25i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD25i >0  <45    
  ANGLE OD25i >45 <90    
}
G.3.OD2533 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD2533 >0  <45    
  ANGLE OD2533 >45 <90    
}
G.3.OD2518 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD2518 >0  <45    
  ANGLE OD2518 >45 <90    
}
G.3.OD25_LK { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD25_LK >0  <45    
  ANGLE OD25_LK >45 <90    
}
G.3.OD33i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD33i >0  <45    
  ANGLE OD33i >45 <90    
}
G.3.ODDECAP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ODDECAP >0  <45    
  ANGLE ODDECAP >45 <90    
}
G.3.PPi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE PPi >0  <45    
  ANGLE PPi >45 <90    
}
G.3.NPi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE NPi >0  <45    
  ANGLE NPi >45 <90    
}
G.3.HVD_N { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE HVD_N >0  <45    
  ANGLE HVD_N >45 <90    
}
G.3.HVD_P { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE HVD_P >0  <45    
  ANGLE HVD_P >45 <90    
}
G.3.COi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE COi >0  <45    
  ANGLE COi >45 <90    
}
G.3.COPUSH { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE COPUSH >0  <45    
  ANGLE COPUSH >45 <90    
}
G.3.COiSRAM { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE COiSRAM >0  <45    
  ANGLE COiSRAM >45 <90    
}
G.3.CBi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CBi >0  <45    
  ANGLE CBi >45 <90    
}
G.3.CB2Wi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CB2Wi >0  <45    
  ANGLE CB2Wi >45 <90    
}
G.3.RPOi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RPOi >0  <45    
  ANGLE RPOi >45 <90    
}
G.3.NTNi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE NTNi >0  <45    
  ANGLE NTNi >45 <90    
}
G.3.LPP_NTNi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE LPP_NTNi >0  <45    
  ANGLE LPP_NTNi >45 <90    
}
G.3.LPP_NTN_21i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE LPP_NTN_21i >0  <45    
  ANGLE LPP_NTN_21i >45 <90    
}
G.3.LPP_NTN_DPOi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE LPP_NTN_DPOi >0  <45    
  ANGLE LPP_NTN_DPOi >45 <90    
}
G.3.LPP_NTN_120i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE LPP_NTN_120i >0  <45    
  ANGLE LPP_NTN_120i >45 <90    
}
G.3.POFUSE { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE POFUSE >0  <45    
  ANGLE POFUSE >45 <90    
}
G.3.FUSELINK { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE FUSELINK >0  <45    
  ANGLE FUSELINK >45 <90    
}
G.3.PM1i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE PM1i >0  <45    
  ANGLE PM1i >45 <90    
}
G.3.PM2i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE PM2i >0  <45    
  ANGLE PM2i >45 <90    
}
G.3.SEALRING_ORI { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SEALRING_ORI >0  <45    
  ANGLE SEALRING_ORI >45 <90    
}
G.3.SEALRING_DB { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SEALRING_DB >0  <45    
  ANGLE SEALRING_DB >45 <90    
}
G.3.SEALRING_ALL { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SEALRING_ALL >0  <45    
  ANGLE SEALRING_ALL >45 <90    
}
G.3.VTHNi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VTHNi >0  <45    
  ANGLE VTHNi >45 <90    
}
G.3.VTHPi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VTHPi >0  <45    
  ANGLE VTHPi >45 <90    
}
G.3.VTLNi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VTLNi >0  <45    
  ANGLE VTLNi >45 <90    
}
G.3.VTLPi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VTLPi >0  <45    
  ANGLE VTLPi >45 <90    
}
G.3.VTULNi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VTULNi >0  <45    
  ANGLE VTULNi >45 <90    
}
G.3.VTULPi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VTULPi >0  <45    
  ANGLE VTULPi >45 <90    
}
G.3.VTLN18 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VTLN18 >0  <45    
  ANGLE VTLN18 >45 <90    
}
G.3.CBDB { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CBDB >0  <45    
  ANGLE CBDB >45 <90    
}
G.3.UBMB { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE UBMB >0  <45    
  ANGLE UBMB >45 <90    
}
G.3.RH { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RH >0  <45    
  ANGLE RH >45 <90    
}
G.3.ESDIMP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ESDIMP >0  <45    
  ANGLE ESDIMP >45 <90    
}
G.3.VARi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VARi >0  <45    
  ANGLE VARi >45 <90    
}
G.3.DVAR { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DVAR >0  <45    
  ANGLE DVAR >45 <90    
}
G.3.APi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE APi >0  <45    
  ANGLE APi >45 <90    
}
G.3.Cu_PPIi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE Cu_PPIi >0  <45    
  ANGLE Cu_PPIi >45 <90    
}
G.3.AP_BSL { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE AP_BSL >0  <45    
  ANGLE AP_BSL >45 <90    
}
G.3.AP_BSP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE AP_BSP >0  <45    
  ANGLE AP_BSP >45 <90    
}
G.3.CBMi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CBMi >0  <45    
  ANGLE CBMi >45 <90    
}
G.3.CTMi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CTMi >0  <45    
  ANGLE CTMi >45 <90    
}
G.3.RVi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RVi >0  <45    
  ANGLE RVi >45 <90    
}
G.3.RV_BSL { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RV_BSL >0  <45    
  ANGLE RV_BSL >45 <90    
}
G.3.DCOi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DCOi >0  <45    
  ANGLE DCOi >45 <90    
}
G.3.SRM { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRM >0  <45    
  ANGLE SRM >45 <90    
}
G.3.SRMN { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRMN >0  <45    
  ANGLE SRMN >45 <90    
}
G.3.SRMP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRMP >0  <45    
  ANGLE SRMP >45 <90    
}
G.3.SRMRP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRMRP >0  <45    
  ANGLE SRMRP >45 <90    
}
G.3.NPreDOSRM { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE NPreDOSRM >0  <45    
  ANGLE NPreDOSRM >45 <90    
}
G.3.ROM { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ROM >0  <45    
  ANGLE ROM >45 <90    
}
G.3.SRM_HS { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRM_HS >0  <45    
  ANGLE SRM_HS >45 <90    
}
G.3.SRAMDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRAMDMY >0  <45    
  ANGLE SRAMDMY >45 <90    
}
G.3.SRAMDMY_PAS { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRAMDMY_PAS >0  <45    
  ANGLE SRAMDMY_PAS >45 <90    
}
G.3.SRAMDMY_PERI_LP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRAMDMY_PERI_LP >0  <45    
  ANGLE SRAMDMY_PERI_LP >45 <90    
}
G.3.SRAMDMY_PERI_G { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRAMDMY_PERI_G >0  <45    
  ANGLE SRAMDMY_PERI_G >45 <90    
}
G.3.CO2 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CO2 >0  <45    
  ANGLE CO2 >45 <90    
}
G.3.DPSRM { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DPSRM >0  <45    
  ANGLE DPSRM >45 <90    
}
G.3.PRSRM { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE PRSRM >0  <45    
  ANGLE PRSRM >45 <90    
}
G.3.SRMLOP12 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRMLOP12 >0  <45    
  ANGLE SRMLOP12 >45 <90    
}
G.3.SRMLOP13 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRMLOP13 >0  <45    
  ANGLE SRMLOP13 >45 <90    
}
G.3.SRMLOP14 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRMLOP14 >0  <45    
  ANGLE SRMLOP14 >45 <90    
}
G.3.LVLOP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE LVLOP >0  <45    
  ANGLE LVLOP >45 <90    
}
G.3.HCDPLOP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE HCDPLOP >0  <45    
  ANGLE HCDPLOP >45 <90    
}
G.3.TPLOP_8T { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE TPLOP_8T >0  <45    
  ANGLE TPLOP_8T >45 <90    
}
G.3.TPLOP_10T { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE TPLOP_10T >0  <45    
  ANGLE TPLOP_10T >45 <90    
}
G.3.RAM1TDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RAM1TDMY >0  <45    
  ANGLE RAM1TDMY >45 <90    
}
G.3.OD1T { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD1T >0  <45    
  ANGLE OD1T >45 <90    
}
G.3.OD1TH { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD1TH >0  <45    
  ANGLE OD1TH >45 <90    
}
G.3.OD1TM { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD1TM >0  <45    
  ANGLE OD1TM >45 <90    
}
G.3.OD1T_WLD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD1T_WLD >0  <45    
  ANGLE OD1T_WLD >45 <90    
}
G.3.OD1T_MOSCAP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD1T_MOSCAP >0  <45    
  ANGLE OD1T_MOSCAP >45 <90    
}
G.3.OD1T_CP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD1T_CP >0  <45    
  ANGLE OD1T_CP >45 <90    
}
G.3.OD1T_20 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD1T_20 >0  <45    
  ANGLE OD1T_20 >45 <90    
}
G.3.OD1T_18 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD1T_18 >0  <45    
  ANGLE OD1T_18 >45 <90    
}
G.3.OD1T_16 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD1T_16 >0  <45    
  ANGLE OD1T_16 >45 <90    
}
G.3.CLDD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CLDD >0  <45    
  ANGLE CLDD >45 <90    
}
G.3.EDRAM_DECAP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE EDRAM_DECAP >0  <45    
  ANGLE EDRAM_DECAP >45 <90    
}
G.3.SNCT { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SNCT >0  <45    
  ANGLE SNCT >45 <90    
}
G.3.CROWN { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CROWN >0  <45    
  ANGLE CROWN >45 <90    
}
G.3.P3 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE P3 >0  <45    
  ANGLE P3 >45 <90    
}
G.3.LDDBLK { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE LDDBLK >0  <45    
  ANGLE LDDBLK >45 <90    
}
G.3.CDUDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CDUDMY >0  <45    
  ANGLE CDUDMY >45 <90    
}
G.3.TCDDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE TCDDMY >0  <45    
  ANGLE TCDDMY >45 <90    
}
G.3.TCDDMY_H { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE TCDDMY_H >0  <45    
  ANGLE TCDDMY_H >45 <90    
}
G.3.TCDDMY_V { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE TCDDMY_V >0  <45    
  ANGLE TCDDMY_V >45 <90    
}
G.3.ICOVL { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ICOVL >0  <45    
  ANGLE ICOVL >45 <90    
}
G.3.LOGO { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE LOGO >0  <45    
  ANGLE LOGO >45 <90    
}
G.3.TLDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE TLDMY >0  <45    
  ANGLE TLDMY >45 <90    
}
G.3.DIODMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DIODMY >0  <45    
  ANGLE DIODMY >45 <90    
}
G.3.RFDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RFDMY >0  <45    
  ANGLE RFDMY >45 <90    
}
G.3.RFIPDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RFIPDMY >0  <45    
  ANGLE RFIPDMY >45 <90    
}
G.3.LUPWDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE LUPWDMY >0  <45    
  ANGLE LUPWDMY >45 <90    
}
G.3.M1i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M1i >0  <45    
  ANGLE M1i >45 <90    
}
G.3.DM1_O { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DM1_O >0  <45    
  ANGLE DM1_O >45 <90    
}
G.3.DUM1 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM1 >0  <45    
  ANGLE DUM1 >45 <90    
}
G.3.M2i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M2i >0  <45    
  ANGLE M2i >45 <90    
}
G.3.DM2_O { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DM2_O >0  <45    
  ANGLE DM2_O >45 <90    
}
G.3.DUM2 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM2 >0  <45    
  ANGLE DUM2 >45 <90    
}
G.3.M3i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M3i >0  <45    
  ANGLE M3i >45 <90    
}
G.3.DM3_O { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DM3_O >0  <45    
  ANGLE DM3_O >45 <90    
}
G.3.DUM3 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM3 >0  <45    
  ANGLE DUM3 >45 <90    
}
G.3.M4i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M4i >0  <45    
  ANGLE M4i >45 <90    
}
G.3.DM4_O { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DM4_O >0  <45    
  ANGLE DM4_O >45 <90    
}
G.3.DUM4 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM4 >0  <45    
  ANGLE DUM4 >45 <90    
}
G.3.M5i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M5i >0  <45    
  ANGLE M5i >45 <90    
}
G.3.DM5_O { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DM5_O >0  <45    
  ANGLE DM5_O >45 <90    
}
G.3.DUM5 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM5 >0  <45    
  ANGLE DUM5 >45 <90    
}
G.3.M6i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M6i >0  <45    
  ANGLE M6i >45 <90    
}
G.3.DM6_O { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DM6_O >0  <45    
  ANGLE DM6_O >45 <90    
}
G.3.DUM6 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM6 >0  <45    
  ANGLE DUM6 >45 <90    
}
G.3.M7i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M7i >0  <45    
  ANGLE M7i >45 <90    
}
G.3.DM7_O { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DM7_O >0  <45    
  ANGLE DM7_O >45 <90    
}
G.3.DUM7 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM7 >0  <45    
  ANGLE DUM7 >45 <90    
}
G.3.M8i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M8i >0  <45    
  ANGLE M8i >45 <90    
}
G.3.DM8_O { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DM8_O >0  <45    
  ANGLE DM8_O >45 <90    
}
G.3.DUM8 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM8 >0  <45    
  ANGLE DUM8 >45 <90    
}
G.3.M9_OLD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M9_OLD >0  <45    
  ANGLE M9_OLD >45 <90    
}
G.3.M9_NEW { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M9_NEW >0  <45    
  ANGLE M9_NEW >45 <90    
}
G.3.DUM9_OLD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM9_OLD >0  <45    
  ANGLE DUM9_OLD >45 <90    
}
G.3.DUM9_NEW { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM9_NEW >0  <45    
  ANGLE DUM9_NEW >45 <90    
}
G.3.M10_OLD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M10_OLD >0  <45    
  ANGLE M10_OLD >45 <90    
}
G.3.M10_NEW { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M10_NEW >0  <45    
  ANGLE M10_NEW >45 <90    
}
G.3.DUM10_OLD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM10_OLD >0  <45    
  ANGLE DUM10_OLD >45 <90    
}
G.3.DUM10_NEW { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM10_NEW >0  <45    
  ANGLE DUM10_NEW >45 <90    
}
G.3.VIA1i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA1i >0  <45    
  ANGLE VIA1i >45 <90    
}
G.3.DVIA1 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DVIA1 >0  <45    
  ANGLE DVIA1 >45 <90    
}
G.3.VIA2i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA2i >0  <45    
  ANGLE VIA2i >45 <90    
}
G.3.DVIA2 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DVIA2 >0  <45    
  ANGLE DVIA2 >45 <90    
}
G.3.VIA3i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA3i >0  <45    
  ANGLE VIA3i >45 <90    
}
G.3.DVIA3 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DVIA3 >0  <45    
  ANGLE DVIA3 >45 <90    
}
G.3.VIA4i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA4i >0  <45    
  ANGLE VIA4i >45 <90    
}
G.3.DVIA4 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DVIA4 >0  <45    
  ANGLE DVIA4 >45 <90    
}
G.3.VIA5i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA5i >0  <45    
  ANGLE VIA5i >45 <90    
}
G.3.DVIA5 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DVIA5 >0  <45    
  ANGLE DVIA5 >45 <90    
}
G.3.VIA6i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA6i >0  <45    
  ANGLE VIA6i >45 <90    
}
G.3.DVIA6 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DVIA6 >0  <45    
  ANGLE DVIA6 >45 <90    
}
G.3.VIA7i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA7i >0  <45    
  ANGLE VIA7i >45 <90    
}
G.3.DVIA7 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DVIA7 >0  <45    
  ANGLE DVIA7 >45 <90    
}
G.3.VIA8_OLD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA8_OLD >0  <45    
  ANGLE VIA8_OLD >45 <90    
}
G.3.VIA8_NEW { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA8_NEW >0  <45    
  ANGLE VIA8_NEW >45 <90    
}
G.3.VIA9_OLD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA9_OLD >0  <45    
  ANGLE VIA9_OLD >45 <90    
}
G.3.VIA9_NEW { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA9_NEW >0  <45    
  ANGLE VIA9_NEW >45 <90    
}
G.3.ODi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ODi >0  <45    
  ANGLE ODi >45 <90    
}
G.3.ODiRFDRAIN { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ODiRFDRAIN >0  <45    
  ANGLE ODiRFDRAIN >45 <90    
}
G.3.ODiSRAM { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ODiSRAM >0  <45    
  ANGLE ODiSRAM >45 <90    
}
G.3.DOD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DOD >0  <45    
  ANGLE DOD >45 <90    
}
G.3.SRDOD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRDOD >0  <45    
  ANGLE SRDOD >45 <90    
}
G.3.POi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE POi >0  <45    
  ANGLE POi >45 <90    
}
G.3.POiSRAM { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE POiSRAM >0  <45    
  ANGLE POiSRAM >45 <90    
}
G.3.DPO { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DPO >0  <45    
  ANGLE DPO >45 <90    
}
G.3.SRDPO { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRDPO >0  <45    
  ANGLE SRDPO >45 <90    
}
G.3.mVTLi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE mVTLi >0  <45    
  ANGLE mVTLi >45 <90    
}
G.3.BJTDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE BJTDMY >0  <45    
  ANGLE BJTDMY >45 <90    
}
G.3.POS1 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE POS1 >0  <45    
  ANGLE POS1 >45 <90    
}
G.3.POS2 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE POS2 >0  <45    
  ANGLE POS2 >45 <90    
}
G.3.POS_OTHERS { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE POS_OTHERS >0  <45    
  ANGLE POS_OTHERS >45 <90    
}
G.3.PMi { @ Shapes must be orthogonal or on a 45 degree angle except {PMi AND UBM}
  ANGLE (PMi NOT UBMi) >0  <45    
  ANGLE (PMi NOT UBMi) >45 <90    
}
G.3.CBDi { @ Shapes must be orthogonal or on a 45 degree angle except {CBDi AND UBM}
  ANGLE (CBDi NOT UBMi) >0  <45    
  ANGLE (CBDi NOT UBMi) >45 <90    
}
G.3.CB2Fi { @ Shapes must be orthogonal or on a 45 degree angle except {CB2Fi AND UBM}
  ANGLE (CB2Fi NOT UBMi) >0  <45    
  ANGLE (CB2Fi NOT UBMi) >45 <90    
}
G.4.PPi { @ Adjacent edges with length less than min. width is not allowed.
  PPia = PPi NOT INSIDE SRAM_REGION
  X = LENGTH PPia < PP_W_1
  PPi_ShortExp = EXPAND EDGE X BY 0.01
  PPi_SmallJog = (VERTEX PPi_ShortExp > 4) NOT INSIDE SRAM_REGION
  PPi INSIDE EDGE PPi_SmallJog
}
G.4.NPi { @ Adjacent edges with length less than min. width is not allowed.
  NPia = NPi NOT INSIDE SRAM_REGION
  X = LENGTH NPia < NP_W_1
  NPi_ShortExp = EXPAND EDGE X BY 0.01
  NPi_SmallJog = (VERTEX NPi_ShortExp > 4) NOT INSIDE SRAM_REGION
  NPi INSIDE EDGE NPi_SmallJog
}
G.4.ODi { @ Adjacent edges with length less than min. width is not allowed.
  ODia = COPY OD_NSF
  X = LENGTH ODia < OD_W_1
  ODi_ShortExp = EXPAND EDGE X BY 0.01
  ODi_SmallJog = VERTEX ODi_ShortExp > 4
  ODi INSIDE EDGE ODi_SmallJog
}
G.4.POi { @ Adjacent edges with length less than min. width is not allowed.
  POia = POi NOT INSIDE RAM1TDMY
  X = LENGTH POia < PO_W_1
  POi_ShortExp = EXPAND EDGE X BY 0.01
  POi_SmallJog = (VERTEX POi_ShortExp > 4) NOT INSIDE RAM1TDMY
  POi INSIDE EDGE POi_SmallJog
}
G.4.VTHNi { @ Adjacent edges with length less than min. width is not allowed.
  VTHNia = VTHNi NOT INSIDE SRAM_EXCLUDE
  X = LENGTH VTHNia < VTHN_W_1
  VTHNi_ShortExp = EXPAND EDGE X BY 0.01
  VTHNi_SmallJog = (VERTEX VTHNi_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  VTHNi INSIDE EDGE VTHNi_SmallJog
}
G.4.VTHPi { @ Adjacent edges with length less than min. width is not allowed.
  VTHPia = VTHPi NOT INSIDE SRAM_EXCLUDE
  X = LENGTH VTHPia < VTHP_W_1
  VTHPi_ShortExp = EXPAND EDGE X BY 0.01
  VTHPi_SmallJog = (VERTEX VTHPi_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  VTHPi INSIDE EDGE VTHPi_SmallJog
}
G.4.VTLNi { @ Adjacent edges with length less than min. width is not allowed.
  VTLNia = VTLNi NOT INSIDE SRAM_EXCLUDE
  X = LENGTH VTLNia < VTLN_W_1
  VTLNi_ShortExp = EXPAND EDGE X BY 0.01
  VTLNi_SmallJog = (VERTEX VTLNi_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  VTLNi INSIDE EDGE VTLNi_SmallJog
}
G.4.VTLPi { @ Adjacent edges with length less than min. width is not allowed.
  VTLPia = VTLPi NOT INSIDE SRAM_EXCLUDE
  X = LENGTH VTLPia < VTLP_W_1
  VTLPi_ShortExp = EXPAND EDGE X BY 0.01
  VTLPi_SmallJog = (VERTEX VTLPi_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  VTLPi INSIDE EDGE VTLPi_SmallJog
}
G.4.M1i { @ Adjacent edges with length less than min. width is not allowed.
  M1ia = M1i NOT INSIDE SRAM_EXCLUDE
  X = LENGTH M1ia < M1_W_1
  M1i_ShortExp = EXPAND EDGE X BY 0.01
  M1i_SmallJog = (VERTEX M1i_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  M1i INSIDE EDGE M1i_SmallJog
}
G.4.SRDOD { @ Adjacent edges with length less than min. width is not allowed.
  SRDODa = SRDOD NOT INSIDE SRAM_EXCLUDE
  X = LENGTH SRDODa < SRDOD_W_1
  SRDOD_ShortExp = EXPAND EDGE X BY 0.01
  SRDOD_SmallJog = (VERTEX SRDOD_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  SRDOD INSIDE EDGE SRDOD_SmallJog
}
G.4.SRDPO { @ Adjacent edges with length less than min. width is not allowed.
  SRDPOa = SRDPO NOT INSIDE SRAM_EXCLUDE
  X = LENGTH SRDPOa < SRDPO_W_1
  SRDPO_ShortExp = EXPAND EDGE X BY 0.01
  SRDPO_SmallJog = (VERTEX SRDPO_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  SRDPO INSIDE EDGE SRDPO_SmallJog
}
G.4.M2i { @ Adjacent edges with length less than min. width is not allowed.
  X = LENGTH M2i < M2_W_1
  M2i_ShortExp = EXPAND EDGE X BY 0.01
  M2i_SmallJog = VERTEX M2i_ShortExp > 4
  M2i INSIDE EDGE M2i_SmallJog
}
G.4.M3i { @ Adjacent edges with length less than min. width is not allowed.
  X = LENGTH M3i < M3_W_1
  M3i_ShortExp = EXPAND EDGE X BY 0.01
  M3i_SmallJog = VERTEX M3i_ShortExp > 4
  M3i INSIDE EDGE M3i_SmallJog
}
G.4.M4i { @ Adjacent edges with length less than min. width is not allowed.
  X = LENGTH M4i < M4_W_1
  M4i_ShortExp = EXPAND EDGE X BY 0.01
  M4i_SmallJog = VERTEX M4i_ShortExp > 4
  M4i INSIDE EDGE M4i_SmallJog
}
G.4.M5i { @ Adjacent edges with length less than min. width is not allowed.
  X = LENGTH M5i < M5_W_1
  M5i_ShortExp = EXPAND EDGE X BY 0.01
  M5i_SmallJog = VERTEX M5i_ShortExp > 4
  M5i INSIDE EDGE M5i_SmallJog
}
G.4.M6i { @ Adjacent edges with length less than min. width is not allowed.
  X = LENGTH M6i < M6_W_1
  M6i_ShortExp = EXPAND EDGE X BY 0.01
  M6i_SmallJog = VERTEX M6i_ShortExp > 4
  M6i INSIDE EDGE M6i_SmallJog
}
G.4.M7i { @ Adjacent edges with length less than min. width is not allowed.
  X = LENGTH M7i < M7_W_1
  M7i_ShortExp = EXPAND EDGE X BY 0.01
  M7i_SmallJog = VERTEX M7i_ShortExp > 4
  M7i INSIDE EDGE M7i_SmallJog
}
G.4.M8i { @ Adjacent edges with length less than min. width is not allowed.
  X = LENGTH M8i < M8_W_1
  M8i_ShortExp = EXPAND EDGE X BY 0.01
  M8i_SmallJog = VERTEX M8i_ShortExp > 4
  M8i INSIDE EDGE M8i_SmallJog
}

// Rules G.4.VIAx are unnecessary to check (Covered by rule VIAx.W.1)


USER_GUIDE.M1 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM1
}    
USER_GUIDE.M2 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM2
}    
USER_GUIDE.M3 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM3
}    
USER_GUIDE.M4 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM4
}    
USER_GUIDE.M5 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM5
}    
USER_GUIDE.M6 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM6
}    
USER_GUIDE.M7 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM7
}    
USER_GUIDE.M8 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM8
}    
USER_GUIDE.M9 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM9
}    
USER_GUIDE.M10 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM10
}    
USER_GUIDE.VIA1 { @ Via layers with forbidden datatypes.
  COPY NOUSEV1
}    
USER_GUIDE.VIA2 { @ Via layers with forbidden datatypes.
  COPY NOUSEV2
}    
USER_GUIDE.VIA3 { @ Via layers with forbidden datatypes.
  COPY NOUSEV3
}    
USER_GUIDE.VIA4 { @ Via layers with forbidden datatypes.
  COPY NOUSEV4
}    
USER_GUIDE.VIA5 { @ Via layers with forbidden datatypes.
  COPY NOUSEV5
}    
USER_GUIDE.VIA6 { @ Via layers with forbidden datatypes.
  COPY NOUSEV6
}    
USER_GUIDE.VIA7 { @ Via layers with forbidden datatypes.
  COPY NOUSEV7
}    
USER_GUIDE.VIA8 { @ Via layers with forbidden datatypes.
  COPY NOUSEV8
}    
USER_GUIDE.VIA9 { @ Via layers with forbidden datatypes.
  COPY NOUSEV9
}    


#IFDEF DATATYPE_WARNING
NW_DATATYPE.WARNING { @ Extreme user care needs to be taken when using any layer other than (3;0) that default MT form considers to create NW mask. The tapeout engineer must explicitly explain those non-default layers must be considered equivalent to NW in the MT form to ensure complete fabrication. It is strongly recommended to use NW;drawing (3;0) layer to define NW regions.
  COPY NWiOTHERS
}
OD_DATATYPE.WARNING1 { @ Extreme user care needs to be taken when using any other layer to create OD mask such as pdiff (7;0), ndiff (8;0) or any layer other than (6;0), and (6;1) that default MT form considers. The tapeout engineer must explicitly explain those non-default layers must be considered equivalent to OD in the MT form to ensure complete fabrication.  It is strongly recommended to use only OD;drawing (6;0) and OD;dummy (6;1) layers to defined OD and DOD regions.
  COPY ODiOTHERS
}
OD_DATATYPE.WARNING2 { @ SRAM OD (6;11-13) layer are only allowed in SRAM region
  ODiSRAM NOT (SRM OR SRAMDMY)
}
OD_DATATYPE.WARNING3 { @ Layer (6;3) is for recognition purpose of RF devices, please take care if this layer is adopted for non-RF designs and not for masking purpose of diffusion regions together with OD (6;0). 
  ODiRFDRAIN NOT RFDMY
  ODiRFDRAIN AND POi
  ODiRFDRAIN NOT ODi
}
PO_DATATYPE.WARNING1 { @ Extreme user care needs to be taken when using any layer other than (17;0), and (17,1) that default MT form considers to create PO mask. The tapeout engineer must explicitly explain those non-default layers must be considered equivalent to PO in the MT form to ensure complete fabrication. It is strongly recommended to use PO;drawing (17;0) and PO;dummy (17;1) layer to define PO and DPO regions.
  COPY POiOTHERS
}
PO_DATATYPE.WARNING2 { @ SRAM PO (17;11-13) layer are only allowed in SRAM region. 
  POiSRAM NOT (SRM OR SRAMDMY)
}
CO_DATATYPE.WARNING1 { @ Extreme user care needs to be taken when using any layer other than (30;0) that default MT form considers to create CO mask. The tapeout engineer must explicitly explain those non-default layers must be considered equivalent to CO in the MT form to ensure complete fabrication. It is strongly recommended to use CO;drawing (30;0) to define CO regions. 
  COPY COiOTHERS
}
CO_DATATYPE.WARNING2 { @ SRAM CO (30;11-13) layers are only allowed in SRAM region. 
  COiSRAM NOT (SRM OR SRAMDMY)  
}
#ENDIF


#IFDEF FRONT_END


//NW CHECKS
//=========

NW2V = NWEL AND OD2
NW1V = NWEL NOT OD2
NW.W.1 { @ Width >= 0.34 
  A = (INT NWi < NW_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION 
  A OUTSIDE SRAM_REGION
  B = A CUT SRAM_REGION
  C = (NWi INTERACT B) NOT SRAM_REGION
  D = INT C < NW_W_1 ABUT < 90 SINGULAR REGION 
  B INTERACT D 
}
NW.S.1 { @ Space >= 0.34 
  (EXT NWEL < NW_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
NW.S.2 { @ Space of two NW1V with different potentials (*) >= 0.8 
  NW1V_NODAL = STAMP NW1V BY NWi
  (EXT NW1V_NODAL < NW_S_2 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
NW.S.3 { @ NW1V space to NW2V with different potentials (*) >= 1 
  NW1Vc = STAMP NW1V BY NWi
  NW2Vc = STAMP NW2V BY NWi
  (EXT NW1Vc NW2Vc < NW_S_3 ABUT < 90 > 0 SINGULAR REGION NOT CONNECTED) NOT INSIDE SRAM_EXCLUDE
}
NW.S.4 { @ Space of two NW2V with different potentials (*) >= 1 
  NW2V_NODAL = STAMP NW2V BY NWi
  (EXT NW2V_NODAL < NW_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}

#IFDEF NW_SUGGESTED
SUGGESTED.NW.S.3_NW.S.4 { @ A more conservative way to check NW.S.3, NW.S.4 with 
		          @ varied operating voltages determination of nwels.
  NW1V = NWEL OUTSIDE OD2
  NW2V = NWEL NOT OUTSIDE OD2
  NW1Vc = STAMP NW1V BY NWi
  NW2Vc = STAMP NW2V BY NWi
  EXT NW1Vc NW2Vc < NW_S_3 ABUT < 90 > 0 NOT CONNECTED SINGULAR REGION
  NW2V_NODAL = STAMP NW2V BY NWi
  EXT NW2V_NODAL < NW_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION
}
#ENDIF

NW.S.5 { @ Space to PW STRAP >= 0.08 
  EXT NWi PPOD < NW_S_5 ABUT < 90 SINGULAR REGION
  PPOD CUT NWi
}
NW.S.6 { @ Space to N+ ACTIVE (except NW resistor) >= 0.08 
  A = NPOD NOT INTERACT RNWEL
  (EXT NWi A < NW_S_6 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
  (A CUT NWi) NOT INSIDE SRAM_REGION
}
NW.S.6.1 { @ Space to N+ ACTIVE [at least one edge at each corner] (except NW resistor) >= 0.16 
   NACTx = (NPOD NOT INTERACT RNWEL) NOT NWi 
   OD_CONVEX_CORNER = INT [NACTx] < GRID ABUT == 90 INTERSECTING ONLY 
   NW_CONCAVE_CORNER = EXT [NWi] < (NW_S_6_1-NW_S_6+GRID) ABUT == 90 INTERSECTING ONLY 
   X1 = ANGLE  OD_CONVEX_CORNER == 0
   X2 = ANGLE  NW_CONCAVE_CORNER == 0
   A = EXT [X1] X2 < NW_S_6_1 OPPOSITE EXTENDED NW_S_6
   X3 = ANGLE  OD_CONVEX_CORNER == 90
   X4 = ANGLE  NW_CONCAVE_CORNER == 90
   B = EXT [X3] X4 < NW_S_6_1 OPPOSITE EXTENDED NW_S_6  
   (INT A B < GRID ABUT == 90 INTERSECTING ONLY REGION) NOT INSIDE SRAM_REGION
}
NW.S.7 { @ Space to {N+ ACTIVE interact with OD2} >= 0.22 
  EXT NWi NACT2 < NW_S_7 ABUT < 90 SINGULAR REGION
}
NW.EN.1 { @ Enclosure of NW STRAP (except NW resistor) >= 0.08 
  A = NPOD NOT INSIDE SRAM_REGION
  ENC A NONWR < NW_EN_1 ABUT < 90 SINGULAR REGION
}
NW.EN.2 { @ Enclosure of P+ ACTIVE >= 0.08 
   A = PPOD NOT INSIDE SRAM_REGION
   ENC A NONWR < NW_EN_2 ABUT < 90 SINGULAR REGION
}
NW.EN.2.1 { @ Enclosure of P+ ACTIVE [at least one edge at each corner] >= 0.16 
   OD_CONVEX_CORNER = INT [PACT] < GRID ABUT == 90 INTERSECTING ONLY 
   NW_CONVEX_CORNER = INT [NONWR] < (NW_EN_2_1-NW_EN_2+GRID) ABUT == 90 INTERSECTING ONLY 
   X1 = ANGLE OD_CONVEX_CORNER == 0
   X2 = ANGLE NW_CONVEX_CORNER == 0
   A = ENC [X1] X2 < NW_EN_2_1 OPPOSITE EXTENDED NW_EN_2  
   X3 = ANGLE OD_CONVEX_CORNER == 90
   X4 = ANGLE NW_CONVEX_CORNER == 90
   B = ENC [X3] X4 < NW_EN_2_1 OPPOSITE EXTENDED NW_EN_2  
   INT A B < GRID ABUT == 90 INTERSECTING ONLY
}
NW.EN.3 { @ Enclosure of {P+ ACTIVE interact with OD2} >= 0.22 
  ENC PACT2 NWi < NW_EN_3 ABUT < 90 SINGULAR REGION
}
NW.A.1 { @ Area >= 0.64 
  AREA NWEL < NW_A_1
}
NW.A.2 { @ Enclosed area >= 0.64 
  A = HOLES NWEL INNER
  B = A NOT NWEL
  (AREA B < NW_A_2) NOT INSIDE SRAM_EXCLUDE
}


//NWROD CHECKS
//=============

NWROD.W.1 { @ Width >= 1.8 
  INT RNWEL < NWROD_W_1 ABUT < 90 SINGULAR REGION
}
NWROD.S.1 { @ Space between segments of NW resistor or NW resistor to other NW  ^NWROD_S_1 um
  EXT RNWEL < NWROD_S_1 ABUT < 90 NOTCH SINGULAR REGION
  EXT RNWEL NWEL < NWROD_S_1 ABUT < 90 SINGULAR REGION 
}  
NWROD.S.2 { @ Space to RPO >= 0.3 
  EXT NWRES RPO < NWROD_S_2 ABUT < 90 SINGULAR REGION
  (NWRES AND RPO) NOT INTERACT NWDMY
  A = RPO INSIDE EDGE NWRES
  EXT A < RPO_W_1 ABUT == 90 REGION INTERSECTING ONLY
}
NWROD.EN.1 { @ Enclosure by OD >= 1.0 
  ENC NWRES ODWR < NWROD_EN_1 ABUT < 90 SINGULAR REGION
  NWRES CUT ODWR
}
NWROD.EN.2 { @ Enclosure of CO >= 0.3 
  X = RHWR AND NWRES	// Terminal
  ENC COWR X < NWROD_EN_2 ABUT < 90 SINGULAR REGION
  COWR NOT X
}
NWROD.O.1 { @ RPO overlap of NP. Use exact value (0.4 um) on sides touching NWDMY. = 0.4 
  INT NPWR RPO < NWROD_O_1 ABUT < 90 SINGULAR REGION
  A = RHWR INSIDE EDGE NWEL
  B = EXPAND EDGE A OUTSIDE BY NWROD_O_1
  ((NPWR AND RPO) AND NWRES) NOT B
  RHWR NOT NPWR
}
NWROD.O.2 { @ {OD AND NWDMY} overlap of {NP, PP, VTH_N, VTH_P, VTL_N, or VTL_P} (all implant layers except NW) is not allowed.   
  A = OD AND NWDMY
  A AND NP
  A AND PP
  A AND VTHN
  A AND VTHP
  A AND VTLN
  A AND VTLP
}
NWROD.R.4 { @ Only one NW inside NWROD is allowed in one OD
  A = OD INTERACT (RNWEL AND OD) > 1
  RNWEL INTERACT A
}
NWROD.R.5 { @ Only two NPs in NWROD is allowed in one OD
  A = OD INTERACT NWRES
  B = NP INTERACT NWRES    
  C = A NOT INTERACT B == 2
  NP INTERACT C
}
NWROD.R.6 { @ Only two RPO holes(Salicide) NWROD are allowed in same OD 
  A = OD INTERACT RNWEL
  B = HOLES RPO INNER
  C = A NOT INTERACT B == 2
  RPO INTERACT C
}
NWROD.R.7 { @ For U-shape or S-shape NWROD, both OD and NW must be U-shape or S-shape and the OD edge must be parallel to NW edge. DRC can only flag the pattern without OD space while 2 edges of NW [NW space or notch <= 5 um] parallel length > 0 um
  ((EXT RNWEL <= 5 NOTCH OPPOSITE REGION) NOT RNWEL) INSIDE OD
}

//NWRSTI CHECKS
//=============

//NWRSTI.W.1 is checked by NWROD.W.1
//NWRSTI.S.1 is checked by NWROD.S.1

NWRSTI.EN.1 { @ NP enclosure of OD >= 0.4 
  ENC ODWR_STI NPWR_STI < NWRSTI_EN_1 ABUT < 90 SINGULAR REGION
  ODWR_STI NOT NPWR_STI
}
NWRSTI.EN.2 { @ OD enclosure of CO >= 0.3 
  X = ODWR_STI AND NWRES_STI	// Terminal
  ENC COWR_STI X < NWRSTI_EN_2 ABUT < 90 SINGULAR REGION
  COWR_STI NOT X
}

// NWRSTI.EN.3 is checked by NWRSTI.EN.2

NWRSTI.EX.1 { @ OD extension on NWRSTI >= 0.3 
  ENC NWRES_STI ODWR_STI < NWRSTI_EX_1 ABUT < 90 SINGULAR REGION
  A = ODWR_STI INSIDE EDGE NWRES_STI
  INT A < OD_W_1 ABUT == 90 REGION INTERSECTING ONLY
  ANGLE A == 45
  (NWRES_STI NOT NWDMY) NOT OD
}
NWRSTI.O.1 { @ {NP interact with NWDMY} overlap of {PP, VTH_P, or VTL_P} (all p-type implant layers) is not allowed   
  A = NP INTERACT NWDMY
  A AND PP
  A AND VTHP
  A AND VTLP
}



//NT_N RULES CHECK
//================
 
NTN_OD      = NTN AND OD
NTN_PO      = NTN AND POLY
NTN_GATE_W  = NTN_PO INSIDE EDGE NTN_OD
NTN_2533V_GATE_W = NTN_GATE_W INSIDE EDGE (((OD25 OR OD33) NOT OD2533) NOT OD2518)
NTN_18V_GATE_W   = NTN_GATE_W INSIDE EDGE OD18

NT_N.W.1 { @ Width >= 0.34 
  INT NTN < NTN_W_1 ABUT < 90 SINGULAR REGION
}
NT_N.W.2 { @ Channel length of 0.9V/1.1V/1.2V native device >= 0.30 
  (INT NTN_GATE_W < NTN_W_2 ABUT < 90 REGION) NOT INSIDE VTLN18
}

NT_N.W.3 { @ Channel length of 2.5V/3.3V native device (for 2.5V overdrive to 3.3V, please refer to section OD25_33 Layout Rules) >= 1.20 
  INT NTN_2533V_GATE_W < NTN_W_3 ABUT < 90 REGION
}
NT_N.W.4 { @ Channel length of 1.8V native device (for 2.5V underdrive to 1.8V, please refer to section OD25_18 Layout Rules) >= 0.8 
  (INT NTN_18V_GATE_W < NTN_W_4 ABUT < 90 REGION) NOT INSIDE VTLN18
}
NT_N.W.5 { @ Channel width >= 0.5 
  (LENGTH NTN_GATE_W < NTN_W_5) NOT INSIDE EDGE VTLN18
} 
NT_N.S.1 { @ Space >= 0.34 
  EXT NTN < NTN_S_1 ABUT < 90 SINGULAR REGION
}

//NTN_exc_ind = NTN NOT INDDMY
NTN_exc_ind = COPY NTN

NT_N.S.2 { @ Space to [Active outside NT_N] >= 0.38 
  A = DACT OUTSIDE NTN
  EXT NTN_exc_ind A < NTN_S_2 ABUT < 90 SINGULAR REGION
}
NT_N.S.3 { @ Space to NW >= 1 
  EXT NTN NWi < NTN_S_3 ABUT < 90 SINGULAR REGION
}
NT_N.EN.1 { @ Enclosure range of N+OD. = 0.26 
  A = NTN_exc_ind INTERACT NPOD
  B = NPOD INTERACT NTN_exc_ind
  (ENC B A < NTN_EN_1 ABUT < 90 SINGULAR REGION) NOT INSIDE VTLN18
  (B CUT A) NOT INSIDE VTLN18
  (A NOT (SIZE B BY NTN_EN_1)) NOT INSIDE VTLN18
}
NT_N.EX.1 { @ PO extension on {OD inside NT_N} (PO endcap) >= 0.35 
  A = DACT INSIDE NTN
  ENC A POLY < NTN_EX_1 ABUT < 90 SINGULAR REGION
}
NT_N.A.1 { @ Area >= ^NTN_A_1 um2
  (AREA NTNs < NTN_A_1) NOT INSIDE SRAM_EXCLUDE
}
NT_N.A.2 { @ Enclosed area >= ^NTN_A_2 um2
  A = HOLES NTN INNER
  B = A NOT NTN
  AREA B < NTN_A_2
}

NT_N.R.1 { @ Overlap of {NW OR DNW} is not allowed   
  NTN AND DNW
  NTN AND NWEL
}
NT_N.R.3 { @ Only one OD region is allowed in NT_N l Except NMOS capacitor with same potential, pickup and MOMDMY (155;21) region. l You have to draw a NCap_NTN layer to cover the NMOS capacitors. The NCap_NTN enclosure of OD have to be >= 0um. All the source and drain must be connected together. l DRC also flags NCap_NTN and OD outside of the NCap_NTN in the same NT_N.   
  A = NTN_exc_ind CUT DACT > 1
  A NOT INTERACT (NCapNTN OR MOMDMY)
  B = A INTERACT NCapNTN
  C = OD INTERACT B
  C NOT NCapNTN  // Mixture of NMOS cap and normal device is not allowed
  NCapNTN NOT NTN // NCapNTN must be fully inside NTN 
  A INTERACT NSDc > 1 BY NET // all source and drain of all Nmos caps in the same NT_N must be connected together
}

NT_N.R.2 { @ P+ACTIVE region is not allowed in NT_N but PW STRAP is allowed. DRC only can check P+ Gate is not allowed in NT_N.   
  GATE_PP AND NTN 
}


//DNW CHECKS
//==========

DNW.W.1 { @ Width >= 3 
  (INT DNW < DNW_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
DNW.S.1 { @ Space >= 3.5 
  (EXT DNW < DNW_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
DNW.S.2 { @ Space to NW with different potential >= 2.5 
  NW_CHK = NWEL NOT TCDDMY  
  (EXT DNW NW_CHK < DNW_S_2 ABUT < 90 NOT CONNECTED SINGULAR REGION MEASURE ALL) NOT INSIDE SRAM_EXCLUDE
}
DNW.S.3 { @ Space to {N+ACTIVE outside DNW} >= 1.65 
  A = NACT OUTSIDE DNW
  EXT DNW A < DNW_S_3 ABUT < 90 SINGULAR REGION
}

RW   = PWEL INSIDE DNW
RW1V = RW OUTSIDE OD2
RW2V = RW NOT OUTSIDE OD2
RW1V_NODAL = STAMP RW1V BY RWi
RW2V_NODAL = STAMP RW2V BY RWi
PWELx = PWEL NOT INSIDE DNW
PWEL_NODAL = STAMP PWELx BY PWELi

DNW.S.4 { @ RW space to {RW OR PW} with different potential >= 0.8 
  (EXT RW1V_NODAL < DNW_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
  (EXT RW1V_NODAL PWEL_NODAL < DNW_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
DNW.S.5 { @ {RW OR PW} space to {RW interact with OD2} with different potential >= 1.0 
  (EXT RW2V_NODAL < DNW_S_5 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
  (EXT RW2V_NODAL RW1V_NODAL < DNW_S_5 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
  (EXT RW2V_NODAL PWEL_NODAL < DNW_S_5 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
DNW.EN.3 { @ Enclosure of N+ACTIVE >= 0.48 
  (ENC NACT DNW < DNW_EN_3 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
DNW.O.1 { @ Overlap of NW >= 0.4 
  (INT DNW NWEL < DNW_O_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}

// DNW.R.2 is not necessary to check
// DNW.R.3 is not necessary to check
// DNW.R.4 can not be checked by DRC

DNW.R.5 { @ DNW cut N+ACTIVE is not allowed   
    NACT CUT DNW
}


//OD CHECKS
//=========
OD.W.1 { @ Width >= ^OD_W_1
  (INT OD_NSF < OD_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
}

ODW2_NOTCHECK = SRAM_REGION OR RAM1TDMY

OD.W.2 { @ Channel width of core device >= 0.12 
   LV_GATE_W_C = LV_GATE_W NOT INSIDE EDGE ODW2_NOTCHECK
   LENGTH LV_GATE_W_C < OD_W_2
}

ODW2x_NOTCHECK = (((LOGO OR VAR) OR NTN) OR TCDDMY) OR SRESD
#IFDEF GS
ODW21_LV_GATE_W_C =  (LV_GATE_W NOT INSIDE EDGE ODW2x_NOTCHECK) INSIDE EDGE NP
#ELSE
ODW21_LV_GATE_W_C =  ((LV_GATE_W NOT INSIDE EDGE ODW2x_NOTCHECK) INSIDE EDGE NP) INSIDE EDGE DCO
#ENDIF
OD.W.2.1 { @ Maximum channel width of core NMOS device for GS and LPG G device <= 10 (This rule doesn't include the NT_N, SR_ESD, VAR)
  LENGTH ODW21_LV_GATE_W_C > OD_W_2_1
}
#IFDEF GS
OD.W.2.2 { @ Maximum channel width for core PMOS device for GS <= 1.5 (This rule doesn't include the NT_N, SR_ESD, VAR)
  LV_GATE_W_C = (LV_GATE_W NOT INSIDE EDGE (ODW2x_NOTCHECK OR ICOVL)) INSIDE EDGE PP
  LENGTH LV_GATE_W_C > OD_W_2_2
}
#ENDIF

OD.W.3 { @ Channel width of MOS [for I/O device] >= ^OD_W_3
  LENGTH HV_GATE_W < OD_W_3
}

OD_EDGE_45 = OD ANGLE == 45

OD.W.4 { @ Min. width of 45 degree bent OD ^OD_W_4 um
  INT OD_EDGE_45 < OD_W_4 ABUT < 90 REGION
}

OD.S.1 { @ Space >= ^OD_S_1
  (EXT OD_NSF < OD_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION 
}

HV_OD_E = OD INSIDE EDGE OD2
OD.S.2 { @ Space (inside OD2) >= ^OD_S_2 um	
  EXT HV_OD_E < OD_S_2 ABUT < 90 REGION
}

Wide_OD_0.12 = OD WITH WIDTH > OD_S_3_W 

OD.S.3 { @ Space to OD [width > 0.12 um] if the parallel length >= 0.14 um (P) >= 0.10 
  OD_SPACE = (EXT Wide_OD_0.12 OD < OD_S_3 OPPOSITE REGION MEASURE ALL) NOT WITH EDGE GATE_L
  (ENCLOSE RECTANGLE OD_SPACE OD_S_1 OD_S_3_L) NOT INSIDE SRAM_REGION    
} 
OD.S.3.1 { @ Space to OD [width > 0.12 um] if the parallel length >= 0.14 um (P1) in PO gate direction >= 0.11 
  OD_SPACE = (EXT Wide_OD_0.12 OD < OD_S_3_1 OPPOSITE REGION MEASURE ALL) WITH EDGE GATE_L
  (ENCLOSE RECTANGLE OD_SPACE OD_S_1 OD_S_3_1_L) NOT INSIDE SRAM_REGION   
}

OD.S.4 { @ Space to 45-degree bent OD >= 0.17 
  X = EXPAND EDGE OD_EDGE_45 OUTSIDE BY OD_S_4
  X AND OD
}  
OD.S.5 { @ Space between two segments of a U-shape or an O-shape OD (notch only) >= 0.15 
  CONVEX EDGE OD ANGLE1 == 270 ANGLE2 == 270 WITH LENGTH < OD_S_5
}
OD.A.1 { @ Area (This check doesn't include the patterns filling 0.06 um x 0.26 um rectangular tile) >= 0.035 
  A = AREA ((ODs NOT INSIDE SRAM_REGION) NOT OD_DMY) < OD_A_1
  NOT ENCLOSE RECTANGLE A OD_A_1_W OD_A_1_L ORTHOGONAL ONLY
}
OD.A.2 { @ Area [with all of edge length < 0.21 um] >= 0.055 
  A = AREA (ODs NOT INSIDE SRAM_REGION) < OD_A_2
  B = LENGTH A >= OD_A_2_L
  A NOT WITH EDGE B
}
OD.A.3 { @ Enclosed area >= 0.04 
  A = HOLES ODs INNER
  B = A NOT ODi
  (AREA B < OD_A_3) NOT INSIDE SRAM_EXCLUDE
}
OD.A.4 { @ Enclosed area [with all of inner edge length < 0.21 um] >= 0.077 
  A = HOLES ODs INNER
  B = A NOT ODi
  C = LENGTH B >= OD_A_4_L
  D = B NOT WITH EDGE C
  (AREA D < OD_A_4) NOT INSIDE SRAM_EXCLUDE
}

#IFDEF GS
CORE_PACT = PACTi NOT OD2
ODRX = (SIZE ((SIZE GATEi BY OD_A_5_S1-OD_A_5_S2) AND CORE_PACT) BY OD_A_5_S2) AND CORE_PACT
CONNECT ODRX
OD.A.5 { @ Maximum ACTIVE area sum of ((checking Area INTERACT PO) NOT (PO OR SR_DPO)) in same checking Area <= 300. Checking area is defined by size 0.22um in S/D direction and 0.08um in endcap direction from gate
   A = (ODRX INTERACT POi) NOT (POi OR SRDPO) 
   Ac = STAMP A BY ODRX    
   NET AREA RATIO ODRX Ac > OD_A_5 [AREA(Ac)] RDB OD.A.5.rep
}
#ENDIF

OD.L.1 { @ Length of active with width < ^OD_L_1_W um, connected to butted strap <= ^OD_L_1 um
  BUTTED_EDGE = LENGTH NP_PP_BTE < OD_L_1_W
  CHECK_SD = SD WITH EDGE BUTTED_EDGE
  NARROW_SD = INT (CHECK_SD COIN INSIDE EDGE OD) < OD_L_1_W ABUT < 90 OPPOSITE REGION 
  CHECK_OD = (NARROW_SD WITH EDGE BUTTED_EDGE) OR (NARROW_SD WITH EDGE GATE_W)
  PATH LENGTH (OD COIN INSIDE EDGE CHECK_OD) > OD_L_1
} 
OD.L.2 { @ Max. OD length between 2 CO or CO to OD line end when OD width <= ^OD_L_2_W um  ^OD_L_2 um
  OD_CHECK = (INOD NOT RFIP) NOT (SIZE MOMDMY BY 1.2)
  LONGP = AREA OD_CHECK > OD_W_1 * OD_L_2	
  X = LONGP INTERACT COOD
  CHECK_COOD = COOD INTERACT X
  A = SIZE CHECK_COOD BY OD_L_2 / 2 INSIDE OF X STEP OD_S_1*0.7
  LINEN = X INTERACT A == 1
  P2P = X INTERACT A > 1
  B = A INTERACT LINEN
  C = SIZE B BY OD_L_2 / 2 INSIDE OF LINEN STEP OD_S_1*0.7
  BAD = (LINEN NOT C) OR (P2P NOT A)
  BAD_EDGE = BAD COIN INSIDE EDGE OD
  ERR = INT BAD_EDGE < OD_L_2_W ABUT < 90 REGION
  X INTERACT ERR
}


OD.R.1 { @ OD must be fully covered by {NP OR PP} except for {(DOD OR SR_DOD) OR NWDMY}   
  ((OD NOT INTERACT NWRES) NOT LOGO) NOT IMP
}






//DUMMY OD RULE
//================

DOD.W.1 { @ Width >= 0.5 
  INT DOD < DOD_W_1 ABUT < 90 SINGULAR REGION
}
DOD.S.1 { @ Space >= 0.4 
  EXT DOD < DOD_S_1 ABUT < 90 SINGULAR REGION
}
DOD.S.2 { @ Space to OD (Overlap is not allowed) >= 0.34 
  EXT ODi DOD < DOD_S_2 ABUT < 90 SINGULAR REGION INSIDE ALSO
}
DOD.S.3 { @ Space to PO (Overlap is not allowed) >= 0.3 
  EXT POi DOD < DOD_S_3 ABUT < 90 SINGULAR REGION INSIDE ALSO
}
DOD.S.5 { @ Space to NW >= 0.3 
  EXT NWi DOD < DOD_S_5 ABUT < 90 SINGULAR REGION 
}
DOD.S.8 { @ Space to NWDMY (Overlap is not allowed) >= 0.6 
  EXT NWDMY DOD < DOD_S_8 ABUT < 90 SINGULAR REGION 
  NWDMY AND DOD
}
DOD.S.10 { @ Space to INDDMY (Overlap is not allowed) >= 1.2 
  EXT INDDMY DOD < DOD_S_10 ABUT < 90 SINGULAR REGION 
  INDDMY AND DOD
}
DOD.EN.1 { @ Enclosure by NW >= 0.3 
  ENC DOD NWi < DOD_EN_1 ABUT < 90 SINGULAR REGION
  DOD CUT NWi
}

#IFDEF FULL_CHIP
DOD.EN.2 { @ Enclosure by chip edge >= 0.6 
  DOD NOT (SIZE CHIP_EDGE BY -DOD_EN_2)
}

DOD.R.1 { @ DOD is must. DOD must be an individual CAD layer (datatype 1 as default, like 6;1)
  CHIPx NOT INTERACT DOD
}
#ENDIF

// DOD.R.2 is checked by CSR.R.1.DOD

DOD.R.3 { @ Only square (or rectangular) and solid shapes are allowed. A 45-degree shape is not allowed.   
  NOT RECTANGLE DOD ORTHOGONAL ONLY
}

#IFDEF FULL_CHIP

OD.DN.1 { @ {OD OR DOD} density across full chip >= 25%
  DENSITY ALL_OD CHIP < OD_DN_1 INSIDE OF LAYER CHIPx [ AREA(ALL_OD)/AREA(CHIP) ] PRINT OD.DN.1.density
}
OD.DN.1.1 { @ {OD OR DOD} density across full chip <= 75%
  DENSITY ALL_OD CHIP > OD_DN_1_1 INSIDE OF LAYER CHIPx [ AREA(ALL_OD)/AREA(CHIP) ] PRINT OD.DN.1.1.density
}

#ENDIF

OD_EXC = NWDMY OR DEN_EXC_LOW
ODx = ALL_OD NOT OD_EXC
CHIP_NOT_ODEXC = CHIP NOT OD_EXC

#IFDEF CHECK_LOW_DENSITY
OD.DN.2 { @ Min. OD density over window 150 step 75 >= 20% 
  ERR_WIN = DENSITY ODx CHIP_NOT_ODEXC < OD_DN_2 WINDOW OD_DN_2_W STEP OD_DN_2_S INSIDE OF LAYER CHIPx BACKUP
          [ AREA(ODx)/AREA(CHIP_NOT_ODEXC) ]
  F = WITH WIDTH (ERR_WIN NOT OD_EXC) >= OD_DN_2_E
  DENSITY F ODx CHIP_NOT_ODEXC < OD_DN_2 WINDOW OD_DN_2_W STEP OD_DN_2_S INSIDE OF LAYER CHIPx BACKUP PRINT OD.DN.2.density
          [ !AREA(F)+AREA(ODx)/AREA(CHIP_NOT_ODEXC) ]
}
#ENDIF

OD.DN.2.2 { @ Max. OD density over window 150 step 75 <= 90% 
  ERR_WIN = DENSITY ODx CHIP_NOT_ODEXC > OD_DN_2_2 WINDOW OD_DN_2_2_W STEP OD_DN_2_2_S INSIDE OF LAYER CHIPx BACKUP
          [ AREA(ODx)/AREA(CHIP_NOT_ODEXC) ]
  F = WITH WIDTH (ERR_WIN NOT OD_EXC) >= OD_DN_2_2_E
  DENSITY F ODx CHIP_NOT_ODEXC > OD_DN_2_2 WINDOW OD_DN_2_2_W STEP OD_DN_2_2_S INSIDE OF LAYER CHIPx BACKUP PRINT OD.DN.2.2.density
  [ !!AREA(F)*AREA(ODx)/AREA(CHIP_NOT_ODEXC) ]
}

ODx_MAX_CORE = ODx NOT OD2
CHIP_MAX_CORE = CHIP_NOT_ODEXC NOT OD2

OD.DN.2.1 { @ Max. OD density over window 150 step 75 <= 80% in core 
  ERR_WIN = DENSITY ODx_MAX_CORE CHIP_MAX_CORE > OD_DN_2_1 WINDOW OD_DN_2_1_W STEP OD_DN_2_1_S INSIDE OF LAYER CHIPx BACKUP
           [ AREA(ODx_MAX_CORE)/AREA(CHIP_MAX_CORE) ]
  F = WITH WIDTH ((ERR_WIN NOT OD2) NOT OD_EXC) >= OD_DN_2_1_E 
  DENSITY F ODx_MAX_CORE CHIP_MAX_CORE > OD_DN_2_1 WINDOW OD_DN_2_1_W STEP OD_DN_2_1_S INSIDE OF LAYER CHIPx BACKUP PRINT OD.DN.2.1.density
  [!!AREA(F)*AREA(ODx_MAX_CORE)/AREA(CHIP_MAX_CORE) ]
}

CHIP_ODBLK = CHIP_NOT_ODEXC AND ODBLK
OD_ODBLK = ODx AND ODBLK
CHIP_ODBLKx = COPY CHIP_ODBLK

OD.DN.3 { @ Min. OD density over window 150 step 75 >= 20% (within ODBLK)
    ERR_WIN1 = DENSITY OD_ODBLK CHIP_ODBLK < OD_DN_3 WINDOW OD_DN_3_W STEP OD_DN_3_S INSIDE OF LAYER CHIP_ODBLKx BACKUP PRINT OD.DN.3.density [AREA(OD_ODBLK)/AREA(CHIP_ODBLK)]
    ERR_WIN2 = DENSITY ODx CHIP_NOT_ODEXC < OD_DN_3 WINDOW OD_DN_3_W STEP OD_DN_3_S BACKUP INSIDE OF LAYER CHIP [ AREA(ODx)/AREA(CHIP_NOT_ODEXC) ]
    ERR_WIN = ERR_WIN1 NOT OUTSIDE ERR_WIN2
    ((ERR_WIN AND ODBLK) NOT OD_EXC) WITH WIDTH >= OD_DN_3_E
    
}

OD.DN.3.2 { @ Max. OD density over window 150 step 75 <= 90% (within ODBLK)
   ERR_WIN1 = DENSITY OD_ODBLK CHIP_ODBLK > OD_DN_3_2 WINDOW OD_DN_3_2_W STEP OD_DN_3_2_S INSIDE OF LAYER CHIP_ODBLKx BACKUP PRINT OD.DN.3.2.density [AREA(OD_ODBLK)/AREA(CHIP_ODBLK)]
   ERR_WIN2 = DENSITY ODx CHIP_NOT_ODEXC > OD_DN_3_2 WINDOW OD_DN_3_2_W STEP OD_DN_3_2_S BACKUP INSIDE OF LAYER CHIP [ AREA(ODx)/AREA(CHIP_NOT_ODEXC) ]
   ERR_WIN = ERR_WIN1 NOT OUTSIDE ERR_WIN2
   ((ERR_WIN AND ODBLK) NOT OD_EXC) WITH WIDTH >= OD_DN_3_2_E
}

ODx_MAX_CORE_ODBLK = OD_ODBLK NOT OD2
CHIP_MAX_CORE_ODBLK = CHIP_ODBLK NOT OD2

OD.DN.3.1 { @ Max. OD density over window 150 step 75 <= 80% in core (within ODBLK)
   ERR_WIN1 = DENSITY ODx_MAX_CORE_ODBLK > OD_DN_3_1 WINDOW OD_DN_3_1_W STEP OD_DN_3_1_S INSIDE OF LAYER CHIP_MAX_CORE_ODBLK BACKUP PRINT OD.DN.3.1.density 
   ERR_WIN2 = DENSITY ODx_MAX_CORE CHIP_MAX_CORE > OD_DN_3_1 WINDOW OD_DN_3_1_W STEP OD_DN_3_1_S BACKUP INSIDE OF LAYER CHIP [ AREA(ODx_MAX_CORE)/AREA(CHIP_MAX_CORE) ]
   ERR_WIN = ERR_WIN1 NOT OUTSIDE ERR_WIN2
   (((ERR_WIN NOT OD2) AND ODBLK) NOT OD_EXC) WITH WIDTH >= OD_DN_3_1_E
}




//SR_DOD CHECKS
//=============

SR_DOD.W.1 { @ Width >= 0.1 
  INT SRDOD < SRDOD_W_1 ABUT < 90 SINGULAR REGION
}
SR_DOD.W.2 { @ Maximum width <= 0.5 
  A = INT SRDOD <= SRDOD_W_2 ABUT < 90 REGION
  SRDOD NOT A
}
SR_DOD.S.1 { @ Space >= 0.12 
  EXT SRDOD < SRDOD_S_1 ABUT < 90 SINGULAR REGION
}
SR_DOD.S.1.1 { @ Space to OD, DOD (Overlap is not allowed) >= 0.12 
  EXT SRDOD ODi < SRDOD_S_1_1 ABUT < 90 SINGULAR REGION INSIDE ALSO
  EXT SRDOD DOD < SRDOD_S_1_1 ABUT < 90 SINGULAR REGION INSIDE ALSO
}
SR_DOD.S.2 { @ Space to PO (Overlap is not allowed) >= 0.05 
  EXT SRDOD POi < SRDOD_S_2 ABUT < 90 SINGULAR REGION INSIDE ALSO
}
SR_DOD.S.3 { @ Space to DPO, SR_DPO (Overlap is not allowed) >= 0.03 
  EXT SRDOD DPO < SRDOD_S_3 ABUT < 90 SINGULAR REGION INSIDE ALSO
  EXT SRDOD SRDPO < SRDOD_S_3 ABUT < 90 SINGULAR REGION INSIDE ALSO
}
SR_DOD.S.4 { @ Space to 45-degree bent OD >= 0.17 
  X = EXPAND EDGE OD_EDGE_45 OUTSIDE BY SRDOD_S_4
  X AND SRDOD
}
SR_DOD.S.7 { @ Space to NW (for both core and I/O) >= 0.08 
  EXT SRDOD NWi < SRDOD_S_7 ABUT < 90 SINGULAR REGION
}
SR_DOD.S.8 { @ Space to NWDMY (Overlap is not allowed) >= 0.6 
  EXT SRDOD NWDMY < SRDOD_S_8 ABUT < 90 SINGULAR REGION INSIDE ALSO
}
SR_DOD.S.9 { @ Space to LOGO (Overlap is not allowed) >= 0 
  SRDOD AND LOGO
}
SR_DOD.S.10 { @ Space to INDDMY (Overlap is not allowed) >= 1.2 
  EXT SRDOD INDDMY < SRDOD_S_10 ABUT < 90 SINGULAR REGION INSIDE ALSO
}
SR_DOD.S.11 { @ Space to NT_N (Overlap is not allowed) >= 0.14 
  EXT SRDOD NTNi < SRDOD_S_11 ABUT < 90 SINGULAR REGION INSIDE ALSO
}
SR_DOD.EN.1 { @ NW enclosure of SR_DOD (for both core and I/O) >= 0.08 
  ENC SRDOD NWi < SRDOD_EN_1 ABUT < 90 SINGULAR REGION
  SRDOD CUT NWi
}
#IFDEF FULL_CHIP
SR_DOD.EN.2 { @ Enclosure by chip edge >= 0.6 
  SRDOD NOT (SIZE CHIP_EDGE BY -SRDOD_EN_2)
}
#ENDIF

SR_DOD.A.1 { @ Area >= 0.05 
  AREA SRDOD < SRDOD_A_1
}    

SR_DOD.L.1 { @ Length >= 0.5 
  NOT ENCLOSE RECTANGLE SRDOD SRDOD_L_1 GRID ORTHOGONAL ONLY
}
SR_DOD.L.2 { @ Maximum length <= 10 
  ENCLOSE RECTANGLE SRDOD SRDOD_L_2+GRID GRID ORTHOGONAL ONLY
}

SR_DOD.R.1 { @ 45-degree bent SR_DOD is not allowed   
  SRDOD ANGLE == 45
}
SR_DOD.R.2 { @ Overlap of CO is not allowed.   
  SRDOD AND CO
}
SR_DOD.R.3 { @ Only rectangle is allowed   
  NOT RECTANGLE SRDOD
}



//THICK OXIDE CHECKS
//==================

OD2.W.1 { @ Width >= 0.34 
  INT OD18 < OD2_W_1 ABUT < 90 SINGULAR REGION
  INT OD25 < OD2_W_1 ABUT < 90 SINGULAR REGION
  INT OD33 < OD2_W_1 ABUT < 90 SINGULAR REGION
} 
OD2.W.2 { @ Width of {OD2 OR {NW OR NT_N}} >= 0.34 
  Y = OD2i OR NTNi
  X = NWi OR Y
  A = (INT X < OD2_W_2 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
  (A OUTSIDE SRAM_REGION) INTERACT Y 
  B = A CUT SRAM_REGION
  C = (X INTERACT B) NOT SRAM_REGION
  D = INT C < OD2_W_2 ABUT < 90 SINGULAR REGION 
  (B INTERACT D) INTERACT Y 
}

OD2.S.1 { @ Space >= 0.34 
  EXT OD2 < OD2_S_1 ABUT < 90 SINGULAR REGION
}
OD2.S.2 { @ Space to {ACTIVE OR GATE}(OD2 cut {ACTIVE OR GATE} is not allowed) >= 0.2 
  DACTG = DACT OR GATE  
  EXT OD2 DACTG < OD2_S_2 ABUT < 90 SINGULAR REGION
  DACTG CUT OD2
}
OD2.S.3 { @ Space to 0.9V/1.2V GATE in S/D direction. >= 0.25 
  A = OD2 INSIDE EDGE OD  
  EXT A GATE_W < OD2_S_3 ABUT < 90 REGION
  GATE CUT OD2
  B = LV_GATE_W INSIDE EDGE VAR
  EXT B OD2 < OD2_S_3 ABUT < 90 OPPOSITE REGION
}
OD2.S.4 { @ Space to NW. Space = 0 um is allowed. >= 0.34 
  EXT OD18 NWEL < OD2_S_4 ABUT < 90 > 0 SINGULAR REGION
  EXT OD25 NWEL < OD2_S_4 ABUT < 90 > 0 SINGULAR REGION
  EXT OD33 NWEL < OD2_S_4 ABUT < 90 > 0 SINGULAR REGION
}
OD2.S.5 { @ Space of {NW NOT OD2} >= 0.34 
  X = NWi NOT OD2i
  (EXT X < OD2_S_5 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
OD2.S.6 { @ Space of {NW AND OD2} >= 0.34 
  X = NWi AND OD2i
  (EXT X < OD2_S_6 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
OD2.S.7 { @ Space of {OD2 NOT {NW OR NT_N}} >= 0.34 
  X = OD2i NOT (NWi OR NTNi)	
  (EXT X < OD2_S_7 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
OD2.EN.1 { @ Enclosure of 1.8V or 2.5V or 3.3V Gate in S/D direction. >= 0.25 
  ENC GATE_W OD18 < OD2_EN_1 ABUT < 90 OPPOSITE REGION
  ENC GATE_W OD25 < OD2_EN_1 ABUT < 90 OPPOSITE REGION    
  ENC GATE_W OD33 < OD2_EN_1 ABUT < 90 OPPOSITE REGION
}
OD2.EX.1 { @ NW extension on OD2. Extension = 0 um is allowed. >= 0.34 
  ENC OD18 NWEL < OD2_EX_1 ABUT < 90 > 0 SINGULAR REGION
  ENC OD25 NWEL < OD2_EX_1 ABUT < 90 > 0 SINGULAR REGION
  ENC OD33 NWEL < OD2_EX_1 ABUT < 90 > 0 SINGULAR REGION
}
OD2.EX.2 { @ Extension on NW. Extension = 0 um is allowed. >= 0.34 
  ENC NWEL OD18 < OD2_EX_2 ABUT < 90 > 0 SINGULAR REGION
  ENC NWEL OD25 < OD2_EX_2 ABUT < 90 > 0 SINGULAR REGION
  ENC NWEL OD33 < OD2_EX_2 ABUT < 90 > 0 SINGULAR REGION
}
OD2.EX.3 { @ Extension on {ACTIVE OR GATE} >= 0.2 
   DACTG = DACT OR GATE  
   CHECK_EDGE = ENC [DACTG] OD2 < OD2_EX_3 ABUT < 90 SINGULAR
   CHECK_EDGE NOT COIN OUTSIDE EDGE DSTP
}
OD2.O.1 { @ Overlap of NW. Overlap = 0 um is allowed. >= 0.34 
  X = OD18 AND NWEL
  INT X < OD2_O_1 ABUT < 89.5 SINGULAR REGION
  Y = OD25 AND NWEL
  INT Y < OD2_O_1 ABUT < 89.5 SINGULAR REGION
  Z = OD33 AND NWEL
  INT Z < OD2_O_1 ABUT < 89.5 SINGULAR REGION
}
OD2.R.1 { @ OD_18, OD_25, and OD_33 cannot be used on same die.   
  X = CHIP INTERACT OD25
  X INTERACT OD18
  X INTERACT OD33
  Y = CHIP INTERACT OD33
  Y INTERACT OD18
}



//DCO CHECKS
//==========

DCO.W.1 { @ Width >= 0.34 
  (INT DCOs < DCO_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
DCO.W.2 { @ Width of {DCO OR NW} >= 0.34 
  X = NWEL OR DCOs
  A = (INT X < OD2_W_2 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
  (A OUTSIDE SRAM_EXCLUDE) INTERACT DCOs
  B = A CUT SRAM_EXCLUDE
  C = (X INTERACT B) NOT SRAM_EXCLUDE
  D = INT C < OD2_W_2 ABUT < 90 SINGULAR REGION 
  (B INTERACT D) INTERACT DCOs
}
DCO.S.1 { @ Space >= 0.34 
  (EXT DCOs < DCO_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
DCO.S.2 { @ Space to ACTIVE >= 0.05 
  EXT DCO DACT < DCO_S_2 ABUT < 90 SINGULAR REGION
}
DCO.S.3__DCO.S.4 { @ Space to LP(core 1.1V) gate in S/D direction >= ^DCO_S_3 
            @ Space to LP(core 1.1V) gate in end-cap direction >= ^DCO_S_4             
  A = GATE NOT INTERACT DCO
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (DCO_S_3 - DCO_S_4 )) OR A
  C = SIZE B BY DCO_S_4
  C AND DCO
}
DCO.S.5 { @ Space to NW. Space = 0 is allowed. >= 0.34 
  EXT DCO NWEL < DCO_S_5 ABUT < 90 > 0 SINGULAR REGION
}
DCO.S.6 { @ Space to OD2. Space = 0 is allowed. >= 0.34 
  EXT DCO OD2 < DCO_S_6 ABUT < 90 > 0 SINGULAR REGION
}
DCO.S.8 { @ Space of {DCO NOT NW} >= 0.34 
  (EXT (DCOs NOT NWEL) < DCO_S_8 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
}
DCO.S.9 { @ Space of {DCO AND NW} >= 0.34 
  (EXT (DCOs AND NWEL) < DCO_S_9 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
DCO.S.10 { @ Space of {NW NOT DCO} >= 0.34 
  (EXT (NWEL NOT DCOs) < DCO_S_10 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
DCO.EN.1__DCO.EN.2 { @ Enclosure of G(core 0.9V) gate in S/D direction >= ^DCO_EN_1 
             @ Enclosure of G(core 0.9V) gate in end-cap direction >= ^DCO_EN_2  
  A = GATE INTERACT DCO
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (DCO_EN_1 - DCO_EN_2 )) OR A
  C = SIZE B BY DCO_EN_2
  C NOT DCO
}
DCO.EX.1 { @ NW extension on DCO. Extension = 0 is allowed. >= 0.34 
  ENC DCO NWEL < DCO_EX_1 ABUT < 90 > 0 SINGULAR REGION
}
DCO.EX.2 { @ Extension on NW. Extension = 0 is allowed. >= 0.34 
  ENC NWEL DCO < DCO_EX_2 ABUT < 90 > 0 SINGULAR REGION
}
DCO.EX.3 { @ Extension on ACTIVE [Cut is not allowed if without Gate] >= 0.05 
  ENC DACT DCO < DCO_EX_3 ABUT < 90 SINGULAR REGION
  (DACT NOT INTERACT GATE) CUT DCO
}
DCO.A.1 { @ Area >= 0.7 
  (AREA DCOs < DCO_A_1) NOT INSIDE SRAM_EXCLUDE
}
DCO.A.2 { @ Enclosed area >= 0.7 
  A = HOLES DCOs INNER
  B = A NOT DCOs
  (AREA B < DCO_A_2) NOT INSIDE SRAM_EXCLUDE
}
DCO.O.1 { @ Overlap of NW. Overlap = 0 is allowed. >= 0.34 
  X = DCOs AND NWEL
  (INT X < DCO_O_1 ABUT < 89.5 SINGULAR REGION) NOT INSIDE SRAM_REGION
}
DCO.R.2 { @ Overlap of OD2 is not allowed   
  DCO AND OD2
}
DCO.R.3 { @ DCO cut RH is not allowed   
  RH CUT DCO
}


// waive one/two tracks overlap
OD12_OA1 = INT OD12s < OD12_W_1 ABUT < 90 REGION PROJ==0
OD12_OB1 = OD12s NOT (EXPAND EDGE OD12s INSIDE BY OD12_R_4/2)
OD12_OB2 = OD12s NOT (EXPAND EDGE OD12s INSIDE BY OD12_R_4)
OD12_OC1 = EXT OD12_OB1 < GRID SINGULAR INTERSECTING ONLY REGION
OD12_OC2 = EXT OD12_OB2 < GRID SINGULAR INTERSECTING ONLY REGION
OD12_O = OD12_OA1 ENCLOSE (OD12_OC1 OR OD12_OC2)
// waive one/two tracks space
OD12_SA1 = EXT OD12s < OD12_S_1 ABUT < 90 REGION PROJ==0
OD12_SB1 = OD12s OR (EXPAND EDGE OD12s OUTSIDE BY OD12_R_4/2)
OD12_SB2 = OD12s OR (EXPAND EDGE OD12s OUTSIDE BY OD12_R_4)
OD12_SC1 = EXT OD12_SB1 < GRID SINGULAR INTERSECTING ONLY REGION
OD12_SC2 = EXT OD12_SB2 < GRID SINGULAR INTERSECTING ONLY REGION
OD12_S = OD12_SA1 ENCLOSE (OD12_SC1 OR OD12_SC2)
// waive point touch
OD12_P = EXT OD12s < OD12_S_1 SINGULAR INTERSECTING ONLY REGION

OD_12.W.1 { @ Width >= 0.34 
  A = INT OD12s < OD12_W_1 ABUT < 90 REGION
  (A INTERACT (A NOT OD12_O)) NOT INSIDE SRAM_EXCLUDE
}
OD_12.W.3 { @ Channel length 0.07  
  OD12_GATE_W = GATE_W INSIDE EDGE OD12s
  (INT OD12_GATE_W < OD12_W_3 ABUT < 90 REGION) NOT INSIDE SRAM_EXCLUDE
}
OD_12.S.1 { @ Space >= 0.34 
  A = EXT OD12s < OD12_S_1 ABUT < 90 SINGULAR REGION
  (A INTERACT (A NOT (OD12_S OR OD12_P))) NOT INSIDE SRAM_EXCLUDE
}
OD_12.S.2 { @ Space to {ACTIVE OR GATE}C 0.05  
  DACTG = DACT OR GATE
  EXT OD12 DACTG < OD12_S_2 ABUT < 90 SINGULAR REGION
}
OD_12.S.3_4 { @ Space to core 0.9V gate in S/D direction >= ^OD12_S_3
              @ Space to core 0.9V gate in end-cap direction >= ^OD12_S_4
  A = GATE NOT INTERACT OD12
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (OD12_S_3 - OD12_S_4 )) OR A
  C = SIZE B BY OD12_S_4
  C AND OD12
}
// OD_12.S.3 and OD_12.S.4 are checked by OD_12.S.3_4

OD_12.S.6 { @ Space to OD2. Space = 0 um is allowed. >= 0.18 
  EXT OD12 OD2 < OD12_S_6 ABUT < 90 > 0 SINGULAR REGION
}
OD_12.EN.1_2 { @ Enclosure of core 1.2V gate in S/D direction >= ^OD12_EN_1
               @ Enclosure of core 1.2V gate in end-cap direction >= ^OD12_EN_2
  A = GATE INTERACT OD12
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (OD12_EN_1 - OD12_EN_2 )) OR A
  C = SIZE B BY OD12_EN_2
  C NOT OD12
}
// OD_12.EN.1 and OD_12.EN.2 are checked by OD_12.EN.1_2

OD_12.EX.3 { @ Extension on ACTIVE [Cut is not allowed if without Gate] >= 0.05 
  ENC DACT OD12 < OD12_EX_3 ABUT < 90 SINGULAR REGION
  (DACT NOT INTERACT GATE) CUT OD12
}
OD_12.A.1 { @ Area >= ^OD12_A_1
  (AREA OD12s < OD12_A_1) NOT INSIDE SRAM_EXCLUDE
}
OD_12.A.2 { @ Enclosed Area >= ^OD12_A_2
  A = HOLES OD12s INNER
  B = A NOT OD12s
  (AREA B < OD12_A_2) NOT INSIDE SRAM_EXCLUDE
}
OD_12.R.2 { @ Overlap of VTH_N, VTH_P, VTL_N, VTL_P, RPO, RH, NWDMY, BJTDMY, OD2 is not allowed   
  OD12 AND VTHN
  OD12 AND VTHP
  OD12 AND VTLN
  OD12 AND VTLP
  OD12 AND RPO
  OD12 AND RH
  OD12 AND NWDMY
  OD12 AND BJTDMY
  OD12 AND OD2
}
OD_12.R.3 { @ OD_12 cut {ACTIVE OR GATE} is not allowed (Except OD shared by core and OD_12 is at same potential, DRC can not exclude this exception.)   
  DACTG = DACT OR GATE  
  (DACTG CUT OD12s) NOT INSIDE SRAM_EXCLUDE
}
// OD_12.R.4 is checked by OD_12.W.1 and OD_12.S.1



//OD18_15 CHECKS
//==============
18_15V_GATE_W = 18V_GATE_W INSIDE EDGE OD1815

OD18_15.W.1 { @ Channel length of 1.8V MOS underdriven to 1.5V (Gate AND OD18_15) >= ^OD18_15_W_1 um
  INT 18_15V_GATE_W < OD18_15_W_1 ABUT < 90 REGION
}
OD18_15.R.1 { @ {GATE AND OD18_15} can't overlap OD_25, OD_33, OD25_18, or OD25_33. {Gate AND OD18_15} must be covered by OD_18. OD18_15 can't cut GATE.
  18_15V_GATE = GATE AND OD1815
  18_15V_GATE AND OD25
  18_15V_GATE AND OD33
  18_15V_GATE AND OD2518
  18_15V_GATE AND OD2533
  18_15V_GATE NOT OD18
  GATE CUT OD1815
}
OD18_15.R.2 {@ 1.8V and 1.5V can not share same NW
   A = GATE INTERACT OD18
   B = A INTERACT OD1815    
   C = A NOT INTERACT OD1815
   (NWEL INTERACT B) INTERACT C
}


//OD25_33 CHECKS
//==============
25_33V_GATE_W = 25V_GATE_W INSIDE EDGE OD2533

OD25_33.W.1 { @ Channel length of 2.5V NMOS overdrive to 3.3V (NMOS Gate AND OD25_33). >= ^OD25_33_W_1 um
  25_33V_GATE_W_NP = 25_33V_GATE_W INSIDE EDGE NP
  INT 25_33V_GATE_W_NP < OD25_33_W_1 ABUT < 90 REGION
}
OD25_33.W.2 { @ Channel length of 2.5V PMOS overdriven to 3.3V (PMOS Gate AND OD25_33) >= ^OD25_33_W_2 um
  25_33V_GATE_W_PP = 25_33V_GATE_W INSIDE EDGE PP
  INT 25_33V_GATE_W_PP < OD25_33_W_2 ABUT < 90 REGION
}
OD25_33.W.3 { @ Channel length of 2.5V native NMOS overdrive to 3.3V. ((Gate AND NT_N) AND OD25_33) 1.2  
  25_33V_GATE_W_NP_NTN = (25_33V_GATE_W INSIDE EDGE NP) INSIDE EDGE NTN
  INT 25_33V_GATE_W_NP_NTN < OD25_33_W_3 ABUT < 90 REGION
}

OD25_33.R.1 { @ (Gate AND OD25_33) can't overlap OD_18 or OD_33 or OD25_18. (Gate AND OD25_33) must be covered by OD_25. OD25_33 can't cut GATE.   
  25_33V_GATE = GATE AND OD2533
  25_33V_GATE AND OD18
  25_33V_GATE AND OD33
  25_33V_GATE AND OD2518
  25_33V_GATE NOT OD25
  GATE CUT OD2533
}

//OD25_18 CHECKS
//==============
25_18V_GATE_W = 25V_GATE_W INSIDE EDGE OD2518

OD25_18.W.1 { @ Channel length of 2.5V MOS underdriven to 1.8V (Gate AND OD25_18) >= ^OD25_18_W_1 um
  INT 25_18V_GATE_W < OD25_18_W_1 ABUT < 90 REGION
}

#IFDEF GS
OD25_18.W.1GS { @ Channel length of 2.5V PMOS underdriven to 1.8V (Gate AND OD25_18) >= ^OD25_18_W_1GS um
   A = 25_18V_GATE_W INSIDE EDGE PP
   INT A < OD25_18_W_1GS ABUT < 90 REGION
}
#ENDIF

OD25_18.W.2 { @ Channel length of 2.5V native NMOS underdrive to 1.8V ((Gate AND NT_N) AND OD25_18) 1.2  
  25_18V_GATE_W_NP_NTN = (25_18V_GATE_W INSIDE EDGE NP) INSIDE EDGE NTN
  INT 25_18V_GATE_W_NP_NTN < OD25_18_W_2 ABUT < 90 REGION
}
OD25_18.R.1 { @ (Gate AND OD25_18) can't overlap OD_18 or OD_33 or OD25_33. (Gate AND OD25_18) must be covered by OD_25. OD25_18 can't cut GATE.   
  25_18V_GATE = GATE AND OD2518
  25_18V_GATE AND OD18
  25_18V_GATE AND OD33
  25_18V_GATE AND OD2533
  25_18V_GATE NOT OD25
  GATE CUT OD2518
}




//PO CHECKS
//=========

PO.W.1 { @ Width >= 0.04 
  (INT POLY < PO_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE RAM1TDMY
}
PO.W.2 { @ Channel length of 2.5V MOS (for 2.5V overdrive to 3.3V, please refer to section OD25_33 Layout Rules) >= 0.27 
  25V_GATE_W_NORMAL = 25V_GATE_W NOT INSIDE EDGE (OD2518 OR OD2533) 
  INT 25V_GATE_W_NORMAL < PO_W_2 ABUT < 90 REGION 
}
PO.W.3 { @ Channel length of 3.3V MOS >= ^PO_W_3 um
  INT 33V_GATE_W < PO_W_3 ABUT < 90 REGION 
}
PO.W.4 { @ Channel length of 1.8 V MOS (For 2.5V underdrive to 1.8V, please refer to section OD25_18 Layout Rules. For 1.8V underdrive to 1.5V, please refer to section OD18_15 Layout Rules.) >= 0.15 
  18V_GATE_W_NORMAL = 18V_GATE_W NOT INSIDE EDGE OD1815
  INT 18V_GATE_W_NORMAL < PO_W_4 ABUT < 90 REGION
}

PO_EDGE_45 = POLY ANGLE == 45

#IFDEF GS
PO.W.6 { @ Channel length of core device for GS (This check doesn't include the regions covered by layers of NT_N, SDI, and VAR.) = 0.04 / 0.045 / 0.05 / 0.06 / 0.07 / 0.08~10 
  EXCLUDE_REGION = ((((LOGO OR NTNi) OR SDI) OR VAR) OR SRAM_REGION) OR CSRDMY  
  LV_GATE_L_C = LV_GATE_L NOT INSIDE EDGE EXCLUDE_REGION
  GATE WITH EDGE (LENGTH LV_GATE_L_C < PO_W_6A)
  GATE WITH EDGE (LENGTH LV_GATE_L_C < PO_W_6B > PO_W_6A)
  GATE WITH EDGE (LENGTH LV_GATE_L_C < PO_W_6C > PO_W_6B)
  GATE WITH EDGE (LENGTH LV_GATE_L_C < PO_W_6D > PO_W_6C)
  GATE WITH EDGE (LENGTH LV_GATE_L_C < PO_W_6E > PO_W_6D)
  GATE WITH EDGE (LENGTH LV_GATE_L_C < PO_W_6F > PO_W_6E)
  GATE WITH EDGE (LENGTH LV_GATE_L_C > PO_W_6G)
}
#ENDIF

PO.W.7 { @ Width of 45-degree FIELD PO (except PO fuse element, POFUSE, 156;0). (Please make sure the vertex of 45 degree pattern is on 5nm grid (refer to the rule, G.6U, in section 3.7)) >= 0.17 
  INT (PO_EDGE_45 NOT INSIDE EDGE POFUSE) < PO_W_7 ABUT < 90 REGION
}
#IFNDEF GS
PO.W.8 {@ Maximum channel length of NMOS [for LPG G device] <= 10
    LV_GATE_L_C = (LV_GATE_L INSIDE EDGE NP) INSIDE EDGE DCO
    GATE WITH EDGE (LENGTH LV_GATE_L_C > PO_W_8)
}
#ENDIF
PO.S.1 { @ Space >= 0.10 
  (EXT POi < PO_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE (SRAM_REGION OR RAM1TDMY)
}

PO.S.3 { @ {GATE inside OD2} space in the same OD >= 0.22 
  EXT HV_GATE_W < PO_S_3 ABUT < 90 REGION
}

PO.S.4 { @ FIELD PO space to OD (except CSRDMY (166;0) region) >= 0.03 
  POLY_CHECK = POLY NOT CSRDMY    
  WAIVE_REGION = SRAM_REGION OR RAM1TDMY
  (EXT POLY_CHECK OD < PO_S_4 ABUT < 90 SINGULAR REGION) NOT INSIDE WAIVE_REGION
}


PO.S.4.1 { @ Gate space [L-shape OD and L-shape PO enclosed area < 0.0121 um2 ] >= 0.11 
  X = RECTANGLE (HOLES (POLY OR OD) INNER EMPTY < PO_S_4_1_A)
  (EXT GATE < PO_S_4_1 ABUT < 90 REGION CORNER TO CORNER) INTERACT X
}
PO.S.6 { @ L-shape PO space to OD when PO and OD are in the same MOS L-shape PO length (R1) <= 0.06 um] >= 0.04 
  A = ((EXPAND EDGE GATE_L INSIDE BY GRID EXTEND BY PO_S_6_L) NOT GATE) TOUCH EDGE OD
  B = EXT A [FPO1] < PO_S_6_1 ABUT < 90 OPPOSITE
  (EXT B OD < PO_S_6 ABUT < 90 OPPOSITE REGION) NOT INSIDE (SRAM_REGION OR RAM1TDMY)
}
PO.S.6.1 { @ L-shape PO space to OD when PO and OD are in the same MOS [L-shape PO length > 0.06 um (R1) and L-shape PO length <= 0.1 um (R1)] >= 0.05 
  L_GATE_L1 = EXPAND EDGE GATE_L INSIDE BY GRID EXTEND BY PO_S_6_1_L2
  L_GATE_L2 = EXPAND EDGE GATE_L INSIDE BY GRID EXTEND BY PO_S_6_1_L1+0.001
  L_GATE_L = L_GATE_L1 NOT L_GATE_L2
  L_GATE_L1E = (L_GATE_L1 TOUCH EDGE GATE_L) TOUCH EDGE OD
  L_GATE_LE = L_GATE_L COIN EDGE L_GATE_L1E
  B = EXT L_GATE_LE [FPO1] <= PO_S_6_1 ABUT < 90 OPPOSITE
  (EXT B OD < PO_S_6_1 ABUT < 90 OPPOSITE REGION) NOT INSIDE RAM1TDMY
  U_PO = CONVEX EDGE POLY ANGLE1 == 270 ANGLE2 == 270 WITH LENGTH > PO_S_6_1_L1 <= PO_S_6_1_L1*2
  X = EXT U_PO OD < PO_S_6_1 OPPOSITE REGION
  ((SIZE X BY 0.001) INTERACT GATE == 2) NOT INSIDE RAM1TDMY
}
PO.S.7 { @ Space if at least one {PO OR SR_DPO} width > 0.12 um, and the {PO OR SR_DPO} parallel run length > 0.14 um (individual projection). >= 0.16 
  Wide_POLY = SR_POLY WITH WIDTH > PO_S_7_W
  X = EXT Wide_POLY SR_POLY < PO_S_7 OPPOSITE REGION MEASURE ALL
  Y = ENCLOSE RECTANGLE X PO_S_1 - GRID PO_S_7_L + GRID
  WideEdge = Wide_POLY COIN OUTSIDE EDGE Y
  A = PATH LENGTH WideEdge > PO_S_7_L
  B = EXPAND EDGE A BY 0.001
  C = EXTENTS B 
  D = ENCLOSE RECTANGLE C 0.001 PO_S_7_L + GRID ORTHOGONAL ONLY
  E = A INSIDE EDGE D
  EXT E SR_POLY < PO_S_7 OPPOSITE REGION MEASURE ALL
}
PO.S.9 { @ Space [in same RPO] >= 0.18 
  A = POLY INSIDE EDGE RPO
  EXT A < PO_S_9 ABUT < 90 REGION
}  
PO.S.10 { @ Space at {PO OR SR_DPO} line-end (W <0.07 um (Q1)) in a dense-line-end configuration: If {PO OR SR_DPO} has parallel run length with opposite {PO OR SR_DPO} (measured with T1 = 0.035 um extension) along 2 adjacent edges of {PO OR SR_DPO} [any one edge < Q1 distance from the corner of the two edges], then one of the space (S1 or S2) needs to be at least this value (This check doesn't include small jog with edge length < 0.04 um (R)) >= 0.11 
  A = CONVEX EDGE SR_POLY ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < PO_S_10_Q
  B = EXT [A] SR_POLY < PO_S_10 ABUT < 90 OPPOSITE EXTENDED PO_S_10_E
  C = A TOUCH INSIDE EDGE B
  D = INT C [SR_POLY] < PO_S_10_Q ABUT == 90 INTERSECTING ONLY
  I = LENGTH D >= PO_S_10_L
  J = EXPAND EDGE I INSIDE BY 0.001 EXTEND BY PO_S_10_E
  K = EXPAND EDGE I INSIDE BY 0.001 
  L = J NOT K
  M = L WITH EDGE A 
  N = M OR K
  O = N TOUCH EDGE I
  EXT O SR_POLY < PO_S_10 ABUT < 90 OPPOSITE REGION

}
PO.S.15 { @ Large PO to gate [channel length <= 0.08 um] space. The large PO is defined as PO area >= 630 um2 and interact with regions of density > 70% in window 30 um x 30 um, stepping 15 um. DPO will be excluded from density check. 1.0  
  PO_EXC = POi NOT DEN_EXC_LOW
  A = AREA PO_EXC >= PO_S_15_A
  B = EXTENTS A
  C = SIZE B BY PO_S_15_S
  D = DENSITY PO_EXC > PO_S_15_D INSIDE OF LAYER C WINDOW PO_S_15_W2 STEP PO_S_15_S BACKUP PRINT PO.S.15.density
  E = A INTERACT D 
  GATE_W_S80 = INT [GATE_W] <= PO_S_15_W1
  GATE_S80 = GATE WITH EDGE GATE_W_S80
  EXT E GATE_S80 < PO_S_15 ABUT<90 REGION 
}
PO.S.16 { @ Space to 45-degree bent {PO OR SR_DPO} >= 0.17 
  A = SR_POLY ANGLE == 45
  X = EXPAND EDGE A OUTSIDE BY PO_S_16
  X AND POLY  
}  
PO.EX.1 { @ Extension on OD (end-cap) >= 0.09 
  WAIVE_REGION = (SRAM_REGION OR LOGO) OR RAM1TDMY 
  A = OD NOT INSIDE WAIVE_REGION
  ENC A POLY < PO_EX_1 ABUT < 90 OPPOSITE SINGULAR REGION
}
PO.EX.2 { @ OD extension on PO >= 0.09 
  WAIVE_REGION = LOGO OR SRAM_REGION
  ENC (POLY NOT WAIVE_REGION) OD < PO_EX_2 ABUT < 90 SINGULAR REGION
}
PO.EX.3 { @ Extension on OD (end-cap) when the PO to L-shape OD (in the same MOS) space < 0.1 um. (This check doesn't include ACTIVE jog <= 0.02 um.) >= 0.11 
  A = GATE_W NOT INSIDE EDGE (SRAM_REGION OR LOGO)
  B = EXPAND EDGE A INSIDE BY GRID EXTEND BY OD_S_1
  C = EXPAND EDGE A INSIDE BY GRID EXTEND BY PO_EX_3_J 
  D = B NOT C
  E = (B TOUCH EDGE A) TOUCH EDGE POLY
  F = D COIN EDGE E
  G = EXT F OD < PO_EX_3_S ABUT < 90 OPPOSITE REGION
  H = FPO1 TOUCH OUTSIDE EDGE G
  I = EXPAND EDGE H INSIDE BY GRID
  J = GATE_L TOUCH OUTSIDE EDGE I
  K = EXPAND EDGE J OUTSIDE BY PO_EX_3
  L = K INTERACT G
  L NOT POLY
}
PO.L.1 { @ Maximum PO length between two contacts, as well as the length from any point inside PO gate to nearest CO when the PO width< 0.08 um.(This check doesn't include ESD protection devices.) <= 18 
  ILP2 = (ILP1 NOT SDI) NOT RAM1TDMY
  LONGP = AREA ILP2 > PO_W_1 * PO_L_1
  X = LONGP INTERACT COPO
  CHECK_COPO = COPO INTERACT X
  A = SIZE CHECK_COPO BY PO_L_1 / 2 INSIDE OF X STEP PO_S_1*0.7
  P2P = X INTERACT A > 1
  BAD = P2P NOT A
  BAD_EDGE = BAD COIN INSIDE EDGE POLY
  ERR = INT BAD_EDGE < PO_L_1_W ABUT < 90 REGION
  X1 = (X INTERACT ERR) NOT GATE
  CHECK_COPO1 = CHECK_COPO INTERACT X1
  A1 = SIZE CHECK_COPO1 BY PO_L_1 / 2 INSIDE OF X1 STEP PO_S_1*0.7
  P2P1 = X1 INTERACT A1 > 1
  BAD1 = (P2P1 NOT A1) INTERACT A1 > 1
  BAD_EDGE1 = BAD1 COIN INSIDE EDGE POLY
  ERR1 = INT BAD_EDGE1 < PO_L_1_W ABUT < 90 REGION
  X1 INTERACT ERR1
  NARROW_GATE = (GATE WITH EDGE (LENGTH GATE_L < PO_L_1_W)) AND X
  B = SIZE A BY PO_L_1 / 2 INSIDE OF X STEP PO_S_1*0.7
  NARROW_GATE NOT B
}
PO.A.1 { @ Area (This check doesn't include the pattern filling0.04 um x 0.3 um rectangular tile) >= 0.022 
  A = AREA POLYs < PO_A_1
  NOT ENCLOSE RECTANGLE A PO_W_1 PO_A_1_L ORTHOGONAL ONLY
}
PO.A.2 { @ Area [with all of edge length< 0.21 um] >= 0.055 
    A = AREA POLYs < PO_A_2
    B = LENGTH A >= PO_A_2_L 
    (A NOT WITH EDGE B) NOT INSIDE SRAM_EXCLUDE 
}
PO.A.3 { @ Enclosed area >= 0.04 
  A = HOLES POLYs INNER
  B = A NOT POi
  (AREA B < PO_A_3) NOT INSIDE SRAM_EXCLUDE 
}
PO.A.4 { @ Enclosed area [with all of inner edge length< 0.21 um] >= 0.077 
  A = HOLES POLYs INNER
  B = A NOT POi
  C = LENGTH B >= PO_A_4_L
  D = B NOT WITH EDGE C
  (AREA D < PO_A_4) NOT INSIDE SRAM_EXCLUDE
}
#IFDEF FULL_CHIP
PO.DN.1 { @ Min. POLY density across full chip 14%
  DENSITY ALL_POLY CHIP < PO_DN_1 INSIDE OF LAYER CHIPx [ AREA(ALL_POLY)/AREA(CHIP) ] PRINT PO.DN.1.density
}
PO.DN.1.1 { @ Max. poly density across full chip 40%
  DENSITY ALL_POLY CHIP > PO_DN_1_1 INSIDE OF LAYER CHIPx [ AREA(ALL_POLY)/AREA(CHIP) ] PRINT PO.DN.1.1.density
}
#ENDIF

ALL_POD = ALL_OD OR ALL_POLY
PODEXC  = ((ODBLK OR POBLK) OR NWDMY) OR DEN_EXC_LOW

#IFDEF CHECK_LOW_DENSITY
PO.DN.2 { @ {OD OR DOD OR PO OR DPO } local density (minimun) over window 20um x 20um stepping 10um >= 0.1%
  ERR_WIN = DENSITY ALL_POD CHIP < PO_DN_2 WINDOW PO_DN_2_W STEP PO_DN_2_S INSIDE OF LAYER CHIPx BACKUP  
          [ AREA(ALL_POD)/AREA(CHIP) ]
  F = WITH WIDTH (ERR_WIN NOT PODEXC) >= PO_DN_2_E
  DENSITY F ALL_POD CHIP < PO_DN_2 WINDOW PO_DN_2_W STEP PO_DN_2_S INSIDE OF LAYER CHIPx BACKUP PRINT PO.DN.2.density 
          [ !AREA(F)+AREA(ALL_POD)/AREA(CHIP) ]
}
#ENDIF

PODN3_POBLK = ((((POBLK NOT RFIP) NOT TCDDMY) NOT ICOVL) NOT MOMDMY) NOT DEN_EXC_LOW

CHIP_POBLK = CHIP AND PODN3_POBLK
PO_POBLK = ALL_POLY AND PODN3_POBLK

PO.DN.3 { @ PO density within POBLK. (except {RFDMY AND RFIP_DMY}, MOMDMY(155;21)) 14%  
  A = DENSITY PO_POBLK CHIP_POBLK < PO_DN_3 INSIDE OF LAYER CHIPx PRINT PO.DN.3.density
      [ AREA(PO_POBLK)/AREA(CHIP_POBLK) ] 
  A AND PODN3_POBLK
}

PO.R.1 { @ GATE must be a rectangle orthogonal to grid. (Both bent GATE and gate with jog are not allowed). (Except CSRDMY region)   
  (NOT RECTANGLE GATE ORTHOGONAL ONLY) NOT INSIDE ((LOGO OR CSRDMY) OR ICOVL)
}

// PO.R.2 can not be checked by DRC

PO.R.4 { @ PO intersecting OD must form two or more diffusions. (Except CSRDMY region)   
  WAIVE_REGION = (LOGO OR (RODMY AND SRAMDMY)) OR CSRDMY    
  FOD = EXPAND EDGE (GATE INSIDE EDGE OD) BY GRID
  (GATE NOT INSIDE WAIVE_REGION) NOT INTERACT FOD >= 2
} 

POR7_REGION = (SRM OR SRAMDMY) NOT RAM1TDMY
POR7_GATE = (GATEi NOT OUTSIDE POR7_REGION) OUTSIDE RODMY // not check RODMY
POR7_GATE_W = POi COIN INSIDE EDGE POR7_GATE
POR7_GATE_W_V = EXPAND EDGE (ANGLE POR7_GATE_W == 90) INSIDE BY GRID
POR7_GATE_W_H = EXPAND EDGE (ANGLE POR7_GATE_W == 0) INSIDE BY GRID
POR7_BAD = (CHIP INTERACT POR7_GATE_W_V) INTERACT POR7_GATE_W_H
PO.R.7_V { @ Poly gates of all SRAM cells (50;0 OR 186;0) must be uni-directional in a chip. (This check doesn't include the regions covered by layer 49 (RODMY) and RAM1TDMY (160;0)) Chips on MPW or shuttles may be rotated due to this rule   
  POR7_GATE_W_V AND POR7_BAD
}
PO.R.7_H { @ Poly gates of all SRAM cells (50;0 OR 186;0) must be uni-directional in a chip. (This check doesn't include the regions covered by layer 49 (RODMY) and RAM1TDMY (160;0)) Chips on MPW or shuttles may be rotated due to this rule   
  POR7_GATE_W_H AND POR7_BAD
}

//H-GATE CHECK
//============

PO.R.6 { @ H-gate that fulfills the following conditions at the same time is not allowed. [inner space < 0.43 um (U), channel length < 0.10 um (V), interconnect PO width < 0.25 um (W), and interconnect PO length > 0.065 um(X)]   
  A1 = CONVEX EDGE POLY ANGLE1 == 270 ANGLE2 == 270 
  A = LENGTH A1 >= PO_S_1 < PO_R_6_S     
  B = A INSIDE EDGE OD
  C = POLY TOUCH INSIDE EDGE B
  D = INTERNAL [POLY] < PO_R_6_W1 OPPOSITE 
  E = POLY TOUCH INSIDE EDGE D
  F = C COIN INSIDE EDGE E
  G = INT [POLY] < PO_R_6_W2 OPPOSITE 
  H = LENGTH G > PO_R_6_L
  I = H NOT COIN INSIDE EDGE F
  J = EXT [F] I < GRID ABUT == 90 INTERSECTING ONLY
  K = EXPAND EDGE F INSIDE BY GRID
  L = K WITH EDGE J == 2
  GATE INTERACT L == 2
}

//FLOATING GATE CHECK
//===================
GATEu  = STAMP GATEi BY POu
NSDu_g = NSDu INTERACT POu 
PSDu_g = PSDu INTERACT POu 

Float_GATE = NET AREA RATIO GATEu PSTPu NSTPu PSDu_g NSDu_g CBu CB2Fu CB2Wu UBMu COu > 0 
  [!AREA(PSTPu)*!AREA(NSTPu)*!AREA(PSDu_g)*!AREA(NSDu_g)*!AREA(CBu)*!AREA(CB2Fu)*!AREA(CB2Wu)*!AREA(UBMu)+!AREA(COu)]
Float_NSD = NET AREA RATIO NSDu_g PSDu_g GATEu PSTPu NSTPu CBu CB2Fu CB2Wu UBMu > 0
  [~(COUNT(NSDu_g)-1)*!AREA(PSDu_g)*!AREA(GATEu)*!AREA(PSTPu)*!AREA(NSTPu)*!AREA(CBu)*!AREA(CB2Fu)*!AREA(CB2Wu)*!AREA(UBMu)]
Float_PSD = NET AREA RATIO PSDu_g NSDu_g GATEu PSTPu NSTPu CBu CB2Fu CB2Wu UBMu > 0
  [~(COUNT(PSDu_g)-1)*!AREA(NSDu_g)*!AREA(GATEu)*!AREA(PSTPu)*!AREA(NSTPu)*!AREA(CBu)*!AREA(CB2Fu)*!AREA(CB2Wu)*!AREA(UBMu)]


effective_NSD = NSDu_g NOT Float_NSD
effective_PSD = PSDu_g NOT Float_PSD
Float_NSD_a = Float_NSD NOT ((Float_NSD OR GATE) INTERACT effective_NSD > 1 BY NET)
Float_PSD_a = Float_PSD NOT ((Float_PSD OR GATE) INTERACT effective_PSD > 1 BY NET)
    
#IFDEF CHECK_FLOATING_GATE_BY_TEXT

IP_PIN_M1u_BY_TEXT = M1u WITH TEXT IP_PIN_TEXT M1_PIN_TEXT
IP_PIN_M2u_BY_TEXT = M2u WITH TEXT IP_PIN_TEXT M2_PIN_TEXT
IP_PIN_M3u_BY_TEXT = M3u WITH TEXT IP_PIN_TEXT M3_PIN_TEXT
IP_PIN_M4u_BY_TEXT = M4u WITH TEXT IP_PIN_TEXT M4_PIN_TEXT
IP_PIN_M5u_BY_TEXT = M5u WITH TEXT IP_PIN_TEXT M5_PIN_TEXT
IP_PIN_M6u_BY_TEXT = M6u WITH TEXT IP_PIN_TEXT M6_PIN_TEXT
IP_PIN_M7u_BY_TEXT = M7u WITH TEXT IP_PIN_TEXT M7_PIN_TEXT
IP_PIN_M8u_BY_TEXT = M8u WITH TEXT IP_PIN_TEXT M8_PIN_TEXT
IP_PIN_M9u_BY_TEXT = M9u WITH TEXT IP_PIN_TEXT M9_PIN_TEXT
IP_PIN_M10u_BY_TEXT = M10u WITH TEXT IP_PIN_TEXT M10_PIN_TEXT
IP_PIN_APu_BY_TEXT = APu WITH TEXT IP_PIN_TEXT AP_PIN_TEXT


IP_PIN_WAIVE = NET AREA RATIO GATEu OVER IP_PIN_M10u_BY_TEXT IP_PIN_M9u_BY_TEXT IP_PIN_M8u_BY_TEXT IP_PIN_M7u_BY_TEXT IP_PIN_M6u_BY_TEXT IP_PIN_M5u_BY_TEXT IP_PIN_M4u_BY_TEXT IP_PIN_M3u_BY_TEXT IP_PIN_M2u_BY_TEXT IP_PIN_M1u_BY_TEXT IP_PIN_APu_BY_TEXT > 0

Float_GATE_check = (Float_GATE NOT INTERACT (Float_NSD_a OR Float_PSD_a)) NOT INTERACT IP_PIN_WAIVE
#ELSE
Float_GATE_check = Float_GATE NOT INTERACT (Float_NSD_a OR Float_PSD_a)
#ENDIF
    

#IFDEF CHECK_FLOATING_GATE_BY_TEXT
#DEFINE CHECK_POR8
#ENDIF
#IFDEF FULL_CHIP
#DEFINE CHECK_POR8
#ENDIF

#IFDEF CHECK_POR8

Float_GATE_fail_n = Float_GATE_check INTERACT NSDu > 1 BY NET
Float_GATE_fail_p = Float_GATE_check INTERACT PSDu > 1 BY NET
PO.R.8 { @ It is prohibited for Floating Gate if the effective source/drain is not connected together 
   Float_GATE_fail_n NOT INSIDE SRAM_REGION
   Float_GATE_fail_p NOT INSIDE SRAM_REGION
}
PO.R.8.SRAM { @ It is prohibited for Floating Gate if the effective source/drain is not connected together 
   Float_GATE_fail_n INSIDE SRAM_REGION
   Float_GATE_fail_p INSIDE SRAM_REGION
}
#ENDIF

//PO GATE SPACE CHECK
//===================
#IFDEF GS
WLD_POS2_WAIVE = COPY SRAMDMY_PERI_G
#ELSE
WLD_POS2_WAIVE = COPY EMPTYi
#ENDIF

POS2_GATEW = GATE_W NOT INSIDE EDGE WLD_POS2_WAIVE  // exclude (186;5)
POS2_CHECK = (INT [POS2_GATEW] < PO_S_2_W OPPOSITE) NOT INSIDE EDGE SRAM_REGION
#IFDEF GS
POS2_GOOD1 = TDDRC [ALL_POLY] SPACE == PO_S_2A EXCLUDE SHIELDED 4 OPPOSITE
POS2_GOOD2 = TDDRC [ALL_POLY] SPACE == PO_S_2B EXCLUDE SHIELDED 4 OPPOSITE
POS2_GOOD3 = TDDRC [ALL_POLY] SPACE == PO_S_2C EXCLUDE SHIELDED 4 OPPOSITE
POS2_BAD   = ((POS2_CHECK NOT COIN INSIDE EDGE POS2_GOOD1) NOT COIN INSIDE EDGE POS2_GOOD2) NOT COIN INSIDE EDGE POS2_GOOD3
#ELSE
POS2_GOOD1 = TDDRC [ALL_POLY] SPACE >= PO_S_2A <= PO_S_2B EXCLUDE SHIELDED 4 OPPOSITE
POS2_GOOD2 = TDDRC [ALL_POLY] SPACE == PO_S_2C EXCLUDE SHIELDED 4 OPPOSITE
POS2_BAD   = (POS2_CHECK NOT COIN INSIDE EDGE POS2_GOOD1) NOT COIN INSIDE EDGE POS2_GOOD2  
#ENDIF
GATE_EXP   = EXPAND EDGE ( GATE_W TOUCH INSIDE EDGE POS2_BAD ) INSIDE BY GRID
CONNECT GATE_EXP

#IFDEF GS
PO.S.2 { @ The poly gate space range to neighboring {PO OR SR_DPO} [for channel length < 0.08 um], and allow the violation with length ratio < 30% on one side and one segment The length ratio = violation length / device width. This rule is for poly gate CDU control (This check doesn't include the regions covered by layer SRAMDMY;5) (Except SRAM (186;0) region) = 0.14 / 0.16 / 0.2 
  GATE_ERR_EXP = (EXPAND EDGE POS2_BAD INSIDE BY GRID) NOT CDUDMY
  GATE_ERR_EXP_C = STAMP GATE_ERR_EXP BY GATE_EXP
  BAD_GATE = GATE WITH EDGE POS2_BAD > 1
  (POS2_BAD COIN INSIDE EDGE BAD_GATE) NOT INSIDE EDGE CDUDMY
  NET AREA RATIO GATE_ERR_EXP_C GATE_EXP >= 0.3
}
#ELSE
PO.S.2 { @ The poly gate space range to neighboring {PO OR SR_DPO} [for channel length < 0.06um]. It allows the violation with length ratio < 30% on one side and one segment. The length ratio = violation length / device width. The 0.12 ~ 0.125 are not shrinkable. This rule is for poly gate CDU control (Except SRAM (186;0) region) = 0.12 ~ 0.22 or 0.32 
  GATE_ERR_EXP = (EXPAND EDGE POS2_BAD INSIDE BY GRID) NOT CDUDMY
  GATE_ERR_EXP_C = STAMP GATE_ERR_EXP BY GATE_EXP
  BAD_GATE = GATE WITH EDGE POS2_BAD > 1
  (POS2_BAD COIN INSIDE EDGE BAD_GATE) NOT INSIDE EDGE CDUDMY
  NET AREA RATIO GATE_ERR_EXP_C GATE_EXP >= 0.3
}
#ENDIF
#IFNDEF FULL_CHIP
#IFDEF SKIP_POS2_BOUNDARY
DRC UNSELECT CHECK PO.S.2
#IFDEF GS
PO.S.2_SkipBoundary { @ The poly gate space range to neighboring {PO OR SR_DPO} [for channel length < 0.08 um], and allow the violation with length ratio < 30% on one side and one segment The length ratio = violation length / device width. This rule is for poly gate CDU control (This check doesn't include the regions covered by layer SRAMDMY;5) (Except SRAM (186;0) region) = 0.14 / 0.16 / 0.2 
  POOD_BOUNDARY = EXTENT (ALL_OD OR ALL_POLY) // od/po boundary
  POOD_BOUNDARYs = (POOD_BOUNDARY NOT TOUCH EDGE ALL_POLY) TOUCH EDGE SD
  A = ENC [POS2_BAD] POOD_BOUNDARYs <= PO_S_2A OPPOSITE  
  POS2_BAD2 = POS2_BAD NOT COIN INSIDE EDGE A
  GATE_ERR_EXP = EXPAND EDGE POS2_BAD2 INSIDE BY GRID
  GATE_ERR_EXP_C = STAMP GATE_ERR_EXP BY GATE_EXP
  BAD_GATE = GATE WITH EDGE POS2_BAD2 > 1
  POS2_BAD COIN INSIDE EDGE BAD_GATE
  NET AREA RATIO GATE_ERR_EXP_C GATE_EXP >= 0.3
}
#ELSE
PO.S.2_SkipBoundary { @ The poly gate space range to neighboring {PO OR SR_DPO} [for channel length < 0.06um]. It allows the violation with length ratio < 30% on one side and one segment. The length ratio = violation length / device width. The 0.12 ~ 0.125 are not shrinkable. This rule is for poly gate CDU control (Except SRAM (186;0) region) = 0.12 ~ 0.22 or 0.32 
  POOD_BOUNDARY = EXTENT (ALL_OD OR ALL_POLY) // od/po boundary
  POOD_BOUNDARYs = (POOD_BOUNDARY NOT TOUCH EDGE ALL_POLY) TOUCH EDGE SD
  A = ENC [POS2_BAD] POOD_BOUNDARYs <= PO_S_2A OPPOSITE  
  POS2_BAD2 = POS2_BAD NOT COIN INSIDE EDGE A
  GATE_ERR_EXP = EXPAND EDGE POS2_BAD2 INSIDE BY GRID
  GATE_ERR_EXP_C = STAMP GATE_ERR_EXP BY GATE_EXP
  BAD_GATE = GATE WITH EDGE POS2_BAD2 > 1
  POS2_BAD COIN INSIDE EDGE BAD_GATE
  NET AREA RATIO GATE_ERR_EXP_C GATE_EXP >= 0.3
}
#ENDIF
#ENDIF
#ENDIF
PO.S.2.1 { @ Gate space [either one channel length >= ^PO_S_2_1_W ] >= ^PO_S_2_1
  GATE_LL = LENGTH GATE_L >= PO_S_2_1_W
  GATE_F = GATE WITH EDGE GATE_LL
  GATE_WW = POLY COIN INSIDE EDGE GATE_F
  (EXT GATE_W GATE_WW < PO_S_2_1 ABUT < 90 REGION) NOT INSIDE (SRAM_REGION OR RAM1TDMY)
}
#IFDEF GS
PO.S.2.1.1__PO.EX.2.1 { @ Maximum OD extension on the edge gate [channel length>= ^PO_S_2_1_1_W ] and gate space [either one channel length >= ^PO_S_2_1_1_W ] in core device regions <= ^PO_S_2_1_1 . This check doesn't include the regions covered by SR_ESD.
 GATE_LL = LENGTH GATE_L >= PO_S_2_1_1_W
 GATE_WW = (POLY COIN INSIDE EDGE ((LV_GATE NOT (RODMY AND SRAMDMY)) WITH EDGE GATE_LL)) NOT INSIDE EDGE (SRESD OR LOGO)
 POS211g = EXT [GATE_WW] SR_POLY <= PO_S_2_1_1 OPPOSITE // good edge of PO.S.2.1.1
 POEX21a = GATE_WW NOT COIN INSIDE EDGE POS211g
 POEX21g = ENC [POEX21a] ODi <= PO_S_2_1_1 ABUT < 90 OPPOSITE // good edge of od extension
 POEX21a NOT COIN EDGE POEX21g
}
//PO.S.2.1.1 is checked by PO.S.2.1.1__PO.EX.2.1
//PO.EX.2.1 is checked by PO.S.2.1.1__PO.EX.2.1
#ENDIF



//SR_DPO CHECKS
//=============
SRDPO_EDGE_45 = SRDPO ANGLE == 45

SR_DPO.W.1 { @ Width >= 0.04 
  INT SRDPO < SRDPO_W_1 ABUT < 90 SINGULAR REGION
}
SR_DPO.W.2 { @ Width in OD2 >= 0.1 
  HV_SRDPO = SRDPO NOT OUTSIDE OD2
  (INT HV_SRDPO < SRDPO_W_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE OD2
}
SR_DPO.W.6 { @ Width of 45-degree dummy PO. (Please make sure the vertex of 45 degree pattern is on 0.005 um grid (refer to the rule, G.6U, in section 3.7)) >= 0.17 
  INT SRDPO_EDGE_45 < SRDPO_W_6 ABUT < 90 REGION
}
SR_DPO.S.1 { @ Space to {PO OR SR_DPO} (SR_DPO overlap with PO is not allowed) >= 0.1 
  EXT SRDPO < SRDPO_S_1 ABUT < 90 SINGULAR REGION
  EXT SRDPO POLY < SRDPO_S_1 ABUT < 90 SINGULAR REGION
  SRDPO AND POLY
}
SR_DPO.S.2 { @ The SR_DPO (17;7) gate space to other gate (17;0 OR 17;7), SR_DPO (17;7) only can be used for dummy patterns. >= 0.14 
  EXT SR_GATE_W < SRDPO_S_2 ABUT < 90 REGION
  EXT SR_GATE_W GATE_W < SRDPO_S_2 ABUT < 90 REGION
}
HV_DACT = DACT AND OD2
CONNECT HV_DACT
SR_DPO.S.3 { @ {((PO OR SR_DPO) AND OD) inside OD2} space in the same OD >= 0.22 
  HV_GATE_C = STAMP HV_GATE BY HV_DACT
  SR_HV_GATE_C = STAMP SR_HV_GATE BY HV_DACT
  EXT SR_HV_GATE_C < SRDPO_S_3 ABUT < 90 SINGULAR REGION CONNECTED
  EXT SR_HV_GATE_C HV_GATE_C < SRDPO_S_3 ABUT < 90 SINGULAR REGION CONNECTED
}
SR_DPO.S.4 { @ Space to OD >= 0.03 
  EXT SRDPO OD < SRDPO_S_4 ABUT < 90 SINGULAR REGION
}
SR_DPO.S.9 { @ Space of {(PO OR SR_DPO) AND RPO} >= 0.18 
  SR_PO_RPO = SR_POLY AND RPO
  EXT SR_PO_RPO < SRDPO_S_9 ABUT < 90 SINGULAR REGION
}  
SR_DPO.S.16 { @ Space to 45-degree bent {PO OR SR_DPO} >= 0.17 
  A = SR_POLY ANGLE == 45
  X = EXPAND EDGE A OUTSIDE BY SRDPO_S_16
  X AND SRDPO
} 
SR_DPO.S.17 { @ {CO inside SR_DPO} space to OD >= 0.05 
  EXT SR_COPO OD < SRDPO_S_17 ABUT < 90 SINGULAR REGION
}
SR_DPO.S.18 { @ {SR_DPO AND OD} space to RPO (overlap is not allowed.) >= 0.38 
  EXT SR_GATE RPO < SRDPO_S_18 ABUT < 90 SINGULAR REGION
  SR_GATE AND RPO
}
SR_DPO.S.19 { @ {SR_DPO AND OD} space to CO (overlap is not allowed.) >= 0.04 
  EXT SR_GATE COOD < SRDPO_S_19 ABUT < 90 SINGULAR REGION
  SR_GATE AND CO
}
SR_DPO.S.20 { @ {CO inside OD} space to 1.8V, 2.5V, 3.3V {SR_DPO AND OD} >= 0.08 
  EXT SR_HV_GATE COOD < SRDPO_S_20 ABUT < 90 SINGULAR REGION
}
SR_DPO.EN.1 { @ Enclosure of CO >= 0.01 
  ENC SR_COPO SRDPO < SRDPO_EN_1 ABUT < 90 SINGULAR REGION
}
SR_DPO.EN.2 { @ Enclosure of CO [at least two opposite sides] >= 0.02 
  X = RECTANGLE ENCLOSURE SR_COPO SRDPO ABUT < 90 SINGULAR GOOD 0 SRDPO_EN_2 OPPOSITE 0 SRDPO_EN_2 OPPOSITE
  Y = ENC [X] SRDPO < SRDPO_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < CO_W_1 ABUT == 90 INTERSECTING ONLY REGION   // adjacent narrow sides
}
SR_DPO.EX.1 { @ Extension on OD (end-cap) >= 0.09 
  ENC OD SRDPO < SRDPO_EX_1 ABUT < 90 OPPOSITE SINGULAR REGION
}
SR_DPO.EX.2 { @ OD extension on SR_DPO >= 0.03 
  ENC SRDPO OD < SRDPO_EX_2 ABUT < 90 SINGULAR REGION
}
SR_DPO.L.2 { @ Length of 45-degree bent SR_DPO (minimum edge length) >= 0.26 
  LENGTH SRDPO_EDGE_45 < SRDPO_L_2
}
SR_DPO.A.1 { @ Area (This check doesn't include rectangle area with length >= 0.3 um) >= 0.022 
  A = AREA SRDPO < SRDPO_A_1
  B = RECTANGLE A
  C = ENCLOSE RECTANGLE B GRID SRDPO_A_1_L ORTHOGONAL ONLY
  A NOT C
}
SR_DPO.A.2 { @ Area [with all of edge length< 0.21 um] >= 0.055 
  A = LENGTH SRDPO >= SRDPO_A_2_L
  B = SRDPO NOT WITH EDGE A
  AREA B < SRDPO_A_2
}
SR_DPO.A.3 { @ Enclosed area >= 0.04 
  A = HOLES SRDPO INNER
  B = A NOT SRDPO
  AREA B < SRDPO_A_3
}
SR_DPO.A.4 { @ Enclosed area [with all of inner edge length< 0.21 um] >= 0.077 
  A = HOLES SRDPO INNER
  B = A NOT SRDPO
  C = LENGTH B >= SRDPO_A_4_L
  D = B NOT WITH EDGE C
  AREA D < SRDPO_A_4
}
SR_DPO.R.1 { @ {SR_DPO AND OD} must be a rectangle orthogonal to grid. (Both bent GATE and GATE with jogs are not allowed).   
  NOT RECTANGLE SR_GATE ORTHOGONAL ONLY
}
// SRDPO.R.2 can not be checked by DRC
SR_DPO.R.4 { @ SR_DPO intersecting OD must form two or more diffusions. (except MOMDMY (155;21) region)   
  SR_GATEW = SR_GATE INSIDE EDGE OD
  X = SR_GATE NOT WITH EDGE SR_GATEW == 2
  Y = INT SR_GATEW < GRID ABUT == 90 INTERSECTING ONLY REGION
  (X OR (SR_GATE INTERACT Y)) NOT MOMDMY
} 
SR_DPO.R.5 { @ Overlap of SRAM is not allowed   
  SRDPO AND SRM
  SRDPO AND SRAMDMY
}
SR_DPO.R.6 { @ SR_DPO(17;7) can not form device, SR_DPO must be placed besideOD edge. (except MOMDMY (155;21) region).   
    OD_EDGE_pre1 = (OD NOT SR_POLY) INTERACT GATE == 1
    OD_EDGE_pre2 = (OD NOT POLY) INTERACT GATE == 1
    OD_EDGE = (OD_EDGE_pre2 NOT OD_EDGE_pre1) NOT INTERACT CO
    OD_dummy = (OD NOT INTERACT POLY) NOT INTERACT CO 
    ((SR_GATE NOT INTERACT OD_EDGE) NOT INTERACT OD_dummy) NOT MOMDMY
}



//DPO CHECKS
//================
DPO.W.1 { @ Width >= 0.4 
  INT DPO < DPO_W_1 ABUT < 90 SINGULAR REGION
}
DPO.S.1 { @ Space >= 0.3 
  EXT DPO < DPO_S_1 ABUT < 90 SINGULAR REGION
}
DPO.S.2 { @ Space to OD (Overlap is not allowed) >= 0.2 
  EXT ODi DPO < DPO_S_2 ABUT < 90 SINGULAR REGION INSIDE ALSO
}
DPO.S.3 { @ Space to (PO OR SR_DPO) (Overlap is not allowed) >= 0.5 
  EXT POi DPO < DPO_S_3 ABUT < 90 SINGULAR REGION INSIDE ALSO
  EXT SRDPO DPO < DPO_S_3 ABUT < 90 SINGULAR REGION INSIDE ALSO
}
DPO.S.9 { @ Space to INDDMY (Overlap is not allowed) >= 1.2 
  EXT INDDMY DPO < DPO_S_9 ABUT < 90 SINGULAR REGION
  INDDMY AND DPO
}

#IFDEF FULL_CHIP
DPO.EN.1 { @ Enclosure by chip edge >= 0.6 
  DPO NOT (SIZE CHIP_EDGE BY -DPO_EN_1)
}
DPO.R.1 { @ DPO is must. DPO must be an individual CAD layer (datatype 1 as default, like 17;1)
  CHIPx NOT INTERACT DPO
}
#ENDIF

// DPO.R.2 is checked by CSR.R.1.DPO

DPO.R.3 { @ Only square (or rectangular) and solid shapes are allowed. A 45-degree shape is not allowed.   
  NOT RECTANGLE DPO ORTHOGONAL ONLY
}


VARIABLE POS1_W_1  0.04
VARIABLE POS1_S_1  0.06
VARIABLE POS1_EN_1 0.04
VARIABLE POS1_EX_1 0.04

// POS1 CHECKS
//============
POS1.W.1 {@  Channel length in POS1 = ^POS1_W_1
   A = GATE_W INSIDE EDGE POS1   
   INT A < POS1_W_1 ABUT < 90 REGION
   B = INT A == POS1_W_1 ABUT < 90 REGION
   (GATE INTERACT POS1) NOT B
}
POS1.S.1 { @ Space to POS1, POS2 [butted is allowed, overlap is not allowed]>= ^POS1_S_1 um
  EXT POS1 < POS1_S_1 ABUT > 0 < 90 SINGULAR REGION
  EXT POS1 POS2 < POS1_S_1 ABUT > 0 < 90 SINGULAR REGION INSIDE ALSO
}
POS1.EN.1 { @ POS1 enclosure of GATE (cut is not allowed) >= ^POS1_EN_1 um
  POS1_GATE = GATE INTERACT POS1
  ENC POS1_GATE POS1 < POS1_EN_1 ABUT < 90 SINGULAR REGION OUTSIDE ALSO
}
POS1.EX.1 { @ PO extension on POS1 (recommended to put the PO endcap fully inside POS1) >= ^POS1_EX_1 um
  ENC POS1 POLY < POS1_EX_1 ABUT < 90 SINGULAR REGION
}

// POS1.R.1 is checked by POS1.S.1

POS1.R.2 { @ POS1 without any GATE inside is not allowed.
  POS1 NOT ENCLOSE GATE
}
POS1.R.3 { @ POS1 overlap of NT_N ot OD2 is not allowed.
  POS1 AND NTN
  POS1 AND OD2
}

VARIABLE POS2_W_1  0.04
VARIABLE POS2_S_1  0.06
VARIABLE POS2_EN_1 0.04
VARIABLE POS2_EX_1 0.04

// POS2 CHECKS
//============
POS2.W.1 {@  Channel length in POS2 = ^POS2_W_1
   A = GATE_W INSIDE EDGE POS2   
   INT A < POS2_W_1 ABUT < 90 REGION
   B = INT A == POS2_W_1 ABUT < 90 REGION
   (GATE INTERACT POS2) NOT B
}
POS2.S.1 { @ Space to POS1, POS2 [butted is allowed, overlap is not allowed]>= ^POS2_S_1 um
  EXT POS2 < POS2_S_1 ABUT > 0 < 90 SINGULAR REGION
  EXT POS2 POS1 < POS2_S_1 ABUT > 0 < 90 SINGULAR REGION INSIDE ALSO
}
POS2.EN.1 { @ POS2 enclosure of GATE (cut is not allowed) >= ^POS2_EN_1 um
  POS2_GATE = GATE INTERACT POS2
  ENC POS2_GATE POS2 < POS2_EN_1 ABUT < 90 SINGULAR REGION OUTSIDE ALSO
}
POS2.EX.1 { @ PO extension on POS2 (recommended to put the PO endcap fully inside POS2) >= ^POS2_EX_1 um
  ENC POS2 POLY < POS2_EX_1 ABUT < 90 SINGULAR REGION
}

// POS2.R.1 is checked by POS2.S.1

POS2.R.2 { @ POS2 without any GATE inside is not allowed.
  POS2 NOT ENCLOSE GATE
}
POS2.R.3 { @ POS2 overlap of NT_N ot OD2 is not allowed.
  POS2 AND NTN
  POS2 AND OD2
}



POSx.WARN {@ illegal POSx layers (X>2) 
  COPY POS_OTHERS 
}


//DTCD CHECKS
//============
PO_TCD = POi AND TCDDMY
OD_TCD = ODi AND TCDDMY
GATE_TCD = (PO_TCD AND OD_TCD) AND TCDDMY
GATE_L_TCD = GATE_L INSIDE EDGE TCDDMY
OLD_TCD = (TCDDMY NOT TCDDMY_H) NOT TCDDMY_V
NEW_TCD = TCDDMY_H OR TCDDMY_V
GATE_W_OLD_TCD = GATE_W INSIDE EDGE OLD_TCD
GATE_W_NEW_TCD = GATE_W INSIDE EDGE NEW_TCD

DTCD.W.1 { @ Width of {(TCDDMY NOT TCDDMY_H) NOT TCDDMY_V} = 12, 24, 9.245 
  A = NOT RECTANGLE OLD_TCD == DTCD_W_1A BY == DTCD_W_1A ORTHOGONAL ONLY
  B = NOT RECTANGLE A == DTCD_W_1A BY == DTCD_W_1A*2 ORTHOGONAL ONLY
  NOT RECTANGLE B == DTCD_W_1B BY == DTCD_W_1B ORTHOGONAL ONLY
}
DTCD.W.2 { @ Channel width of gate inside {(TCDDMY NOT TCDDMY_H) NOT TCDDMY_V} 5, 4, 0.43  
  LENGTH GATE_W_OLD_TCD < DTCD_W_2A
  LENGTH GATE_W_OLD_TCD > DTCD_W_2A < DTCD_W_2B
  LENGTH GATE_W_OLD_TCD > DTCD_W_2B < DTCD_W_2C
  LENGTH GATE_W_OLD_TCD > DTCD_W_2C
}
DTCD.W.3 { @ Channel length of gate inside TCDDMY 0.04  
  LENGTH GATE_L_TCD < DTCD_W_3
  LENGTH GATE_L_TCD > DTCD_W_3
}
DTCD.S.1 { @ Space of poly gate in the same OD inside { (TCDDMY NOT TCDDMY_H) NOT TCDDMY_V} 0.14  
  A = (OD_TCD NOT PO_TCD) INTERACT GATE_TCD > 1
  B = GATE_W_OLD_TCD COIN OUTSIDE EDGE A  
  C = EXT [B] == DTCD_S_1 OPPOSITE  
  B NOT COIN INSIDE EDGE C  
}
DTCD.R.1 { @ TCDDMY should contain OD/PO/PP/NP/POBLK/ODBLK layer   
  TCDDMY OUTSIDE ODi
  TCDDMY OUTSIDE POi    
  TCDDMY OUTSIDE PPi
  TCDDMY OUTSIDE NPi
  TCDDMY XOR (POBLK AND TCDDMY)
  TCDDMY XOR (ODBLK AND TCDDMY)
}
DTCD.R.2 { @ TCDDMY overlap of DOD, SR_DOD, DPO, SR_DPO, OD2, DCO, OD_12, NT_N, POFUSE, RPO, RH, VAR, VTH_P, VTH_N, VTL_P, VTL_N, HVD_N, HVD_P, SRM, SRAMDMY, INDDMY, BJTDMY, or MOMDMY is not allowed.   
  TCDDMY AND DOD
  TCDDMY AND DPO
  TCDDMY AND SRDOD
  TCDDMY AND SRDPO
  TCDDMY AND OD2i
  TCDDMY AND OD12i
  TCDDMY AND DCOi
  TCDDMY AND NTNi
  TCDDMY AND POFUSE
  TCDDMY AND RPOi
  TCDDMY AND RH
  TCDDMY AND VARi
  TCDDMY AND VTHPi
  TCDDMY AND VTHNi
  TCDDMY AND VTLPi
  TCDDMY AND VTLNi
  TCDDMY AND HVD_N
  TCDDMY AND HVD_P
  TCDDMY AND SRM
  TCDDMY AND SRAMDMY
  TCDDMY AND INDDMY
  TCDDMY AND MOMDMY
  TCDDMY AND BJTDMY
}

// DTCD.R.3 was checked by PO.DN.3, OD.W.2.1, OD.W.2.2, OD.W.1.R, DNW.S.2, PO.EX.2.R, OD.S.1.R, PO.S.1.R, PO.S.6.R, PO.S.18.R, PO.EX.1.R, NW.R.1g


DTCD.W.1.1 {@ Dimension of TCDDMY_H = 5.71 X 3.57
  NOT RECTANGLE TCDDMY_H == DTCD_W_1_1A BY == DTCD_W_1_1B ORTHOGONAL ONLY
}
DTCD.W.1.2 {@ Dimension of TCDDMY_V = 3.6 X 6.33
  NOT RECTANGLE TCDDMY_V == DTCD_W_1_2A BY == DTCD_W_1_2B ORTHOGONAL ONLY
}
DTCD.W.2.1 {@ Channel width of gate inside TCDDMY_H or TCDDMY_V = 2.4, 0.41, 0.31
  LENGTH GATE_W_NEW_TCD < DTCD_W_2_1A
  LENGTH GATE_W_NEW_TCD > DTCD_W_2_1A < DTCD_W_2_1B
  LENGTH GATE_W_NEW_TCD > DTCD_W_2_1B < DTCD_W_2_1C
  LENGTH GATE_W_NEW_TCD > DTCD_W_2_1C
}
DTCD.S.1.1 {@ Gate space to neighboring poly inside TCDDMY_H or TCDDMY_V [channel width < 2.0um]  = 0.14 or 0.2
  X = LENGTH GATE_W_NEW_TCD < DTCD_S_1_1W
  A = EXT [X] POLY == DTCD_S_1_1A EXCLUDE SHIELDED 4 OPPOSITE
  B = EXT [X] POLY == DTCD_S_1_1B EXCLUDE SHIELDED 4 OPPOSITE
  (X NOT COIN INSIDE EDGE A) NOT COIN INSIDE EDGE B
}
DTCD.S.1.2{@ Gate space to neighboring poly inside TCDDMY_H or TCDDMY_V [channel width >= 2.0um] = 0.14
  X = LENGTH GATE_W_NEW_TCD >= DTCD_S_1_2W
  A = EXT [X] POLY == DTCD_S_1_2 EXCLUDE SHIELDED 4 OPPOSITE
  X NOT COIN INSIDE EDGE A
}
DTCD.R.4 {@ TCDDMY_H/ TCDDMY_V must keep same block orientation and no rotation no mirror in X, Y direction. DRC will check relative coordinates of three aligment marks with square PO (0.5um x 0.5um) in the TCDDMY_H/ TCDDMY_V.
  SQUARE_PO = RECTANGLE PO_TCD == DTCD_R_4 BY == DTCD_R_4 ORTHOGONAL ONLY
#IFDEF  VERTICAL_TCD_PATTERN
  H_SQUARE_PO = SQUARE_PO AND TCDDMY_H 
  H_PO_MARK1 = SHRINK TCDDMY_H LEFT BY 5.08 BOTTOM BY 0.83 RIGHT BY (DTCD_W_1_1A-5.58) TOP BY (DTCD_W_1_1B-1.33)
  H_PO_MARK2 = SHRINK TCDDMY_H LEFT BY 4.38 BOTTOM BY 0.13 RIGHT BY (DTCD_W_1_1A-4.88) TOP BY (DTCD_W_1_1B-0.63)
  H_PO_MARK3 = SHRINK TCDDMY_H LEFT BY 5.08 BOTTOM BY 0.13 RIGHT BY (DTCD_W_1_1A-5.58) TOP BY (DTCD_W_1_1B-0.63)
  H_PO_MARK = (H_PO_MARK1 OR H_PO_MARK2) OR H_PO_MARK3 
  TCDDMY_H INTERACT (H_SQUARE_PO XOR H_PO_MARK) 
    
  V_SQUARE_PO = SQUARE_PO AND TCDDMY_V 
  V_PO_MARK1 = SHRINK TCDDMY_V LEFT BY 2.97 BOTTOM BY 3.59 RIGHT BY (DTCD_W_1_2A-3.47) TOP BY (DTCD_W_1_2B-4.09)
  V_PO_MARK2 = SHRINK TCDDMY_V LEFT BY 2.27 BOTTOM BY 2.89 RIGHT BY (DTCD_W_1_2A-2.77) TOP BY (DTCD_W_1_2B-3.39)
  V_PO_MARK3 = SHRINK TCDDMY_V LEFT BY 2.97 BOTTOM BY 2.89 RIGHT BY (DTCD_W_1_2A-3.47) TOP BY (DTCD_W_1_2B-3.39)
  V_PO_MARK = (V_PO_MARK1 OR V_PO_MARK2) OR V_PO_MARK3 
  TCDDMY_V INTERACT (V_SQUARE_PO XOR V_PO_MARK)
#ELSE
  H_SQUARE_PO = SQUARE_PO AND TCDDMY_H 
  H_PO_MARK1 = SHRINK TCDDMY_H LEFT BY 0.83 BOTTOM BY (DTCD_W_1_1A-5.58) RIGHT BY (DTCD_W_1_1B-1.33) TOP BY 5.08
  H_PO_MARK2 = SHRINK TCDDMY_H LEFT BY 0.13 BOTTOM BY (DTCD_W_1_1A-4.88) RIGHT BY (DTCD_W_1_1B-0.63) TOP BY 4.38
  H_PO_MARK3 = SHRINK TCDDMY_H LEFT BY 0.13 BOTTOM BY (DTCD_W_1_1A-5.58) RIGHT BY (DTCD_W_1_1B-0.63) TOP BY 5.08
  H_PO_MARK = (H_PO_MARK1 OR H_PO_MARK2) OR H_PO_MARK3 
  TCDDMY_H INTERACT (H_SQUARE_PO XOR H_PO_MARK) 
 
  V_SQUARE_PO = SQUARE_PO AND TCDDMY_V 
  V_PO_MARK1 = SHRINK TCDDMY_V LEFT BY 3.59 BOTTOM BY (DTCD_W_1_2A-3.47) RIGHT BY (DTCD_W_1_2B-4.09) TOP BY 2.97
  V_PO_MARK2 = SHRINK TCDDMY_V LEFT BY 2.89 BOTTOM BY (DTCD_W_1_2A-2.77) RIGHT BY (DTCD_W_1_2B-3.39) TOP BY 2.27
  V_PO_MARK3 = SHRINK TCDDMY_V LEFT BY 2.89 BOTTOM BY (DTCD_W_1_2A-3.47) RIGHT BY (DTCD_W_1_2B-3.39) TOP BY 2.97
  V_PO_MARK = (V_PO_MARK1 OR V_PO_MARK2) OR V_PO_MARK3 
  TCDDMY_V INTERACT (V_SQUARE_PO XOR V_PO_MARK) 
#ENDIF
}

NEW_DTCD_GATE_W_V = EXPAND EDGE (ANGLE GATE_W_NEW_TCD == 90) INSIDE BY 0.005
NEW_DTCD_GATE_W_H = EXPAND EDGE (ANGLE GATE_W_NEW_TCD == 0) INSIDE BY 0.005
NEW_DTCD_BAD = (CHIP INTERACT NEW_DTCD_GATE_W_V) INTERACT NEW_DTCD_GATE_W_H

#IFDEF CYBER_SHUTTLE
DTCD.R.5 { @ Gate direction on the TCDDMY_H/TCDDMY_V must be same as gate on the SRAM for cyber shuttle
  DTCD_V_BAD = (CHIP INTERACT NEW_DTCD_GATE_W_V) INTERACT POR7_GATE_W_H
  DTCD_H_BAD = (CHIP INTERACT NEW_DTCD_GATE_W_H) INTERACT POR7_GATE_W_V
  NEW_DTCD_GATE_W_V AND DTCD_V_BAD
  NEW_DTCD_GATE_W_H AND DTCD_H_BAD   
}
#ENDIF


DTCD.R.6_V { @ Poly Gates in TCDDMY_H/TCDDMY_V are uni-directional in a whole chip level
  NEW_DTCD_GATE_W_V AND NEW_DTCD_BAD
}

DTCD.R.6_H { @ Poly Gates in TCDDMY_H/TCDDMY_V are uni-directional in a whole chip level
  NEW_DTCD_GATE_W_H AND NEW_DTCD_BAD
}



//VTH_N CHECKS
//============

VTHN_R = COPY VTHNs
// waive one track overlap 	  
VTHN_A1 = INT VTHNs < VTHN_W_1 ABUT < 90 REGION PROJ==0
VTHN_B1 = VTHN_R NOT (EXPAND EDGE VTHN_R INSIDE BY VTHN_R_3/2)	
VTHN_C1 = EXT VTHN_B1 < GRID SINGULAR INTERSECTING ONLY REGION
VTHN_D1 = VTHN_A1 ENCLOSE VTHN_C1
// waive one track space
VTHN_A2 = EXT VTHNs < VTHN_S_1 ABUT < 90 REGION PROJ==0
VTHN_B2 = VTHN_R OR (EXPAND EDGE VTHN_R OUTSIDE BY VTHN_R_3/2)
VTHN_C2 = EXT VTHN_B2 < GRID SINGULAR INTERSECTING ONLY REGION
VTHN_D2  = VTHN_A2 ENCLOSE VTHN_C2
// waive point touch
VTHN_P = EXT VTHN_R < VTHN_S_1 SINGULAR INTERSECTING ONLY REGION

VTH_N.W.1 { @ Width >= ^VTHN_W_1. One-track(^VTHN_R_3) overlap is allowed
  X = INT VTHNs < VTHN_W_1 ABUT < 90 REGION
  (X INTERACT (X NOT VTHN_D1)) NOT INSIDE SRAM_EXCLUDE
}
VTH_N.S.1 { @ Space >= ^VTHN_S_1. Point touch of corners is allowed. One-track(^VTHN_R_3) space is allowed.
  X = EXT VTHNs < VTHN_S_1 ABUT < 90 REGION SINGULAR
  (X INTERACT (X NOT (VTHN_D2 OR VTHN_P))) NOT INSIDE SRAM_EXCLUDE
}
VTH_N.S.2_VTH_N.S.2.1 { @ Space to gate in PO endcap direction >= ^VTHN_S_2 & in S/D direction >= ^VTHN_S_2_1
  A = GATE NOT INTERACT VTHN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTHN_S_2_1 - VTHN_S_2)) OR A
  C = SIZE B BY VTHN_S_2
  VTHN AND C
}

// VTH_N.S.2 and VTH_N.S.2.1 are checked by VTH_N.S.2_VTH_N.S.2.1
VTH_N.S.3 { @ Space to unsilicided PO/OD resistor >= ^VTHN_S_3
  EXT VTHN ODPO_RES_RPO < VTHN_S_3 ABUT < 90 SINGULAR
  AND VTHN ODPO_RES_RPO    
}  
VTH_N.EN.1_VTH_N.EN.2 { @ Enclosure of gate in S/D direction >= ^VTHN_EN_1 & in PO endcap direction >= ^VTHN_EN_2 
  A = GATE INTERACT VTHN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTHN_EN_1 - VTHN_EN_2)) OR A
  C = SIZE B BY VTHN_EN_2
  C NOT VTHN
}
// VTH_N.EN.1 and VTH_N.EN.2 are checked by VTH_N.EN.1_VTH_N.EN.2
VTH_N.A.1 { @ Area >= ^VTHN_A_1
  (AREA VTHNs < VTHN_A_1) NOT INSIDE SRAM_EXCLUDE
}
VTH_N.A.2 { @ Enclosed area >= ^VTHN_A_2
  A = HOLES VTHN INNER
  B = A NOT VTHN
  AREA B < VTHN_A_2
}
VTH_N.R.1 { @ Overlap of P+ACTIVE, VAR, VTL_N, NT_N, or OD2 is not allowed.   
  VTHN AND OD2
  VTHN AND NTN
  VTHN AND PACT
  VTHN AND VTLN
}
// VTH_N.R.2 and VTH_N.R.3 are checked by VTH_N.W.1 and VTH_N.S.1
VTH_N.L.1 { @ 45-degree edge length 0.5  
  VTHN_45ANGLE = VTHN ANGLE == 45
  (LENGTH VTHN_45ANGLE < VTHN_L_1) NOT INSIDE EDGE SRAM_EXCLUDE
}

//VTH_P CHECKS
//============

VTHP_R = COPY VTHPs
// waive one track overlap 	  
VTHP_A1 = INT VTHPs < VTHP_W_1 ABUT < 90 REGION PROJ==0
VTHP_B1 = VTHP_R NOT (EXPAND EDGE VTHP_R INSIDE BY VTHP_R_3/2)	
VTHP_C1 = EXT VTHP_B1 < GRID SINGULAR INTERSECTING ONLY REGION
VTHP_D1 = VTHP_A1 ENCLOSE VTHP_C1
// waive one track space
VTHP_A2 = EXT VTHPs < VTHP_S_1 ABUT < 90 REGION PROJ==0
VTHP_B2 = VTHP_R OR (EXPAND EDGE VTHP_R OUTSIDE BY VTHP_R_3/2)
VTHP_C2 = EXT VTHP_B2 < GRID SINGULAR INTERSECTING ONLY REGION
VTHP_D2  = VTHP_A2 ENCLOSE VTHP_C2
// waive point touch
VTHP_P = EXT VTHP_R < VTHP_S_1 SINGULAR INTERSECTING ONLY REGION

VTH_P.W.1 { @ Width >= ^VTHP_W_1. One-track(^VTHP_R_3) overlap is allowed
  X = INT VTHPs < VTHP_W_1 ABUT < 90 REGION
  (X INTERACT (X NOT VTHP_D1)) NOT INSIDE SRAM_EXCLUDE
}
VTH_P.S.1 { @ Space >= ^VTHP_S_1. Point touch of corners is allowed. One-track(^VTHP_R_3) space is allowed.
  X = EXT VTHPs < VTHP_S_1 ABUT < 90 REGION SINGULAR
  (X INTERACT (X NOT (VTHP_D2 OR VTHP_P))) NOT INSIDE SRAM_EXCLUDE
}
VTH_P.S.2_VTH_P.S.2.1 { @ Space to gate in PO endcap direction >= ^VTHP_S_2 & in S/D direction >= ^VTHP_S_2_1
  A = GATE NOT INTERACT VTHP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTHP_S_2_1 - VTHP_S_2)) OR A
  C = SIZE B BY VTHP_S_2
  VTHP AND C
}

// VTH_P.S.2 and VTH_P.S.2.1 are checked by VTH_P.S.2_VTH_P.S.2.1
VTH_P.S.3 { @ Space to unsilicided PO/OD resistor >= ^VTHP_S_3
  EXT VTHP ODPO_RES_RPO < VTHP_S_3 ABUT < 90 SINGULAR
  AND VTHP ODPO_RES_RPO    
}  
VTH_P.EN.1_VTH_P.EN.2 { @ Enclosure of gate in S/D direction >= ^VTHP_EN_1 & in PO endcap direction >= ^VTHP_EN_2 
  A = GATE INTERACT VTHP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTHP_EN_1 - VTHP_EN_2)) OR A
  C = SIZE B BY VTHP_EN_2
  C NOT VTHP
}
// VTH_P.EN.1 and VTH_P.EN.2 are checked by VTH_P.EN.1_VTH_P.EN.2
VTH_P.A.1 { @ Area >= ^VTHP_A_1
  (AREA VTHPs < VTHP_A_1) NOT INSIDE SRAM_EXCLUDE
}
VTH_P.A.2 { @ Enclosed area >= ^VTHP_A_2
  A = HOLES VTHP INNER
  B = A NOT VTHP
  AREA B < VTHP_A_2
}
VTH_P.R.1 { @ Overlap of N+ACTIVE, VAR, VTL_P, NT_N, or OD2 is not allowed.   
  VTHP AND OD2
  VTHP AND NTN
  VTHP AND NACT
  VTHP AND VTLP
}
// VTH_P.R.2 and VTH_P.R.3 are checked by VTH_P.W.1 and VTH_P.S.1
VTH_P.L.1 { @ 45-degree edge length 0.5  
  VTHP_45ANGLE = VTHP ANGLE == 45
  (LENGTH VTHP_45ANGLE < VTHP_L_1) NOT INSIDE EDGE SRAM_EXCLUDE
}

//VTL_N CHECKS
//============

VTLN_R = COPY VTLNs
// waive one track overlap 	  
VTLN_A1 = INT VTLNs < VTLN_W_1 ABUT < 90 REGION PROJ==0
VTLN_B1 = VTLN_R NOT (EXPAND EDGE VTLN_R INSIDE BY VTLN_R_3/2)	
VTLN_C1 = EXT VTLN_B1 < GRID SINGULAR INTERSECTING ONLY REGION
VTLN_D1 = VTLN_A1 ENCLOSE VTLN_C1
// waive one track space
VTLN_A2 = EXT VTLNs < VTLN_S_1 ABUT < 90 REGION PROJ==0
VTLN_B2 = VTLN_R OR (EXPAND EDGE VTLN_R OUTSIDE BY VTLN_R_3/2)
VTLN_C2 = EXT VTLN_B2 < GRID SINGULAR INTERSECTING ONLY REGION
VTLN_D2  = VTLN_A2 ENCLOSE VTLN_C2
// waive point touch
VTLN_P = EXT VTLN_R < VTLN_S_1 SINGULAR INTERSECTING ONLY REGION

VTL_N.W.1 { @ Width >= ^VTLN_W_1. One-track(^VTLN_R_3) overlap is allowed
  X = INT VTLNs < VTLN_W_1 ABUT < 90 REGION
  (X INTERACT (X NOT VTLN_D1)) NOT INSIDE SRAM_EXCLUDE
}
VTL_N.S.1 { @ Space >= ^VTLN_S_1. Point touch of corners is allowed. One-track(^VTLN_R_3) space is allowed.
  X = EXT VTLNs < VTLN_S_1 ABUT < 90 REGION SINGULAR
  (X INTERACT (X NOT (VTLN_D2 OR VTLN_P))) NOT INSIDE SRAM_EXCLUDE
}
VTL_N.S.2_VTL_N.S.2.1 { @ Space to gate in PO endcap direction >= ^VTLN_S_2 & in S/D direction >= ^VTLN_S_2_1
  A = GATE NOT INTERACT VTLN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTLN_S_2_1 - VTLN_S_2)) OR A
  C = SIZE B BY VTLN_S_2
  VTLN AND C
}

// VTL_N.S.2 and VTL_N.S.2.1 are checked by VTL_N.S.2_VTL_N.S.2.1
VTL_N.S.3 { @ Space to unsilicided PO/OD resistor >= ^VTLN_S_3
  EXT VTLN ODPO_RES_RPO < VTLN_S_3 ABUT < 90 SINGULAR
  AND VTLN ODPO_RES_RPO    
}  
VTL_N.EN.1_VTL_N.EN.2 { @ Enclosure of gate in S/D direction >= ^VTLN_EN_1 & in PO endcap direction >= ^VTLN_EN_2 
  A = GATE INTERACT VTLN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTLN_EN_1 - VTLN_EN_2)) OR A
  C = SIZE B BY VTLN_EN_2
  C NOT VTLN
}
// VTL_N.EN.1 and VTL_N.EN.2 are checked by VTL_N.EN.1_VTL_N.EN.2
VTL_N.A.1 { @ Area >= ^VTLN_A_1
  (AREA VTLNs < VTLN_A_1) NOT INSIDE SRAM_EXCLUDE
}
VTL_N.A.2 { @ Enclosed area >= ^VTLN_A_2
  A = HOLES VTLN INNER
  B = A NOT VTLN
  AREA B < VTLN_A_2
}
VTL_N.R.1 { @ Overlap of P+ACTIVE, VAR, VTH_N, NT_N, or OD2 is not allowed.   
  VTLN AND OD2
  VTLN AND NTN
  VTLN AND PACT
  VTLN AND VTHN
}
// VTL_N.R.2 and VTL_N.R.3 are checked by VTL_N.W.1 and VTL_N.S.1
VTL_N.L.1 { @ 45-degree edge length 0.5  
  VTLN_45ANGLE = VTLN ANGLE == 45
  (LENGTH VTLN_45ANGLE < VTLN_L_1) NOT INSIDE EDGE SRAM_EXCLUDE
}

//VTL_P CHECKS
//============

VTLP_R = COPY VTLPs
// waive one track overlap 	  
VTLP_A1 = INT VTLPs < VTLP_W_1 ABUT < 90 REGION PROJ==0
VTLP_B1 = VTLP_R NOT (EXPAND EDGE VTLP_R INSIDE BY VTLP_R_3/2)	
VTLP_C1 = EXT VTLP_B1 < GRID SINGULAR INTERSECTING ONLY REGION
VTLP_D1 = VTLP_A1 ENCLOSE VTLP_C1
// waive one track space
VTLP_A2 = EXT VTLPs < VTLP_S_1 ABUT < 90 REGION PROJ==0
VTLP_B2 = VTLP_R OR (EXPAND EDGE VTLP_R OUTSIDE BY VTLP_R_3/2)
VTLP_C2 = EXT VTLP_B2 < GRID SINGULAR INTERSECTING ONLY REGION
VTLP_D2  = VTLP_A2 ENCLOSE VTLP_C2
// waive point touch
VTLP_P = EXT VTLP_R < VTLP_S_1 SINGULAR INTERSECTING ONLY REGION

VTL_P.W.1 { @ Width >= ^VTLP_W_1. One-track(^VTLP_R_3) overlap is allowed
  X = INT VTLPs < VTLP_W_1 ABUT < 90 REGION
  (X INTERACT (X NOT VTLP_D1)) NOT INSIDE SRAM_EXCLUDE
}
VTL_P.S.1 { @ Space >= ^VTLP_S_1. Point touch of corners is allowed. One-track(^VTLP_R_3) space is allowed.
  X = EXT VTLPs < VTLP_S_1 ABUT < 90 REGION SINGULAR
  (X INTERACT (X NOT (VTLP_D2 OR VTLP_P))) NOT INSIDE SRAM_EXCLUDE
}
VTL_P.S.2_VTL_P.S.2.1 { @ Space to gate in PO endcap direction >= ^VTLP_S_2 & in S/D direction >= ^VTLP_S_2_1
  A = GATE NOT INTERACT VTLP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTLP_S_2_1 - VTLP_S_2)) OR A
  C = SIZE B BY VTLP_S_2
  VTLP AND C
}

// VTL_P.S.2 and VTL_P.S.2.1 are checked by VTL_P.S.2_VTL_P.S.2.1
VTL_P.S.3 { @ Space to unsilicided PO/OD resistor >= ^VTLP_S_3
  EXT VTLP ODPO_RES_RPO < VTLP_S_3 ABUT < 90 SINGULAR
  AND VTLP ODPO_RES_RPO    
}  
VTL_P.EN.1_VTL_P.EN.2 { @ Enclosure of gate in S/D direction >= ^VTLP_EN_1 & in PO endcap direction >= ^VTLP_EN_2 
  A = GATE INTERACT VTLP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTLP_EN_1 - VTLP_EN_2)) OR A
  C = SIZE B BY VTLP_EN_2
  C NOT VTLP
}
// VTL_P.EN.1 and VTL_P.EN.2 are checked by VTL_P.EN.1_VTL_P.EN.2
VTL_P.A.1 { @ Area >= ^VTLP_A_1
  (AREA VTLPs < VTLP_A_1) NOT INSIDE SRAM_EXCLUDE
}
VTL_P.A.2 { @ Enclosed area >= ^VTLP_A_2
  A = HOLES VTLP INNER
  B = A NOT VTLP
  AREA B < VTLP_A_2
}
VTL_P.R.1 { @ Overlap of N+ACTIVE, VAR, VTH_P, NT_N, or OD2 is not allowed.   
  VTLP AND OD2
  VTLP AND NTN
  VTLP AND NACT
  VTLP AND VTHP
}
// VTL_P.R.2 and VTL_P.R.3 are checked by VTL_P.W.1 and VTL_P.S.1
VTL_P.L.1 { @ 45-degree edge length 0.5  
  VTLP_45ANGLE = VTLP ANGLE == 45
  (LENGTH VTLP_45ANGLE < VTLP_L_1) NOT INSIDE EDGE SRAM_EXCLUDE
}




// VTL_N_18 CHECK
//===============
VTLN18_OD      = VTLN18 AND OD
VTLN18_PO      = VTLN18 AND POLY
VTLN18_GATE    = VTLN18 AND GATE
VTLN18_SRDPO   = VTLN18 AND SRDPO
VTLN18_GATE_W  = VTLN18_PO INSIDE EDGE VTLN18_OD
VTLN18_GATE_L  = VTLN18_OD INSIDE EDGE VTLN18_PO
VTLN18_DACT    = VTLN18 AND DACT
VTLN18_NTN     = VTLN18 AND NTN

VTL_N_18.W.1 { @ Channel length >= ^VTLN18_W_1 um 
  INT VTLN18_GATE_W < VTLN18_W_1 ABUT < 90 REGION
}
VTL_N_18.W.1.1 { @ Maximum channel length <= ^VTLN18_W_1_1 um
  LENGTH VTLN18_GATE_L > VTLN18_W_1_1
}
VTL_N_18.W.1.2 { @ SR_DPO(17;7) width in VTL_N_18 == ^VTLN18_W_1_2 um 
  VTLN18_SRDPO NOT WITH WIDTH == VTLN18_W_1_2
}
VTL_N_18.W.2 { @ Channel Width >= ^VTLN18_W_2 um 
  LENGTH VTLN18_GATE_W < VTLN18_W_2
}
VTL_N_18.W.3 { @ Channel Width <= ^VTLN18_W_3 um 
  LENGTH VTLN18_GATE_W > VTLN18_W_3
}
VTL_N_18.S.1 { @ Gate Space == ^VTLN18_S_1
  A = EXT [VTLN18_GATE] == VTLN18_S_1 ABUT < 90
  B = EXT [VTLN18_GATE] VTLN18_SRDPO == VTLN18_S_1 ABUT < 90
  VTLN18_GATE_W NOT COIN EDGE ( A OR EDGE B )
}
VTL_N_18.S.2 { @ {SR_DPO on OD} space to {gate OR SR_DPO on field} in S/D direction == ^VTLN18_S_2
  Field_SRDPO = SRDPO NOT INTERACT OD
  FSRDPO_GATE = Field_SRDPO OR VTLN18_GATE
  GOOD_EDGE = EXT [VTLN18_SRDPO] FSRDPO_GATE == VTLN18_S_2 ABUT < 90 OPPOSITE
  SUS_EDGE = VTLN18_SRDPO INSIDE EDGE VTLN18_OD
  SUS_EDGE NOT COIN EDGE GOOD_EDGE
}
VTL_N_18.S.3 { @ VTL_N_18 space to OD >= ^VTLN18_S_3 um 
  EXT VTLN18 OD < VTLN18_S_3 ABUT < 90 SINGULAR REGION
}
VTL_N_18.EN.1 { @ OD enclosure of NT_N == ^VTLN18_EN_1 um 
  VTLN18_OD_S = SIZE VTLN18_OD BY -VTLN18_EN_1
  XOR VTLN18_NTN VTLN18_OD_S
}
VTL_N_18.EN.2 { @ OD enclosure of gate in S/D direction >= ^VTLN18_EN_2 um 
  ENC VTLN18_GATE OD < VTLN18_EN_2 ABUT > 0 < 90 SINGULAR REGION
}
VTL_N_18.EN.3 { @ OD enclosure of SR_DPO in S/D direction == ^VTLN18_EN_3 um
  EDGE_OD = ((VTLN18_OD NOT VTLN18_PO) NOT VTLN18_SRDPO) INTERACT (VTLN18_PO OR VTLN18_SRDPO) == 1
  ENC_OD = INT EDGE_OD == VTLN18_EN_3 ABUT < 90 OPPOSITE REGION
  (VTLN18_SRDPO COIN EDGE EDGE_OD) NOT COIN EDGE ENC_OD
}
VTL_N_18.EN.4 { @ OD_18 enclosure of VTL_N_18 >= ^VTLN18_EN_4 um 
  VTLN18 NOT OD18
}


VTL_N_18.R.1 { @ {OD inside VTL_N_18} must be rectangular.
  NOT RECTANGLE VTLN18_OD
}

VTL_N_18.R.2 { @ VTL_N_18 overlap of VTH_N, VTH_P, VTL_N, VTL_P, PP, VAR, RPO, RH, NWDMY, BJTDMY, OD_25 is not allowed.
  VTLN18 AND VTHN
  VTLN18 AND VTHP
  VTLN18 AND VTLN
  VTLN18 AND VTLP
  VTLN18 AND PP
  VTLN18 AND VAR
  VTLN18 AND RPO
  VTLN18 AND RH
  VTLN18 AND NWDMY
  VTLN18 AND BJTDMY
  VTLN18 AND OD25
}


//PP CHECKS
//=========

ODIMP = OD COINCIDENT INSIDE EDGE IMP
PP_BEDGE = PP INSIDE EDGE OD   

PP.W.1 { @ Width >= 0.18 
  (INT PP < PP_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
PP.S.1 { @ Space >= 0.18 
  (EXT PP < PP_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
}
PP.S.2 { @ Space to N+ACTIVE (non-butted) >= 0.08 
  WAIVE_REGION = COPY SRAM_REGION
  NACT_CHECK = NACT NOT OD_DMY
  (EXT PP NACT_CHECK < PP_S_2 ABUT < 90 > 0 OPPOSITE REGION) NOT INSIDE SRAM_REGION
  (EXT PP NACT_CHECK < PP_S_2 ABUT < 90 > 0 CORNER SINGULAR REGION) NOT INSIDE SRAM_REGION
  (EXT PP NACT_CHECK < PP_S_2 ABUT < 90 > 0 PROJ == 0 REGION) NOT INSIDE SRAM_REGION
  X = EXT PP [NACT] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT PPOD) NOT INSIDE SRAM_REGION 
}


// PP.S.3 is checked by PP.S.2 and PP.R.2

PP.S.4 { @ Space to NW STRAP (non-butted) >= 0.02 
  EXT PP NSTP < PP_S_4 ABUT < 90 > 0 SINGULAR REGION
  X = EXT PP [NSTP] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT PPOD
}
PP.S.5 { @ {PP edge on OD} space to NMOS GATE >= 0.23 
  EXT GATEN_W PP_BEDGE < PP_S_5 ABUT < 90 OPPOSITE REGION
}

EX_GATEN = EXPAND EDGE GATEN_W OUTSIDE BY PP_S_6 EXTEND BY PP_S_6_J

PP.S.6 { @ Butted PW STRAP space to PO in the same OD [the butted N+ ACTIVE extending  < J1 < 0.13 um] >= 0.23 
  A = EX_GATEN AND BUTT_PSTP
  B = EX_GATEN AND NACT
  C = A INTERACT B
  D = SD INTERACT C
  E = GATEN_W COIN OUTSIDE EDGE D
  F = EXPAND EDGE E OUTSIDE BY PP_S_6 EXTEND BY PP_S_6_J
  C AND F
}

PP.S.7 { @ Space to N-type unsilicided OD/PO resistor >= 0.14 
  EXT PP ODPO_RES_RPO_NP < PP_S_7 ABUT < 90 SINGULAR REGION
}

PP.EN.1 { @ {NP OR PP} enclosure of PO (except DPO) >= 0.11 
  WAIVE_REGION = COPY SRAM_REGION
  A = POLY NOT INSIDE WAIVE_REGION  
  (ENC A IMP < PP_EN_1 ABUT < 90 SINGULAR REGION) NOT INSIDE WAIVE_REGION
  (POLY NOT LOGO) NOT IMP
}


PP.EX.1 { @ Extension on P+ACTIVE >= 0.08 
  PACT_CHECK = (PACT NOT OD_DMY) NOT INSIDE SRAM_REGION  
  ENC PACT_CHECK PP < PP_EX_1 ABUT < 90 > 0 SINGULAR REGION
  X = ENC [PACT_CHECK] PP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT NPOD
  (EXPAND EDGE ODIMP INSIDE BY 0.001) AND PACT_CHECK
}

PP.EX.2 { @ Extension on PW STRAP (except sealring(162;2)) >= 0.02 
  PSTP_CHECK = (PSTP NOT SEALRING_EXCLUDE) NOT INSIDE SRAM_REGION 
  ENC PSTP_CHECK PP < PP_EX_2 ABUT < 90 > 0 SINGULAR REGION
  X = ENC [PSTP_CHECK] PP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT NPOD
  (EXPAND EDGE ODIMP INSIDE BY 0.001) AND PSTP_CHECK
}

PP.EX.3 { @ Extension on P-type unsilicided OD/PO resistor >= 0.14 
  ENC ODPO_RES_RPO_PP PP < PP_EX_3 ABUT < 90 SINGULAR
}

PP.EX.4 { @ {PP edge on OD} extension on PMOS GATE >= 0.23 
  ENC GATEP_W PP_BEDGE < PP_EX_4 ABUT < 90 OPPOSITE REGION
}
PP.O.1 { @ Overlap of OD >= 0.10 
  INT OD PP < PP_O_1 ABUT < 90 > 0 SINGULAR REGION
}
PP.A.1 { @ Area >= 0.11 
  AREA (PP NOT INSIDE SRAM_REGION) < PP_A_1
}
PP.A.2 { @ Enclosed area >= 0.11 
  A = HOLES PP INNER
  B = A NOT PP
  (AREA B < PP_A_2) NOT INSIDE SRAM_EXCLUDE
}
PP.A.3 { @ Area of butted PW STRAP >= 0.021 
  AREA BUTT_PSTP < PP_A_3
}

PP.R.1 { @ PP must fully cover {PMOS GATE SIZING 0.08 um} >= 0.08 
  CHECK_GATE = GATE_PP NOT INSIDE SRAM_REGION
  EXGATE_PP = SIZE CHECK_GATE BY PP_R_1
  EXGATE_PP NOT PP
}

PP.R.2 { @ Overlap of NP is not allowed.   
  PP AND NP
}
// PP.R.3 is checked by OD.R.1
// PP.R.4 is checked by PP.EN.1
PP.L.1 { @ 45-degree edge length 0.5  
  PP_45ANGLE = PP ANGLE == 45
  (LENGTH PP_45ANGLE < PP_L_1) NOT INSIDE EDGE SRAM_EXCLUDE
}



//NP CHECKS
//=========

NP_BEDGE = NP INSIDE EDGE OD   
NP.W.1 { @ Width >= 0.18 
  (INT NP < NP_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
}
NP.S.1 { @ Space >= 0.18 
  (EXT NP < NP_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
NP.S.2 { @ Space to P+ACTIVE (non-butted) >= 0.08 
  PACT_CHECK = PACT NOT OD_DMY  
  (EXT NP PACT_CHECK < NP_S_2 ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE SRAM_REGION
  X = EXT NP [PACT_CHECK] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT NPOD) NOT INSIDE SRAM_REGION
}
// NP.S.3 is checked by NP.S.2 and PP.R.2
NP.S.4 { @ Space to PW STRAP (non-butted) >= 0.02 
  WAIVE_REGION = COPY SRAM_REGION
  (EXT NP PSTP < NP_S_4 ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE WAIVE_REGION
  X = EXT NP [PSTP] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT NPOD) NOT INSIDE WAIVE_REGION
}
NP.S.5 { @ {NP edge on OD} space to PMOS GATE >= 0.23 
  EXT GATEP_W NP_BEDGE < NP_S_5 ABUT < 90 OPPOSITE REGION
}

EX_GATEP = EXPAND EDGE GATEP_W OUTSIDE BY NP_S_6 EXTEND BY NP_S_6_J

NP.S.6 { @ Butted NW STRAP space to PO in the same OD [the butted P+ ACTIVE extending  < J1 < 0.13 um] >= 0.23 
  A = EX_GATEP AND BUTT_NSTP
  B = EX_GATEP AND PACT
  C = A INTERACT B
  D = SD INTERACT C
  E = GATEP_W COIN OUTSIDE EDGE D
  F = EXPAND EDGE E OUTSIDE BY NP_S_6 EXTEND BY NP_S_6_J
  C AND F
}
NP.S.7 { @ Space to P-type unsilicided OD/PO resistor >= 0.14 
  EXT NP ODPO_RES_RPO_PP < NP_S_7 ABUT < 90 SINGULAR REGION
}

// NP.EN.1 is checked by PP.EN.1
NP.EX.1 { @ Extension on N+ACTIVE (except NWROD) >= 0.08 
  NACT_CHECK = ((NACT NOT ODWR) NOT OD_DMY) NOT INSIDE SRAM_REGION
  ENC NACT_CHECK NP < NP_EX_1 ABUT < 90 > 0 SINGULAR REGION
  X = ENC [NACT_CHECK] NP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT PPOD 
  (EXPAND EDGE ODIMP INSIDE BY 0.001) AND NACT_CHECK
}
NP.EX.2 { @ Extension on NW STRAP (except NWROD) >= 0.02 
  ENC NSTP NP < NP_EX_2 ABUT < 90 > 0 SINGULAR REGION
  X = ENC [NSTP] NP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT PPOD
  (EXPAND EDGE ODIMP INSIDE BY 0.001) AND NSTP
}
NP.EX.3 { @ Extension on N-type unsilicided OD/PO resistor >= 0.14 
  ENC ODPO_RES_RPO_NP NP < NP_EX_3 ABUT < 90 SINGULAR REGION
}
NP.EX.4 { @ {NP edge on OD} extension on NMOS GATE >= 0.23 
  ENC GATEN_W NP_BEDGE < NP_EX_4 ABUT < 90 OPPOSITE REGION
}
NP.O.1 { @ Overlap of OD >= 0.10 
  INT OD NP < NP_O_1  ABUT < 90 > 0 SINGULAR REGION
}
NP.A.1 { @ Area >= 0.11 
  AREA (NP NOT INSIDE SRAM_EXCLUDE) < NP_A_1
}
NP.A.2 { @ Enclosed area >= 0.11 
  A = HOLES NP INNER
  B = A NOT NP
  (AREA B < NP_A_2) NOT INSIDE SRAM_REGION
}
NP.A.3 { @ Area of butted NW STRAP >= 0.021 
  AREA BUTT_NSTP < NP_A_3
}  

NP.R.1 { @ NP must fully cover {NMOS GATE SIZING 0.08 um} >= 0.08 
  CHECK_GATE = GATE_NP NOT INSIDE SRAM_REGION
  EXGATE_NP = SIZE CHECK_GATE BY NP_R_1
  EXGATE_NP NOT NP
}

// NP.R.2 is checked by PP.R.2
// NP.R.3 is checked by OD.R.1
// NP.R.4 is checked by PP.EN.1
NP.L.1 { @ 45-degree edge length 0.5  
  NP_45ANGLE = NP ANGLE == 45
  (LENGTH NP_45ANGLE < NP_L_1) NOT INSIDE EDGE SRAM_EXCLUDE
}




//LOGICAL OPERATION RULE
//======================
VARIABLE  NLDDN1V_SU  0.089
VARIABLE  NLDDN1V_SD  0.178
VARIABLE  NLDDN2V_SU  0.089
VARIABLE  NLDDN2V_SD  0.178
VARIABLE  VTLN_SU     0.089
VARIABLE  VTLN_SD     0.178
VARIABLE  PLDDP1V_SU  0.089
VARIABLE  PLDDP1V_SD  0.178
VARIABLE  PLDDP2V_SU  0.089
VARIABLE  PLDDP2V_SD  0.178
VARIABLE  VTLP_SU     0.089
VARIABLE  VTLP_SD     0.178

VTLND = COPY VTLN 
VTLPD = COPY VTLP 


NP_NOT_NW = NP NOT NWEL
NLDDN1 = ((((NP_NOT_NW NOT OD2) NOT RH) NOT VAR) NOT BJTDMY) NOT POFUSE
NLDDN1V = SIZE (SIZE (SIZE NLDDN1 BY NLDDN1V_SU) BY - NLDDN1V_SD) BY NLDDN1V_SU
#IFDEF GS
NLDDN2 = (((((NP_NOT_NW AND OD2) NOT RH) NOT VAR) NOT BJTDMY) NOT NTN) NOT POFUSE
#ELSE
NLDDN2 = ((((NP_NOT_NW AND OD2) NOT RH) NOT VAR) NOT BJTDMY) NOT POFUSE
#ENDIF
NLDDN2V = SIZE (SIZE (SIZE NLDDN2 BY NLDDN2V_SU) BY - NLDDN2V_SD) BY NLDDN2V_SU

VTL_N_LD = SIZE (SIZE (SIZE ((OD2 OR NWEL) OR VTLND) BY VTLN_SU) BY -VTLN_SD) BY VTLN_SU

PP_AND_NW = PP AND NWEL
PLDDP1 = ((((PP_AND_NW NOT OD2) NOT RH) NOT VAR) NOT BJTDMY) NOT POFUSE
PLDDP1V = SIZE (SIZE (SIZE PLDDP1 BY PLDDP1V_SU) BY - PLDDP1V_SD) BY PLDDP1V_SU
PLDDP2 = ((((PP_AND_NW AND OD2) NOT RH) NOT VAR) NOT BJTDMY) NOT POFUSE
PLDDP2V = SIZE (SIZE (SIZE PLDDP2 BY PLDDP2V_SU) BY - PLDDP2V_SD) BY PLDDP2V_SU

VTL_P_LD = SIZE (SIZE (SIZE ((NWEL NOT OD2) NOT VTLPD) BY VTLP_SU) BY -VTLP_SD) BY VTLP_SU

LDN.EX.1 { @ NP extension on NW >= ^LDN_EX_1 um. 
@ LDN.EX.2  NP extension on OD2 >= ^LDN_EX_1 
@ LDN.EX.3  NP extension on {RH OR BJTDMY} >= ^LDN_EX_1
@ LDN.EX.4  NP extension on VAR >= ^LDN_EX_1
  A = INT NLDDN1V < LDN_EX_1 ABUT < 90 OPPOSITE REGION
  B = EXT NLDDN1V < LDN_EX_1 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A 0.1 LDN_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B 0.1 LDN_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT NLDDN1V < LDN_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT NLDDN1V < LDN_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT NLDDN1V < LDN_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT NLDDN1V < LDN_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}

LDN.O.1 { @ NP overlap of OD2 >= ^LDN_O_1
@ LDN.EX.1  NP extension on NW  >= ^LDN_O_1 
@ LDN.EX.3  NP extension on {RH OR BJTDMY} >= ^LDN_O_1
@ LDN.EX.4  NP extension on VAR >= ^LDN_O_1
  A = INT NLDDN2V < LDN_O_1 ABUT < 90 OPPOSITE REGION
  B = EXT NLDDN2V < LDN_O_1 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A 0.1 LDN_O_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B 0.1 LDN_O_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT NLDDN2V < LDN_O_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT NLDDN2V < LDN_O_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT NLDDN2V < LDN_O_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT NLDDN2V < LDN_O_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}

// LDN.EX.1 is checked by LDN.EX.1 and LDN.O.1
// LDN.EX.2 is checked by LDN.EX.1
// LDN.EX.3 is checked by LDN.EX.1 and LDN.O.1
// LDN.EX.4 is checked by LDN.EX.1 and LDN.O.1

LDP.EX.1 { @ PP extension on OD2 >= ^LDP_EX_1
@ LDP.EX.2  PP extension on {RH OR BJTDMY} >= ^LDP_EX_1 
@ LDP.EX.3  PP extension on VAR. >= ^LDP_EX_1
@ LDP.O.1  PP overlap of NW. >= ^LDP_EX_1
  A = INT PLDDP1V < LDP_EX_1 ABUT < 90 OPPOSITE REGION
  B = EXT PLDDP1V < LDP_EX_1 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A 0.1 LDP_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B 0.1 LDP_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT PLDDP1V < LDP_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT PLDDP1V < LDP_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT PLDDP1V < LDP_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT PLDDP1V < LDP_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}


LDP.O.2 { @ PP overlap of OD2 >= ^LDP_O_2 
@ LDP.EX.2  PP extension on {RH OR BJTDMY} >= ^LDP_O_2 
@ LDP.EX.3  PP extension on VAR. >= ^LDP_O_2
@ LDP.O.1  PP overlap of NW. >= ^LDP_O_2
  A = INT PLDDP2V < LDP_O_2 ABUT < 90 OPPOSITE REGION
  B = EXT PLDDP2V < LDP_O_2 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A 0.1 LDP_O_2 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B 0.1 LDP_O_2 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT PLDDP2V < LDP_O_2 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT PLDDP2V < LDP_O_2 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT PLDDP2V < LDP_O_2 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT PLDDP2V < LDP_O_2 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}

// LDP.EX.2 is checked by LDP.EX.1 and LDP.O.2
// LDP.EX.3 is checked by LDP.EX.1 and LDP.O.2
// LDP.O.1 is checked by LDP.EX.1 and LDP.O.2

VT.S.1 { @ VTL_N space to {OD2 OR NW} >= ^VT_S_1 
 A = INT VTL_N_LD < VT_S_1 ABUT < 90 OPPOSITE REGION
 B = EXT VTL_N_LD < VT_S_1 ABUT < 90 OPPOSITE REGION
 (NOT ENCLOSE RECTANGLE A 0.1 VT_S_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
 (NOT ENCLOSE RECTANGLE B 0.1 VT_S_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
 (INT VTL_N_LD < VT_S_1 ABUT < 90 CORNER REGION) NOT INSIDE SRAM_EXCLUDE
 D = INT VTL_N_LD < VT_S_1 ABUT < 90 PROJ == 0 REGION
 (D INTERACT (D NOT VTLN_D1)) NOT INSIDE SRAM_EXCLUDE
 E = EXT VTL_N_LD < VT_S_1 ABUT < 90 CORNER SINGULAR REGION
 (E INTERACT (E NOT VTLN_P)) NOT INSIDE SRAM_EXCLUDE
 F = EXT VTL_N_LD < VT_S_1 ABUT < 90 PROJ == 0 REGION
 (F INTERACT (F NOT VTLN_D2)) NOT INSIDE SRAM_EXCLUDE
}

VT.EX.2 { @ NW extension on {OD2 OR VTL_P} >= ^VT_EX_2 
 A = INT VTL_P_LD < VT_EX_2 ABUT < 90 OPPOSITE REGION
 B = EXT VTL_P_LD < VT_EX_2 ABUT < 90 OPPOSITE REGION
 (NOT ENCLOSE RECTANGLE A 0.1 VT_EX_2 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
 (NOT ENCLOSE RECTANGLE B 0.1 VT_EX_2 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
 C = INT VTL_P_LD < VT_EX_2 ABUT < 90 CORNER REGION SINGULAR
 (C INTERACT (C NOT VTLP_P)) NOT INSIDE SRAM_EXCLUDE
 D = INT VTL_P_LD < VT_EX_2 ABUT < 90 PROJ == 0 REGION
 (D INTERACT (D NOT VTLP_D2)) NOT INSIDE SRAM_EXCLUDE
 (EXT VTL_P_LD < VT_EX_2 ABUT < 90 CORNER REGION) NOT INSIDE SRAM_EXCLUDE 
 F = EXT VTL_P_LD < VT_EX_2 ABUT < 90 PROJ == 0 REGION
 (F INTERACT (F NOT VTLP_D1)) NOT INSIDE SRAM_EXCLUDE
}


// ESDIMP CHECKS
//==============

ESDIMP.W.1 { @ Width >= ^ESDIMP_W_1 um
  INT ESDIMP < ESDIMP_W_1 ABUT < 90 SINGULAR REGION
}
ESDIMP.S.1 { @ Space >= ^ESDIMP_S_1 um
  EXT ESDIMP < ESDIMP_S_1 ABUT < 90 SINGULAR REGION
}
ESDIMP.EN.1 { @ (OD NOT PO) enclosure of ESDIMP. ESDIMP must be fully inside (OD NOT PO). >= 0.4 
  OD_NPO = OD NOT POLY
  ENC ESDIMP OD_NPO < ESDIMP_EN_1 ABUT < 90 SINGULAR REGION
  ESDIMP NOT OD_NPO
}
ESDIMP.A.1 { @ Area >= 1.0 
  AREA ESDIMP < ESDIMP_A_1
}
ESDIMP.A.2 { @ Enclosed area >= 1.0 
  A = HOLES ESDIMP INNER
  B = A NOT ESDIMP
  AREA B < ESDIMP_A_2
}
ESDIMP.R.1 { @ ESDIMP must be fully inside N+ ACTIVE   
  ESDIMP NOT NACT
}



//RPO CHECKS
//==========

FPO1A      = FPO1 NOT SDI
Wide_RPO   = RPO INTERACT (SIZE RPO BY - RPO_EX_1_1_W /2)

RPO.W.1 { @ WidthA 0.40  
  INT RPO < RPO_W_1 ABUT < 90 SINGULAR REGION
}
RPO.S.1 { @ Space >= 0.40 
  EXT RPO < RPO_S_1 ABUT < 90 SINGULAR REGION
}
RPO.S.2 { @ Space to OD >= 0.22 
  EXT RPO OD < RPO_S_2 ABUT < 90 SINGULAR REGION
}
RPO.S.3 { @ Space to CO (overlap of CO is not allowed.) >= 0.22 
  EXT RPO CO < RPO_S_3 ABUT < 90 SINGULAR REGION
  (RPO AND CO) NOT ICOVL
}
RPO.S.4 { @ Space to GATE (overlap of GATE is not allowed except ESD circuit.) >= 0.38 
  NOGT = GATE NOT (SDI OR ICOVL)
  EXT RPO NOGT < RPO_S_4 ABUT < 90 SINGULAR REGION
  RPO AND NOGT
}
RPO.S.5 { @ Space to PO >= 0.30 
  EXT RPO FPO1 < RPO_S_5 ABUT < 90 SINGULAR REGION
}

OD_NOSDI = OD NOT SDI
RPO.EX.1 { @ Extension on unsilicided OD/PO (This check doesn't include the regions covered by the layer SDI) >= 0.22 
  ENC OD_NOSDI RPO < RPO_EX_1 ABUT < 90 SINGULAR REGION
  ENC FPO1A RPO < RPO_EX_1 ABUT < 90 SINGULAR REGION
  RPO INSIDE OD_NOSDI
  RPO INSIDE FPO1A  
}
RPO.EX.1.1 { @ Extension on unsilicided OD/PO [RPO width > 10 um] (This check doesn't include the regions covered by the layer SDI) >= 0.30 
  ENC OD_NOSDI Wide_RPO < RPO_EX_1_1 ABUT < 90 SINGULAR REGION
  ENC FPO1A Wide_RPO < RPO_EX_1_1 ABUT < 90 SINGULAR REGION
}
Wide_RPO2 = RPO INTERACT (WITH WIDTH RPO <= RPO_EX_1_2_W)
RPO.EX.1.2 { @ Extension on unsilicided OD/PO [RPO width <= 0.43 um] (This check doesn't include the regions covered by the layer SDI) >= 0.30 
  ENC OD_NOSDI Wide_RPO2 < RPO_EX_1_2 ABUT < 90 SINGULAR REGION
  ENC FPO1A Wide_RPO2 < RPO_EX_1_2 ABUT < 90 SINGULAR REGION
}
RPO.EX.2 { @ OD extension on RPO >= 0.22 
  ENC RPO OD < RPO_EX_2 ABUT < 90 SINGULAR REGION
}
RPO.A.1 { @ Area >= 1.00 
  (AREA RPOs < RPO_A_1) NOT INSIDE SRAM_EXCLUDE
}
RPO.A.2 { @ Enclosed area >= 1.00 
  A = HOLES RPO INNER
  B = A NOT RPO
  AREA B < RPO_A_2
}  
RPO.R.1 { @ Butted NP/PP on unsilicided OD/PO is not allowed.   
  X = (RPO AND POLY) OR (RPO AND OD)
  NX = X AND NP
  PX = X AND PP    
  Y  = NX INTERACT PX
  X INTERACT Y
}  



//RES CHECKS
//==========

RES.W.1.OD { @ Width of unsilicide OD resistor >= ^RES_W_1
  INT OD_RES_RPO < RES_W_1 ABUT < 90 SINGULAR REGION
}
RES.W.1.PO { @ Width of unsilicide PO resistor >= ^RES_W_1
  INT PO_RES_RPO < RES_W_1 ABUT < 90 SINGULAR REGION
}
// RES.W.1 is checked by RES.W.1.OD, RES.W.1.PO

RES.L.1.OD { @ Length of unsilicide OD resistor >= ^RES_L_1
  RES_L = OD_RES_RPO INSIDE EDGE RPO
  X = PATH LENGTH RES_L < RES_L_1
  CHECK_RES = OD_RES_RPO WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE RPO
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY (RES_L_1/2 - GRID*2) INSIDE OF OD_RES_RPO STEP OD_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}
RES.L.1.PO { @ Length of unsilicide PO resistor >= ^RES_L_1
  RES_L = PO_RES_RPO INSIDE EDGE RPO
  X = PATH LENGTH RES_L < RES_L_1
  CHECK_RES = PO_RES_RPO WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE RPO
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY (RES_L_1/2 - GRID*2) INSIDE OF PO_RES_RPO STEP PO_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}
// RES.L.1 is checked by RES.L.1.OD, RES.L.1.PO

OD_RES_RPO_L = EXPAND EDGE (OD_RES_RPO NOT INSIDE EDGE OD) BY 0.005
OD_RES_RPO_W = EXPAND EDGE (OD_RES_RPO INSIDE EDGE OD) BY 0.005
CONNECT OD_RES_RPO_L OD_RES_RPO_W

RES.R.1.OD { @ Square number (length/width) of unsilicided OD resistor >= ^RES_R_1
  NET AREA RATIO OD_RES_RPO_L OD_RES_RPO_W < RES_R_1
}

PO_RES_RPO_L = EXPAND EDGE (PO_RES_RPO NOT INSIDE EDGE POLY) BY 0.005
PO_RES_RPO_W = EXPAND EDGE (PO_RES_RPO INSIDE EDGE POLY) BY 0.005
CONNECT PO_RES_RPO_L PO_RES_RPO_W

RES.R.1.PO { @ Square number (length/width) of unsilicided PO resistor >= ^RES_R_1
  NET AREA RATIO PO_RES_RPO_L PO_RES_RPO_W < RES_R_1
}
// RES.R.1 is checked by RES.R.1.OD, RES.R.1.PO

RES.S.1 { @ RH space to Gate in source or drain direction for unsilicided OD resistor >= ^RES_S_1
   RH_CHECK = RH INTERACT OD_RES_RPO 
   EXT RH_CHECK GATE_W < RES_S_1 ABUT < 90 OPPOSITE REGION
}
RES.S.2 {@ RH space to GATE (overlap is not allowed) >= ^RES_S_2
  EXT RH GATE < RES_S_2 ABUT<90 SINGULAR REGION
  RH AND GATE
}
RES.EN.1 { @ RH enclosure of unsilicided/silicided OD/PO resistor >= ^RES_EN_1
  ENC OD_RES RH < RES_EN_1 ABUT < 90 SINGULAR REGION
  ENC PO_RES RH < RES_EN_1 ABUT < 90 SINGULAR REGION
}

RES.R.2 { @ RPO intersecting {(PO AND RH) AND RPDMY} must form two or more POs   
   A = (POLY INTERACT PO_RES_RPO) NOT PO_RES_RPO
   PO_RES_RPO NOT INTERACT A >=  2
} 
RES.R.3 { @ RPO intersecting {(OD AND RH) AND RPDMY} must form two or more ODs   
   A = (OD INTERACT OD_RES_RPO) NOT OD_RES_RPO
   OD_RES_RPO NOT INTERACT A >=  2
}
RES.R.4 { @ {RPDMY AND PO} must be fully covered by RH
   (RPDMY AND POLY) NOT RH
}
RES.R.5 { @ {RPDMY AND OD} must be fully covered by RH
   (RPDMY AND OD) NOT RH
}



//VAR CHECKS
//==========
VAR_GATE     = GATE NOT OUTSIDE VAR
VAR_GATE_W   = VAR_GATE INSIDE EDGE OD
DVAR_GATE = GATE NOT OUTSIDE DVAR
DVAR_GATE_W = DVAR_GATE INSIDE EDGE OD

VAR.W.1 { @ Channel length of {gate AND VAR} >= 0.2 
  INT VAR_GATE_W < VAR_W_1 ABUT < 90 REGION
}
VAR.W.3 { @ Channel length of {(gate AND OD2) AND VAR} >= 0.4 
  VAR_HV_GATE_W = (VAR_GATE_W INSIDE EDGE OD2) OUTSIDE EDGE DVAR
  INT VAR_HV_GATE_W < VAR_W_3 ABUT < 90 REGION
}
VAR.W.4 { @ Channel width of {gate AND VAR} >= 0.32 
  LENGTH VAR_GATE_W < VAR_W_4 
}

VAR.W.5 { @ Channel length of { (gate AND OD2) AND DVAR } >= ^VAR_W_5
  DVAR_HV_GATE_W = DVAR_GATE_W INSIDE EDGE OD2 
  INT DVAR_HV_GATE_W < VAR_W_5 ABUT < 90 REGION    
} 

VAR.S.1 { @ Space to ACTIVE >= 0.13 
  EXT VAR DACT < VAR_S_1 ABUT < 90 SINGULAR REGION
}
VAR.EN.1 { @ Enclosure of OD (Cut is not allowed) >= 0.16 
  ENC OD VAR < VAR_EN_1 ABUT < 90 SINGULAR REGION
  OD CUT VAR
}
VAR.R.1 { @ VAR layer must be drawn to fully cover the varactor devices. DRC only checks VAR fully cover gate.   
@ VAR layer must be drawn to fully cover the differential varactor
  DVAR_GATE NOT VAR 
  VAR_GATE NOT VAR
}
VAR.R.2 { @ Overlap of VTL_N, VTL_P, VTH_N, VTH_P, NT_N, or RPO is not allowed.   
  VAR AND VTLN
  VAR AND VTLP
  VAR AND VTHN
  VAR AND VTHP
  VAR AND NTN
  VAR AND RPO
}

VAR.R.3 { @ PP overlap of {(gate AND NW) AND VAR} is not allowed.   
  (VAR_GATE AND NWEL) AND PP
}

VAR.R.3.1 { @ NP overlap of {(gate AND PW) AND VAR} is not allowed.   
  (VAR_GATE AND PWEL) AND NP
}

VAR.R.4 { @ Overlap to {(PO AND ACTIVE) SIZING 0.16 um} is not allowed   
  VAR_E = SIZE VAR BY VAR_W_1 	// For filtering only
  VAR_EXG = (GATE INTERACT VAR_E) OUTSIDE VAR
  VAR_EXGS = SIZE VAR_EXG BY VAR_R_4
  VAR AND VAR_EXGS
}
VAR.R.5 { @ NP must fully cover {(((VAR AND (GATE AND NW)) SIZING 0.19 um) AND OD) SIZING 0.13 um }   
  A = SIZE ((VAR AND GATE) AND NWEL) BY VAR_R_5_X
  B = SIZE (A AND OD) BY VAR_R_5_Y
  B NOT NP
}
VAR.R.5.1 { @ PP must fully cover {(((VAR AND (GATE AND PW)) SIZING 0.19 um) AND OD) SIZING 0.13 um }   
  A = SIZE ((VAR AND GATE) AND PWEL) BY VAR_R_5_1_X
  B = SIZE (A AND OD) BY VAR_R_5_1_Y
  B NOT PP
}

VAR.R.6 { @ DVAR layer must be drawn to fully cover the IO differential MOSVAR
  DVAR_GATE NOT DVAR
}
VAR.R.7 { @ DVAR overlap of {gate NOT OD2} is not allowed 
  DVAR AND LV_GATE
}
VAR.R.8 { @ PP overlap of {gate AND DVAR} is not allowed 
  PP AND DVAR_GATE 
}

#IFDEF GS
VAR.A.1 { @ Maximum core unit varactor gate area for GS process
  AREA ((GATE AND VAR) NOT OD2) > VAR_A_1
}
#ELSE
VAR.A.1 { @ Maximum core unit varactor gate area for LPG G device
  AREA (((GATE AND VAR) NOT OD2) AND DCO) > VAR_A_1
}
#ENDIF


//HVD_N CHECKS
//============

HVD_N.W.1 { @ Width >= 0.47 
  INT HVD_N < HVD_N_W_1 ABUT < 90 SINGULAR REGION
}
HVD_N.S.1 { @ Space >= 0.47 
  EXT HVD_N < HVD_N_S_1 ABUT < 90 SINGULAR REGION
}
HVD_N.S.2 { @ Space of two HVD_N with different potentials >= 1.37 
  A = STAMP HVD_N BY NSDc
  EXT A < HVD_N_S_2 ABUT < 90 NOT CONNECTED SINGULAR REGION
  B = HVD_N NOT INTERACT NSDc
  EXT B HVD_N < HVD_N_S_2 ABUT < 90 SINGULAR REGION SPACE
}
HVD_N.S.3 { @ Space to NW >= 1.6 
  EXT HVD_N NWEL < HVD_N_S_3 ABUT < 90 SINGULAR REGION
}
HVD_N.S.4 { @ Space to PW STRAP (overlap is not allowed) >= 0.3 
  EXT HVD_N PSTP < HVD_N_S_4 ABUT < 90 SINGULAR REGION
  HVD_N AND PSTP
}
HVD_N.S.5 { @ Space to N+ ACTIVE >= 0.6 
  EXT HVD_N NACT < HVD_N_S_5 ABUT < 90 SINGULAR REGION
}
HVD_N.S.6 { @ Space to DNW (overlap is not allowed) >= 3.0 
  EXT HVD_N DNW < HVD_N_S_6 ABUT < 90 SINGULAR REGION
  HVD_N AND DNW
}
HVD_N.EX.1 { @ Extension on N+ ACTIVE (Drian side must be fully inside HVD_N) >= 0.24 
  ENC NACT HVD_N < HVD_N_EX_1 ABUT < 90 SINGULAR REGION
  HVD_NMOS_DRAIN NOT HVD_N
}
HVD_N.O.1 { @ Overlap of {I/O NMOS GATE} = ^HVD_N_O_1
  A = HV_GATE_W COIN OUTSIDE EDGE HVD_NMOS_DRAIN
  B = EXPAND EDGE A INSIDE BY HVD_N_O_1
  C = HVD_N AND HVD_NGATE
  C XOR B 
  HVD_NGATE INTERACT B > 1
}
HVD_N.L.1 { @ Channel length of {gate interact with HVD_N} >= ^HVD_N_L_1
  A = HV_GATE_W COIN INSIDE EDGE HVD_NGATE 
  INT A < HVD_N_L_1 ABUT < 90 REGION
}
HVD_N.A.1 { @ Area >= 0.64 
  AREA HVD_N < HVD_N_A_1
}
HVD_N.A.2 { @ Enclosed area >= 0.64 
  A = HOLES HVD_N INNER
  B = A NOT HVD_N
  AREA B < HVD_N_A_2
}
HVD_N.R.1 { @ Overlap of NW is not allowed.   
  HVD_N AND NWEL 
}
HVD_N.R.2 { @ HVD_N edge landing on OD without landing on GATE is not allowed.   
  (HVD_N INSIDE EDGE OD) NOT INSIDE EDGE GATE
}
HVD_N.R.3 { @ HVD_N must be fully inside OD_25.   
  HVD_N NOT OD25 
}

HVD_N.R.4 { @ {(OD NOT PO) inside one HVD_N} must be same potential   
  HVD_N INTERACT NSDc > 1 BY NET 
}


//HVD_P CHECKS
//============

HVD_P.W.1 { @ Width >= 0.47 
  INT HVD_P < HVD_P_W_1 ABUT < 90 SINGULAR REGION
}
HVD_P.S.1 { @ Space >= 0.47 
  EXT HVD_P < HVD_P_S_1 ABUT < 90 SINGULAR REGION
}
HVD_P.S.2 { @ Space of two HVD_P with different potentials >= 1.2 
  A = STAMP HVD_P BY PSDc 
  EXT A < HVD_P_S_2 ABUT < 90 NOT CONNECTED SINGULAR REGION
  B = HVD_P NOT INTERACT PSDc
  EXT B HVD_P < HVD_P_S_2 ABUT < 90 SINGULAR REGION SPACE
}
HVD_P.S.4 { @ Space to NW STRAP (overlap is not allowed) >= 0.24 
  EXT HVD_P NSTP < HVD_P_S_4 ABUT < 90 SINGULAR REGION
  HVD_P AND NSTP
}
HVD_P.S.5 { @ Space to P+ ACTIVE >= 0.48 
  EXT HVD_P PACT < HVD_P_S_5 ABUT < 90 SINGULAR REGION
}
HVD_P.EX.1 { @ Extension on P+ ACTIVE(Drian side must be fully inside HVD_P) >= 0.24 
  ENC PACT HVD_P < HVD_P_EX_1 ABUT < 90 SINGULAR REGION
  HVD_PMOS_DRAIN NOT HVD_P
}
HVD_P.EN.1 { @ Enclosure by NW >= 0.6 
  ENC HVD_P NWEL < HVD_P_EN_1 ABUT < 90 SINGULAR REGION
}
HVD_P.EN.2 { @ Enclosure by DNW 0.6  
  ENC HVD_P DNW < HVD_P_EN_2 ABUT < 90 SINGULAR REGION
}
HVD_P.O.1 { @ Overlap of {I/O PMOS GATE} = ^HVD_P_O_1
  A = HV_GATE_W COIN OUTSIDE EDGE HVD_PMOS_DRAIN
  B = EXPAND EDGE A INSIDE BY HVD_P_O_1
  C = HVD_P AND HVD_PGATE
  C XOR B 
  HVD_PGATE INTERACT B > 1
}
HVD_P.L.1 { @ Channel length of {gate interact with HVD_P} >= ^HVD_P_L_1 
  A = HV_GATE_W COIN INSIDE EDGE HVD_PGATE 
  INT A < HVD_P_L_1 ABUT < 90 REGION
}
HVD_P.A.1 { @ Area >= 0.64 
  AREA HVD_P < HVD_P_A_1
}
HVD_P.A.2 { @ Enclosed area >= 0.64 
  A = HOLES HVD_P INNER
  B = A NOT HVD_P
  AREA B < HVD_P_A_2
}
HVD_P.R.1 { @ HVD_P must be inside NW   
  HVD_P NOT NWEL 
}
HVD_P.R.2 { @ HVD_P edge landing on OD without landing on GATE is not allowed.   
  (HVD_P INSIDE EDGE OD) NOT INSIDE EDGE GATE
}
HVD_P.R.3 { @ HVD_P must be fully inside OD_25.   
  HVD_P NOT OD25 
}
HVD_P.R.4 { @ {(OD NOT PO) inside same HVD_P} must be same potential   
   HVD_P INTERACT PSDc > 1 BY NET
}

HVD_P.R.6 { @ HVD_P must be inside DNW
   HVD_P NOT DNW
}


#ENDIF


//CO CHECKS
//=========
SRAM_CO  = COi INSIDE SRAM_REGION
SRAM_BCO = SRAM_CO NOT COPUSH   // sram butted contact, {CO not 30;11}
SRAM_SCO = SRAM_CO NOT SRAM_BCO // sram square contact

CO.W.1 { @ Width (maximum = minimum) (Except butted CO in SRAM (186;0) region only) = 0.06 
  NOT RECTANGLE (((COi NOT SEALRING_EXCLUDE) NOT ICOVL) NOT SRAM_BCO) == CO_W_1 BY == CO_W_1 ORTHOGONAL ONLY
}

CO.S.1 { @ Space (Except SRAM (186;0) region) >= 0.08 
  (EXT CO < CO_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
}

CO.S.2 { @ Space to 3-neighboring CO (distance < 0.11 um) (Except SRAM (186;0) region) >= 0.10 
  COx = RECTANGLE COs == CO_W_1 BY == CO_W_1 ORTHOGONAL ONLY
  X = WITH NEIGHBOR COx > 2 SPACE < CO_S_2_D
  (EXT X COx < CO_S_2 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
}

CO_NODAL = STAMP CO BY COi

CO.S.2.1 { @ Space [different net] (Except SRAM (186;0) region) >= 0.11 
  (EXT CO_NODAL < CO_S_2_1 ABUT < 90 NOT CONNECTED REGION) NOT INSIDE SRAM_REGION
}

CO.S.3 { @ Space to GATE (Overlap of GATE is not allowed) [space >= 0.035 um is allowed inside SRAM word line driver covered by layer 186;5 or 186;4] (Except SRAM (186;0) region) >= 0.04 
  A = EXT COOD GATE < CO_S_3 ABUT < 90 SINGULAR REGION
  (A NOT INSIDE SRAMDMY_PERI) NOT INSIDE SRAM_REGION
  (CO AND GATE) NOT INSIDE SRAM_REGION
  // Checks for SRAM periphery are implemented by WLD.R.2
}

CO.S.4 { @ {CO inside PO} space to OD (Except SRAM (186;0) region) >= 0.05 
  (EXT COPO OD < CO_S_4 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_REGION
}

CO.S.5 { @ {CO inside OD} space to I/O GATE >= 0.08 
  EXT COOD HV_GATE < CO_S_5 ABUT < 90 SINGULAR REGION
}
CO.S.5.1 { @ {CO inside drain side OD} space to HVD GATE = ^CO_S_5_1 
  CO_CHK = CO AND (HVD_NMOS_DRAIN OR HVD_PMOS_DRAIN)
  CO_GOOD = EXT [CO_CHK] HVD_GATE == CO_S_5_1 OPPOSITE
  CO_CHK NOT WITH EDGE CO_GOOD
}
CO.S.6 { @ Space to butted PP/NP edge on OD (overlap of NP/PP boundary on OD is not allowed.) >= 0.04 
  EXT NP_PP_BTE COOD < CO_S_6 ABUT < 90 REGION
  ENC COOD NP_PP_BTE < CO_S_6 ABUT < 90 REGION 
  COOD CUT PP
  ENC COOD PP < 0.001 ABUT < 90 SINGULAR REGION
  ENC COOD NP < 0.001 ABUT < 90 SINGULAR REGION
}

CO.EN.1 { @ Enclosure by OD (Except SRAM (186;0) region) >= 0.01 
  ENC (COOD NOT INSIDE SRAM_REGION) OD < CO_EN_1 ABUT < 90 SINGULAR REGION
}

PICK_UP = DSTP NOT VAR

COOD_ACT = COOD NOT INSIDE PICK_UP  
COOD_STP = COOD INSIDE PICK_UP

CO.EN.1.1_CO.EN.1.3 { @ Enclosure by OD [at least two opposite sides] >= ^CO_EN_1_1 or [four sides] >= ^CO_EN_1_3, do not check butted contact
  X = RECTANGLE ENCLOSURE (COOD_ACT NOT SRAM_BCO) OD ABUT < 90 SINGULAR GOOD 0 CO_EN_1_1 OPPOSITE 0 CO_EN_1_1 OPPOSITE
  ENC X OD < CO_EN_1_3 ABUT < 90 SINGULAR REGION
}

CO.EN.1.2 { @ Enclosure by OD for STRAP NOT VAR [at least two opposite sides] >= 0.02 
  X = RECTANGLE ENCLOSURE COOD_STP OD ABUT < 90 SINGULAR GOOD CO_EN_1 CO_EN_1_2 OPPOSITE CO_EN_1 CO_EN_1_2 OPPOSITE
  Y = ENC [X] OD < CO_EN_1_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < CO_W_1 ABUT == 90 INTERSECTING ONLY REGION   // adjacent narrow sides
}

// Enclosure by PO is defined by either {CO.EN.2 and CO.EN.3} or {CO.EN.5 and CO.EN.6} 
// CO.EN.2 and CO.EN.3 are checked by CO.EN.0
// CO.EN.5 and CO.EN.6 are checked by CO.EN.0


CO.EN.0 { @ Enclosure by PO is defined by either {CO.EN.2 and CO.EN.3} or {CO.EN.5 and CO.EN.6}, that is enclosure by poly must meet either 10/20/10/20nm or 5/30/15/30nm
  X = (CO NOT INSIDE SRAM_REGION) NOT SEALRING_EXCLUDE
  LE_10 = X WITH EDGE (ENC [COPO] POLYs < CO_EN_2 ABUT < 90 SINGULAR)
  GE_10 = (COPO AND X) NOT LE_10
  EN3_ERR = RECTANGLE ENCLOSURE GE_10 POLYs ABUT >0 < 90 SINGULAR GOOD CO_EN_2 CO_EN_3 OPPOSITE CO_EN_2 CO_EN_3 OPPOSITE
  LE_5 = X WITH EDGE (ENC [LE_10] POLYs < CO_EN_5A ABUT < 90 SINGULAR)
  GE_5_LE_10 = LE_10 NOT LE_5
  EN6_ERR = RECTANGLE ENCLOSURE GE_5_LE_10 POLYs ABUT >0 < 90 SINGULAR GOOD CO_EN_5A CO_EN_6 OPPOSITE CO_EN_5A CO_EN_6 OPPOSITE
  EN5_SUS = GE_5_LE_10 NOT EN6_ERR
  EN5_ERR = EN5_SUS WITH EDGE (EN5_SUS TOUCH EDGE (ENC [EN5_SUS] POLYs < CO_EN_5B ABUT < 90 SINGULAR OPPOSITE)) > 1
  (COPO AND X) NOT POLY
  Y1 = ENC [EN3_ERR] POLYs < CO_EN_3 ABUT < 90 OPPOSITE
  Z1 = EN3_ERR TOUCH EDGE Y1
  INT Z1 < CO_W_1 ABUT == 90 INTERSECTING ONLY REGION    // CO.EN.3
  ENC LE_5 POLYs < CO_EN_5A ABUT < 90 SINGULAR REGION     // CO.EN.5 (0.005)
  Y2 = ENC [EN6_ERR] POLYs < CO_EN_6 ABUT < 90 OPPOSITE
  Z2 = EN6_ERR TOUCH EDGE Y2
  INT Z2 < CO_W_1 ABUT == 90 INTERSECTING ONLY REGION      // CO.EN.6
  ENC EN5_ERR POLYs < CO_EN_5B ABUT < 90 SINGULAR REGION OPPOSITE // CO.EN.5 (0.015)
}

// CO.R.2 is checked by RPO.S.3
// CO.R.3 is checked by CO.W.1
// CO.R.4 is checked by M1.EN.1, CO.EN.0



#IFDEF BACK_END


//M1 CHECKS
//=========
#IFNDEF WIDE_ADJUST
M1Wide_2_0 = M1 WITH WIDTH > M1_S_2_W            // 0.17
M1Wide_2_1 = M1Wide_2_0 WITH WIDTH > M1_S_2_1_W  // 0.24
M1Wide_2_2 = M1Wide_2_1 WITH WIDTH > M1_S_2_2_W  // 0.31
M1Wide_2_3 = M1Wide_2_2 WITH WIDTH > M1_S_2_3_W  // 0.62
M1Wide_3_0 = M1Wide_2_3 WITH WIDTH > M1_S_3_W    // 1.5
#ELSE
M1Wide_2_4 = M1 WITH WIDTH > M1_S_2_4_W          // 0.17
M1Wide_2_0 = M1Wide_2_4 WITH WIDTH > M1_S_2_W    // 0.19
M1Wide_2_5 = M1Wide_2_0 WITH WIDTH > M1_S_2_5_W  // 0.24
M1Wide_2_1 = M1Wide_2_5 WITH WIDTH > M1_S_2_1_W  // 0.265
M1Wide_2_6 = M1Wide_2_1 WITH WIDTH > M1_S_2_6_W  // 0.31
M1Wide_2_2 = M1Wide_2_6 WITH WIDTH > M1_S_2_2_W  // 0.345
M1Wide_2_7 = M1Wide_2_2 WITH WIDTH > M1_S_2_7_W  // 0.62
M1Wide_2_3 = M1Wide_2_7 WITH WIDTH > M1_S_2_3_W  // 0.685
M1Wide_3_0 = M1Wide_2_3 WITH WIDTH > M1_S_3_W    // 1.65
#ENDIF

M1_EDGE_45 = M1 ANGLE == 45

M1.W.1 { @ Width >= 0.07 
  (INT M1s < M1_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE    
}
M1.W.2 { @ Width of 45-degree bent M1. (Please make sure the vertex of 45 degree pattern is on 0.005 um grid (refer to the guideline, G.6gU, in section 3.7)) >= 0.17 
  INT M1_EDGE_45 < M1_W_2 ABUT < 90 REGION
}
M1.W.3 { @ Maximum width (This check doesn't include the sealring (162;2) region) <= 4.50 
  (M1_MAX_WIDTH WITH WIDTH > M1_W_3) NOT INSIDE IND_REGION
}
M1.S.1 { @ Space >= 0.07 
  EXT M1 < M1_S_1 ABUT < 90 SINGULAR REGION
}
M1.S.2 { @ Min. Metal space (for W> ^M1_S_2_W um & parallel length > ^M1_S_2_L um) >= ^M1_S_2 um
  X = EXT M1Wide_2_0 M1 < M1_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_2_L+GRID
}
M1.S.2.1 { @ Min. Metal space (for W> ^M1_S_2_1_W um & parallel length > ^M1_S_2_1_L um) >= ^M1_S_2_1 um
  X = EXT M1Wide_2_1 M1 < M1_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_2_1_L+GRID
}
M1.S.2.2 { @ Min. Metal space (for W> ^M1_S_2_2_W um & parallel length > ^M1_S_2_2_L um) >= ^M1_S_2_2 um
  X = EXT M1Wide_2_2 M1 < M1_S_2_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_2_2_L+GRID
}
M1.S.2.3 { @ Min. Metal space (for W> ^M1_S_2_3_W um & parallel length > ^M1_S_2_3_L um) >= ^M1_S_2_3 um
  X = EXT M1Wide_2_3 M1 < M1_S_2_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_2_3_L+GRID
}
#IFDEF WIDE_ADJUST
M1.S.2.4 { @ Min. Metal space (for W> ^M1_S_2_4_W um & parallel length > ^M1_S_2_4_L um) >= ^M1_S_2_4 um
  X = EXT M1Wide_2_4 M1 < M1_S_2_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_2_4_L+GRID
}
M1.S.2.5 { @ Min. Metal space (for W> ^M1_S_2_5_W um & parallel length > ^M1_S_2_5_L um) >= ^M1_S_2_5 um
  X = EXT M1Wide_2_5 M1 < M1_S_2_5 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_2_5_L+GRID
}
M1.S.2.6 { @ Min. Metal space (for W> ^M1_S_2_6_W um & parallel length > ^M1_S_2_6_L um) >= ^M1_S_2_6 um
  X = EXT M1Wide_2_6 M1 < M1_S_2_6 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_2_6_L+GRID
}
M1.S.2.7 { @ Min. Metal space (for W> ^M1_S_2_7_W um & parallel length > ^M1_S_2_7_L um) >= ^M1_S_2_7 um
  X = EXT M1Wide_2_7 M1 < M1_S_2_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_2_7_L+GRID
}
#ENDIF
M1.S.3 { @  Min. Metal space (for W> ^M1_S_3_W um & parallel length > ^M1_S_3_L um) >= ^M1_S_3 um
  X = EXT M1Wide_3_0 M1 < M1_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  (ENCLOSE RECTANGLE Y 0.001 M1_S_3_L+0.001) NOT INSIDE IND_REGION
}
M1.S.5 { @ If M1 has parallel run length with opposite M1 along two adjacent edges of M1 [any one edge < ^M1_S_5_W Q = ^M1_S_5_Q um and its opposite extension< ^M1_S_5_T distance from the corner of the two edges of M1], then one of the space (S1 or S2) to opposite M1 must be >= ^M1_S_5 um.  
  A = CONVEX EDGE M1 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M1_S_5_W
  B = EXT [A] M1 < M1_S_5 ABUT < 90 OPPOSITE EXTENDED M1_S_5_T
  C = A TOUCH INSIDE EDGE B
  D = INT C [M1] < M1_S_5_Q ABUT == 90 INTERSECTING ONLY
  I = LENGTH D >= M1_W_1
  J = EXPAND EDGE I INSIDE BY 0.001 EXTEND BY M1_S_5_T
  K = EXPAND EDGE I INSIDE BY 0.001 
  L = J NOT K
  M = L WITH EDGE A 
  N = M OR K
  O = N TOUCH EDGE I
  (EXT O M1 < M1_S_5 ABUT < 90 OPPOSITE REGION) NOT INSIDE SRAM_REGION 

}
M1.S.6 { @ Space to 45-degree bent M1 >= 0.17 
  X = EXPAND EDGE M1_EDGE_45 OUTSIDE BY M1_S_6
  X AND M1
}

M1_HVN_5V = NET AREA RATIO M1i OVER M10_HV_5V M9_HV_5V M8_HV_5V M7_HV_5V M6_HV_5V M5_HV_5V M4_HV_5V M3_HV_5V M2_HV_5V M1_HV_5V > 0 
M1_HVN = NET AREA RATIO M1i OVER M10_HV M9_HV M8_HV M7_HV M6_HV M5_HV M4_HV M3_HV M2_HV M1_HV > 0 
M1_MVN = NET AREA RATIO M1i OVER M10_MV M9_MV M8_MV M7_MV M6_MV M5_MV M4_MV M3_MV M2_MV M1_MV > 0
M1_LVN = NET AREA RATIO M1i OVER M10_LV M9_LV M8_LV M7_LV M6_LV M5_LV M4_LV M3_LV M2_LV M1_LV > 0

M1_NOMARK = (((M1i NOT M1_HVN_5V) NOT M1_HVN) NOT M1_MVN) NOT M1_LVN

#IFDEF Mx_S_8_IO_NET
  M1_NOMARK_5V = NET AREA RATIO M1_NOMARK PSD_HVD NSD_HVD S_HVD_GATE PSTPi > 0 
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD)+!!AREA(S_HVD_GATE))*!AREA(PSTPi)]
  M1_NOMARK_HV = NET AREA RATIO M1_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPi > 0 
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPi)]
  M1_NOMARK_MV = NET AREA RATIO M1_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPi > 0 
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPi)]
#ELSE  
  M1_NOMARK_5V = NET AREA RATIO M1_NOMARK PSD_HVD NSD_HVD S_HVD_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD)+!!AREA(S_HVD_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M1_NOMARK_HV = NET AREA RATIO M1_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M1_NOMARK_MV = NET AREA RATIO M1_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)] 
#ENDIF 

M1_5V_ALL = M1_HVN_5V OR M1_NOMARK_5V  
M1_HV_ALL = M1_HVN OR M1_NOMARK_HV
M1_MV_ALL = M1_MVN OR M1_NOMARK_MV

M1.S.1.1 { @ Space [any one of Mx connect to > 3.3V and <= 5V net] >= ^M1_S_1_1
  I = STAMP M1_5V_ALL BY M1i
  EXT I M1i < M1_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}
M1.S.8.2 { @ Space to neighboring {VIAx-1 or VIAx} [either VIAx-1, VIAx or Mx connects to > 3.3V and <= 5V net] >= ^M1_S_8_2
  I = STAMP M1_5V_ALL BY M1i
  J = STAMP (VIA1i AND M1_5V_ALL) BY M1i
  EXT I VIA1i < M1_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M1i < M1_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}

M1.S.8 { @ Space to VIA1 [different net, either VIA1 or M1 connects to 1.8V ~ 3.3V net] 0.1  
  I = STAMP M1_HV_ALL BY M1i
  J = STAMP (VIA1i AND M1_HV_ALL) BY M1i
  EXT I VIA1i < M1_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M1i < M1_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}


M1.S.9 { @ This rule is to check Metal (A) space to neighboring VIA1 [either VIA1 or M1 connects to >3.3V and <= 5V net]. DRC methodology to find Metal (A) Find a edge (B) of metal line end [edge length <= 0.12um] Run length (C) from edge (B) inside metal >= 0.13um Jog length (D) <= 0.01um within 0.13um run length Extend 0.06um outside from edge (B) to form a polygon metal (A) Metal (A) is defined if conditions 1~4 are all satisfied. >= 0.15 
  LINE_END_pre   = CONVEX EDGE M1 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= M1_S_9_B
  LINE_END_pre1  = EXPAND EDGE LINE_END_pre INSIDE BY GRID EXTEND BY -M1_S_9_D    
  LINE_END_pre2  = LINE_END_pre COIN INSIDE EDGE LINE_END_pre1  
  LINE_END_pre3  = INT [LINE_END_pre2] M1 < M1_S_9_C OPPOSITE 
  LINE_END_pre4  = LINE_END_pre NOT TOUCH INSIDE EDGE LINE_END_pre3
  LINE_END_pre5  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M1_S_9_D+GRID
  LINE_END_pre6  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M1_S_9_D
  LINE_END_pre7  = LINE_END_pre5 NOT LINE_END_pre6
  LINE_END_pre8  = LINE_END_pre5 TOUCH OUTSIDE EDGE LINE_END_pre4
  LINE_END_pre9  = LINE_END_pre8 COIN INSIDE EDGE LINE_END_pre7 
  LINE_END_pre10 = EXT [LINE_END_pre9] M1 < M1_S_9_C OPPOSITE
  LINE_END = LINE_END_pre4 NOT TOUCH OUTSIDE EDGE (LINE_END_pre8 TOUCH INSIDE EDGE LINE_END_pre10)
  A = EXPAND EDGE LINE_END OUTSIDE BY M1_S_9_A INSIDE BY GRID
  B = STAMP A BY M1i
  I = STAMP (A INTERACT M1_5V_ALL) BY M1i
  J = STAMP (VIA1i AND M1_5V_ALL) BY M1i
  X1 = EXT I VIA1i < M1_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X2 = EXT J B < M1_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  Y = X1 OR X2
  COPY Y
  A INTERACT Y
}

M1.S.8.1 { @ Space to VIA1 [different net, either VIA1 or M1 connects to >= 1.5V and < 1.8V net] 0.08  
  I = STAMP M1_MV_ALL BY M1i
  J = STAMP (VIA1i AND M1_MV_ALL) BY M1i
  EXT I VIA1i < M1_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M1i < M1_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}

// M1.EN.0 is checked by M1.EN.1, and M1.EN.2_M1.EN.3_M1.EN.3.1_M1.EN.3.2

M1.EN.1 { @ Enclosure of CO >= 0.00, do not check butted contact in SRAM
  ((COs NOT SRAM_BCO) NOT M1s) NOT CSRDMY
}
M1.EN.2__M1.EN.3__M1.EN.3.1__M1.EN.3.2 { @ Enclosure of CO [at least two opposite sides] >= ^M1_EN_2, or [four sides] >= ^M1_EN_3, or [four sides] >= ^M1_EN_3_1 with [at least two opposite sides] >= ^M1_EN_3_2
  A = RECTANGLE ENCLOSURE (COs NOT INSIDE SRAM_REGION) M1s ABUT > 0 < 90 GOOD 0 M1_EN_2 OPPOSITE 0 M1_EN_2 OPPOSITE
  B = ENC A M1s < M1_EN_3_1 ABUT < 90 SINGULAR REGION
  C = RECTANGLE ENCLOSURE (A NOT TOUCH B) M1s ABUT < 90 GOOD M1_EN_3_1 M1_EN_3_2 OPPOSITE M1_EN_3_1 M1_EN_3_2 OPPOSITE
  (B OR (ENC C M1s < M1_EN_3 ABUT < 90 SINGULAR REGION)) NOT CSRDMY
}

M1Wide_0.7 = M1Wide_2_0 WITH WIDTH > M1_EN_4_W
M1.EN.4 { @ Enclosure of CO [M1 width > 0.7 um] (except CSRDMY (166;0) region) >= 0.03 
   A = (COs INSIDE M1Wide_0.7) NOT CSRDMY
   ENC A M1s < M1_EN_4 ABUT < 90 SINGULAR REGION
}

M1.EN.5 { @ Enclosure of CO [metal width >= 0.11um, space < 0.08 um and parallel run length > 0.27 um] (This check doesn't include two or more COs resent in the metal intersection) >= 0.015 
  X = M1s WITH WIDTH >= M1_EN_5_W
  sus_co = COs NOT OUTSIDE X
  sus_M1 = M1i INTERACT sus_co
  sus_M1_OD = (sus_M1 AND (OD NOT POLY)) ENCLOSE COi == 1
  sus_M1_PO = (sus_M1 AND POLY) ENCLOSE COi == 1
  check_co = sus_co AND (sus_M1_OD OR sus_M1_PO)
  G1 = EXT [X] M1s < M1_EN_5_S OPPOSITE MEASURE ALL
  G2 = (EXT X M1s < M1_EN_5_S OPPOSITE REGION MEASURE ALL) NOT M1s
  I = ENCLOSE RECTANGLE G2 GRID M1_EN_5_L+GRID
  check_edge = EXT G1 [I] < M1_EN_5 OPPOSITE ABUT < 90
  (EXT check_co check_edge < M1_EN_5 ABUT < 90 REGION OPPOSITE) NOT INSIDE SRAM_EXCLUDE
}

M1.A.1 { @ Area (Except SRAM (186;0) region) >= 0.0215 
  AREA (M1s NOT INSIDE SRAM_REGION) < M1_A_1
}

M1.A.2 { @ Area [with all of edge length< 0.17 um]. (This check doesn't include the patterns filling 0.07 um x 0.17 um rectangular tile) (Except SRAM (186;0) region) >= 0.055 
  A = AREA (M1s NOT INSIDE SRAM_REGION) < M1_A_2
  B = LENGTH A >= M1_A_2_L1
  C = A NOT WITH EDGE B
  NOT ENCLOSE RECTANGLE C M1_A_2_W M1_A_2_L1 ORTHOGONAL ONLY
}

VARIABLE M1_A_3pre ((M1_A_3 + (M1_S_1 * M1_S_1 * 3.142))/(2 * M1_S_1))*((M1_A_3 + (M1_S_1 * M1_S_1 * 3.142))/(2 * M1_S_1))/3.141

M1.A.3 { @ Enclosed area >= 0.2 
  X = HOLES M1s INNER < M1_A_3pre
  (AREA ( X NOT M1i ) < M1_A_3) NOT INSIDE SRAM_EXCLUDE
}


#IFDEF FULL_CHIP
CHIP_M1 = COPY CHIP
#ELSE
CHIP_M1 = CHIP INTERACT M1x
#ENDIF

#IFDEF CHECK_LOW_DENSITY
M1.DN.1 { @ Minimum local density [window ^M1_DN_1_W um x ^M1_DN_1_W um, stepping ^M1_DN_1_S um] >= ^M1_DN_1
  M1_CHECK = M1x NOT M1_EXC_LOW
  CHIP_CHECK = CHIP NOT M1_EXC_LOW
  
  ERR_WIN = DENSITY M1_CHECK CHIP_CHECK < M1_DN_1 WINDOW M1_DN_1_W STEP M1_DN_1_S INSIDE OF LAYER CHIP_M1 BACKUP 
	[ AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M1_EXC_LOW) >= M1_DN_1_E
  DENSITY F M1_CHECK CHIP_CHECK < M1_DN_1 WINDOW M1_DN_1_W STEP M1_DN_1_S INSIDE OF LAYER CHIP_M1 BACKUP PRINT M1.DN.1.density
         [ !AREA(F)+AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
}
#ENDIF

M1.DN.1.1 { @ Maximum local density [window ^M1_DN_1_1_W um x ^M1_DN_1_1_W um, stepping ^M1_DN_1_1_S um] <= ^M1_DN_1_1
  M1_CHECK = M1x NOT M1_EXC_HIGH
  CHIP_CHECK = CHIP NOT M1_EXC_HIGH
  ERR_WIN = DENSITY M1_CHECK CHIP_CHECK > M1_DN_1_1 WINDOW M1_DN_1_1_W STEP M1_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M1_EXC_HIGH) >= M1_DN_1_1_E
  DENSITY F M1_CHECK CHIP_CHECK > M1_DN_1_1 WINDOW M1_DN_1_1_W STEP M1_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP PRINT M1.DN.1.1.density
         [ !!AREA(F)*AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
}

M1.DN.4 { @ The metal density difference between any two neighboring checking windows including DM1EXCL [window ^M1_DN_4_W um x ^M1_DN_4_W um, stepping ^M1_DN_4_W um]  <= ^M1_DN_4
  DENSITY M1x CHIP <=1 WINDOW M1_DN_4_W BACKUP GRADIENT > M1_DN_4 ABSOLUTE CORNER INSIDE OF LAYER CHIPx PRINT M1.DN.4.density
  	[ AREA(M1x)/AREA(CHIP) ]    
}

#IFDEF CHECK_LOW_DENSITY
M1.DN.6 { @ Metal Desnsity >= ^M1_DN_6. All condition-A, Condition-B, and Condition-C must be followed.
@ (1) Condition-A: Metal density [window ^M1_DN_6_W_A um x ^M1_DN_6_W_A um, stepping ^M1_DN_6_S_A um] >= ^M1_DN_6
@ (2) Condition-B: Maximum area of merged low density windows [window ^M1_DN_6_W_BC um x ^M1_DN_6_W_BC um, stepping ^M1_DN_6_S_BC um < ^M1_DN_6] <= ^M1_DN_6_A_B um2, except merged low density windows width <= ^M1_DN_6_U um
@ (3) Condition-C: Maximum area of merged low density windows [window ^M1_DN_6_W_BC um x ^M1_DN_6_W_BC um, stepping ^M1_DN_6_S_BC um < ^M1_DN_6] <= ^M1_DN_6_A_C um2
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M1_DN_6_E_A um for condition-A and >= ^M1_DN_6_E_BC um for both condition-B/condition-C 
  M1_CHECK = M1x NOT NEW_DEN_EXC
  CHIP_CHECK = CHIP NOT NEW_DEN_EXC
  // Condition-A
  ERR_WIN_A = DENSITY M1_CHECK CHIP_CHECK < M1_DN_6 WINDOW M1_DN_6_W_A STEP M1_DN_6_S_A INSIDE OF LAYER CHIP_M1 BACKUP 
	[ AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
  F_A = WITH WIDTH (ERR_WIN_A NOT NEW_DEN_EXC) >= M1_DN_6_E_A
  DENSITY F_A M1_CHECK CHIP_CHECK < M1_DN_6 WINDOW M1_DN_6_W_A STEP M1_DN_6_S_A INSIDE OF LAYER CHIP_M1 BACKUP PRINT M1.DN.6_A.density
         [ !AREA(F_A)+AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
  // Condition-B 
  ERR_WIN_B = DENSITY M1_CHECK CHIP_CHECK < M1_DN_6 WINDOW M1_DN_6_W_BC STEP M1_DN_6_S_BC INSIDE OF LAYER CHIP_M1 BACKUP 
	[ AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
  F_B = WITH WIDTH (ERR_WIN_B NOT NEW_DEN_EXC) >= M1_DN_6_E_BC
  A = DENSITY F_B M1_CHECK CHIP_CHECK < M1_DN_6 WINDOW M1_DN_6_W_BC STEP M1_DN_6_S_BC INSIDE OF LAYER CHIP_M1 BACKUP PRINT M1.DN.6_BC.density
         [ !AREA(F_B)+AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
  B = AREA A > M1_DN_6_A_B
  C = SIZE B BY M1_DN_6_U/2 UNDEROVER
  B INTERACT C
  // Condition-C
  AREA B > M1_DN_6_A_C
}
#ENDIF


//M1.R.1 can't be checked

M1_CORE = M1x NOT SEALRING_EXCLUDE


M1.R.2 { @ Metal(pin) layers must be drawn only interact with one relative Metal(drawing) layers
    M1_PIN NOT INTERACT M1i == 1
}



//VIA1 CHECKS
//===========
#IFNDEF WIDE_ADJUST
M2Wide_2_0 = M2 WITH WIDTH > M2_S_2_W            // 0.17
M2Wide_2_1 = M2Wide_2_0 WITH WIDTH > M2_S_2_1_W  // 0.24
M2Wide_2_2 = M2Wide_2_1 WITH WIDTH > M2_S_2_2_W  // 0.31
M2Wide_2_3 = M2Wide_2_2 WITH WIDTH > M2_S_2_3_W  // 0.62
M2Wide_3_0 = M2Wide_2_3 WITH WIDTH > M2_S_3_W    // 1.65
#ELSE
M2Wide_2_4 = M2 WITH WIDTH > M2_S_2_4_W          // 0.17
M2Wide_2_0 = M2Wide_2_4 WITH WIDTH > M2_S_2_W    // 0.19
M2Wide_2_5 = M2Wide_2_0 WITH WIDTH > M2_S_2_5_W  // 0.24
M2Wide_2_1 = M2Wide_2_5 WITH WIDTH > M2_S_2_1_W  // 0.265
M2Wide_2_6 = M2Wide_2_1 WITH WIDTH > M2_S_2_6_W  // 0.31
M2Wide_2_2 = M2Wide_2_6 WITH WIDTH > M2_S_2_2_W  // 0.345
M2Wide_2_7 = M2Wide_2_2 WITH WIDTH > M2_S_2_7_W  // 0.62
M2Wide_2_3 = M2Wide_2_7 WITH WIDTH > M2_S_2_3_W  // 0.685
M2Wide_3_0 = M2Wide_2_3 WITH WIDTH > M2_S_3_W    // 1.65
#ENDIF

M1Wide_R2_VIA1 = M1Wide_2_0 WITH WIDTH > VIA1_R_2_W        // 0.21
M1Wide_R4_VIA1 = M1Wide_R2_VIA1 WITH WIDTH > VIA1_R_4_W    // 0.21
M1Wide_R3_VIA1 = M1Wide_R4_VIA1 WITH WIDTH > VIA1_R_3_W    // 0.55
M1Wide_R5_VIA1 = M1Wide_R3_VIA1 WITH WIDTH > VIA1_R_5_W    // 1.4
M1Wide_R6_VIA1 = M1Wide_R5_VIA1 WITH WIDTH > VIA1_R_6_W    // 2.1
M2Wide_R2_VIA1 = M2Wide_2_0 WITH WIDTH > VIA1_R_2_W      // 0.21
M2Wide_R4_VIA1 = M2Wide_R2_VIA1 WITH WIDTH > VIA1_R_4_W  // 0.21
M2Wide_R3_VIA1 = M2Wide_R4_VIA1 WITH WIDTH > VIA1_R_3_W  // 0.55
M2Wide_R5_VIA1 = M2Wide_R3_VIA1 WITH WIDTH > VIA1_R_5_W  // 1.4
M2Wide_R6_VIA1 = M2Wide_R5_VIA1 WITH WIDTH > VIA1_R_6_W  // 2.1

VIA1.W.1 { @ Width (maximum = minimum) (Except sealring (162,2) and {VIAx bar INSIDE {LOWMEDN NOT (LOWMEDN SIZING -4 um)}} region) = 0.07 
   NOT RECTANGLE (VIA1i NOT (SEALRING_EXCLUDE OR P_RING_REGION)) == VIA1_W_1 BY == VIA1_W_1 ORTHOGONAL ONLY
}
VIA1.S.1 { @ Space >= 0.07 
  EXT VIA1i < VIA1_S_1 ABUT < 90 SINGULAR REGION
}
VIA1.S.1.1 { @ Space [any one of VIAx connect to > 3.3V and <= 5V different net] >= ^VIA1_S_1_1
  J = STAMP (VIA1i AND M1_5V_ALL) BY M1i
  EXT J VIA1i < VIA1_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}
VIA1.S.2 { @ Space to 3-neighboring VIAx (distance < 0.098 um) >= 0.09 
  X = WITH NEIGHBOR VIA1i > 2 SPACE < VIA1_S_2_D
  EXT X VIA1i < VIA1_S_2 ABUT < 90 SINGULAR REGION
}
VIA1.S.3 { @ Space to neighboring VIAx [different net] >= 0.095 
  EXT VIA1i < VIA1_S_3 ABUT < 90 NOT CONNECTED REGION
}
VIA1.S.3.1 { @ Space to neighboring VIAx [different net and common parallel run length > 0 um] >= 0.11 
  EXT VIA1i < VIA1_S_3_1 ABUT < 90 NOT CONNECTED OPPOSITE REGION
}

// VIA1.EN.0 is checked by VIA1.EN.1, and VIA1.EN.2_VIA1.EN.4_VIA1.EN.4.1

VIA1.EN.1 { @ Enclosure by Mx or M1 >= 0.00 
  VIA1 NOT M1
}

VIA1.EN.2__VIA1.EN.4__VIA1.EN.4.1 { @ Enclosure by M1 [at least two opposite sides] >= ^VIA1_EN_2, or [four sides] >= ^VIA1_EN_4 with [at least two opposite sides] >= ^VIA1_EN_4_1
  X = RECTANGLE ENCLOSURE (VIA1 NOT SEALRING_EXCLUDE) M1s ABUT < 90 SINGULAR GOOD 0 VIA1_EN_2 OPPOSITE 0 VIA1_EN_2 OPPOSITE
  Y = ENC X M1s < VIA1_EN_4 ABUT < 90 SINGULAR REGION
  Z = RECTANGLE ENCLOSURE (X NOT TOUCH Y) M1s ABUT < 90 GOOD VIA1_EN_4 VIA1_EN_4_1 OPPOSITE VIA1_EN_4 VIA1_EN_4_1 OPPOSITE
  (Y OR (ENC Z M1s < VIA1_EN_4_1 ABUT < 90 SINGULAR REGION)) NOT SEALRING_DB
}


VIA1.EN.3.1 { @ VIA1 Enclosure by M1 [metal width >= 0.11 um, space < 0.08 um and parallel run length > 0.27 um] (This check doesn't include two or more via1 present in the metal intersection) >= 0.015 
  X = M1s WITH WIDTH >= VIA1_EN_3_1_W
  sus_via1 = VIA1s NOT OUTSIDE X
  check_via1 = sus_via1 AND (((M1i INTERACT sus_via1) AND (M2i INTERACT sus_via1)) ENCLOSE VIA1i == 1)
  G1 = EXT [X] M1s < VIA1_EN_3_1_S OPPOSITE MEASURE ALL
  G2 = (EXT X M1s < VIA1_EN_3_1_S OPPOSITE REGION MEASURE ALL) NOT M1s
  I = ENCLOSE RECTANGLE G2 GRID VIA1_EN_3_1_L+GRID
  check_edge = EXT G1 [I] < VIA1_EN_3_1 OPPOSITE ABUT < 90
  (EXT check_via1 check_edge < VIA1_EN_3_1 ABUT < 90 REGION OPPOSITE) NOT INSIDE SRAM_EXCLUDE

}

// VIA1.R.1 is checked by VIA1.W.1
VIA1.R.2__VIA1.R.3 { @ When M1 or M2 width > ^VIA1_R_2_W um, more than one VIA1 is required.
                    @ 2 vias spacing should be <= ^VIA1_R_2_S1 um or 4 vias spacing should be <= ^VIA1_R_2_S2 um
                    @ When M1 or M2 width > ^VIA1_R_3_W um, more than three VIA1 is required.
                    @ 4 vias spacing should be <= ^VIA1_R_3_S1 um or 9 vias spacing should be <= ^VIA1_R_3_S2 um
                    @ not check SRAM region					
   M2OvpM1_W_ = (M1Wide_R2_VIA1 AND M2) OR (M2Wide_R2_VIA1 AND M1)
   M2OvpM1_B  = (M1Wide_R3_VIA1 AND M2) OR (M2Wide_R3_VIA1 AND M1)
   M2OvpM1_W  = M2OvpM1_W_ NOT M2OvpM1_B 
   Checked_VIA1_W_ = VIA1_EXD NOT OUTSIDE M2OvpM1_W
   Checked_VIA1_B  = VIA1_EXD NOT OUTSIDE M2OvpM1_B
   Checked_VIA1_W  = Checked_VIA1_W_ NOT Checked_VIA1_B
   M1_effect = M1i INTERACT M2OvpM1_W_
   M2_effect = M2i INTERACT M2OvpM1_W_
   effect_M2OvpM1_ = M1_effect AND M2_effect
   effect_M2OvpM1 = effect_M2OvpM1_ INTERACT M2OvpM1_W_
   effect_VIA = VIA1_EXD INTERACT effect_M2OvpM1

   V1Merged_A = SIZE effect_VIA BY VIA1_R_2_S1/2 INSIDE OF effect_M2OvpM1 STEP M1_S_1*0.7
   V1Merged_B = SIZE V1Merged_A BY (VIA1_R_2_S2 - VIA1_R_2_S1)/2 INSIDE OF effect_M2OvpM1 STEP M1_S_1*0.7
   V1Merged_C = SIZE V1Merged_B BY (VIA1_R_3_S2 - VIA1_R_2_S2)/2 INSIDE OF effect_M2OvpM1 STEP M1_S_1*0.7
   V1Merged_A2R = V1Merged_A INTERACT effect_VIA < 2
   V1Merged_A2 = V1Merged_A OUTSIDE V1Merged_A2R
   V1Merged_A4R = V1Merged_A2 INTERACT effect_VIA < 4
   V1Merged_A4 = V1Merged_A2 OUTSIDE V1Merged_A4R
   V1Merged_B4R = V1Merged_B INTERACT effect_VIA < 4
   V1Merged_B4 = V1Merged_B OUTSIDE V1Merged_B4R
   V1Merged_C9R = V1Merged_C INTERACT effect_VIA < 9
   V1Merged_C9 = V1Merged_C OUTSIDE V1Merged_C9R

   GMergeW = V1Merged_A2 OR V1Merged_B4
   GMergeB = V1Merged_A4 OR V1Merged_C9
   GVIA_W = Checked_VIA1_W INTERACT GMergeW
   GVIA_B = Checked_VIA1_B INTERACT GMergeB
   GOOD_AREA_W = M2OvpM1_W INTERACT GVIA_W
   GOOD_AREA_B = M2OvpM1_B INTERACT GVIA_B
   (Checked_VIA1_W OUTSIDE GOOD_AREA_W) NOT INSIDE SRAM_REGION
   (Checked_VIA1_B OUTSIDE GOOD_AREA_B) NOT INSIDE SRAM_REGION
}

VIA1.R.4.M1 { @ At least two VIAx must be used for a connection that is <= ^VIA1_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_4_W um (L) and width > ^VIA1_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA1_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_4_W um (L) and width > ^VIA1_R_4_W um (W).)   
  Branch1 = ((SIZE M1Wide_R4_VIA1 BY VIA1_R_4_D + GRID) NOT M1Wide_R4_VIA1) AND M1
  Branch1HasVia = (Branch1 INTERACT M1Wide_R4_VIA1) INTERACT VIA1_EXD
  Branch1Edge = M1Wide_R4_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_4_D INSIDE OF Branch1HasVia STEP M1_S_1*0.5
  GoodBranch = (Branch AND M2) INTERACT VIA1_EXD > 1
  BranchSingleVia = (VIA1_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M1) INTERACT BranchSingleVia) INTERACT VIA1_EXD == 1
  ERR = (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
  ERR NOT INSIDE SRAM_REGION
}

VIA1.R.4.M2 { @ At least two VIAx must be used for a connection that is <= ^VIA1_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_4_W um (L) and width > ^VIA1_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA1_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_4_W um (L) and width > ^VIA1_R_4_W um (W)).   
  Branch1 = ((SIZE M2Wide_R4_VIA1 BY VIA1_R_4_D + GRID) NOT M2Wide_R4_VIA1) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Wide_R4_VIA1) INTERACT VIA1_EXD
  Branch1Edge = M2Wide_R4_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_4_D INSIDE OF Branch1HasVia STEP M2_S_1*0.5
  GoodBranch = (Branch AND M1) INTERACT VIA1_EXD > 1
  BranchSingleVia = (VIA1_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M1 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA1_EXD == 1
  ERR = (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
  ERR NOT INSIDE SRAM_REGION   
}

VIA1.R.5.M1 { @ At least two VIAx must be used for a connection that is <= ^VIA1_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_5_W um (L) and width > ^VIA1_R_5_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA1_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA1_R_5_W um (L) and width > ^VIA1_R_5_W um (W)).
  Branch1 = ((SIZE M1Wide_R5_VIA1 BY VIA1_R_5_D + GRID) NOT M1Wide_R5_VIA1) AND M1
  Branch1HasVia = (Branch1 INTERACT M1Wide_R5_VIA1) INTERACT VIA1_EXD
  Branch1Edge = M1Wide_R5_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_5_D INSIDE OF Branch1HasVia STEP M1_S_1*0.7
  GoodBranch = (Branch AND M2) INTERACT VIA1_EXD > 1
  BranchSingleVia = (VIA1_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M1) INTERACT BranchSingleVia) INTERACT VIA1_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA1.R.5.M2 { @ At least two VIAx must be used for a connection that is <= ^VIA1_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_5_W um (L) and width > ^VIA1_R_5_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA1_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA1_R_5_W um (L) and width > ^VIA1_R_5_W um (W)).
  Branch1 = ((SIZE M2Wide_R5_VIA1 BY VIA1_R_5_D + GRID) NOT M2Wide_R5_VIA1) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Wide_R5_VIA1) INTERACT VIA1_EXD
  Branch1Edge = M2Wide_R5_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_5_D INSIDE OF Branch1HasVia STEP M2_S_1*0.7
  GoodBranch = (Branch AND M1) INTERACT VIA1_EXD > 1
  BranchSingleVia = (VIA1_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M1 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA1_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M1Big_R6_VIA1 = ENCLOSE RECTANGLE M1Wide_R6_VIA1 VIA1_R_6_W VIA1_R_6_L+GRID

VIA1.R.6.M1 { @ At least two VIAx must be used for a connection that is <= ^VIA1_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_6_L um (L) and width > ^VIA1_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA1_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA1_R_6_L um (L) and width > ^VIA1_R_6_W um (W)).
  Branch1 = ((SIZE M1Big_R6_VIA1 BY VIA1_R_6_D + GRID) NOT M1Big_R6_VIA1) AND M1
  Branch1HasVia = (Branch1 INTERACT M1Big_R6_VIA1) INTERACT VIA1_EXD
  Branch1Edge = M1Big_R6_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_6_D INSIDE OF Branch1HasVia STEP M1_S_1*0.7
  GoodBranch = (Branch AND M2) INTERACT VIA1_EXD > 1
  BranchSingleVia = (VIA1_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M1) INTERACT BranchSingleVia) INTERACT VIA1_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M2Big_R6_VIA1 = ENCLOSE RECTANGLE M2Wide_R6_VIA1 VIA1_R_6_W VIA1_R_6_L+GRID

VIA1.R.6.M2 { @ At least two VIAx must be used for a connection that is <= ^VIA1_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_6_L um (L) and width > ^VIA1_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA1_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA1_R_6_L um (L) and width > ^VIA1_R_6_W um (W)).
  Branch1 = ((SIZE M2Big_R6_VIA1 BY VIA1_R_6_D + GRID) NOT M2Big_R6_VIA1) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Big_R6_VIA1) INTERACT VIA1_EXD
  Branch1Edge = M2Big_R6_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_6_D INSIDE OF Branch1HasVia STEP M2_S_1*0.7
  GoodBranch = (Branch AND M1) INTERACT VIA1_EXD > 1
  BranchSingleVia = (VIA1_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M1 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA1_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}
// VIA1.R.7 is checked by VIA1.EN.1
// VIA1.R.9 can't be checked

VIA1.R.11 { @ Single VIAx is not allowed for H-shape Mx+1 when all of the following conditions come into existence: 1. The Mx+1 has H-shape interact with two metal holes: two metal hole length(L2) <= ^VIA1_R_11_L1 um and both two metal hole area <= ^VIA1_R_11_A um2 2. The VIAx overlaps on the center metal bar of this H-shape Mx+1 3. The length (L) of the center metal bar <= ^VIA1_R_11_L2 um and the width of metal bar is <= ^VIA1_R_11_W um.
  W = M2i WITH WIDTH <= VIA1_R_11_W   
  H_HOLE = HOLES M2i INNER <= VIA1_R_11_A
  A = M2i COIN OUTSIDE EDGE H_HOLE
  B0 = ((INT A <= VIA1_R_11_W ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE M2i) INTERACT H_HOLE == 2 
  B1 = (((INT A <= VIA1_R_11_L2 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE M2i) AND W) INTERACT H_HOLE == 2
  HOLE_NOTCH = EXT H_HOLE <= VIA1_R_11_W ABUT<90 OPPOSITE NOTCH REGION  
  B2 = (B1 NOT HOLE_NOTCH) OR B0
  CORNER_M = ((EXT B2 <= VIA1_R_11_W ABUT == 90 INTERSECTING ONLY REGION EXTENTS) TOUCH B2 == 2) AND W
  B = B2 OR CORNER_M
  CENTER_BAR1 = NOT ENCLOSE RECTANGLE B GRID VIA1_R_11_L2+GRID
  CENTER_BAR2 = CENTER_BAR1 INTERACT H_HOLE == 2
  C = CENTER_BAR2 COIN OUTSIDE EDGE H_HOLE 
  D = EXT [C] M2i <= VIA1_R_11_L1 OPPOSITE
  E = C NOT COIN INSIDE EDGE D
  CENTER_BAR3 = CENTER_BAR2 NOT WITH EDGE E
  CHECK_VIA = VIA1 NOT OUTSIDE CENTER_BAR3
  CHECK_VIA AND (((M2i INTERACT CHECK_VIA) AND (M1i INTERACT CHECK_VIA)) INTERACT VIA1i == 1)
}

VIA1.R.12 { @ VIA1 connected to DM1, DM1_O, DM2, DM2_O is not allowed
  VIA1 INTERACT DUM1
  VIA1 INTERACT DUM2
  VIA1 INTERACT DM1_O
  VIA1 INTERACT DM2_O
}  

//M2 CHECKS
//=========


M2_EDGE_45 = M2 ANGLE == 45

M2.W.1 { @ Width >= 0.07 
  INT M2 < M2_W_1 ABUT < 90 SINGULAR REGION
}
M2.W.2 { @ Width of 45-degree bent Mx. (Please make sure the vertex of 45 degree pattern is on 0.005 um grid (refer to the guideline, G.6gU, in section 3.7)) >= 0.17 
  INT M2_EDGE_45 < M2_W_2 ABUT < 90 REGION
}
M2.W.3 { @ Maximum width <= ^M2_W_3 um, exclude sealring 
  M2_MAX_WIDTH WITH WIDTH > M2_W_3
}

M2.S.1 { @ Space >= 0.07 
  EXT M2 < M2_S_1 ABUT < 90 SINGULAR REGION
}
M2.S.2 { @ Min. Metal space (for W> ^M2_S_2_W um & parallel length > ^M2_S_2_L um) >= ^M2_S_2 um
  X = EXT M2Wide_2_0 M2 < M2_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_2_L+GRID
}
M2.S.2.1 { @ Min. Metal space (for W> ^M2_S_2_1_W um & parallel length > ^M2_S_2_1_L um) >= ^M2_S_2_1 um
  X = EXT M2Wide_2_1 M2 < M2_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_2_1_L+GRID
}
M2.S.2.2 { @ Min. Metal space (for W> ^M2_S_2_2_W um & parallel length > ^M2_S_2_2_L um) >= ^M2_S_2_2 um
  X = EXT M2Wide_2_2 M2 < M2_S_2_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_2_2_L+GRID
}
M2.S.2.3 { @ Min. Metal space (for W> ^M2_S_2_3_W um & parallel length > ^M2_S_2_3_L um) >= ^M2_S_2_3 um
  X = EXT M2Wide_2_3 M2 < M2_S_2_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_2_3_L+GRID
}
#IFDEF WIDE_ADJUST
M2.S.2.4 { @ Min. Metal space (for W> ^M2_S_2_4_W um & parallel length > ^M2_S_2_4_L um) >= ^M2_S_2_4 um
  X = EXT M2Wide_2_4 M2 < M2_S_2_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_2_4_L+GRID
}
M2.S.2.5 { @ Min. Metal space (for W> ^M2_S_2_5_W um & parallel length > ^M2_S_2_5_L um) >= ^M2_S_2_5 um
  X = EXT M2Wide_2_5 M2 < M2_S_2_5 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_2_5_L+GRID
}
M2.S.2.6 { @ Min. Metal space (for W> ^M2_S_2_6_W um & parallel length > ^M2_S_2_6_L um) >= ^M2_S_2_6 um
  X = EXT M2Wide_2_6 M2 < M2_S_2_6 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_2_6_L+GRID
}
M2.S.2.7 { @ Min. Metal space (for W> ^M2_S_2_7_W um & parallel length > ^M2_S_2_7_L um) >= ^M2_S_2_7 um
  X = EXT M2Wide_2_7 M2 < M2_S_2_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_2_7_L+GRID
}
#ENDIF
M2.S.3 { @ Min. Metal space (for W> ^M2_S_3_W um & parallel length > ^M2_S_3_L um) >= ^M2_S_3 um
  X = EXT M2Wide_3_0 M2 < M2_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  (ENCLOSE RECTANGLE Y 0.001 M2_S_3_L+0.001) NOT INSIDE IND_REGION
}
M2.S.5 { @ Space at Mx line-end (W < 0.10 um (Q)) in a dense-line-end configuration: If Mx has parallel run length with opposite Mx (measured with T = 0.035 um extension) along 2 adjacent edges of Mx [any one edge <Q distance from the corner of the two edges], then one of the space (S1 or S2) needs to be at least this value (This check doesn't include small jog with edge length < 0.07 um(R)) (M2.S.5 except SRAM (186;0) region) >= 0.10 
  A = CONVEX EDGE M2 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M2_S_5_W
  B = EXT [A] M2 < M2_S_5 ABUT < 90 OPPOSITE EXTENDED M2_S_5_T
  C = A TOUCH INSIDE EDGE B
  D = INT C [M2] < M2_S_5_W ABUT == 90 INTERSECTING ONLY
  I = LENGTH D >= M2_W_1
  J = EXPAND EDGE I INSIDE BY 0.001 EXTEND BY M2_S_5_T
  K = EXPAND EDGE I INSIDE BY 0.001 
  L = J NOT K
  M = L WITH EDGE A 
  N = M OR K
  O = N TOUCH EDGE I
  (EXT O M2 < M2_S_5 ABUT < 90 OPPOSITE REGION) NOT INSIDE SRAM_REGION 

}

M2.S.5.1 { @ Space at Mx line-end (W<Q=^M2_S_5_1_W) in a dense-line-end configuration.If Mx has parallel run length with opposite Mx (measured with ^M2_S_5_1_T (T) extension) along two adjacent edges of Mx [any one edge < ^M2_S_5_1_W (W) from the corner of the two edges of Mx], and Mx enclosure of VIAx-1 < ^M2_S_5_1_E at line-end, then one of the space (S1 or S2) must be >= ^M2_S_5_1 um.
  A = CONVEX EDGE M2 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M2_S_5_1_W
  V1_EN = ENC [VIA1i] A < M2_S_5_1_E ABUT < 90 OPPOSITE
  M2_EN = ENC V1_EN [A] < M2_S_5_1_E ABUT < 90 OPPOSITE
  M2_SA = EXT A [M2] < M2_S_5_1 ABUT < 90 OPPOSITE EXTENDED M2_S_5_1_T
  M2_SB = EXT [A] M2_SA < M2_S_5_1 ABUT < 90 OPPOSITE EXTENDED M2_S_5_1_T
  M2_END = (A TOUCH INSIDE EDGE M2_EN) TOUCH INSIDE EDGE M2_SB
  EN_B = ENC V1_EN [M2_END] < M2_S_5_1_E2 OPPOSITE
  EN_C = ENC V1_EN [M2_END] < M2_S_5_1_E3 OPPOSITE
  EN_D = ENC V1_EN [M2_END] < M2_S_5_1_E4 OPPOSITE
  S1_B = EXT [M2_END] M2_SA < M2_S_5_1_S2 OPPOSITE EXTENDED M2_S_5_1_T
  S1_C = EXT [M2_END] M2_SA < M2_S_5_1_S3 OPPOSITE EXTENDED M2_S_5_1_T
  S1_D = EXT [M2_END] M2_SA < M2_S_5_1_S4 OPPOSITE EXTENDED M2_S_5_1_T
  PASS_B = (M2_END NOT TOUCH INSIDE EDGE EN_B) NOT TOUCH INSIDE EDGE S1_B
  PASS_C = (M2_END NOT TOUCH INSIDE EDGE EN_C) NOT TOUCH INSIDE EDGE S1_C
  PASS_D = (M2_END NOT TOUCH INSIDE EDGE EN_D) NOT TOUCH INSIDE EDGE S1_D
  M2_CHECK = ((M2_END NOT TOUCH INSIDE EDGE PASS_B) NOT TOUCH INSIDE EDGE PASS_C) NOT TOUCH INSIDE EDGE PASS_D
  H = INT M2_CHECK [M2] < M2_S_5_1_W ABUT == 90 INTERSECTING ONLY
  I = LENGTH H >= M2_W_1
  J = EXPAND EDGE I INSIDE BY GRID EXTEND BY M2_S_5_1_T
  K = EXPAND EDGE I INSIDE BY GRID
  L = J NOT K
  M = L WITH EDGE A 
  N = M OR K
  O = N TOUCH INSIDE EDGE I
  P = EXT [O] M2 < M2_S_5_1 ABUT < 90 OPPOSITE
  Q = ENC VIA1i (O TOUCH INSIDE EDGE P) < M2_S_5_1_E ABUT < 90 OPPOSITE REGION
  VIA_BAD1 = VIA1i INTERACT Q
  VIA_GOOD = VIA1i NOT VIA_BAD1
  VIA_BAD2 = VIA_BAD1 NOT INTERACT ((M2 AND M1) INTERACT VIA_GOOD)
  ENC VIA_BAD2 M2_CHECK < M2_S_5_1_E ABUT < 90 OPPOSITE REGION
}

M2.S.6 { @ Space to 45-degree bent Mx >= 0.17 
  X = EXPAND EDGE M2_EDGE_45 OUTSIDE BY M2_S_6
  X AND M2
}


M2_HVN_5V = NET AREA RATIO M2i OVER M10_HV_5V M9_HV_5V M8_HV_5V M7_HV_5V M6_HV_5V M5_HV_5V M4_HV_5V M3_HV_5V M2_HV_5V M1_HV_5V > 0 
M2_HVN = NET AREA RATIO M2i OVER M10_HV M9_HV M8_HV M7_HV M6_HV M5_HV M4_HV M3_HV M2_HV M1_HV > 0 
M2_MVN = NET AREA RATIO M2i OVER M10_MV M9_MV M8_MV M7_MV M6_MV M5_MV M4_MV M3_MV M2_MV M1_MV > 0
M2_LVN = NET AREA RATIO M2i OVER M10_LV M9_LV M8_LV M7_LV M6_LV M5_LV M4_LV M3_LV M2_LV M1_LV > 0

M2_NOMARK = (((M2i NOT M2_HVN_5V) NOT M2_HVN) NOT M2_MVN) NOT M2_LVN

#IFDEF Mx_S_8_IO_NET
  M2_NOMARK_5V = NET AREA RATIO M2_NOMARK PSD_HVD NSD_HVD S_HVD_GATE PSTPi > 0 
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD)+!!AREA(S_HVD_GATE))*!AREA(PSTPi)]
  M2_NOMARK_HV = NET AREA RATIO M2_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPi > 0 
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPi)]
  M2_NOMARK_MV = NET AREA RATIO M2_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPi > 0 
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPi)]
#ELSE  
  M2_NOMARK_5V = NET AREA RATIO M2_NOMARK PSD_HVD NSD_HVD S_HVD_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD)+!!AREA(S_HVD_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M2_NOMARK_HV = NET AREA RATIO M2_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M2_NOMARK_MV = NET AREA RATIO M2_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)] 
#ENDIF 

M2_5V_ALL = M2_HVN_5V OR M2_NOMARK_5V  
M2_HV_ALL = M2_HVN OR M2_NOMARK_HV
M2_MV_ALL = M2_MVN OR M2_NOMARK_MV

M2.S.1.1 { @ Space [any one of Mx connect to > 3.3V and <= 5V net] >= ^M2_S_1_1
  I = STAMP M2_5V_ALL BY M2i
  EXT I M2i < M2_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}
M2.S.8.2 { @ Space to neighboring {VIAx-1 or VIAx} [either VIAx-1, VIAx or Mx connects to > 3.3V and <= 5V net] >= ^M2_S_8_2
  I = STAMP M2_5V_ALL BY M2i
  J = STAMP (VIA1i AND M2_5V_ALL) BY M2i
  EXT I VIA1i < M2_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M2i < M2_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA2i AND M2_5V_ALL) BY M2i
  EXT I VIA2i < M2_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M2i < M2_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}
M2.S.8 { @ Space to {VIAx-1 OR VIAx} [different net, any one of VIAx-1, VIAx or Mx connects to 1.8V ~ 3.3V net] 0.1  
  I = STAMP M2_HV_ALL BY M2i
  J = STAMP (VIA1i AND M2_HV_ALL) BY M2i
  EXT I VIA1i < M2_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M2i < M2_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA2i AND M2_HV_ALL) BY M2i
  EXT I VIA2i < M2_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M2i < M2_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}
M2.S.8.1 { @ Space to {VIAx-1 OR VIAx} [different net, any one of VIAx-1, VIAx or Mx connects to >= 1.5V and < 1.8V net] 0.08  
  I = STAMP M2_MV_ALL BY M2i
  J = STAMP (VIA1i AND M2_MV_ALL) BY M2i
  EXT I VIA1i < M2_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M2i < M2_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA2i AND M2_MV_ALL) BY M2i
  EXT I VIA2i < M2_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M2i < M2_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}

M2.S.9 { @ This rule is to check Metal (A) space to neighboring VIAx [either VIAx or Mx connects to >3.3V and <= 5V net]. DRC methodology to find Metal (A) Find a edge (B) of metal line end [edge length <= 0.12um] Run length (C) from edge (B) inside metal >= 0.13um Jog length (D) <= 0.01um within 0.13um run length Extend 0.06um outside from edge (B) to form a polygon metal (A) Metal (A) is defined if conditions 1~4 are all satisfied. >= 0.15 
  LINE_END_pre   = CONVEX EDGE M2 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= M2_S_9_B
  LINE_END_pre1  = EXPAND EDGE LINE_END_pre INSIDE BY GRID EXTEND BY -M2_S_9_D    
  LINE_END_pre2  = LINE_END_pre COIN INSIDE EDGE LINE_END_pre1  
  LINE_END_pre3  = INT [LINE_END_pre2] M2 < M2_S_9_C OPPOSITE 
  LINE_END_pre4  = LINE_END_pre NOT TOUCH INSIDE EDGE LINE_END_pre3
  LINE_END_pre5  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M2_S_9_D+GRID
  LINE_END_pre6  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M2_S_9_D
  LINE_END_pre7  = LINE_END_pre5 NOT LINE_END_pre6
  LINE_END_pre8  = LINE_END_pre5 TOUCH OUTSIDE EDGE LINE_END_pre4
  LINE_END_pre9  = LINE_END_pre8 COIN INSIDE EDGE LINE_END_pre7 
  LINE_END_pre10 = EXT [LINE_END_pre9] M2 < M2_S_9_C OPPOSITE
  LINE_END = LINE_END_pre4 NOT TOUCH OUTSIDE EDGE (LINE_END_pre8 TOUCH INSIDE EDGE LINE_END_pre10)
  A = EXPAND EDGE LINE_END OUTSIDE BY M2_S_9_A INSIDE BY GRID
  B = STAMP A BY M2i
  I = STAMP (A INTERACT M2_5V_ALL) BY M2i
  J = STAMP (VIA1i AND M2_5V_ALL) BY M2i
  K = STAMP (VIA2i AND M2_5V_ALL) BY M2i
  X1 = EXT I VIA1i < M2_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X2 = EXT I VIA2i  < M2_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X3 = EXT J B < M2_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X4 = EXT K B < M2_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  Y = ((X1 OR X2) OR X3) OR X4   
  COPY Y
  A INTERACT Y
}

// M2.EN.0 is checked by M2.EN.1, and M2.EN.2_M2.EN.3_M2.EN.3.1

M2.EN.1 { @ Enclosure of VIAx-1 >= 0.00 
  VIA1 NOT M2
}
M2.EN.2__M2.EN.3__M2.EN.3.1 { @ Enclosure of VIAx-1 [at least two opposite sides] >= ^M2_EN_2, or [four sides] >= ^M2_EN_3 with [at least two opposite sides] >= ^M2_EN_3_1
  X = RECTANGLE ENCLOSURE (VIA1 NOT SEALRING_ALL) M2 ABUT < 90 SINGULAR GOOD 0 M2_EN_2 OPPOSITE 0 M2_EN_2 OPPOSITE
  Y = ENC X M2 < M2_EN_3 ABUT < 90 SINGULAR REGION
  Z = RECTANGLE ENCLOSURE (X NOT TOUCH Y) M2 ABUT < 90 GOOD M2_EN_3 M2_EN_3_1 OPPOSITE M2_EN_3 M2_EN_3_1 OPPOSITE
  Y OR (ENC Z M2 < M2_EN_3_1 ABUT < 90 SINGULAR REGION)
}
M2.A.1 { @ Area (M2.A.1 except SRAM (186;0) region) >= 0.027 
     AREA (M2 NOT INSIDE SRAM_REGION) < M2_A_1
}
M2.A.2 { @ Area [with all of edge length< 0.17 um] (This check doesn't include the patterns filling 0.07 um x 0.17 um rectangular tile) (M2.A.2 except SRAM (186;0) region) >= 0.06 
  A = AREA (M2 NOT INSIDE SRAM_REGION) < M2_A_2
  B = LENGTH A >= M2_A_2_L1
  C = A NOT WITH EDGE B
  NOT ENCLOSE RECTANGLE C M2_A_2_W M2_A_2_L2 ORTHOGONAL ONLY
}


VARIABLE M2_A_3pre ((M2_A_3 + (M2_S_1 * M2_S_1 * 3.142))/(2 * M2_S_1))*((M2_A_3 + (M2_S_1 * M2_S_1 * 3.142))/(2 * M2_S_1))/3.141

M2.A.3 { @ Enclosed area >= 0.2 
  X = HOLES M2 INNER < M2_A_3pre
  AREA ( X NOT M2 ) < M2_A_3
}

// M2.R.1 can not be checked


#IFDEF FULL_CHIP
CHIP_M2 = COPY CHIP
#ELSE
CHIP_M2 = CHIP INTERACT M2x
#ENDIF

#IFDEF CHECK_LOW_DENSITY
M2.DN.1 { @ Minimum local density [window ^M2_DN_1_W um x ^M2_DN_1_W um, stepping ^M2_DN_1_S um] >= ^M2_DN_1
  M2_CHECK = M2x NOT M2_EXC_LOW
  CHIP_CHECK = CHIP NOT M2_EXC_LOW
  
  ERR_WIN = DENSITY M2_CHECK CHIP_CHECK < M2_DN_1 WINDOW M2_DN_1_W STEP M2_DN_1_S INSIDE OF LAYER CHIP_M2 BACKUP 
	[ AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M2_EXC_LOW) >= M2_DN_1_E
  DENSITY F M2_CHECK CHIP_CHECK < M2_DN_1 WINDOW M2_DN_1_W STEP M2_DN_1_S INSIDE OF LAYER CHIP_M2 BACKUP PRINT M2.DN.1.density
         [ !AREA(F)+AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
}
#ENDIF

M2.DN.1.1 { @ Maximum local density [window ^M2_DN_1_1_W um x ^M2_DN_1_1_W um, stepping ^M2_DN_1_1_S um] <= ^M2_DN_1_1
  M2_CHECK = M2x NOT M2_EXC_HIGH
  CHIP_CHECK = CHIP NOT M2_EXC_HIGH
  ERR_WIN = DENSITY M2_CHECK CHIP_CHECK > M2_DN_1_1 WINDOW M2_DN_1_1_W STEP M2_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M2_EXC_HIGH) >= M2_DN_1_1_E
  DENSITY F M2_CHECK CHIP_CHECK > M2_DN_1_1 WINDOW M2_DN_1_1_W STEP M2_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP PRINT M2.DN.1.1.density
         [ !!AREA(F)*AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
}

M2.DN.4 { @ The metal density difference between any two neighboring checking windows including DM2EXCL [window ^M2_DN_4_W um x ^M2_DN_4_W um, stepping ^M2_DN_4_W um]  <= ^M2_DN_4
  DENSITY M2x CHIP <=1 WINDOW M2_DN_4_W BACKUP GRADIENT > M2_DN_4 ABSOLUTE CORNER INSIDE OF LAYER CHIPx PRINT M2.DN.4.density
  	[ AREA(M2x)/AREA(CHIP) ]    
}

#IFDEF CHECK_LOW_DENSITY
M2.DN.6 { @ Metal Desnsity >= ^M2_DN_6. All condition-A, Condition-B, and Condition-C must be followed.
@ (1) Condition-A: Metal density [window ^M2_DN_6_W_A um x ^M2_DN_6_W_A um, stepping ^M2_DN_6_S_A um] >= ^M2_DN_6
@ (2) Condition-B: Maximum area of merged low density windows [window ^M2_DN_6_W_BC um x ^M2_DN_6_W_BC um, stepping ^M2_DN_6_S_BC um < ^M2_DN_6] <= ^M2_DN_6_A_B um2, except merged low density windows width <= ^M2_DN_6_U um
@ (3) Condition-C: Maximum area of merged low density windows [window ^M2_DN_6_W_BC um x ^M2_DN_6_W_BC um, stepping ^M2_DN_6_S_BC um < ^M2_DN_6] <= ^M2_DN_6_A_C um2
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M2_DN_6_E_A um for condition-A and >= ^M2_DN_6_E_BC um for both condition-B/condition-C 
  M2_CHECK = M2x NOT NEW_DEN_EXC
  CHIP_CHECK = CHIP NOT NEW_DEN_EXC
  // Condition-A
  ERR_WIN_A = DENSITY M2_CHECK CHIP_CHECK < M2_DN_6 WINDOW M2_DN_6_W_A STEP M2_DN_6_S_A INSIDE OF LAYER CHIP_M2 BACKUP 
	[ AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
  F_A = WITH WIDTH (ERR_WIN_A NOT NEW_DEN_EXC) >= M2_DN_6_E_A
  DENSITY F_A M2_CHECK CHIP_CHECK < M2_DN_6 WINDOW M2_DN_6_W_A STEP M2_DN_6_S_A INSIDE OF LAYER CHIP_M2 BACKUP PRINT M2.DN.6_A.density
         [ !AREA(F_A)+AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
  // Condition-B 
  ERR_WIN_B = DENSITY M2_CHECK CHIP_CHECK < M2_DN_6 WINDOW M2_DN_6_W_BC STEP M2_DN_6_S_BC INSIDE OF LAYER CHIP_M2 BACKUP 
	[ AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
  F_B = WITH WIDTH (ERR_WIN_B NOT NEW_DEN_EXC) >= M2_DN_6_E_BC
  A = DENSITY F_B M2_CHECK CHIP_CHECK < M2_DN_6 WINDOW M2_DN_6_W_BC STEP M2_DN_6_S_BC INSIDE OF LAYER CHIP_M2 BACKUP PRINT M2.DN.6_BC.density
         [ !AREA(F_B)+AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
  B = AREA A > M2_DN_6_A_B
  C = SIZE B BY M2_DN_6_U/2 UNDEROVER
  B INTERACT C
  // Condition-C
  AREA B > M2_DN_6_A_C
}
#ENDIF


// Mx.DN.5
//===========
M2_CORE = M2x NOT SEALRING_EXCLUDE


M2.R.3 { @ Metal(pin) layers must be drawn only interact with one relative Metal(drawing) layers
   M2_PIN NOT INTERACT M2i == 1
}


//VIA2 CHECKS
//===========
#IFNDEF WIDE_ADJUST
M3Wide_2_0 = M3 WITH WIDTH > M3_S_2_W            // 0.17
M3Wide_2_1 = M3Wide_2_0 WITH WIDTH > M3_S_2_1_W  // 0.24
M3Wide_2_2 = M3Wide_2_1 WITH WIDTH > M3_S_2_2_W  // 0.31
M3Wide_2_3 = M3Wide_2_2 WITH WIDTH > M3_S_2_3_W  // 0.62
M3Wide_3_0 = M3Wide_2_3 WITH WIDTH > M3_S_3_W    // 1.65
#ELSE
M3Wide_2_4 = M3 WITH WIDTH > M3_S_2_4_W          // 0.17
M3Wide_2_0 = M3Wide_2_4 WITH WIDTH > M3_S_2_W    // 0.19
M3Wide_2_5 = M3Wide_2_0 WITH WIDTH > M3_S_2_5_W  // 0.24
M3Wide_2_1 = M3Wide_2_5 WITH WIDTH > M3_S_2_1_W  // 0.265
M3Wide_2_6 = M3Wide_2_1 WITH WIDTH > M3_S_2_6_W  // 0.31
M3Wide_2_2 = M3Wide_2_6 WITH WIDTH > M3_S_2_2_W  // 0.345
M3Wide_2_7 = M3Wide_2_2 WITH WIDTH > M3_S_2_7_W  // 0.62
M3Wide_2_3 = M3Wide_2_7 WITH WIDTH > M3_S_2_3_W  // 0.685
M3Wide_3_0 = M3Wide_2_3 WITH WIDTH > M3_S_3_W    // 1.65
#ENDIF

M2Wide_R2_VIA2 = M2Wide_2_0 WITH WIDTH > VIA2_R_2_W        // 0.21
M2Wide_R4_VIA2 = M2Wide_R2_VIA2 WITH WIDTH > VIA2_R_4_W    // 0.21
M2Wide_R3_VIA2 = M2Wide_R4_VIA2 WITH WIDTH > VIA2_R_3_W    // 0.55
M2Wide_R5_VIA2 = M2Wide_R3_VIA2 WITH WIDTH > VIA2_R_5_W    // 1.4
M2Wide_R6_VIA2 = M2Wide_R5_VIA2 WITH WIDTH > VIA2_R_6_W    // 2.1
M3Wide_R2_VIA2 = M3Wide_2_0 WITH WIDTH > VIA2_R_2_W      // 0.21
M3Wide_R4_VIA2 = M3Wide_R2_VIA2 WITH WIDTH > VIA2_R_4_W  // 0.21
M3Wide_R3_VIA2 = M3Wide_R4_VIA2 WITH WIDTH > VIA2_R_3_W  // 0.55
M3Wide_R5_VIA2 = M3Wide_R3_VIA2 WITH WIDTH > VIA2_R_5_W  // 1.4
M3Wide_R6_VIA2 = M3Wide_R5_VIA2 WITH WIDTH > VIA2_R_6_W  // 2.1

VIA2.W.1 { @ Width (maximum = minimum) (Except sealring (162,2) and {VIAx bar INSIDE {LOWMEDN NOT (LOWMEDN SIZING -4 um)}} region) = 0.07 
   NOT RECTANGLE (VIA2i NOT (SEALRING_EXCLUDE OR P_RING_REGION)) == VIA2_W_1 BY == VIA2_W_1 ORTHOGONAL ONLY
}
VIA2.S.1 { @ Space >= 0.07 
  EXT VIA2i < VIA2_S_1 ABUT < 90 SINGULAR REGION
}
VIA2.S.1.1 { @ Space [any one of VIAx connect to > 3.3V and <= 5V different net] >= ^VIA2_S_1_1
  J = STAMP (VIA2i AND M2_5V_ALL) BY M2i
  EXT J VIA2i < VIA2_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}
VIA2.S.2 { @ Space to 3-neighboring VIAx (distance < 0.098 um) >= 0.09 
  X = WITH NEIGHBOR VIA2i > 2 SPACE < VIA2_S_2_D
  EXT X VIA2i < VIA2_S_2 ABUT < 90 SINGULAR REGION
}
VIA2.S.3 { @ Space to neighboring VIAx [different net] >= 0.095 
  EXT VIA2i < VIA2_S_3 ABUT < 90 NOT CONNECTED REGION
}
VIA2.S.3.1 { @ Space to neighboring VIAx [different net and common parallel run length > 0 um] >= 0.11 
  EXT VIA2i < VIA2_S_3_1 ABUT < 90 NOT CONNECTED OPPOSITE REGION
}

// VIA2.EN.0 is checked by VIA2.EN.1, and VIA2.EN.2_VIA2.EN.4_VIA2.EN.4.1

VIA2.EN.1 { @ Enclosure by Mx or M1 >= 0.00 
  VIA2 NOT M2
}

VIA2.EN.2__VIA2.EN.4__VIA2.EN.4.1 { @ Enclosure by M2 [at least two opposite sides] >= ^VIA2_EN_2, or [four sides] >= ^VIA2_EN_4 with [at least two opposite sides] >= ^VIA2_EN_4_1
  X = RECTANGLE ENCLOSURE (VIA2 NOT SEALRING_EXCLUDE) M2 ABUT < 90 SINGULAR GOOD 0 VIA2_EN_2 OPPOSITE 0 VIA2_EN_2 OPPOSITE
  Y = ENC X M2 < VIA2_EN_4 ABUT < 90 SINGULAR REGION
  Z = RECTANGLE ENCLOSURE (X NOT TOUCH Y) M2 ABUT < 90 GOOD VIA2_EN_4 VIA2_EN_4_1 OPPOSITE VIA2_EN_4 VIA2_EN_4_1 OPPOSITE
  (Y OR (ENC Z M2 < VIA2_EN_4_1 ABUT < 90 SINGULAR REGION)) NOT SRAM_EXCLUDE

}



// VIA2.R.1 is checked by VIA2.W.1
VIA2.R.2__VIA2.R.3 { @ When M2 or M3 width > ^VIA2_R_2_W um, more than one VIA2 is required.
                    @ 2 vias spacing should be <= ^VIA2_R_2_S1 um or 4 vias spacing should be <= ^VIA2_R_2_S2 um
                    @ When M2 or M3 width > ^VIA2_R_3_W um, more than three VIA2 is required.
                    @ 4 vias spacing should be <= ^VIA2_R_3_S1 um or 9 vias spacing should be <= ^VIA2_R_3_S2 um
                    @ not check SRAM region					
   M3OvpM2_W_ = (M2Wide_R2_VIA2 AND M3) OR (M3Wide_R2_VIA2 AND M2)
   M3OvpM2_B  = (M2Wide_R3_VIA2 AND M3) OR (M3Wide_R3_VIA2 AND M2)
   M3OvpM2_W  = M3OvpM2_W_ NOT M3OvpM2_B 
   Checked_VIA2_W_ = VIA2_EXD NOT OUTSIDE M3OvpM2_W
   Checked_VIA2_B  = VIA2_EXD NOT OUTSIDE M3OvpM2_B
   Checked_VIA2_W  = Checked_VIA2_W_ NOT Checked_VIA2_B
   M2_effect = M2i INTERACT M3OvpM2_W_
   M3_effect = M3i INTERACT M3OvpM2_W_
   effect_M3OvpM2_ = M2_effect AND M3_effect
   effect_M3OvpM2 = effect_M3OvpM2_ INTERACT M3OvpM2_W_
   effect_VIA = VIA2_EXD INTERACT effect_M3OvpM2

   V2Merged_A = SIZE effect_VIA BY VIA2_R_2_S1/2 INSIDE OF effect_M3OvpM2 STEP M2_S_1*0.7
   V2Merged_B = SIZE V2Merged_A BY (VIA2_R_2_S2 - VIA2_R_2_S1)/2 INSIDE OF effect_M3OvpM2 STEP M2_S_1*0.7
   V2Merged_C = SIZE V2Merged_B BY (VIA2_R_3_S2 - VIA2_R_2_S2)/2 INSIDE OF effect_M3OvpM2 STEP M2_S_1*0.7
   V2Merged_A2R = V2Merged_A INTERACT effect_VIA < 2
   V2Merged_A2 = V2Merged_A OUTSIDE V2Merged_A2R
   V2Merged_A4R = V2Merged_A2 INTERACT effect_VIA < 4
   V2Merged_A4 = V2Merged_A2 OUTSIDE V2Merged_A4R
   V2Merged_B4R = V2Merged_B INTERACT effect_VIA < 4
   V2Merged_B4 = V2Merged_B OUTSIDE V2Merged_B4R
   V2Merged_C9R = V2Merged_C INTERACT effect_VIA < 9
   V2Merged_C9 = V2Merged_C OUTSIDE V2Merged_C9R

   GMergeW = V2Merged_A2 OR V2Merged_B4
   GMergeB = V2Merged_A4 OR V2Merged_C9
   GVIA_W = Checked_VIA2_W INTERACT GMergeW
   GVIA_B = Checked_VIA2_B INTERACT GMergeB
   GOOD_AREA_W = M3OvpM2_W INTERACT GVIA_W
   GOOD_AREA_B = M3OvpM2_B INTERACT GVIA_B
   Checked_VIA2_W OUTSIDE GOOD_AREA_W
   Checked_VIA2_B OUTSIDE GOOD_AREA_B
}

VIA2.R.4.M2 { @ At least two VIAx must be used for a connection that is <= ^VIA2_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_4_W um (L) and width > ^VIA2_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA2_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_4_W um (L) and width > ^VIA2_R_4_W um (W).)   
  Branch1 = ((SIZE M2Wide_R4_VIA2 BY VIA2_R_4_D + GRID) NOT M2Wide_R4_VIA2) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Wide_R4_VIA2) INTERACT VIA2_EXD
  Branch1Edge = M2Wide_R4_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_4_D INSIDE OF Branch1HasVia STEP M2_S_1*0.5
  GoodBranch = (Branch AND M3) INTERACT VIA2_EXD > 1
  BranchSingleVia = (VIA2_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA2_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA2.R.4.M3 { @ At least two VIAx must be used for a connection that is <= ^VIA2_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_4_W um (L) and width > ^VIA2_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA2_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_4_W um (L) and width > ^VIA2_R_4_W um (W)).   
  Branch1 = ((SIZE M3Wide_R4_VIA2 BY VIA2_R_4_D + GRID) NOT M3Wide_R4_VIA2) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Wide_R4_VIA2) INTERACT VIA2_EXD
  Branch1Edge = M3Wide_R4_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_4_D INSIDE OF Branch1HasVia STEP M3_S_1*0.5
  GoodBranch = (Branch AND M2) INTERACT VIA2_EXD > 1
  BranchSingleVia = (VIA2_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA2_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA2.R.5.M2 { @ At least two VIAx must be used for a connection that is <= ^VIA2_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_5_W um (L) and width > ^VIA2_R_5_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA2_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA2_R_5_W um (L) and width > ^VIA2_R_5_W um (W)).
  Branch1 = ((SIZE M2Wide_R5_VIA2 BY VIA2_R_5_D + GRID) NOT M2Wide_R5_VIA2) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Wide_R5_VIA2) INTERACT VIA2_EXD
  Branch1Edge = M2Wide_R5_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_5_D INSIDE OF Branch1HasVia STEP M2_S_1*0.7
  GoodBranch = (Branch AND M3) INTERACT VIA2_EXD > 1
  BranchSingleVia = (VIA2_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA2_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA2.R.5.M3 { @ At least two VIAx must be used for a connection that is <= ^VIA2_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_5_W um (L) and width > ^VIA2_R_5_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA2_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA2_R_5_W um (L) and width > ^VIA2_R_5_W um (W)).
  Branch1 = ((SIZE M3Wide_R5_VIA2 BY VIA2_R_5_D + GRID) NOT M3Wide_R5_VIA2) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Wide_R5_VIA2) INTERACT VIA2_EXD
  Branch1Edge = M3Wide_R5_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_5_D INSIDE OF Branch1HasVia STEP M3_S_1*0.7
  GoodBranch = (Branch AND M2) INTERACT VIA2_EXD > 1
  BranchSingleVia = (VIA2_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA2_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M2Big_R6_VIA2 = ENCLOSE RECTANGLE M2Wide_R6_VIA2 VIA2_R_6_W VIA2_R_6_L+GRID

VIA2.R.6.M2 { @ At least two VIAx must be used for a connection that is <= ^VIA2_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_6_L um (L) and width > ^VIA2_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA2_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA2_R_6_L um (L) and width > ^VIA2_R_6_W um (W)).
  Branch1 = ((SIZE M2Big_R6_VIA2 BY VIA2_R_6_D + GRID) NOT M2Big_R6_VIA2) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Big_R6_VIA2) INTERACT VIA2_EXD
  Branch1Edge = M2Big_R6_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_6_D INSIDE OF Branch1HasVia STEP M2_S_1*0.7
  GoodBranch = (Branch AND M3) INTERACT VIA2_EXD > 1
  BranchSingleVia = (VIA2_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA2_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M3Big_R6_VIA2 = ENCLOSE RECTANGLE M3Wide_R6_VIA2 VIA2_R_6_W VIA2_R_6_L+GRID

VIA2.R.6.M3 { @ At least two VIAx must be used for a connection that is <= ^VIA2_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_6_L um (L) and width > ^VIA2_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA2_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA2_R_6_L um (L) and width > ^VIA2_R_6_W um (W)).
  Branch1 = ((SIZE M3Big_R6_VIA2 BY VIA2_R_6_D + GRID) NOT M3Big_R6_VIA2) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Big_R6_VIA2) INTERACT VIA2_EXD
  Branch1Edge = M3Big_R6_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_6_D INSIDE OF Branch1HasVia STEP M3_S_1*0.7
  GoodBranch = (Branch AND M2) INTERACT VIA2_EXD > 1
  BranchSingleVia = (VIA2_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA2_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}
// VIA2.R.7 is checked by VIA2.EN.1
// VIA2.R.9 can't be checked

VIA2.R.11 { @ Single VIAx is not allowed for H-shape Mx+1 when all of the following conditions come into existence: 1. The Mx+1 has H-shape interact with two metal holes: two metal hole length(L2) <= ^VIA2_R_11_L1 um and both two metal hole area <= ^VIA2_R_11_A um2 2. The VIAx overlaps on the center metal bar of this H-shape Mx+1 3. The length (L) of the center metal bar <= ^VIA2_R_11_L2 um and the width of metal bar is <= ^VIA2_R_11_W um.
  W = M3i WITH WIDTH <= VIA2_R_11_W   
  H_HOLE = HOLES M3i INNER <= VIA2_R_11_A
  A = M3i COIN OUTSIDE EDGE H_HOLE
  B0 = ((INT A <= VIA2_R_11_W ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE M3i) INTERACT H_HOLE == 2 
  B1 = (((INT A <= VIA2_R_11_L2 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE M3i) AND W) INTERACT H_HOLE == 2
  HOLE_NOTCH = EXT H_HOLE <= VIA2_R_11_W ABUT<90 OPPOSITE NOTCH REGION  
  B2 = (B1 NOT HOLE_NOTCH) OR B0
  CORNER_M = ((EXT B2 <= VIA2_R_11_W ABUT == 90 INTERSECTING ONLY REGION EXTENTS) TOUCH B2 == 2) AND W
  B = B2 OR CORNER_M
  CENTER_BAR1 = NOT ENCLOSE RECTANGLE B GRID VIA2_R_11_L2+GRID
  CENTER_BAR2 = CENTER_BAR1 INTERACT H_HOLE == 2
  C = CENTER_BAR2 COIN OUTSIDE EDGE H_HOLE 
  D = EXT [C] M3i <= VIA2_R_11_L1 OPPOSITE
  E = C NOT COIN INSIDE EDGE D
  CENTER_BAR3 = CENTER_BAR2 NOT WITH EDGE E
  CHECK_VIA = VIA2 NOT OUTSIDE CENTER_BAR3
  CHECK_VIA AND (((M3i INTERACT CHECK_VIA) AND (M2i INTERACT CHECK_VIA)) INTERACT VIA2i == 1)
}

VIA2.R.12 { @ VIA2 connected to DM2, DM2_O, DM3, DM3_O is not allowed
  VIA2 INTERACT DUM2
  VIA2 INTERACT DUM3
  VIA2 INTERACT DM2_O
  VIA2 INTERACT DM3_O
}  

//M3 CHECKS
//=========


M3_EDGE_45 = M3 ANGLE == 45

M3.W.1 { @ Width >= 0.07 
  INT M3 < M3_W_1 ABUT < 90 SINGULAR REGION
}
M3.W.2 { @ Width of 45-degree bent Mx. (Please make sure the vertex of 45 degree pattern is on 0.005 um grid (refer to the guideline, G.6gU, in section 3.7)) >= 0.17 
  INT M3_EDGE_45 < M3_W_2 ABUT < 90 REGION
}
M3.W.3 { @ Maximum width <= ^M3_W_3 um, exclude sealring 
  M3_MAX_WIDTH WITH WIDTH > M3_W_3
}

M3.S.1 { @ Space >= 0.07 
  EXT M3 < M3_S_1 ABUT < 90 SINGULAR REGION
}
M3.S.2 { @ Min. Metal space (for W> ^M3_S_2_W um & parallel length > ^M3_S_2_L um) >= ^M3_S_2 um
  X = EXT M3Wide_2_0 M3 < M3_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_2_L+GRID
}
M3.S.2.1 { @ Min. Metal space (for W> ^M3_S_2_1_W um & parallel length > ^M3_S_2_1_L um) >= ^M3_S_2_1 um
  X = EXT M3Wide_2_1 M3 < M3_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_2_1_L+GRID
}
M3.S.2.2 { @ Min. Metal space (for W> ^M3_S_2_2_W um & parallel length > ^M3_S_2_2_L um) >= ^M3_S_2_2 um
  X = EXT M3Wide_2_2 M3 < M3_S_2_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_2_2_L+GRID
}
M3.S.2.3 { @ Min. Metal space (for W> ^M3_S_2_3_W um & parallel length > ^M3_S_2_3_L um) >= ^M3_S_2_3 um
  X = EXT M3Wide_2_3 M3 < M3_S_2_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_2_3_L+GRID
}
#IFDEF WIDE_ADJUST
M3.S.2.4 { @ Min. Metal space (for W> ^M3_S_2_4_W um & parallel length > ^M3_S_2_4_L um) >= ^M3_S_2_4 um
  X = EXT M3Wide_2_4 M3 < M3_S_2_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_2_4_L+GRID
}
M3.S.2.5 { @ Min. Metal space (for W> ^M3_S_2_5_W um & parallel length > ^M3_S_2_5_L um) >= ^M3_S_2_5 um
  X = EXT M3Wide_2_5 M3 < M3_S_2_5 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_2_5_L+GRID
}
M3.S.2.6 { @ Min. Metal space (for W> ^M3_S_2_6_W um & parallel length > ^M3_S_2_6_L um) >= ^M3_S_2_6 um
  X = EXT M3Wide_2_6 M3 < M3_S_2_6 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_2_6_L+GRID
}
M3.S.2.7 { @ Min. Metal space (for W> ^M3_S_2_7_W um & parallel length > ^M3_S_2_7_L um) >= ^M3_S_2_7 um
  X = EXT M3Wide_2_7 M3 < M3_S_2_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_2_7_L+GRID
}
#ENDIF
M3.S.3 { @ Min. Metal space (for W> ^M3_S_3_W um & parallel length > ^M3_S_3_L um) >= ^M3_S_3 um
  X = EXT M3Wide_3_0 M3 < M3_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  (ENCLOSE RECTANGLE Y 0.001 M3_S_3_L+0.001) NOT INSIDE IND_REGION
}
M3.S.5 { @ Space at Mx line-end (W < 0.10 um (Q)) in a dense-line-end configuration: If Mx has parallel run length with opposite Mx (measured with T = 0.035 um extension) along 2 adjacent edges of Mx [any one edge <Q distance from the corner of the two edges], then one of the space (S1 or S2) needs to be at least this value (This check doesn't include small jog with edge length < 0.07 um(R)) (M2.S.5 except SRAM (186;0) region) >= 0.10 
  A = CONVEX EDGE M3 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M3_S_5_W
  B = EXT [A] M3 < M3_S_5 ABUT < 90 OPPOSITE EXTENDED M3_S_5_T
  C = A TOUCH INSIDE EDGE B
  D = INT C [M3] < M3_S_5_W ABUT == 90 INTERSECTING ONLY
  I = LENGTH D >= M3_W_1
  J = EXPAND EDGE I INSIDE BY 0.001 EXTEND BY M3_S_5_T
  K = EXPAND EDGE I INSIDE BY 0.001 
  L = J NOT K
  M = L WITH EDGE A 
  N = M OR K
  O = N TOUCH EDGE I
  EXT O M3 < M3_S_5 ABUT < 90 OPPOSITE REGION

}

M3.S.5.1 { @ Space at Mx line-end (W<Q=^M3_S_5_1_W) in a dense-line-end configuration.If Mx has parallel run length with opposite Mx (measured with ^M3_S_5_1_T (T) extension) along two adjacent edges of Mx [any one edge < ^M3_S_5_1_W (W) from the corner of the two edges of Mx], and Mx enclosure of VIAx-1 < ^M3_S_5_1_E at line-end, then one of the space (S1 or S2) must be >= ^M3_S_5_1 um.
  A = CONVEX EDGE M3 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M3_S_5_1_W
  V2_EN = ENC [VIA2i] A < M3_S_5_1_E ABUT < 90 OPPOSITE
  M3_EN = ENC V2_EN [A] < M3_S_5_1_E ABUT < 90 OPPOSITE
  M3_SA = EXT A [M3] < M3_S_5_1 ABUT < 90 OPPOSITE EXTENDED M3_S_5_1_T
  M3_SB = EXT [A] M3_SA < M3_S_5_1 ABUT < 90 OPPOSITE EXTENDED M3_S_5_1_T
  M3_END = (A TOUCH INSIDE EDGE M3_EN) TOUCH INSIDE EDGE M3_SB
  EN_B = ENC V2_EN [M3_END] < M3_S_5_1_E2 OPPOSITE
  EN_C = ENC V2_EN [M3_END] < M3_S_5_1_E3 OPPOSITE
  EN_D = ENC V2_EN [M3_END] < M3_S_5_1_E4 OPPOSITE
  S1_B = EXT [M3_END] M3_SA < M3_S_5_1_S2 OPPOSITE EXTENDED M3_S_5_1_T
  S1_C = EXT [M3_END] M3_SA < M3_S_5_1_S3 OPPOSITE EXTENDED M3_S_5_1_T
  S1_D = EXT [M3_END] M3_SA < M3_S_5_1_S4 OPPOSITE EXTENDED M3_S_5_1_T
  PASS_B = (M3_END NOT TOUCH INSIDE EDGE EN_B) NOT TOUCH INSIDE EDGE S1_B
  PASS_C = (M3_END NOT TOUCH INSIDE EDGE EN_C) NOT TOUCH INSIDE EDGE S1_C
  PASS_D = (M3_END NOT TOUCH INSIDE EDGE EN_D) NOT TOUCH INSIDE EDGE S1_D
  M3_CHECK = ((M3_END NOT TOUCH INSIDE EDGE PASS_B) NOT TOUCH INSIDE EDGE PASS_C) NOT TOUCH INSIDE EDGE PASS_D
  H = INT M3_CHECK [M3] < M3_S_5_1_W ABUT == 90 INTERSECTING ONLY
  I = LENGTH H >= M3_W_1
  J = EXPAND EDGE I INSIDE BY GRID EXTEND BY M3_S_5_1_T
  K = EXPAND EDGE I INSIDE BY GRID
  L = J NOT K
  M = L WITH EDGE A 
  N = M OR K
  O = N TOUCH INSIDE EDGE I
  P = EXT [O] M3 < M3_S_5_1 ABUT < 90 OPPOSITE
  Q = ENC VIA2i (O TOUCH INSIDE EDGE P) < M3_S_5_1_E ABUT < 90 OPPOSITE REGION
  VIA_BAD1 = VIA2i INTERACT Q
  VIA_GOOD = VIA2i NOT VIA_BAD1
  VIA_BAD2 = VIA_BAD1 NOT INTERACT ((M3 AND M2) INTERACT VIA_GOOD)
  ENC VIA_BAD2 M3_CHECK < M3_S_5_1_E ABUT < 90 OPPOSITE REGION
}

M3.S.6 { @ Space to 45-degree bent Mx >= 0.17 
  X = EXPAND EDGE M3_EDGE_45 OUTSIDE BY M3_S_6
  X AND M3
}


M3_HVN_5V = NET AREA RATIO M3i OVER M10_HV_5V M9_HV_5V M8_HV_5V M7_HV_5V M6_HV_5V M5_HV_5V M4_HV_5V M3_HV_5V M2_HV_5V M1_HV_5V > 0 
M3_HVN = NET AREA RATIO M3i OVER M10_HV M9_HV M8_HV M7_HV M6_HV M5_HV M4_HV M3_HV M2_HV M1_HV > 0 
M3_MVN = NET AREA RATIO M3i OVER M10_MV M9_MV M8_MV M7_MV M6_MV M5_MV M4_MV M3_MV M2_MV M1_MV > 0
M3_LVN = NET AREA RATIO M3i OVER M10_LV M9_LV M8_LV M7_LV M6_LV M5_LV M4_LV M3_LV M2_LV M1_LV > 0

M3_NOMARK = (((M3i NOT M3_HVN_5V) NOT M3_HVN) NOT M3_MVN) NOT M3_LVN

#IFDEF Mx_S_8_IO_NET
  M3_NOMARK_5V = NET AREA RATIO M3_NOMARK PSD_HVD NSD_HVD S_HVD_GATE PSTPi > 0 
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD)+!!AREA(S_HVD_GATE))*!AREA(PSTPi)]
  M3_NOMARK_HV = NET AREA RATIO M3_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPi > 0 
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPi)]
  M3_NOMARK_MV = NET AREA RATIO M3_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPi > 0 
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPi)]
#ELSE  
  M3_NOMARK_5V = NET AREA RATIO M3_NOMARK PSD_HVD NSD_HVD S_HVD_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD)+!!AREA(S_HVD_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M3_NOMARK_HV = NET AREA RATIO M3_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M3_NOMARK_MV = NET AREA RATIO M3_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)] 
#ENDIF 

M3_5V_ALL = M3_HVN_5V OR M3_NOMARK_5V  
M3_HV_ALL = M3_HVN OR M3_NOMARK_HV
M3_MV_ALL = M3_MVN OR M3_NOMARK_MV

M3.S.1.1 { @ Space [any one of Mx connect to > 3.3V and <= 5V net] >= ^M3_S_1_1
  I = STAMP M3_5V_ALL BY M3i
  EXT I M3i < M3_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}
M3.S.8.2 { @ Space to neighboring {VIAx-1 or VIAx} [either VIAx-1, VIAx or Mx connects to > 3.3V and <= 5V net] >= ^M3_S_8_2
  I = STAMP M3_5V_ALL BY M3i
  J = STAMP (VIA2i AND M3_5V_ALL) BY M3i
  EXT I VIA2i < M3_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M3i < M3_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA3i AND M3_5V_ALL) BY M3i
  EXT I VIA3i < M3_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M3i < M3_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}
M3.S.8 { @ Space to {VIAx-1 OR VIAx} [different net, any one of VIAx-1, VIAx or Mx connects to 1.8V ~ 3.3V net] 0.1  
  I = STAMP M3_HV_ALL BY M3i
  J = STAMP (VIA2i AND M3_HV_ALL) BY M3i
  EXT I VIA2i < M3_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M3i < M3_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA3i AND M3_HV_ALL) BY M3i
  EXT I VIA3i < M3_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M3i < M3_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}
M3.S.8.1 { @ Space to {VIAx-1 OR VIAx} [different net, any one of VIAx-1, VIAx or Mx connects to >= 1.5V and < 1.8V net] 0.08  
  I = STAMP M3_MV_ALL BY M3i
  J = STAMP (VIA2i AND M3_MV_ALL) BY M3i
  EXT I VIA2i < M3_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M3i < M3_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA3i AND M3_MV_ALL) BY M3i
  EXT I VIA3i < M3_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M3i < M3_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}

M3.S.9 { @ This rule is to check Metal (A) space to neighboring VIAx [either VIAx or Mx connects to >3.3V and <= 5V net]. DRC methodology to find Metal (A) Find a edge (B) of metal line end [edge length <= 0.12um] Run length (C) from edge (B) inside metal >= 0.13um Jog length (D) <= 0.01um within 0.13um run length Extend 0.06um outside from edge (B) to form a polygon metal (A) Metal (A) is defined if conditions 1~4 are all satisfied. >= 0.15 
  LINE_END_pre   = CONVEX EDGE M3 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= M3_S_9_B
  LINE_END_pre1  = EXPAND EDGE LINE_END_pre INSIDE BY GRID EXTEND BY -M3_S_9_D    
  LINE_END_pre2  = LINE_END_pre COIN INSIDE EDGE LINE_END_pre1  
  LINE_END_pre3  = INT [LINE_END_pre2] M3 < M3_S_9_C OPPOSITE 
  LINE_END_pre4  = LINE_END_pre NOT TOUCH INSIDE EDGE LINE_END_pre3
  LINE_END_pre5  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M3_S_9_D+GRID
  LINE_END_pre6  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M3_S_9_D
  LINE_END_pre7  = LINE_END_pre5 NOT LINE_END_pre6
  LINE_END_pre8  = LINE_END_pre5 TOUCH OUTSIDE EDGE LINE_END_pre4
  LINE_END_pre9  = LINE_END_pre8 COIN INSIDE EDGE LINE_END_pre7 
  LINE_END_pre10 = EXT [LINE_END_pre9] M3 < M3_S_9_C OPPOSITE
  LINE_END = LINE_END_pre4 NOT TOUCH OUTSIDE EDGE (LINE_END_pre8 TOUCH INSIDE EDGE LINE_END_pre10)
  A = EXPAND EDGE LINE_END OUTSIDE BY M3_S_9_A INSIDE BY GRID
  B = STAMP A BY M3i
  I = STAMP (A INTERACT M3_5V_ALL) BY M3i
  J = STAMP (VIA2i AND M3_5V_ALL) BY M3i
  K = STAMP (VIA3i AND M3_5V_ALL) BY M3i
  X1 = EXT I VIA2i < M3_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X2 = EXT I VIA3i  < M3_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X3 = EXT J B < M3_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X4 = EXT K B < M3_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  Y = ((X1 OR X2) OR X3) OR X4   
  COPY Y
  A INTERACT Y
}

// M3.EN.0 is checked by M3.EN.1, and M3.EN.2_M3.EN.3_M3.EN.3.1

M3.EN.1 { @ Enclosure of VIAx-1 >= 0.00 
  VIA2 NOT M3
}
M3.EN.2__M3.EN.3__M3.EN.3.1 { @ Enclosure of VIAx-1 [at least two opposite sides] >= ^M3_EN_2, or [four sides] >= ^M3_EN_3 with [at least two opposite sides] >= ^M3_EN_3_1
  X = RECTANGLE ENCLOSURE (VIA2 NOT SEALRING_ALL) M3 ABUT < 90 SINGULAR GOOD 0 M3_EN_2 OPPOSITE 0 M3_EN_2 OPPOSITE
  Y = ENC X M3 < M3_EN_3 ABUT < 90 SINGULAR REGION
  Z = RECTANGLE ENCLOSURE (X NOT TOUCH Y) M3 ABUT < 90 GOOD M3_EN_3 M3_EN_3_1 OPPOSITE M3_EN_3 M3_EN_3_1 OPPOSITE
  (Y OR (ENC Z M3 < M3_EN_3_1 ABUT < 90 SINGULAR REGION)) NOT SRAM_EXCLUDE
}
M3.A.1 { @ Area (M2.A.1 except SRAM (186;0) region) >= 0.027 
     AREA M3 < M3_A_1
}
M3.A.2 { @ Area [with all of edge length< 0.17 um] (This check doesn't include the patterns filling 0.07 um x 0.17 um rectangular tile) (M2.A.2 except SRAM (186;0) region) >= 0.06 
  A = AREA M3 < M3_A_2
  B = LENGTH A >= M3_A_2_L1
  C = A NOT WITH EDGE B
  NOT ENCLOSE RECTANGLE C M3_A_2_W M3_A_2_L2 ORTHOGONAL ONLY
}


VARIABLE M3_A_3pre ((M3_A_3 + (M3_S_1 * M3_S_1 * 3.142))/(2 * M3_S_1))*((M3_A_3 + (M3_S_1 * M3_S_1 * 3.142))/(2 * M3_S_1))/3.141

M3.A.3 { @ Enclosed area >= 0.2 
  X = HOLES M3 INNER < M3_A_3pre
  AREA ( X NOT M3 ) < M3_A_3
}

// M3.R.1 can not be checked


#IFDEF FULL_CHIP
CHIP_M3 = COPY CHIP
#ELSE
CHIP_M3 = CHIP INTERACT M3x
#ENDIF

#IFDEF CHECK_LOW_DENSITY
M3.DN.1 { @ Minimum local density [window ^M3_DN_1_W um x ^M3_DN_1_W um, stepping ^M3_DN_1_S um] >= ^M3_DN_1
  M3_CHECK = M3x NOT M3_EXC_LOW
  CHIP_CHECK = CHIP NOT M3_EXC_LOW
  
  ERR_WIN = DENSITY M3_CHECK CHIP_CHECK < M3_DN_1 WINDOW M3_DN_1_W STEP M3_DN_1_S INSIDE OF LAYER CHIP_M3 BACKUP 
	[ AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M3_EXC_LOW) >= M3_DN_1_E
  DENSITY F M3_CHECK CHIP_CHECK < M3_DN_1 WINDOW M3_DN_1_W STEP M3_DN_1_S INSIDE OF LAYER CHIP_M3 BACKUP PRINT M3.DN.1.density
         [ !AREA(F)+AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
}
#ENDIF

M3.DN.1.1 { @ Maximum local density [window ^M3_DN_1_1_W um x ^M3_DN_1_1_W um, stepping ^M3_DN_1_1_S um] <= ^M3_DN_1_1
  M3_CHECK = M3x NOT M3_EXC_HIGH
  CHIP_CHECK = CHIP NOT M3_EXC_HIGH
  ERR_WIN = DENSITY M3_CHECK CHIP_CHECK > M3_DN_1_1 WINDOW M3_DN_1_1_W STEP M3_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M3_EXC_HIGH) >= M3_DN_1_1_E
  DENSITY F M3_CHECK CHIP_CHECK > M3_DN_1_1 WINDOW M3_DN_1_1_W STEP M3_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP PRINT M3.DN.1.1.density
         [ !!AREA(F)*AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
}

M3.DN.4 { @ The metal density difference between any two neighboring checking windows including DM3EXCL [window ^M3_DN_4_W um x ^M3_DN_4_W um, stepping ^M3_DN_4_W um]  <= ^M3_DN_4
  DENSITY M3x CHIP <=1 WINDOW M3_DN_4_W BACKUP GRADIENT > M3_DN_4 ABSOLUTE CORNER INSIDE OF LAYER CHIPx PRINT M3.DN.4.density
  	[ AREA(M3x)/AREA(CHIP) ]    
}

#IFDEF CHECK_LOW_DENSITY
M3.DN.6 { @ Metal Desnsity >= ^M3_DN_6. All condition-A, Condition-B, and Condition-C must be followed.
@ (1) Condition-A: Metal density [window ^M3_DN_6_W_A um x ^M3_DN_6_W_A um, stepping ^M3_DN_6_S_A um] >= ^M3_DN_6
@ (2) Condition-B: Maximum area of merged low density windows [window ^M3_DN_6_W_BC um x ^M3_DN_6_W_BC um, stepping ^M3_DN_6_S_BC um < ^M3_DN_6] <= ^M3_DN_6_A_B um2, except merged low density windows width <= ^M3_DN_6_U um
@ (3) Condition-C: Maximum area of merged low density windows [window ^M3_DN_6_W_BC um x ^M3_DN_6_W_BC um, stepping ^M3_DN_6_S_BC um < ^M3_DN_6] <= ^M3_DN_6_A_C um2
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M3_DN_6_E_A um for condition-A and >= ^M3_DN_6_E_BC um for both condition-B/condition-C 
  M3_CHECK = M3x NOT NEW_DEN_EXC
  CHIP_CHECK = CHIP NOT NEW_DEN_EXC
  // Condition-A
  ERR_WIN_A = DENSITY M3_CHECK CHIP_CHECK < M3_DN_6 WINDOW M3_DN_6_W_A STEP M3_DN_6_S_A INSIDE OF LAYER CHIP_M3 BACKUP 
	[ AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
  F_A = WITH WIDTH (ERR_WIN_A NOT NEW_DEN_EXC) >= M3_DN_6_E_A
  DENSITY F_A M3_CHECK CHIP_CHECK < M3_DN_6 WINDOW M3_DN_6_W_A STEP M3_DN_6_S_A INSIDE OF LAYER CHIP_M3 BACKUP PRINT M3.DN.6_A.density
         [ !AREA(F_A)+AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
  // Condition-B 
  ERR_WIN_B = DENSITY M3_CHECK CHIP_CHECK < M3_DN_6 WINDOW M3_DN_6_W_BC STEP M3_DN_6_S_BC INSIDE OF LAYER CHIP_M3 BACKUP 
	[ AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
  F_B = WITH WIDTH (ERR_WIN_B NOT NEW_DEN_EXC) >= M3_DN_6_E_BC
  A = DENSITY F_B M3_CHECK CHIP_CHECK < M3_DN_6 WINDOW M3_DN_6_W_BC STEP M3_DN_6_S_BC INSIDE OF LAYER CHIP_M3 BACKUP PRINT M3.DN.6_BC.density
         [ !AREA(F_B)+AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
  B = AREA A > M3_DN_6_A_B
  C = SIZE B BY M3_DN_6_U/2 UNDEROVER
  B INTERACT C
  // Condition-C
  AREA B > M3_DN_6_A_C
}
#ENDIF


// Mx.DN.5
//===========
M3_CORE = M3x NOT SEALRING_EXCLUDE

Mx.DN.5:M1_M2_M3 { @ It is not allowed to have local density > 85% of all 3 consecutive metal (Mx, Mx+1 and Mx+2) over any window 62.5 um x 62.5 um (stepping 31.25 um), i.e. it is allowed for either one of Mx, Mx+1, or Mx+2 to have a local density <= 85%. 1. The metal layers include M1/Mx and dummy metals. 2. The check does not include chip corner stress relief pattern, sealring (162;2) and top2 metals at CUP area.   
    DENSITY  M1_CORE M2_CORE M3_CORE >0 WINDOW M1_DN_5_W STEP M1_DN_5_S BACKUP INSIDE OF LAYER CHIPx
  	  [ !~(AREA(M1_CORE)/AREA()- M1_DN_5)*!~(AREA(M2_CORE)/AREA()- M1_DN_5)*!~(AREA(M3_CORE)/AREA()- M1_DN_5) ]
 	  RDB Mx.DN.5:M1_M2_M3.density
}
#IFDEF CHECK_LOW_DENSITY
Mx.DN.7:M1_M2_M3 { @ It is not allowed to have local density < 5% of all 3 consecutive metal layer(M1,M2,M3) over any 30umx30um window (stepping 15um), i.e. it is allowed for either one of M1, M2, or M3 to have a local density >= 5 %.
@ 1. The metal layers include M1/Mx and dummy metals
@ 2. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 3. This rule is applied while the width of (checking window NOT above excluding region) >= 15 um    
   M1_CHECK = M1x NOT NEW_DEN_EXC
   M2_CHECK = M2x NOT NEW_DEN_EXC
   M3_CHECK = M3x NOT NEW_DEN_EXC
   CHIP_CHECK = CHIP NOT NEW_DEN_EXC
   ERR_WIN = DENSITY M1_CHECK M2_CHECK M3_CHECK CHIP_CHECK >0 WINDOW M1_DN_7_W STEP M1_DN_7_S BACKUP INSIDE OF LAYER CHIP_M3
   [ !~(M1_DN_7-AREA(M1_CHECK)/AREA(CHIP_CHECK))*!~(M1_DN_7-AREA(M2_CHECK)/AREA(CHIP_CHECK))*!~(M1_DN_7-AREA(M3_CHECK)/AREA(CHIP_CHECK)) ]
   F = WITH WIDTH (ERR_WIN NOT NEW_DEN_EXC) >= M1_DN_7_E
   DENSITY F M1_CHECK M2_CHECK M3_CHECK CHIP_CHECK >0 WINDOW M1_DN_7_W STEP M1_DN_7_S BACKUP INSIDE OF LAYER CHIP_M3
   [ !!AREA(F)*!~(M1_DN_7-AREA(M1_CHECK)/AREA(CHIP_CHECK))*!~(M1_DN_7-AREA(M2_CHECK)/AREA(CHIP_CHECK))*!~(M1_DN_7-AREA(M3_CHECK)/AREA(CHIP_CHECK)) ]
   RDB Mx.DN.7:M1_M2_M3.density
}
#ENDIF

M3.R.3 { @ Metal(pin) layers must be drawn only interact with one relative Metal(drawing) layers
   M3_PIN NOT INTERACT M3i == 1
}


//VIA3 CHECKS
//===========
#IFNDEF WIDE_ADJUST
M4Wide_2_0 = M4 WITH WIDTH > M4_S_2_W            // 0.17
M4Wide_2_1 = M4Wide_2_0 WITH WIDTH > M4_S_2_1_W  // 0.24
M4Wide_2_2 = M4Wide_2_1 WITH WIDTH > M4_S_2_2_W  // 0.31
M4Wide_2_3 = M4Wide_2_2 WITH WIDTH > M4_S_2_3_W  // 0.62
M4Wide_3_0 = M4Wide_2_3 WITH WIDTH > M4_S_3_W    // 1.65
#ELSE
M4Wide_2_4 = M4 WITH WIDTH > M4_S_2_4_W          // 0.17
M4Wide_2_0 = M4Wide_2_4 WITH WIDTH > M4_S_2_W    // 0.19
M4Wide_2_5 = M4Wide_2_0 WITH WIDTH > M4_S_2_5_W  // 0.24
M4Wide_2_1 = M4Wide_2_5 WITH WIDTH > M4_S_2_1_W  // 0.265
M4Wide_2_6 = M4Wide_2_1 WITH WIDTH > M4_S_2_6_W  // 0.31
M4Wide_2_2 = M4Wide_2_6 WITH WIDTH > M4_S_2_2_W  // 0.345
M4Wide_2_7 = M4Wide_2_2 WITH WIDTH > M4_S_2_7_W  // 0.62
M4Wide_2_3 = M4Wide_2_7 WITH WIDTH > M4_S_2_3_W  // 0.685
M4Wide_3_0 = M4Wide_2_3 WITH WIDTH > M4_S_3_W    // 1.65
#ENDIF

M3Wide_R2_VIA3 = M3Wide_2_0 WITH WIDTH > VIA3_R_2_W        // 0.21
M3Wide_R4_VIA3 = M3Wide_R2_VIA3 WITH WIDTH > VIA3_R_4_W    // 0.21
M3Wide_R3_VIA3 = M3Wide_R4_VIA3 WITH WIDTH > VIA3_R_3_W    // 0.55
M3Wide_R5_VIA3 = M3Wide_R3_VIA3 WITH WIDTH > VIA3_R_5_W    // 1.4
M3Wide_R6_VIA3 = M3Wide_R5_VIA3 WITH WIDTH > VIA3_R_6_W    // 2.1
M4Wide_R2_VIA3 = M4Wide_2_0 WITH WIDTH > VIA3_R_2_W      // 0.21
M4Wide_R4_VIA3 = M4Wide_R2_VIA3 WITH WIDTH > VIA3_R_4_W  // 0.21
M4Wide_R3_VIA3 = M4Wide_R4_VIA3 WITH WIDTH > VIA3_R_3_W  // 0.55
M4Wide_R5_VIA3 = M4Wide_R3_VIA3 WITH WIDTH > VIA3_R_5_W  // 1.4
M4Wide_R6_VIA3 = M4Wide_R5_VIA3 WITH WIDTH > VIA3_R_6_W  // 2.1

VIA3.W.1 { @ Width (maximum = minimum) (Except sealring (162,2) and {VIAx bar INSIDE {LOWMEDN NOT (LOWMEDN SIZING -4 um)}} region) = 0.07 
   NOT RECTANGLE (VIA3i NOT (SEALRING_EXCLUDE OR P_RING_REGION)) == VIA3_W_1 BY == VIA3_W_1 ORTHOGONAL ONLY
}
VIA3.S.1 { @ Space >= 0.07 
  EXT VIA3i < VIA3_S_1 ABUT < 90 SINGULAR REGION
}
VIA3.S.1.1 { @ Space [any one of VIAx connect to > 3.3V and <= 5V different net] >= ^VIA3_S_1_1
  J = STAMP (VIA3i AND M3_5V_ALL) BY M3i
  EXT J VIA3i < VIA3_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}
VIA3.S.2 { @ Space to 3-neighboring VIAx (distance < 0.098 um) >= 0.09 
  X = WITH NEIGHBOR VIA3i > 2 SPACE < VIA3_S_2_D
  EXT X VIA3i < VIA3_S_2 ABUT < 90 SINGULAR REGION
}
VIA3.S.3 { @ Space to neighboring VIAx [different net] >= 0.095 
  EXT VIA3i < VIA3_S_3 ABUT < 90 NOT CONNECTED REGION
}
VIA3.S.3.1 { @ Space to neighboring VIAx [different net and common parallel run length > 0 um] >= 0.11 
  EXT VIA3i < VIA3_S_3_1 ABUT < 90 NOT CONNECTED OPPOSITE REGION
}

// VIA3.EN.0 is checked by VIA3.EN.1, and VIA3.EN.2_VIA3.EN.4_VIA3.EN.4.1

VIA3.EN.1 { @ Enclosure by Mx or M1 >= 0.00 
  VIA3 NOT M3
}

VIA3.EN.2__VIA3.EN.4__VIA3.EN.4.1 { @ Enclosure by M3 [at least two opposite sides] >= ^VIA3_EN_2, or [four sides] >= ^VIA3_EN_4 with [at least two opposite sides] >= ^VIA3_EN_4_1
  X = RECTANGLE ENCLOSURE (VIA3 NOT SEALRING_EXCLUDE) M3 ABUT < 90 SINGULAR GOOD 0 VIA3_EN_2 OPPOSITE 0 VIA3_EN_2 OPPOSITE
  Y = ENC X M3 < VIA3_EN_4 ABUT < 90 SINGULAR REGION
  Z = RECTANGLE ENCLOSURE (X NOT TOUCH Y) M3 ABUT < 90 GOOD VIA3_EN_4 VIA3_EN_4_1 OPPOSITE VIA3_EN_4 VIA3_EN_4_1 OPPOSITE
  Y OR (ENC Z M3 < VIA3_EN_4_1 ABUT < 90 SINGULAR REGION)

}



// VIA3.R.1 is checked by VIA3.W.1
VIA3.R.2__VIA3.R.3 { @ When M3 or M4 width > ^VIA3_R_2_W um, more than one VIA3 is required.
                    @ 2 vias spacing should be <= ^VIA3_R_2_S1 um or 4 vias spacing should be <= ^VIA3_R_2_S2 um
                    @ When M3 or M4 width > ^VIA3_R_3_W um, more than three VIA3 is required.
                    @ 4 vias spacing should be <= ^VIA3_R_3_S1 um or 9 vias spacing should be <= ^VIA3_R_3_S2 um
                    @ not check SRAM region					
   M4OvpM3_W_ = (M3Wide_R2_VIA3 AND M4) OR (M4Wide_R2_VIA3 AND M3)
   M4OvpM3_B  = (M3Wide_R3_VIA3 AND M4) OR (M4Wide_R3_VIA3 AND M3)
   M4OvpM3_W  = M4OvpM3_W_ NOT M4OvpM3_B 
   Checked_VIA3_W_ = VIA3_EXD NOT OUTSIDE M4OvpM3_W
   Checked_VIA3_B  = VIA3_EXD NOT OUTSIDE M4OvpM3_B
   Checked_VIA3_W  = Checked_VIA3_W_ NOT Checked_VIA3_B
   M3_effect = M3i INTERACT M4OvpM3_W_
   M4_effect = M4i INTERACT M4OvpM3_W_
   effect_M4OvpM3_ = M3_effect AND M4_effect
   effect_M4OvpM3 = effect_M4OvpM3_ INTERACT M4OvpM3_W_
   effect_VIA = VIA3_EXD INTERACT effect_M4OvpM3

   V3Merged_A = SIZE effect_VIA BY VIA3_R_2_S1/2 INSIDE OF effect_M4OvpM3 STEP M3_S_1*0.7
   V3Merged_B = SIZE V3Merged_A BY (VIA3_R_2_S2 - VIA3_R_2_S1)/2 INSIDE OF effect_M4OvpM3 STEP M3_S_1*0.7
   V3Merged_C = SIZE V3Merged_B BY (VIA3_R_3_S2 - VIA3_R_2_S2)/2 INSIDE OF effect_M4OvpM3 STEP M3_S_1*0.7
   V3Merged_A2R = V3Merged_A INTERACT effect_VIA < 2
   V3Merged_A2 = V3Merged_A OUTSIDE V3Merged_A2R
   V3Merged_A4R = V3Merged_A2 INTERACT effect_VIA < 4
   V3Merged_A4 = V3Merged_A2 OUTSIDE V3Merged_A4R
   V3Merged_B4R = V3Merged_B INTERACT effect_VIA < 4
   V3Merged_B4 = V3Merged_B OUTSIDE V3Merged_B4R
   V3Merged_C9R = V3Merged_C INTERACT effect_VIA < 9
   V3Merged_C9 = V3Merged_C OUTSIDE V3Merged_C9R

   GMergeW = V3Merged_A2 OR V3Merged_B4
   GMergeB = V3Merged_A4 OR V3Merged_C9
   GVIA_W = Checked_VIA3_W INTERACT GMergeW
   GVIA_B = Checked_VIA3_B INTERACT GMergeB
   GOOD_AREA_W = M4OvpM3_W INTERACT GVIA_W
   GOOD_AREA_B = M4OvpM3_B INTERACT GVIA_B
   Checked_VIA3_W OUTSIDE GOOD_AREA_W
   Checked_VIA3_B OUTSIDE GOOD_AREA_B
}

VIA3.R.4.M3 { @ At least two VIAx must be used for a connection that is <= ^VIA3_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_4_W um (L) and width > ^VIA3_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA3_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_4_W um (L) and width > ^VIA3_R_4_W um (W).)   
  Branch1 = ((SIZE M3Wide_R4_VIA3 BY VIA3_R_4_D + GRID) NOT M3Wide_R4_VIA3) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Wide_R4_VIA3) INTERACT VIA3_EXD
  Branch1Edge = M3Wide_R4_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_4_D INSIDE OF Branch1HasVia STEP M3_S_1*0.5
  GoodBranch = (Branch AND M4) INTERACT VIA3_EXD > 1
  BranchSingleVia = (VIA3_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M4 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA3_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA3.R.4.M4 { @ At least two VIAx must be used for a connection that is <= ^VIA3_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_4_W um (L) and width > ^VIA3_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA3_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_4_W um (L) and width > ^VIA3_R_4_W um (W)).   
  Branch1 = ((SIZE M4Wide_R4_VIA3 BY VIA3_R_4_D + GRID) NOT M4Wide_R4_VIA3) AND M4
  Branch1HasVia = (Branch1 INTERACT M4Wide_R4_VIA3) INTERACT VIA3_EXD
  Branch1Edge = M4Wide_R4_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_4_D INSIDE OF Branch1HasVia STEP M4_S_1*0.5
  GoodBranch = (Branch AND M3) INTERACT VIA3_EXD > 1
  BranchSingleVia = (VIA3_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M4) INTERACT BranchSingleVia) INTERACT VIA3_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA3.R.5.M3 { @ At least two VIAx must be used for a connection that is <= ^VIA3_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_5_W um (L) and width > ^VIA3_R_5_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA3_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA3_R_5_W um (L) and width > ^VIA3_R_5_W um (W)).
  Branch1 = ((SIZE M3Wide_R5_VIA3 BY VIA3_R_5_D + GRID) NOT M3Wide_R5_VIA3) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Wide_R5_VIA3) INTERACT VIA3_EXD
  Branch1Edge = M3Wide_R5_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_5_D INSIDE OF Branch1HasVia STEP M3_S_1*0.7
  GoodBranch = (Branch AND M4) INTERACT VIA3_EXD > 1
  BranchSingleVia = (VIA3_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M4 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA3_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA3.R.5.M4 { @ At least two VIAx must be used for a connection that is <= ^VIA3_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_5_W um (L) and width > ^VIA3_R_5_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA3_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA3_R_5_W um (L) and width > ^VIA3_R_5_W um (W)).
  Branch1 = ((SIZE M4Wide_R5_VIA3 BY VIA3_R_5_D + GRID) NOT M4Wide_R5_VIA3) AND M4
  Branch1HasVia = (Branch1 INTERACT M4Wide_R5_VIA3) INTERACT VIA3_EXD
  Branch1Edge = M4Wide_R5_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_5_D INSIDE OF Branch1HasVia STEP M4_S_1*0.7
  GoodBranch = (Branch AND M3) INTERACT VIA3_EXD > 1
  BranchSingleVia = (VIA3_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M4) INTERACT BranchSingleVia) INTERACT VIA3_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M3Big_R6_VIA3 = ENCLOSE RECTANGLE M3Wide_R6_VIA3 VIA3_R_6_W VIA3_R_6_L+GRID

VIA3.R.6.M3 { @ At least two VIAx must be used for a connection that is <= ^VIA3_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_6_L um (L) and width > ^VIA3_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA3_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA3_R_6_L um (L) and width > ^VIA3_R_6_W um (W)).
  Branch1 = ((SIZE M3Big_R6_VIA3 BY VIA3_R_6_D + GRID) NOT M3Big_R6_VIA3) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Big_R6_VIA3) INTERACT VIA3_EXD
  Branch1Edge = M3Big_R6_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_6_D INSIDE OF Branch1HasVia STEP M3_S_1*0.7
  GoodBranch = (Branch AND M4) INTERACT VIA3_EXD > 1
  BranchSingleVia = (VIA3_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M4 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA3_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M4Big_R6_VIA3 = ENCLOSE RECTANGLE M4Wide_R6_VIA3 VIA3_R_6_W VIA3_R_6_L+GRID

VIA3.R.6.M4 { @ At least two VIAx must be used for a connection that is <= ^VIA3_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_6_L um (L) and width > ^VIA3_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA3_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA3_R_6_L um (L) and width > ^VIA3_R_6_W um (W)).
  Branch1 = ((SIZE M4Big_R6_VIA3 BY VIA3_R_6_D + GRID) NOT M4Big_R6_VIA3) AND M4
  Branch1HasVia = (Branch1 INTERACT M4Big_R6_VIA3) INTERACT VIA3_EXD
  Branch1Edge = M4Big_R6_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_6_D INSIDE OF Branch1HasVia STEP M4_S_1*0.7
  GoodBranch = (Branch AND M3) INTERACT VIA3_EXD > 1
  BranchSingleVia = (VIA3_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M4) INTERACT BranchSingleVia) INTERACT VIA3_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}
// VIA3.R.7 is checked by VIA3.EN.1
// VIA3.R.9 can't be checked

VIA3.R.11 { @ Single VIAx is not allowed for H-shape Mx+1 when all of the following conditions come into existence: 1. The Mx+1 has H-shape interact with two metal holes: two metal hole length(L2) <= ^VIA3_R_11_L1 um and both two metal hole area <= ^VIA3_R_11_A um2 2. The VIAx overlaps on the center metal bar of this H-shape Mx+1 3. The length (L) of the center metal bar <= ^VIA3_R_11_L2 um and the width of metal bar is <= ^VIA3_R_11_W um.
  W = M4i WITH WIDTH <= VIA3_R_11_W   
  H_HOLE = HOLES M4i INNER <= VIA3_R_11_A
  A = M4i COIN OUTSIDE EDGE H_HOLE
  B0 = ((INT A <= VIA3_R_11_W ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE M4i) INTERACT H_HOLE == 2 
  B1 = (((INT A <= VIA3_R_11_L2 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE M4i) AND W) INTERACT H_HOLE == 2
  HOLE_NOTCH = EXT H_HOLE <= VIA3_R_11_W ABUT<90 OPPOSITE NOTCH REGION  
  B2 = (B1 NOT HOLE_NOTCH) OR B0
  CORNER_M = ((EXT B2 <= VIA3_R_11_W ABUT == 90 INTERSECTING ONLY REGION EXTENTS) TOUCH B2 == 2) AND W
  B = B2 OR CORNER_M
  CENTER_BAR1 = NOT ENCLOSE RECTANGLE B GRID VIA3_R_11_L2+GRID
  CENTER_BAR2 = CENTER_BAR1 INTERACT H_HOLE == 2
  C = CENTER_BAR2 COIN OUTSIDE EDGE H_HOLE 
  D = EXT [C] M4i <= VIA3_R_11_L1 OPPOSITE
  E = C NOT COIN INSIDE EDGE D
  CENTER_BAR3 = CENTER_BAR2 NOT WITH EDGE E
  CHECK_VIA = VIA3 NOT OUTSIDE CENTER_BAR3
  CHECK_VIA AND (((M4i INTERACT CHECK_VIA) AND (M3i INTERACT CHECK_VIA)) INTERACT VIA3i == 1)
}

VIA3.R.12 { @ VIA3 connected to DM3, DM3_O, DM4, DM4_O is not allowed
  VIA3 INTERACT DUM3
  VIA3 INTERACT DUM4
  VIA3 INTERACT DM3_O
  VIA3 INTERACT DM4_O
}  

//M4 CHECKS
//=========


M4_EDGE_45 = M4 ANGLE == 45

M4.W.1 { @ Width >= 0.07 
  INT M4 < M4_W_1 ABUT < 90 SINGULAR REGION
}
M4.W.2 { @ Width of 45-degree bent Mx. (Please make sure the vertex of 45 degree pattern is on 0.005 um grid (refer to the guideline, G.6gU, in section 3.7)) >= 0.17 
  INT M4_EDGE_45 < M4_W_2 ABUT < 90 REGION
}
M4.W.3 { @ Maximum width <= ^M4_W_3 um, exclude sealring 
  M4_MAX_WIDTH WITH WIDTH > M4_W_3
}

M4.S.1 { @ Space >= 0.07 
  EXT M4 < M4_S_1 ABUT < 90 SINGULAR REGION
}
M4.S.2 { @ Min. Metal space (for W> ^M4_S_2_W um & parallel length > ^M4_S_2_L um) >= ^M4_S_2 um
  X = EXT M4Wide_2_0 M4 < M4_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_2_L+GRID
}
M4.S.2.1 { @ Min. Metal space (for W> ^M4_S_2_1_W um & parallel length > ^M4_S_2_1_L um) >= ^M4_S_2_1 um
  X = EXT M4Wide_2_1 M4 < M4_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_2_1_L+GRID
}
M4.S.2.2 { @ Min. Metal space (for W> ^M4_S_2_2_W um & parallel length > ^M4_S_2_2_L um) >= ^M4_S_2_2 um
  X = EXT M4Wide_2_2 M4 < M4_S_2_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_2_2_L+GRID
}
M4.S.2.3 { @ Min. Metal space (for W> ^M4_S_2_3_W um & parallel length > ^M4_S_2_3_L um) >= ^M4_S_2_3 um
  X = EXT M4Wide_2_3 M4 < M4_S_2_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_2_3_L+GRID
}
#IFDEF WIDE_ADJUST
M4.S.2.4 { @ Min. Metal space (for W> ^M4_S_2_4_W um & parallel length > ^M4_S_2_4_L um) >= ^M4_S_2_4 um
  X = EXT M4Wide_2_4 M4 < M4_S_2_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_2_4_L+GRID
}
M4.S.2.5 { @ Min. Metal space (for W> ^M4_S_2_5_W um & parallel length > ^M4_S_2_5_L um) >= ^M4_S_2_5 um
  X = EXT M4Wide_2_5 M4 < M4_S_2_5 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_2_5_L+GRID
}
M4.S.2.6 { @ Min. Metal space (for W> ^M4_S_2_6_W um & parallel length > ^M4_S_2_6_L um) >= ^M4_S_2_6 um
  X = EXT M4Wide_2_6 M4 < M4_S_2_6 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_2_6_L+GRID
}
M4.S.2.7 { @ Min. Metal space (for W> ^M4_S_2_7_W um & parallel length > ^M4_S_2_7_L um) >= ^M4_S_2_7 um
  X = EXT M4Wide_2_7 M4 < M4_S_2_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_2_7_L+GRID
}
#ENDIF
M4.S.3 { @ Min. Metal space (for W> ^M4_S_3_W um & parallel length > ^M4_S_3_L um) >= ^M4_S_3 um
  X = EXT M4Wide_3_0 M4 < M4_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  (ENCLOSE RECTANGLE Y 0.001 M4_S_3_L+0.001) NOT INSIDE IND_REGION
}
M4.S.5 { @ Space at Mx line-end (W < 0.10 um (Q)) in a dense-line-end configuration: If Mx has parallel run length with opposite Mx (measured with T = 0.035 um extension) along 2 adjacent edges of Mx [any one edge <Q distance from the corner of the two edges], then one of the space (S1 or S2) needs to be at least this value (This check doesn't include small jog with edge length < 0.07 um(R)) (M2.S.5 except SRAM (186;0) region) >= 0.10 
  A = CONVEX EDGE M4 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M4_S_5_W
  B = EXT [A] M4 < M4_S_5 ABUT < 90 OPPOSITE EXTENDED M4_S_5_T
  C = A TOUCH INSIDE EDGE B
  D = INT C [M4] < M4_S_5_W ABUT == 90 INTERSECTING ONLY
  I = LENGTH D >= M4_W_1
  J = EXPAND EDGE I INSIDE BY 0.001 EXTEND BY M4_S_5_T
  K = EXPAND EDGE I INSIDE BY 0.001 
  L = J NOT K
  M = L WITH EDGE A 
  N = M OR K
  O = N TOUCH EDGE I
  EXT O M4 < M4_S_5 ABUT < 90 OPPOSITE REGION

}

M4.S.5.1 { @ Space at Mx line-end (W<Q=^M4_S_5_1_W) in a dense-line-end configuration.If Mx has parallel run length with opposite Mx (measured with ^M4_S_5_1_T (T) extension) along two adjacent edges of Mx [any one edge < ^M4_S_5_1_W (W) from the corner of the two edges of Mx], and Mx enclosure of VIAx-1 < ^M4_S_5_1_E at line-end, then one of the space (S1 or S2) must be >= ^M4_S_5_1 um.
  A = CONVEX EDGE M4 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M4_S_5_1_W
  V3_EN = ENC [VIA3i] A < M4_S_5_1_E ABUT < 90 OPPOSITE
  M4_EN = ENC V3_EN [A] < M4_S_5_1_E ABUT < 90 OPPOSITE
  M4_SA = EXT A [M4] < M4_S_5_1 ABUT < 90 OPPOSITE EXTENDED M4_S_5_1_T
  M4_SB = EXT [A] M4_SA < M4_S_5_1 ABUT < 90 OPPOSITE EXTENDED M4_S_5_1_T
  M4_END = (A TOUCH INSIDE EDGE M4_EN) TOUCH INSIDE EDGE M4_SB
  EN_B = ENC V3_EN [M4_END] < M4_S_5_1_E2 OPPOSITE
  EN_C = ENC V3_EN [M4_END] < M4_S_5_1_E3 OPPOSITE
  EN_D = ENC V3_EN [M4_END] < M4_S_5_1_E4 OPPOSITE
  S1_B = EXT [M4_END] M4_SA < M4_S_5_1_S2 OPPOSITE EXTENDED M4_S_5_1_T
  S1_C = EXT [M4_END] M4_SA < M4_S_5_1_S3 OPPOSITE EXTENDED M4_S_5_1_T
  S1_D = EXT [M4_END] M4_SA < M4_S_5_1_S4 OPPOSITE EXTENDED M4_S_5_1_T
  PASS_B = (M4_END NOT TOUCH INSIDE EDGE EN_B) NOT TOUCH INSIDE EDGE S1_B
  PASS_C = (M4_END NOT TOUCH INSIDE EDGE EN_C) NOT TOUCH INSIDE EDGE S1_C
  PASS_D = (M4_END NOT TOUCH INSIDE EDGE EN_D) NOT TOUCH INSIDE EDGE S1_D
  M4_CHECK = ((M4_END NOT TOUCH INSIDE EDGE PASS_B) NOT TOUCH INSIDE EDGE PASS_C) NOT TOUCH INSIDE EDGE PASS_D
  H = INT M4_CHECK [M4] < M4_S_5_1_W ABUT == 90 INTERSECTING ONLY
  I = LENGTH H >= M4_W_1
  J = EXPAND EDGE I INSIDE BY GRID EXTEND BY M4_S_5_1_T
  K = EXPAND EDGE I INSIDE BY GRID
  L = J NOT K
  M = L WITH EDGE A 
  N = M OR K
  O = N TOUCH INSIDE EDGE I
  P = EXT [O] M4 < M4_S_5_1 ABUT < 90 OPPOSITE
  Q = ENC VIA3i (O TOUCH INSIDE EDGE P) < M4_S_5_1_E ABUT < 90 OPPOSITE REGION
  VIA_BAD1 = VIA3i INTERACT Q
  VIA_GOOD = VIA3i NOT VIA_BAD1
  VIA_BAD2 = VIA_BAD1 NOT INTERACT ((M4 AND M3) INTERACT VIA_GOOD)
  ENC VIA_BAD2 M4_CHECK < M4_S_5_1_E ABUT < 90 OPPOSITE REGION
}

M4.S.6 { @ Space to 45-degree bent Mx >= 0.17 
  X = EXPAND EDGE M4_EDGE_45 OUTSIDE BY M4_S_6
  X AND M4
}


M4_HVN_5V = NET AREA RATIO M4i OVER M10_HV_5V M9_HV_5V M8_HV_5V M7_HV_5V M6_HV_5V M5_HV_5V M4_HV_5V M3_HV_5V M2_HV_5V M1_HV_5V > 0 
M4_HVN = NET AREA RATIO M4i OVER M10_HV M9_HV M8_HV M7_HV M6_HV M5_HV M4_HV M3_HV M2_HV M1_HV > 0 
M4_MVN = NET AREA RATIO M4i OVER M10_MV M9_MV M8_MV M7_MV M6_MV M5_MV M4_MV M3_MV M2_MV M1_MV > 0
M4_LVN = NET AREA RATIO M4i OVER M10_LV M9_LV M8_LV M7_LV M6_LV M5_LV M4_LV M3_LV M2_LV M1_LV > 0

M4_NOMARK = (((M4i NOT M4_HVN_5V) NOT M4_HVN) NOT M4_MVN) NOT M4_LVN

#IFDEF Mx_S_8_IO_NET
  M4_NOMARK_5V = NET AREA RATIO M4_NOMARK PSD_HVD NSD_HVD S_HVD_GATE PSTPi > 0 
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD)+!!AREA(S_HVD_GATE))*!AREA(PSTPi)]
  M4_NOMARK_HV = NET AREA RATIO M4_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPi > 0 
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPi)]
  M4_NOMARK_MV = NET AREA RATIO M4_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPi > 0 
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPi)]
#ELSE  
  M4_NOMARK_5V = NET AREA RATIO M4_NOMARK PSD_HVD NSD_HVD S_HVD_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD)+!!AREA(S_HVD_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M4_NOMARK_HV = NET AREA RATIO M4_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M4_NOMARK_MV = NET AREA RATIO M4_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)] 
#ENDIF 

M4_5V_ALL = M4_HVN_5V OR M4_NOMARK_5V  
M4_HV_ALL = M4_HVN OR M4_NOMARK_HV
M4_MV_ALL = M4_MVN OR M4_NOMARK_MV

M4.S.1.1 { @ Space [any one of Mx connect to > 3.3V and <= 5V net] >= ^M4_S_1_1
  I = STAMP M4_5V_ALL BY M4i
  EXT I M4i < M4_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}
M4.S.8.2 { @ Space to neighboring {VIAx-1 or VIAx} [either VIAx-1, VIAx or Mx connects to > 3.3V and <= 5V net] >= ^M4_S_8_2
  I = STAMP M4_5V_ALL BY M4i
  J = STAMP (VIA3i AND M4_5V_ALL) BY M4i
  EXT I VIA3i < M4_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M4i < M4_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA4i AND M4_5V_ALL) BY M4i
  EXT I VIA4i < M4_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M4i < M4_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}
M4.S.8 { @ Space to {VIAx-1 OR VIAx} [different net, any one of VIAx-1, VIAx or Mx connects to 1.8V ~ 3.3V net] 0.1  
  I = STAMP M4_HV_ALL BY M4i
  J = STAMP (VIA3i AND M4_HV_ALL) BY M4i
  EXT I VIA3i < M4_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M4i < M4_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA4i AND M4_HV_ALL) BY M4i
  EXT I VIA4i < M4_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M4i < M4_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}
M4.S.8.1 { @ Space to {VIAx-1 OR VIAx} [different net, any one of VIAx-1, VIAx or Mx connects to >= 1.5V and < 1.8V net] 0.08  
  I = STAMP M4_MV_ALL BY M4i
  J = STAMP (VIA3i AND M4_MV_ALL) BY M4i
  EXT I VIA3i < M4_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M4i < M4_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA4i AND M4_MV_ALL) BY M4i
  EXT I VIA4i < M4_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M4i < M4_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}

M4.S.9 { @ This rule is to check Metal (A) space to neighboring VIAx [either VIAx or Mx connects to >3.3V and <= 5V net]. DRC methodology to find Metal (A) Find a edge (B) of metal line end [edge length <= 0.12um] Run length (C) from edge (B) inside metal >= 0.13um Jog length (D) <= 0.01um within 0.13um run length Extend 0.06um outside from edge (B) to form a polygon metal (A) Metal (A) is defined if conditions 1~4 are all satisfied. >= 0.15 
  LINE_END_pre   = CONVEX EDGE M4 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= M4_S_9_B
  LINE_END_pre1  = EXPAND EDGE LINE_END_pre INSIDE BY GRID EXTEND BY -M4_S_9_D    
  LINE_END_pre2  = LINE_END_pre COIN INSIDE EDGE LINE_END_pre1  
  LINE_END_pre3  = INT [LINE_END_pre2] M4 < M4_S_9_C OPPOSITE 
  LINE_END_pre4  = LINE_END_pre NOT TOUCH INSIDE EDGE LINE_END_pre3
  LINE_END_pre5  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M4_S_9_D+GRID
  LINE_END_pre6  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M4_S_9_D
  LINE_END_pre7  = LINE_END_pre5 NOT LINE_END_pre6
  LINE_END_pre8  = LINE_END_pre5 TOUCH OUTSIDE EDGE LINE_END_pre4
  LINE_END_pre9  = LINE_END_pre8 COIN INSIDE EDGE LINE_END_pre7 
  LINE_END_pre10 = EXT [LINE_END_pre9] M4 < M4_S_9_C OPPOSITE
  LINE_END = LINE_END_pre4 NOT TOUCH OUTSIDE EDGE (LINE_END_pre8 TOUCH INSIDE EDGE LINE_END_pre10)
  A = EXPAND EDGE LINE_END OUTSIDE BY M4_S_9_A INSIDE BY GRID
  B = STAMP A BY M4i
  I = STAMP (A INTERACT M4_5V_ALL) BY M4i
  J = STAMP (VIA3i AND M4_5V_ALL) BY M4i
  K = STAMP (VIA4i AND M4_5V_ALL) BY M4i
  X1 = EXT I VIA3i < M4_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X2 = EXT I VIA4i  < M4_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X3 = EXT J B < M4_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X4 = EXT K B < M4_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  Y = ((X1 OR X2) OR X3) OR X4   
  COPY Y
  A INTERACT Y
}

// M4.EN.0 is checked by M4.EN.1, and M4.EN.2_M4.EN.3_M4.EN.3.1

M4.EN.1 { @ Enclosure of VIAx-1 >= 0.00 
  VIA3 NOT M4
}
M4.EN.2__M4.EN.3__M4.EN.3.1 { @ Enclosure of VIAx-1 [at least two opposite sides] >= ^M4_EN_2, or [four sides] >= ^M4_EN_3 with [at least two opposite sides] >= ^M4_EN_3_1
  X = RECTANGLE ENCLOSURE (VIA3 NOT SEALRING_ALL) M4 ABUT < 90 SINGULAR GOOD 0 M4_EN_2 OPPOSITE 0 M4_EN_2 OPPOSITE
  Y = ENC X M4 < M4_EN_3 ABUT < 90 SINGULAR REGION
  Z = RECTANGLE ENCLOSURE (X NOT TOUCH Y) M4 ABUT < 90 GOOD M4_EN_3 M4_EN_3_1 OPPOSITE M4_EN_3 M4_EN_3_1 OPPOSITE
  Y OR (ENC Z M4 < M4_EN_3_1 ABUT < 90 SINGULAR REGION)
}
M4.A.1 { @ Area (M2.A.1 except SRAM (186;0) region) >= 0.027 
     AREA M4 < M4_A_1
}
M4.A.2 { @ Area [with all of edge length< 0.17 um] (This check doesn't include the patterns filling 0.07 um x 0.17 um rectangular tile) (M2.A.2 except SRAM (186;0) region) >= 0.06 
  A = AREA M4 < M4_A_2
  B = LENGTH A >= M4_A_2_L1
  C = A NOT WITH EDGE B
  NOT ENCLOSE RECTANGLE C M4_A_2_W M4_A_2_L2 ORTHOGONAL ONLY
}


VARIABLE M4_A_3pre ((M4_A_3 + (M4_S_1 * M4_S_1 * 3.142))/(2 * M4_S_1))*((M4_A_3 + (M4_S_1 * M4_S_1 * 3.142))/(2 * M4_S_1))/3.141

M4.A.3 { @ Enclosed area >= 0.2 
  X = HOLES M4 INNER < M4_A_3pre
  AREA ( X NOT M4 ) < M4_A_3
}

// M4.R.1 can not be checked


#IFDEF FULL_CHIP
CHIP_M4 = COPY CHIP
#ELSE
CHIP_M4 = CHIP INTERACT M4x
#ENDIF

#IFDEF CHECK_LOW_DENSITY
M4.DN.1 { @ Minimum local density [window ^M4_DN_1_W um x ^M4_DN_1_W um, stepping ^M4_DN_1_S um] >= ^M4_DN_1
  M4_CHECK = M4x NOT M4_EXC_LOW
  CHIP_CHECK = CHIP NOT M4_EXC_LOW
  
  ERR_WIN = DENSITY M4_CHECK CHIP_CHECK < M4_DN_1 WINDOW M4_DN_1_W STEP M4_DN_1_S INSIDE OF LAYER CHIP_M4 BACKUP 
	[ AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M4_EXC_LOW) >= M4_DN_1_E
  DENSITY F M4_CHECK CHIP_CHECK < M4_DN_1 WINDOW M4_DN_1_W STEP M4_DN_1_S INSIDE OF LAYER CHIP_M4 BACKUP PRINT M4.DN.1.density
         [ !AREA(F)+AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
}
#ENDIF

M4.DN.1.1 { @ Maximum local density [window ^M4_DN_1_1_W um x ^M4_DN_1_1_W um, stepping ^M4_DN_1_1_S um] <= ^M4_DN_1_1
  M4_CHECK = M4x NOT M4_EXC_HIGH
  CHIP_CHECK = CHIP NOT M4_EXC_HIGH
  ERR_WIN = DENSITY M4_CHECK CHIP_CHECK > M4_DN_1_1 WINDOW M4_DN_1_1_W STEP M4_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M4_EXC_HIGH) >= M4_DN_1_1_E
  DENSITY F M4_CHECK CHIP_CHECK > M4_DN_1_1 WINDOW M4_DN_1_1_W STEP M4_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP PRINT M4.DN.1.1.density
         [ !!AREA(F)*AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
}

M4.DN.4 { @ The metal density difference between any two neighboring checking windows including DM4EXCL [window ^M4_DN_4_W um x ^M4_DN_4_W um, stepping ^M4_DN_4_W um]  <= ^M4_DN_4
  DENSITY M4x CHIP <=1 WINDOW M4_DN_4_W BACKUP GRADIENT > M4_DN_4 ABSOLUTE CORNER INSIDE OF LAYER CHIPx PRINT M4.DN.4.density
  	[ AREA(M4x)/AREA(CHIP) ]    
}

#IFDEF CHECK_LOW_DENSITY
M4.DN.6 { @ Metal Desnsity >= ^M4_DN_6. All condition-A, Condition-B, and Condition-C must be followed.
@ (1) Condition-A: Metal density [window ^M4_DN_6_W_A um x ^M4_DN_6_W_A um, stepping ^M4_DN_6_S_A um] >= ^M4_DN_6
@ (2) Condition-B: Maximum area of merged low density windows [window ^M4_DN_6_W_BC um x ^M4_DN_6_W_BC um, stepping ^M4_DN_6_S_BC um < ^M4_DN_6] <= ^M4_DN_6_A_B um2, except merged low density windows width <= ^M4_DN_6_U um
@ (3) Condition-C: Maximum area of merged low density windows [window ^M4_DN_6_W_BC um x ^M4_DN_6_W_BC um, stepping ^M4_DN_6_S_BC um < ^M4_DN_6] <= ^M4_DN_6_A_C um2
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M4_DN_6_E_A um for condition-A and >= ^M4_DN_6_E_BC um for both condition-B/condition-C 
  M4_CHECK = M4x NOT NEW_DEN_EXC
  CHIP_CHECK = CHIP NOT NEW_DEN_EXC
  // Condition-A
  ERR_WIN_A = DENSITY M4_CHECK CHIP_CHECK < M4_DN_6 WINDOW M4_DN_6_W_A STEP M4_DN_6_S_A INSIDE OF LAYER CHIP_M4 BACKUP 
	[ AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
  F_A = WITH WIDTH (ERR_WIN_A NOT NEW_DEN_EXC) >= M4_DN_6_E_A
  DENSITY F_A M4_CHECK CHIP_CHECK < M4_DN_6 WINDOW M4_DN_6_W_A STEP M4_DN_6_S_A INSIDE OF LAYER CHIP_M4 BACKUP PRINT M4.DN.6_A.density
         [ !AREA(F_A)+AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
  // Condition-B 
  ERR_WIN_B = DENSITY M4_CHECK CHIP_CHECK < M4_DN_6 WINDOW M4_DN_6_W_BC STEP M4_DN_6_S_BC INSIDE OF LAYER CHIP_M4 BACKUP 
	[ AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
  F_B = WITH WIDTH (ERR_WIN_B NOT NEW_DEN_EXC) >= M4_DN_6_E_BC
  A = DENSITY F_B M4_CHECK CHIP_CHECK < M4_DN_6 WINDOW M4_DN_6_W_BC STEP M4_DN_6_S_BC INSIDE OF LAYER CHIP_M4 BACKUP PRINT M4.DN.6_BC.density
         [ !AREA(F_B)+AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
  B = AREA A > M4_DN_6_A_B
  C = SIZE B BY M4_DN_6_U/2 UNDEROVER
  B INTERACT C
  // Condition-C
  AREA B > M4_DN_6_A_C
}
#ENDIF


// Mx.DN.5
//===========
M4_CORE = M4x NOT SEALRING_EXCLUDE

Mx.DN.5:M2_M3_M4 { @ It is not allowed to have local density > 85% of all 3 consecutive metal (Mx, Mx+1 and Mx+2) over any window 62.5 um x 62.5 um (stepping 31.25 um), i.e. it is allowed for either one of Mx, Mx+1, or Mx+2 to have a local density <= 85%. 1. The metal layers include M1/Mx and dummy metals. 2. The check does not include chip corner stress relief pattern, sealring (162;2) and top2 metals at CUP area.   
    DENSITY  M2_CORE M3_CORE M4_CORE >0 WINDOW M2_DN_5_W STEP M2_DN_5_S BACKUP INSIDE OF LAYER CHIPx
  	  [ !~(AREA(M2_CORE)/AREA()- M2_DN_5)*!~(AREA(M3_CORE)/AREA()- M2_DN_5)*!~(AREA(M4_CORE)/AREA()- M2_DN_5) ]
 	  RDB Mx.DN.5:M2_M3_M4.density
}
#IFDEF CHECK_LOW_DENSITY
Mx.DN.7:M2_M3_M4 { @ It is not allowed to have local density < 5% of all 3 consecutive metal layer(M2,M3,M4) over any 30umx30um window (stepping 15um), i.e. it is allowed for either one of M2, M3, or M4 to have a local density >= 5 %.
@ 1. The metal layers include M1/Mx and dummy metals
@ 2. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 3. This rule is applied while the width of (checking window NOT above excluding region) >= 15 um    
   M2_CHECK = M2x NOT NEW_DEN_EXC
   M3_CHECK = M3x NOT NEW_DEN_EXC
   M4_CHECK = M4x NOT NEW_DEN_EXC
   CHIP_CHECK = CHIP NOT NEW_DEN_EXC
   ERR_WIN = DENSITY M2_CHECK M3_CHECK M4_CHECK CHIP_CHECK >0 WINDOW M2_DN_7_W STEP M2_DN_7_S BACKUP INSIDE OF LAYER CHIP_M4
   [ !~(M2_DN_7-AREA(M2_CHECK)/AREA(CHIP_CHECK))*!~(M2_DN_7-AREA(M3_CHECK)/AREA(CHIP_CHECK))*!~(M2_DN_7-AREA(M4_CHECK)/AREA(CHIP_CHECK)) ]
   F = WITH WIDTH (ERR_WIN NOT NEW_DEN_EXC) >= M2_DN_7_E
   DENSITY F M2_CHECK M3_CHECK M4_CHECK CHIP_CHECK >0 WINDOW M2_DN_7_W STEP M2_DN_7_S BACKUP INSIDE OF LAYER CHIP_M4
   [ !!AREA(F)*!~(M2_DN_7-AREA(M2_CHECK)/AREA(CHIP_CHECK))*!~(M2_DN_7-AREA(M3_CHECK)/AREA(CHIP_CHECK))*!~(M2_DN_7-AREA(M4_CHECK)/AREA(CHIP_CHECK)) ]
   RDB Mx.DN.7:M2_M3_M4.density
}
#ENDIF

M4.R.3 { @ Metal(pin) layers must be drawn only interact with one relative Metal(drawing) layers
   M4_PIN NOT INTERACT M4i == 1
}


//VIA4 CHECKS
//===========
#IFNDEF WIDE_ADJUST
M5Wide_2_0 = M5 WITH WIDTH > M5_S_2_W            // 0.17
M5Wide_2_1 = M5Wide_2_0 WITH WIDTH > M5_S_2_1_W  // 0.24
M5Wide_2_2 = M5Wide_2_1 WITH WIDTH > M5_S_2_2_W  // 0.31
M5Wide_2_3 = M5Wide_2_2 WITH WIDTH > M5_S_2_3_W  // 0.62
M5Wide_3_0 = M5Wide_2_3 WITH WIDTH > M5_S_3_W    // 1.65
#ELSE
M5Wide_2_4 = M5 WITH WIDTH > M5_S_2_4_W          // 0.17
M5Wide_2_0 = M5Wide_2_4 WITH WIDTH > M5_S_2_W    // 0.19
M5Wide_2_5 = M5Wide_2_0 WITH WIDTH > M5_S_2_5_W  // 0.24
M5Wide_2_1 = M5Wide_2_5 WITH WIDTH > M5_S_2_1_W  // 0.265
M5Wide_2_6 = M5Wide_2_1 WITH WIDTH > M5_S_2_6_W  // 0.31
M5Wide_2_2 = M5Wide_2_6 WITH WIDTH > M5_S_2_2_W  // 0.345
M5Wide_2_7 = M5Wide_2_2 WITH WIDTH > M5_S_2_7_W  // 0.62
M5Wide_2_3 = M5Wide_2_7 WITH WIDTH > M5_S_2_3_W  // 0.685
M5Wide_3_0 = M5Wide_2_3 WITH WIDTH > M5_S_3_W    // 1.65
#ENDIF

M4Wide_R2_VIA4 = M4Wide_2_0 WITH WIDTH > VIA4_R_2_W        // 0.21
M4Wide_R4_VIA4 = M4Wide_R2_VIA4 WITH WIDTH > VIA4_R_4_W    // 0.21
M4Wide_R3_VIA4 = M4Wide_R4_VIA4 WITH WIDTH > VIA4_R_3_W    // 0.55
M4Wide_R5_VIA4 = M4Wide_R3_VIA4 WITH WIDTH > VIA4_R_5_W    // 1.4
M4Wide_R6_VIA4 = M4Wide_R5_VIA4 WITH WIDTH > VIA4_R_6_W    // 2.1
M5Wide_R2_VIA4 = M5Wide_2_0 WITH WIDTH > VIA4_R_2_W      // 0.21
M5Wide_R4_VIA4 = M5Wide_R2_VIA4 WITH WIDTH > VIA4_R_4_W  // 0.21
M5Wide_R3_VIA4 = M5Wide_R4_VIA4 WITH WIDTH > VIA4_R_3_W  // 0.55
M5Wide_R5_VIA4 = M5Wide_R3_VIA4 WITH WIDTH > VIA4_R_5_W  // 1.4
M5Wide_R6_VIA4 = M5Wide_R5_VIA4 WITH WIDTH > VIA4_R_6_W  // 2.1

VIA4.W.1 { @ Width (maximum = minimum) (Except sealring (162,2) and {VIAx bar INSIDE {LOWMEDN NOT (LOWMEDN SIZING -4 um)}} region) = 0.07 
   NOT RECTANGLE (VIA4i NOT (SEALRING_EXCLUDE OR P_RING_REGION)) == VIA4_W_1 BY == VIA4_W_1 ORTHOGONAL ONLY
}
VIA4.S.1 { @ Space >= 0.07 
  EXT VIA4i < VIA4_S_1 ABUT < 90 SINGULAR REGION
}
VIA4.S.1.1 { @ Space [any one of VIAx connect to > 3.3V and <= 5V different net] >= ^VIA4_S_1_1
  J = STAMP (VIA4i AND M4_5V_ALL) BY M4i
  EXT J VIA4i < VIA4_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}
VIA4.S.2 { @ Space to 3-neighboring VIAx (distance < 0.098 um) >= 0.09 
  X = WITH NEIGHBOR VIA4i > 2 SPACE < VIA4_S_2_D
  EXT X VIA4i < VIA4_S_2 ABUT < 90 SINGULAR REGION
}
VIA4.S.3 { @ Space to neighboring VIAx [different net] >= 0.095 
  EXT VIA4i < VIA4_S_3 ABUT < 90 NOT CONNECTED REGION
}
VIA4.S.3.1 { @ Space to neighboring VIAx [different net and common parallel run length > 0 um] >= 0.11 
  EXT VIA4i < VIA4_S_3_1 ABUT < 90 NOT CONNECTED OPPOSITE REGION
}

// VIA4.EN.0 is checked by VIA4.EN.1, and VIA4.EN.2_VIA4.EN.4_VIA4.EN.4.1

VIA4.EN.1 { @ Enclosure by Mx or M1 >= 0.00 
  VIA4 NOT M4
}

VIA4.EN.2__VIA4.EN.4__VIA4.EN.4.1 { @ Enclosure by M4 [at least two opposite sides] >= ^VIA4_EN_2, or [four sides] >= ^VIA4_EN_4 with [at least two opposite sides] >= ^VIA4_EN_4_1
  X = RECTANGLE ENCLOSURE (VIA4 NOT SEALRING_EXCLUDE) M4 ABUT < 90 SINGULAR GOOD 0 VIA4_EN_2 OPPOSITE 0 VIA4_EN_2 OPPOSITE
  Y = ENC X M4 < VIA4_EN_4 ABUT < 90 SINGULAR REGION
  Z = RECTANGLE ENCLOSURE (X NOT TOUCH Y) M4 ABUT < 90 GOOD VIA4_EN_4 VIA4_EN_4_1 OPPOSITE VIA4_EN_4 VIA4_EN_4_1 OPPOSITE
  Y OR (ENC Z M4 < VIA4_EN_4_1 ABUT < 90 SINGULAR REGION)

}



// VIA4.R.1 is checked by VIA4.W.1
VIA4.R.2__VIA4.R.3 { @ When M4 or M5 width > ^VIA4_R_2_W um, more than one VIA4 is required.
                    @ 2 vias spacing should be <= ^VIA4_R_2_S1 um or 4 vias spacing should be <= ^VIA4_R_2_S2 um
                    @ When M4 or M5 width > ^VIA4_R_3_W um, more than three VIA4 is required.
                    @ 4 vias spacing should be <= ^VIA4_R_3_S1 um or 9 vias spacing should be <= ^VIA4_R_3_S2 um
                    @ not check SRAM region					
   M5OvpM4_W_ = (M4Wide_R2_VIA4 AND M5) OR (M5Wide_R2_VIA4 AND M4)
   M5OvpM4_B  = (M4Wide_R3_VIA4 AND M5) OR (M5Wide_R3_VIA4 AND M4)
   M5OvpM4_W  = M5OvpM4_W_ NOT M5OvpM4_B 
   Checked_VIA4_W_ = VIA4_EXD NOT OUTSIDE M5OvpM4_W
   Checked_VIA4_B  = VIA4_EXD NOT OUTSIDE M5OvpM4_B
   Checked_VIA4_W  = Checked_VIA4_W_ NOT Checked_VIA4_B
   M4_effect = M4i INTERACT M5OvpM4_W_
   M5_effect = M5i INTERACT M5OvpM4_W_
   effect_M5OvpM4_ = M4_effect AND M5_effect
   effect_M5OvpM4 = effect_M5OvpM4_ INTERACT M5OvpM4_W_
   effect_VIA = VIA4_EXD INTERACT effect_M5OvpM4

   V4Merged_A = SIZE effect_VIA BY VIA4_R_2_S1/2 INSIDE OF effect_M5OvpM4 STEP M4_S_1*0.7
   V4Merged_B = SIZE V4Merged_A BY (VIA4_R_2_S2 - VIA4_R_2_S1)/2 INSIDE OF effect_M5OvpM4 STEP M4_S_1*0.7
   V4Merged_C = SIZE V4Merged_B BY (VIA4_R_3_S2 - VIA4_R_2_S2)/2 INSIDE OF effect_M5OvpM4 STEP M4_S_1*0.7
   V4Merged_A2R = V4Merged_A INTERACT effect_VIA < 2
   V4Merged_A2 = V4Merged_A OUTSIDE V4Merged_A2R
   V4Merged_A4R = V4Merged_A2 INTERACT effect_VIA < 4
   V4Merged_A4 = V4Merged_A2 OUTSIDE V4Merged_A4R
   V4Merged_B4R = V4Merged_B INTERACT effect_VIA < 4
   V4Merged_B4 = V4Merged_B OUTSIDE V4Merged_B4R
   V4Merged_C9R = V4Merged_C INTERACT effect_VIA < 9
   V4Merged_C9 = V4Merged_C OUTSIDE V4Merged_C9R

   GMergeW = V4Merged_A2 OR V4Merged_B4
   GMergeB = V4Merged_A4 OR V4Merged_C9
   GVIA_W = Checked_VIA4_W INTERACT GMergeW
   GVIA_B = Checked_VIA4_B INTERACT GMergeB
   GOOD_AREA_W = M5OvpM4_W INTERACT GVIA_W
   GOOD_AREA_B = M5OvpM4_B INTERACT GVIA_B
   Checked_VIA4_W OUTSIDE GOOD_AREA_W
   Checked_VIA4_B OUTSIDE GOOD_AREA_B
}

VIA4.R.4.M4 { @ At least two VIAx must be used for a connection that is <= ^VIA4_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA4_R_4_W um (L) and width > ^VIA4_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA4_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA4_R_4_W um (L) and width > ^VIA4_R_4_W um (W).)   
  Branch1 = ((SIZE M4Wide_R4_VIA4 BY VIA4_R_4_D + GRID) NOT M4Wide_R4_VIA4) AND M4
  Branch1HasVia = (Branch1 INTERACT M4Wide_R4_VIA4) INTERACT VIA4_EXD
  Branch1Edge = M4Wide_R4_VIA4 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA4_R_4_D INSIDE OF Branch1HasVia STEP M4_S_1*0.5
  GoodBranch = (Branch AND M5) INTERACT VIA4_EXD > 1
  BranchSingleVia = (VIA4_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M5 INTERACT BranchSingleVia) AND M4) INTERACT BranchSingleVia) INTERACT VIA4_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA4.R.4.M5 { @ At least two VIAx must be used for a connection that is <= ^VIA4_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA4_R_4_W um (L) and width > ^VIA4_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA4_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA4_R_4_W um (L) and width > ^VIA4_R_4_W um (W)).   
  Branch1 = ((SIZE M5Wide_R4_VIA4 BY VIA4_R_4_D + GRID) NOT M5Wide_R4_VIA4) AND M5
  Branch1HasVia = (Branch1 INTERACT M5Wide_R4_VIA4) INTERACT VIA4_EXD
  Branch1Edge = M5Wide_R4_VIA4 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA4_R_4_D INSIDE OF Branch1HasVia STEP M5_S_1*0.5
  GoodBranch = (Branch AND M4) INTERACT VIA4_EXD > 1
  BranchSingleVia = (VIA4_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M4 INTERACT BranchSingleVia) AND M5) INTERACT BranchSingleVia) INTERACT VIA4_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA4.R.5.M4 { @ At least two VIAx must be used for a connection that is <= ^VIA4_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA4_R_5_W um (L) and width > ^VIA4_R_5_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA4_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA4_R_5_W um (L) and width > ^VIA4_R_5_W um (W)).
  Branch1 = ((SIZE M4Wide_R5_VIA4 BY VIA4_R_5_D + GRID) NOT M4Wide_R5_VIA4) AND M4
  Branch1HasVia = (Branch1 INTERACT M4Wide_R5_VIA4) INTERACT VIA4_EXD
  Branch1Edge = M4Wide_R5_VIA4 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA4_R_5_D INSIDE OF Branch1HasVia STEP M4_S_1*0.7
  GoodBranch = (Branch AND M5) INTERACT VIA4_EXD > 1
  BranchSingleVia = (VIA4_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M5 INTERACT BranchSingleVia) AND M4) INTERACT BranchSingleVia) INTERACT VIA4_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA4.R.5.M5 { @ At least two VIAx must be used for a connection that is <= ^VIA4_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA4_R_5_W um (L) and width > ^VIA4_R_5_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA4_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA4_R_5_W um (L) and width > ^VIA4_R_5_W um (W)).
  Branch1 = ((SIZE M5Wide_R5_VIA4 BY VIA4_R_5_D + GRID) NOT M5Wide_R5_VIA4) AND M5
  Branch1HasVia = (Branch1 INTERACT M5Wide_R5_VIA4) INTERACT VIA4_EXD
  Branch1Edge = M5Wide_R5_VIA4 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA4_R_5_D INSIDE OF Branch1HasVia STEP M5_S_1*0.7
  GoodBranch = (Branch AND M4) INTERACT VIA4_EXD > 1
  BranchSingleVia = (VIA4_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M4 INTERACT BranchSingleVia) AND M5) INTERACT BranchSingleVia) INTERACT VIA4_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M4Big_R6_VIA4 = ENCLOSE RECTANGLE M4Wide_R6_VIA4 VIA4_R_6_W VIA4_R_6_L+GRID

VIA4.R.6.M4 { @ At least two VIAx must be used for a connection that is <= ^VIA4_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA4_R_6_L um (L) and width > ^VIA4_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA4_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA4_R_6_L um (L) and width > ^VIA4_R_6_W um (W)).
  Branch1 = ((SIZE M4Big_R6_VIA4 BY VIA4_R_6_D + GRID) NOT M4Big_R6_VIA4) AND M4
  Branch1HasVia = (Branch1 INTERACT M4Big_R6_VIA4) INTERACT VIA4_EXD
  Branch1Edge = M4Big_R6_VIA4 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA4_R_6_D INSIDE OF Branch1HasVia STEP M4_S_1*0.7
  GoodBranch = (Branch AND M5) INTERACT VIA4_EXD > 1
  BranchSingleVia = (VIA4_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M5 INTERACT BranchSingleVia) AND M4) INTERACT BranchSingleVia) INTERACT VIA4_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M5Big_R6_VIA4 = ENCLOSE RECTANGLE M5Wide_R6_VIA4 VIA4_R_6_W VIA4_R_6_L+GRID

VIA4.R.6.M5 { @ At least two VIAx must be used for a connection that is <= ^VIA4_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA4_R_6_L um (L) and width > ^VIA4_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA4_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA4_R_6_L um (L) and width > ^VIA4_R_6_W um (W)).
  Branch1 = ((SIZE M5Big_R6_VIA4 BY VIA4_R_6_D + GRID) NOT M5Big_R6_VIA4) AND M5
  Branch1HasVia = (Branch1 INTERACT M5Big_R6_VIA4) INTERACT VIA4_EXD
  Branch1Edge = M5Big_R6_VIA4 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA4_R_6_D INSIDE OF Branch1HasVia STEP M5_S_1*0.7
  GoodBranch = (Branch AND M4) INTERACT VIA4_EXD > 1
  BranchSingleVia = (VIA4_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M4 INTERACT BranchSingleVia) AND M5) INTERACT BranchSingleVia) INTERACT VIA4_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}
// VIA4.R.7 is checked by VIA4.EN.1
// VIA4.R.9 can't be checked

VIA4.R.11 { @ Single VIAx is not allowed for H-shape Mx+1 when all of the following conditions come into existence: 1. The Mx+1 has H-shape interact with two metal holes: two metal hole length(L2) <= ^VIA4_R_11_L1 um and both two metal hole area <= ^VIA4_R_11_A um2 2. The VIAx overlaps on the center metal bar of this H-shape Mx+1 3. The length (L) of the center metal bar <= ^VIA4_R_11_L2 um and the width of metal bar is <= ^VIA4_R_11_W um.
  W = M5i WITH WIDTH <= VIA4_R_11_W   
  H_HOLE = HOLES M5i INNER <= VIA4_R_11_A
  A = M5i COIN OUTSIDE EDGE H_HOLE
  B0 = ((INT A <= VIA4_R_11_W ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE M5i) INTERACT H_HOLE == 2 
  B1 = (((INT A <= VIA4_R_11_L2 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE M5i) AND W) INTERACT H_HOLE == 2
  HOLE_NOTCH = EXT H_HOLE <= VIA4_R_11_W ABUT<90 OPPOSITE NOTCH REGION  
  B2 = (B1 NOT HOLE_NOTCH) OR B0
  CORNER_M = ((EXT B2 <= VIA4_R_11_W ABUT == 90 INTERSECTING ONLY REGION EXTENTS) TOUCH B2 == 2) AND W
  B = B2 OR CORNER_M
  CENTER_BAR1 = NOT ENCLOSE RECTANGLE B GRID VIA4_R_11_L2+GRID
  CENTER_BAR2 = CENTER_BAR1 INTERACT H_HOLE == 2
  C = CENTER_BAR2 COIN OUTSIDE EDGE H_HOLE 
  D = EXT [C] M5i <= VIA4_R_11_L1 OPPOSITE
  E = C NOT COIN INSIDE EDGE D
  CENTER_BAR3 = CENTER_BAR2 NOT WITH EDGE E
  CHECK_VIA = VIA4 NOT OUTSIDE CENTER_BAR3
  CHECK_VIA AND (((M5i INTERACT CHECK_VIA) AND (M4i INTERACT CHECK_VIA)) INTERACT VIA4i == 1)
}

VIA4.R.12 { @ VIA4 connected to DM4, DM4_O, DM5, DM5_O is not allowed
  VIA4 INTERACT DUM4
  VIA4 INTERACT DUM5
  VIA4 INTERACT DM4_O
  VIA4 INTERACT DM5_O
}  

//M5 CHECKS
//=========


M5_EDGE_45 = M5 ANGLE == 45

M5.W.1 { @ Width >= 0.07 
  INT M5 < M5_W_1 ABUT < 90 SINGULAR REGION
}
M5.W.2 { @ Width of 45-degree bent Mx. (Please make sure the vertex of 45 degree pattern is on 0.005 um grid (refer to the guideline, G.6gU, in section 3.7)) >= 0.17 
  INT M5_EDGE_45 < M5_W_2 ABUT < 90 REGION
}
M5.W.3 { @ Maximum width <= ^M5_W_3 um, exclude sealring 
  M5_MAX_WIDTH WITH WIDTH > M5_W_3
}

M5.S.1 { @ Space >= 0.07 
  EXT M5 < M5_S_1 ABUT < 90 SINGULAR REGION
}
M5.S.2 { @ Min. Metal space (for W> ^M5_S_2_W um & parallel length > ^M5_S_2_L um) >= ^M5_S_2 um
  X = EXT M5Wide_2_0 M5 < M5_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID M5_S_2_L+GRID
}
M5.S.2.1 { @ Min. Metal space (for W> ^M5_S_2_1_W um & parallel length > ^M5_S_2_1_L um) >= ^M5_S_2_1 um
  X = EXT M5Wide_2_1 M5 < M5_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID M5_S_2_1_L+GRID
}
M5.S.2.2 { @ Min. Metal space (for W> ^M5_S_2_2_W um & parallel length > ^M5_S_2_2_L um) >= ^M5_S_2_2 um
  X = EXT M5Wide_2_2 M5 < M5_S_2_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID M5_S_2_2_L+GRID
}
M5.S.2.3 { @ Min. Metal space (for W> ^M5_S_2_3_W um & parallel length > ^M5_S_2_3_L um) >= ^M5_S_2_3 um
  X = EXT M5Wide_2_3 M5 < M5_S_2_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID M5_S_2_3_L+GRID
}
#IFDEF WIDE_ADJUST
M5.S.2.4 { @ Min. Metal space (for W> ^M5_S_2_4_W um & parallel length > ^M5_S_2_4_L um) >= ^M5_S_2_4 um
  X = EXT M5Wide_2_4 M5 < M5_S_2_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID M5_S_2_4_L+GRID
}
M5.S.2.5 { @ Min. Metal space (for W> ^M5_S_2_5_W um & parallel length > ^M5_S_2_5_L um) >= ^M5_S_2_5 um
  X = EXT M5Wide_2_5 M5 < M5_S_2_5 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID M5_S_2_5_L+GRID
}
M5.S.2.6 { @ Min. Metal space (for W> ^M5_S_2_6_W um & parallel length > ^M5_S_2_6_L um) >= ^M5_S_2_6 um
  X = EXT M5Wide_2_6 M5 < M5_S_2_6 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID M5_S_2_6_L+GRID
}
M5.S.2.7 { @ Min. Metal space (for W> ^M5_S_2_7_W um & parallel length > ^M5_S_2_7_L um) >= ^M5_S_2_7 um
  X = EXT M5Wide_2_7 M5 < M5_S_2_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID M5_S_2_7_L+GRID
}
#ENDIF
M5.S.3 { @ Min. Metal space (for W> ^M5_S_3_W um & parallel length > ^M5_S_3_L um) >= ^M5_S_3 um
  X = EXT M5Wide_3_0 M5 < M5_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  (ENCLOSE RECTANGLE Y 0.001 M5_S_3_L+0.001) NOT INSIDE IND_REGION
}
M5.S.5 { @ Space at Mx line-end (W < 0.10 um (Q)) in a dense-line-end configuration: If Mx has parallel run length with opposite Mx (measured with T = 0.035 um extension) along 2 adjacent edges of Mx [any one edge <Q distance from the corner of the two edges], then one of the space (S1 or S2) needs to be at least this value (This check doesn't include small jog with edge length < 0.07 um(R)) (M2.S.5 except SRAM (186;0) region) >= 0.10 
  A = CONVEX EDGE M5 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M5_S_5_W
  B = EXT [A] M5 < M5_S_5 ABUT < 90 OPPOSITE EXTENDED M5_S_5_T
  C = A TOUCH INSIDE EDGE B
  D = INT C [M5] < M5_S_5_W ABUT == 90 INTERSECTING ONLY
  I = LENGTH D >= M5_W_1
  J = EXPAND EDGE I INSIDE BY 0.001 EXTEND BY M5_S_5_T
  K = EXPAND EDGE I INSIDE BY 0.001 
  L = J NOT K
  M = L WITH EDGE A 
  N = M OR K
  O = N TOUCH EDGE I
  EXT O M5 < M5_S_5 ABUT < 90 OPPOSITE REGION

}

M5.S.5.1 { @ Space at Mx line-end (W<Q=^M5_S_5_1_W) in a dense-line-end configuration.If Mx has parallel run length with opposite Mx (measured with ^M5_S_5_1_T (T) extension) along two adjacent edges of Mx [any one edge < ^M5_S_5_1_W (W) from the corner of the two edges of Mx], and Mx enclosure of VIAx-1 < ^M5_S_5_1_E at line-end, then one of the space (S1 or S2) must be >= ^M5_S_5_1 um.
  A = CONVEX EDGE M5 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M5_S_5_1_W
  V4_EN = ENC [VIA4i] A < M5_S_5_1_E ABUT < 90 OPPOSITE
  M5_EN = ENC V4_EN [A] < M5_S_5_1_E ABUT < 90 OPPOSITE
  M5_SA = EXT A [M5] < M5_S_5_1 ABUT < 90 OPPOSITE EXTENDED M5_S_5_1_T
  M5_SB = EXT [A] M5_SA < M5_S_5_1 ABUT < 90 OPPOSITE EXTENDED M5_S_5_1_T
  M5_END = (A TOUCH INSIDE EDGE M5_EN) TOUCH INSIDE EDGE M5_SB
  EN_B = ENC V4_EN [M5_END] < M5_S_5_1_E2 OPPOSITE
  EN_C = ENC V4_EN [M5_END] < M5_S_5_1_E3 OPPOSITE
  EN_D = ENC V4_EN [M5_END] < M5_S_5_1_E4 OPPOSITE
  S1_B = EXT [M5_END] M5_SA < M5_S_5_1_S2 OPPOSITE EXTENDED M5_S_5_1_T
  S1_C = EXT [M5_END] M5_SA < M5_S_5_1_S3 OPPOSITE EXTENDED M5_S_5_1_T
  S1_D = EXT [M5_END] M5_SA < M5_S_5_1_S4 OPPOSITE EXTENDED M5_S_5_1_T
  PASS_B = (M5_END NOT TOUCH INSIDE EDGE EN_B) NOT TOUCH INSIDE EDGE S1_B
  PASS_C = (M5_END NOT TOUCH INSIDE EDGE EN_C) NOT TOUCH INSIDE EDGE S1_C
  PASS_D = (M5_END NOT TOUCH INSIDE EDGE EN_D) NOT TOUCH INSIDE EDGE S1_D
  M5_CHECK = ((M5_END NOT TOUCH INSIDE EDGE PASS_B) NOT TOUCH INSIDE EDGE PASS_C) NOT TOUCH INSIDE EDGE PASS_D
  H = INT M5_CHECK [M5] < M5_S_5_1_W ABUT == 90 INTERSECTING ONLY
  I = LENGTH H >= M5_W_1
  J = EXPAND EDGE I INSIDE BY GRID EXTEND BY M5_S_5_1_T
  K = EXPAND EDGE I INSIDE BY GRID
  L = J NOT K
  M = L WITH EDGE A 
  N = M OR K
  O = N TOUCH INSIDE EDGE I
  P = EXT [O] M5 < M5_S_5_1 ABUT < 90 OPPOSITE
  Q = ENC VIA4i (O TOUCH INSIDE EDGE P) < M5_S_5_1_E ABUT < 90 OPPOSITE REGION
  VIA_BAD1 = VIA4i INTERACT Q
  VIA_GOOD = VIA4i NOT VIA_BAD1
  VIA_BAD2 = VIA_BAD1 NOT INTERACT ((M5 AND M4) INTERACT VIA_GOOD)
  ENC VIA_BAD2 M5_CHECK < M5_S_5_1_E ABUT < 90 OPPOSITE REGION
}

M5.S.6 { @ Space to 45-degree bent Mx >= 0.17 
  X = EXPAND EDGE M5_EDGE_45 OUTSIDE BY M5_S_6
  X AND M5
}


M5_HVN_5V = NET AREA RATIO M5i OVER M10_HV_5V M9_HV_5V M8_HV_5V M7_HV_5V M6_HV_5V M5_HV_5V M4_HV_5V M3_HV_5V M2_HV_5V M1_HV_5V > 0 
M5_HVN = NET AREA RATIO M5i OVER M10_HV M9_HV M8_HV M7_HV M6_HV M5_HV M4_HV M3_HV M2_HV M1_HV > 0 
M5_MVN = NET AREA RATIO M5i OVER M10_MV M9_MV M8_MV M7_MV M6_MV M5_MV M4_MV M3_MV M2_MV M1_MV > 0
M5_LVN = NET AREA RATIO M5i OVER M10_LV M9_LV M8_LV M7_LV M6_LV M5_LV M4_LV M3_LV M2_LV M1_LV > 0

M5_NOMARK = (((M5i NOT M5_HVN_5V) NOT M5_HVN) NOT M5_MVN) NOT M5_LVN

#IFDEF Mx_S_8_IO_NET
  M5_NOMARK_5V = NET AREA RATIO M5_NOMARK PSD_HVD NSD_HVD S_HVD_GATE PSTPi > 0 
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD)+!!AREA(S_HVD_GATE))*!AREA(PSTPi)]
  M5_NOMARK_HV = NET AREA RATIO M5_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPi > 0 
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPi)]
  M5_NOMARK_MV = NET AREA RATIO M5_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPi > 0 
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPi)]
#ELSE  
  M5_NOMARK_5V = NET AREA RATIO M5_NOMARK PSD_HVD NSD_HVD S_HVD_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD)+!!AREA(S_HVD_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M5_NOMARK_HV = NET AREA RATIO M5_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M5_NOMARK_MV = NET AREA RATIO M5_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)] 
#ENDIF 

M5_5V_ALL = M5_HVN_5V OR M5_NOMARK_5V  
M5_HV_ALL = M5_HVN OR M5_NOMARK_HV
M5_MV_ALL = M5_MVN OR M5_NOMARK_MV

M5.S.1.1 { @ Space [any one of Mx connect to > 3.3V and <= 5V net] >= ^M5_S_1_1
  I = STAMP M5_5V_ALL BY M5i
  EXT I M5i < M5_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}
M5.S.8.2 { @ Space to neighboring {VIAx-1 or VIAx} [either VIAx-1, VIAx or Mx connects to > 3.3V and <= 5V net] >= ^M5_S_8_2
  I = STAMP M5_5V_ALL BY M5i
  J = STAMP (VIA4i AND M5_5V_ALL) BY M5i
  EXT I VIA4i < M5_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M5i < M5_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA5i AND M5_5V_ALL) BY M5i
  EXT I VIA5i < M5_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M5i < M5_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}
M5.S.8 { @ Space to {VIAx-1 OR VIAx} [different net, any one of VIAx-1, VIAx or Mx connects to 1.8V ~ 3.3V net] 0.1  
  I = STAMP M5_HV_ALL BY M5i
  J = STAMP (VIA4i AND M5_HV_ALL) BY M5i
  EXT I VIA4i < M5_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M5i < M5_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA5i AND M5_HV_ALL) BY M5i
  EXT I VIA5i < M5_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M5i < M5_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}
M5.S.8.1 { @ Space to {VIAx-1 OR VIAx} [different net, any one of VIAx-1, VIAx or Mx connects to >= 1.5V and < 1.8V net] 0.08  
  I = STAMP M5_MV_ALL BY M5i
  J = STAMP (VIA4i AND M5_MV_ALL) BY M5i
  EXT I VIA4i < M5_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M5i < M5_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA5i AND M5_MV_ALL) BY M5i
  EXT I VIA5i < M5_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M5i < M5_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}

M5.S.9 { @ This rule is to check Metal (A) space to neighboring VIAx [either VIAx or Mx connects to >3.3V and <= 5V net]. DRC methodology to find Metal (A) Find a edge (B) of metal line end [edge length <= 0.12um] Run length (C) from edge (B) inside metal >= 0.13um Jog length (D) <= 0.01um within 0.13um run length Extend 0.06um outside from edge (B) to form a polygon metal (A) Metal (A) is defined if conditions 1~4 are all satisfied. >= 0.15 
  LINE_END_pre   = CONVEX EDGE M5 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= M5_S_9_B
  LINE_END_pre1  = EXPAND EDGE LINE_END_pre INSIDE BY GRID EXTEND BY -M5_S_9_D    
  LINE_END_pre2  = LINE_END_pre COIN INSIDE EDGE LINE_END_pre1  
  LINE_END_pre3  = INT [LINE_END_pre2] M5 < M5_S_9_C OPPOSITE 
  LINE_END_pre4  = LINE_END_pre NOT TOUCH INSIDE EDGE LINE_END_pre3
  LINE_END_pre5  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M5_S_9_D+GRID
  LINE_END_pre6  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M5_S_9_D
  LINE_END_pre7  = LINE_END_pre5 NOT LINE_END_pre6
  LINE_END_pre8  = LINE_END_pre5 TOUCH OUTSIDE EDGE LINE_END_pre4
  LINE_END_pre9  = LINE_END_pre8 COIN INSIDE EDGE LINE_END_pre7 
  LINE_END_pre10 = EXT [LINE_END_pre9] M5 < M5_S_9_C OPPOSITE
  LINE_END = LINE_END_pre4 NOT TOUCH OUTSIDE EDGE (LINE_END_pre8 TOUCH INSIDE EDGE LINE_END_pre10)
  A = EXPAND EDGE LINE_END OUTSIDE BY M5_S_9_A INSIDE BY GRID
  B = STAMP A BY M5i
  I = STAMP (A INTERACT M5_5V_ALL) BY M5i
  J = STAMP (VIA4i AND M5_5V_ALL) BY M5i
  K = STAMP (VIA5i AND M5_5V_ALL) BY M5i
  X1 = EXT I VIA4i < M5_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X2 = EXT I VIA5i  < M5_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X3 = EXT J B < M5_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X4 = EXT K B < M5_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  Y = ((X1 OR X2) OR X3) OR X4   
  COPY Y
  A INTERACT Y
}

// M5.EN.0 is checked by M5.EN.1, and M5.EN.2_M5.EN.3_M5.EN.3.1

M5.EN.1 { @ Enclosure of VIAx-1 >= 0.00 
  VIA4 NOT M5
}
M5.EN.2__M5.EN.3__M5.EN.3.1 { @ Enclosure of VIAx-1 [at least two opposite sides] >= ^M5_EN_2, or [four sides] >= ^M5_EN_3 with [at least two opposite sides] >= ^M5_EN_3_1
  X = RECTANGLE ENCLOSURE (VIA4 NOT SEALRING_ALL) M5 ABUT < 90 SINGULAR GOOD 0 M5_EN_2 OPPOSITE 0 M5_EN_2 OPPOSITE
  Y = ENC X M5 < M5_EN_3 ABUT < 90 SINGULAR REGION
  Z = RECTANGLE ENCLOSURE (X NOT TOUCH Y) M5 ABUT < 90 GOOD M5_EN_3 M5_EN_3_1 OPPOSITE M5_EN_3 M5_EN_3_1 OPPOSITE
  Y OR (ENC Z M5 < M5_EN_3_1 ABUT < 90 SINGULAR REGION)
}
M5.A.1 { @ Area (M2.A.1 except SRAM (186;0) region) >= 0.027 
     AREA M5 < M5_A_1
}
M5.A.2 { @ Area [with all of edge length< 0.17 um] (This check doesn't include the patterns filling 0.07 um x 0.17 um rectangular tile) (M2.A.2 except SRAM (186;0) region) >= 0.06 
  A = AREA M5 < M5_A_2
  B = LENGTH A >= M5_A_2_L1
  C = A NOT WITH EDGE B
  NOT ENCLOSE RECTANGLE C M5_A_2_W M5_A_2_L2 ORTHOGONAL ONLY
}


VARIABLE M5_A_3pre ((M5_A_3 + (M5_S_1 * M5_S_1 * 3.142))/(2 * M5_S_1))*((M5_A_3 + (M5_S_1 * M5_S_1 * 3.142))/(2 * M5_S_1))/3.141

M5.A.3 { @ Enclosed area >= 0.2 
  X = HOLES M5 INNER < M5_A_3pre
  AREA ( X NOT M5 ) < M5_A_3
}

// M5.R.1 can not be checked


#IFDEF FULL_CHIP
CHIP_M5 = COPY CHIP
#ELSE
CHIP_M5 = CHIP INTERACT M5x
#ENDIF

#IFDEF CHECK_LOW_DENSITY
M5.DN.1 { @ Minimum local density [window ^M5_DN_1_W um x ^M5_DN_1_W um, stepping ^M5_DN_1_S um] >= ^M5_DN_1
  M5_CHECK = M5x NOT M5_EXC_LOW
  CHIP_CHECK = CHIP NOT M5_EXC_LOW
  
  ERR_WIN = DENSITY M5_CHECK CHIP_CHECK < M5_DN_1 WINDOW M5_DN_1_W STEP M5_DN_1_S INSIDE OF LAYER CHIP_M5 BACKUP 
	[ AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M5_EXC_LOW) >= M5_DN_1_E
  DENSITY F M5_CHECK CHIP_CHECK < M5_DN_1 WINDOW M5_DN_1_W STEP M5_DN_1_S INSIDE OF LAYER CHIP_M5 BACKUP PRINT M5.DN.1.density
         [ !AREA(F)+AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
}
#ENDIF

M5.DN.1.1 { @ Maximum local density [window ^M5_DN_1_1_W um x ^M5_DN_1_1_W um, stepping ^M5_DN_1_1_S um] <= ^M5_DN_1_1
  M5_CHECK = M5x NOT M5_EXC_HIGH
  CHIP_CHECK = CHIP NOT M5_EXC_HIGH
  ERR_WIN = DENSITY M5_CHECK CHIP_CHECK > M5_DN_1_1 WINDOW M5_DN_1_1_W STEP M5_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M5_EXC_HIGH) >= M5_DN_1_1_E
  DENSITY F M5_CHECK CHIP_CHECK > M5_DN_1_1 WINDOW M5_DN_1_1_W STEP M5_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP PRINT M5.DN.1.1.density
         [ !!AREA(F)*AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
}

M5.DN.4 { @ The metal density difference between any two neighboring checking windows including DM5EXCL [window ^M5_DN_4_W um x ^M5_DN_4_W um, stepping ^M5_DN_4_W um]  <= ^M5_DN_4
  DENSITY M5x CHIP <=1 WINDOW M5_DN_4_W BACKUP GRADIENT > M5_DN_4 ABSOLUTE CORNER INSIDE OF LAYER CHIPx PRINT M5.DN.4.density
  	[ AREA(M5x)/AREA(CHIP) ]    
}

#IFDEF CHECK_LOW_DENSITY
M5.DN.6 { @ Metal Desnsity >= ^M5_DN_6. All condition-A, Condition-B, and Condition-C must be followed.
@ (1) Condition-A: Metal density [window ^M5_DN_6_W_A um x ^M5_DN_6_W_A um, stepping ^M5_DN_6_S_A um] >= ^M5_DN_6
@ (2) Condition-B: Maximum area of merged low density windows [window ^M5_DN_6_W_BC um x ^M5_DN_6_W_BC um, stepping ^M5_DN_6_S_BC um < ^M5_DN_6] <= ^M5_DN_6_A_B um2, except merged low density windows width <= ^M5_DN_6_U um
@ (3) Condition-C: Maximum area of merged low density windows [window ^M5_DN_6_W_BC um x ^M5_DN_6_W_BC um, stepping ^M5_DN_6_S_BC um < ^M5_DN_6] <= ^M5_DN_6_A_C um2
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M5_DN_6_E_A um for condition-A and >= ^M5_DN_6_E_BC um for both condition-B/condition-C 
  M5_CHECK = M5x NOT NEW_DEN_EXC
  CHIP_CHECK = CHIP NOT NEW_DEN_EXC
  // Condition-A
  ERR_WIN_A = DENSITY M5_CHECK CHIP_CHECK < M5_DN_6 WINDOW M5_DN_6_W_A STEP M5_DN_6_S_A INSIDE OF LAYER CHIP_M5 BACKUP 
	[ AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
  F_A = WITH WIDTH (ERR_WIN_A NOT NEW_DEN_EXC) >= M5_DN_6_E_A
  DENSITY F_A M5_CHECK CHIP_CHECK < M5_DN_6 WINDOW M5_DN_6_W_A STEP M5_DN_6_S_A INSIDE OF LAYER CHIP_M5 BACKUP PRINT M5.DN.6_A.density
         [ !AREA(F_A)+AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
  // Condition-B 
  ERR_WIN_B = DENSITY M5_CHECK CHIP_CHECK < M5_DN_6 WINDOW M5_DN_6_W_BC STEP M5_DN_6_S_BC INSIDE OF LAYER CHIP_M5 BACKUP 
	[ AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
  F_B = WITH WIDTH (ERR_WIN_B NOT NEW_DEN_EXC) >= M5_DN_6_E_BC
  A = DENSITY F_B M5_CHECK CHIP_CHECK < M5_DN_6 WINDOW M5_DN_6_W_BC STEP M5_DN_6_S_BC INSIDE OF LAYER CHIP_M5 BACKUP PRINT M5.DN.6_BC.density
         [ !AREA(F_B)+AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
  B = AREA A > M5_DN_6_A_B
  C = SIZE B BY M5_DN_6_U/2 UNDEROVER
  B INTERACT C
  // Condition-C
  AREA B > M5_DN_6_A_C
}
#ENDIF


// Mx.DN.5
//===========
M5_CORE = M5x NOT SEALRING_EXCLUDE

Mx.DN.5:M3_M4_M5 { @ It is not allowed to have local density > 85% of all 3 consecutive metal (Mx, Mx+1 and Mx+2) over any window 62.5 um x 62.5 um (stepping 31.25 um), i.e. it is allowed for either one of Mx, Mx+1, or Mx+2 to have a local density <= 85%. 1. The metal layers include M1/Mx and dummy metals. 2. The check does not include chip corner stress relief pattern, sealring (162;2) and top2 metals at CUP area.   
    DENSITY  M3_CORE M4_CORE M5_CORE >0 WINDOW M3_DN_5_W STEP M3_DN_5_S BACKUP INSIDE OF LAYER CHIPx
  	  [ !~(AREA(M3_CORE)/AREA()- M3_DN_5)*!~(AREA(M4_CORE)/AREA()- M3_DN_5)*!~(AREA(M5_CORE)/AREA()- M3_DN_5) ]
 	  RDB Mx.DN.5:M3_M4_M5.density
}
#IFDEF CHECK_LOW_DENSITY
Mx.DN.7:M3_M4_M5 { @ It is not allowed to have local density < 5% of all 3 consecutive metal layer(M3,M4,M5) over any 30umx30um window (stepping 15um), i.e. it is allowed for either one of M3, M4, or M5 to have a local density >= 5 %.
@ 1. The metal layers include M1/Mx and dummy metals
@ 2. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 3. This rule is applied while the width of (checking window NOT above excluding region) >= 15 um    
   M3_CHECK = M3x NOT NEW_DEN_EXC
   M4_CHECK = M4x NOT NEW_DEN_EXC
   M5_CHECK = M5x NOT NEW_DEN_EXC
   CHIP_CHECK = CHIP NOT NEW_DEN_EXC
   ERR_WIN = DENSITY M3_CHECK M4_CHECK M5_CHECK CHIP_CHECK >0 WINDOW M3_DN_7_W STEP M3_DN_7_S BACKUP INSIDE OF LAYER CHIP_M5
   [ !~(M3_DN_7-AREA(M3_CHECK)/AREA(CHIP_CHECK))*!~(M3_DN_7-AREA(M4_CHECK)/AREA(CHIP_CHECK))*!~(M3_DN_7-AREA(M5_CHECK)/AREA(CHIP_CHECK)) ]
   F = WITH WIDTH (ERR_WIN NOT NEW_DEN_EXC) >= M3_DN_7_E
   DENSITY F M3_CHECK M4_CHECK M5_CHECK CHIP_CHECK >0 WINDOW M3_DN_7_W STEP M3_DN_7_S BACKUP INSIDE OF LAYER CHIP_M5
   [ !!AREA(F)*!~(M3_DN_7-AREA(M3_CHECK)/AREA(CHIP_CHECK))*!~(M3_DN_7-AREA(M4_CHECK)/AREA(CHIP_CHECK))*!~(M3_DN_7-AREA(M5_CHECK)/AREA(CHIP_CHECK)) ]
   RDB Mx.DN.7:M3_M4_M5.density
}
#ENDIF

M5.R.3 { @ Metal(pin) layers must be drawn only interact with one relative Metal(drawing) layers
   M5_PIN NOT INTERACT M5i == 1
}


//VIA5 CHECKS
//===========
#IFNDEF WIDE_ADJUST
M6Wide_2_0 = M6 WITH WIDTH > M6_S_2_W            // 0.17
M6Wide_2_1 = M6Wide_2_0 WITH WIDTH > M6_S_2_1_W  // 0.24
M6Wide_2_2 = M6Wide_2_1 WITH WIDTH > M6_S_2_2_W  // 0.31
M6Wide_2_3 = M6Wide_2_2 WITH WIDTH > M6_S_2_3_W  // 0.62
M6Wide_3_0 = M6Wide_2_3 WITH WIDTH > M6_S_3_W    // 1.65
#ELSE
M6Wide_2_4 = M6 WITH WIDTH > M6_S_2_4_W          // 0.17
M6Wide_2_0 = M6Wide_2_4 WITH WIDTH > M6_S_2_W    // 0.19
M6Wide_2_5 = M6Wide_2_0 WITH WIDTH > M6_S_2_5_W  // 0.24
M6Wide_2_1 = M6Wide_2_5 WITH WIDTH > M6_S_2_1_W  // 0.265
M6Wide_2_6 = M6Wide_2_1 WITH WIDTH > M6_S_2_6_W  // 0.31
M6Wide_2_2 = M6Wide_2_6 WITH WIDTH > M6_S_2_2_W  // 0.345
M6Wide_2_7 = M6Wide_2_2 WITH WIDTH > M6_S_2_7_W  // 0.62
M6Wide_2_3 = M6Wide_2_7 WITH WIDTH > M6_S_2_3_W  // 0.685
M6Wide_3_0 = M6Wide_2_3 WITH WIDTH > M6_S_3_W    // 1.65
#ENDIF

M5Wide_R2_VIA5 = M5Wide_2_0 WITH WIDTH > VIA5_R_2_W        // 0.21
M5Wide_R4_VIA5 = M5Wide_R2_VIA5 WITH WIDTH > VIA5_R_4_W    // 0.21
M5Wide_R3_VIA5 = M5Wide_R4_VIA5 WITH WIDTH > VIA5_R_3_W    // 0.55
M5Wide_R5_VIA5 = M5Wide_R3_VIA5 WITH WIDTH > VIA5_R_5_W    // 1.4
M5Wide_R6_VIA5 = M5Wide_R5_VIA5 WITH WIDTH > VIA5_R_6_W    // 2.1
M6Wide_R2_VIA5 = M6Wide_2_0 WITH WIDTH > VIA5_R_2_W      // 0.21
M6Wide_R4_VIA5 = M6Wide_R2_VIA5 WITH WIDTH > VIA5_R_4_W  // 0.21
M6Wide_R3_VIA5 = M6Wide_R4_VIA5 WITH WIDTH > VIA5_R_3_W  // 0.55
M6Wide_R5_VIA5 = M6Wide_R3_VIA5 WITH WIDTH > VIA5_R_5_W  // 1.4
M6Wide_R6_VIA5 = M6Wide_R5_VIA5 WITH WIDTH > VIA5_R_6_W  // 2.1

VIA5.W.1 { @ Width (maximum = minimum) (Except sealring (162,2) and {VIAx bar INSIDE {LOWMEDN NOT (LOWMEDN SIZING -4 um)}} region) = 0.07 
   NOT RECTANGLE (VIA5i NOT (SEALRING_EXCLUDE OR P_RING_REGION)) == VIA5_W_1 BY == VIA5_W_1 ORTHOGONAL ONLY
}
VIA5.S.1 { @ Space >= 0.07 
  EXT VIA5i < VIA5_S_1 ABUT < 90 SINGULAR REGION
}
VIA5.S.1.1 { @ Space [any one of VIAx connect to > 3.3V and <= 5V different net] >= ^VIA5_S_1_1
  J = STAMP (VIA5i AND M5_5V_ALL) BY M5i
  EXT J VIA5i < VIA5_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}
VIA5.S.2 { @ Space to 3-neighboring VIAx (distance < 0.098 um) >= 0.09 
  X = WITH NEIGHBOR VIA5i > 2 SPACE < VIA5_S_2_D
  EXT X VIA5i < VIA5_S_2 ABUT < 90 SINGULAR REGION
}
VIA5.S.3 { @ Space to neighboring VIAx [different net] >= 0.095 
  EXT VIA5i < VIA5_S_3 ABUT < 90 NOT CONNECTED REGION
}
VIA5.S.3.1 { @ Space to neighboring VIAx [different net and common parallel run length > 0 um] >= 0.11 
  EXT VIA5i < VIA5_S_3_1 ABUT < 90 NOT CONNECTED OPPOSITE REGION
}

// VIA5.EN.0 is checked by VIA5.EN.1, and VIA5.EN.2_VIA5.EN.4_VIA5.EN.4.1

VIA5.EN.1 { @ Enclosure by Mx or M1 >= 0.00 
  VIA5 NOT M5
}

VIA5.EN.2__VIA5.EN.4__VIA5.EN.4.1 { @ Enclosure by M5 [at least two opposite sides] >= ^VIA5_EN_2, or [four sides] >= ^VIA5_EN_4 with [at least two opposite sides] >= ^VIA5_EN_4_1
  X = RECTANGLE ENCLOSURE (VIA5 NOT SEALRING_EXCLUDE) M5 ABUT < 90 SINGULAR GOOD 0 VIA5_EN_2 OPPOSITE 0 VIA5_EN_2 OPPOSITE
  Y = ENC X M5 < VIA5_EN_4 ABUT < 90 SINGULAR REGION
  Z = RECTANGLE ENCLOSURE (X NOT TOUCH Y) M5 ABUT < 90 GOOD VIA5_EN_4 VIA5_EN_4_1 OPPOSITE VIA5_EN_4 VIA5_EN_4_1 OPPOSITE
  Y OR (ENC Z M5 < VIA5_EN_4_1 ABUT < 90 SINGULAR REGION)

}



// VIA5.R.1 is checked by VIA5.W.1
VIA5.R.2__VIA5.R.3 { @ When M5 or M6 width > ^VIA5_R_2_W um, more than one VIA5 is required.
                    @ 2 vias spacing should be <= ^VIA5_R_2_S1 um or 4 vias spacing should be <= ^VIA5_R_2_S2 um
                    @ When M5 or M6 width > ^VIA5_R_3_W um, more than three VIA5 is required.
                    @ 4 vias spacing should be <= ^VIA5_R_3_S1 um or 9 vias spacing should be <= ^VIA5_R_3_S2 um
                    @ not check SRAM region					
   M6OvpM5_W_ = (M5Wide_R2_VIA5 AND M6) OR (M6Wide_R2_VIA5 AND M5)
   M6OvpM5_B  = (M5Wide_R3_VIA5 AND M6) OR (M6Wide_R3_VIA5 AND M5)
   M6OvpM5_W  = M6OvpM5_W_ NOT M6OvpM5_B 
   Checked_VIA5_W_ = VIA5_EXD NOT OUTSIDE M6OvpM5_W
   Checked_VIA5_B  = VIA5_EXD NOT OUTSIDE M6OvpM5_B
   Checked_VIA5_W  = Checked_VIA5_W_ NOT Checked_VIA5_B
   M5_effect = M5i INTERACT M6OvpM5_W_
   M6_effect = M6i INTERACT M6OvpM5_W_
   effect_M6OvpM5_ = M5_effect AND M6_effect
   effect_M6OvpM5 = effect_M6OvpM5_ INTERACT M6OvpM5_W_
   effect_VIA = VIA5_EXD INTERACT effect_M6OvpM5

   V5Merged_A = SIZE effect_VIA BY VIA5_R_2_S1/2 INSIDE OF effect_M6OvpM5 STEP M5_S_1*0.7
   V5Merged_B = SIZE V5Merged_A BY (VIA5_R_2_S2 - VIA5_R_2_S1)/2 INSIDE OF effect_M6OvpM5 STEP M5_S_1*0.7
   V5Merged_C = SIZE V5Merged_B BY (VIA5_R_3_S2 - VIA5_R_2_S2)/2 INSIDE OF effect_M6OvpM5 STEP M5_S_1*0.7
   V5Merged_A2R = V5Merged_A INTERACT effect_VIA < 2
   V5Merged_A2 = V5Merged_A OUTSIDE V5Merged_A2R
   V5Merged_A4R = V5Merged_A2 INTERACT effect_VIA < 4
   V5Merged_A4 = V5Merged_A2 OUTSIDE V5Merged_A4R
   V5Merged_B4R = V5Merged_B INTERACT effect_VIA < 4
   V5Merged_B4 = V5Merged_B OUTSIDE V5Merged_B4R
   V5Merged_C9R = V5Merged_C INTERACT effect_VIA < 9
   V5Merged_C9 = V5Merged_C OUTSIDE V5Merged_C9R

   GMergeW = V5Merged_A2 OR V5Merged_B4
   GMergeB = V5Merged_A4 OR V5Merged_C9
   GVIA_W = Checked_VIA5_W INTERACT GMergeW
   GVIA_B = Checked_VIA5_B INTERACT GMergeB
   GOOD_AREA_W = M6OvpM5_W INTERACT GVIA_W
   GOOD_AREA_B = M6OvpM5_B INTERACT GVIA_B
   Checked_VIA5_W OUTSIDE GOOD_AREA_W
   Checked_VIA5_B OUTSIDE GOOD_AREA_B
}

VIA5.R.4.M5 { @ At least two VIAx must be used for a connection that is <= ^VIA5_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA5_R_4_W um (L) and width > ^VIA5_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA5_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA5_R_4_W um (L) and width > ^VIA5_R_4_W um (W).)   
  Branch1 = ((SIZE M5Wide_R4_VIA5 BY VIA5_R_4_D + GRID) NOT M5Wide_R4_VIA5) AND M5
  Branch1HasVia = (Branch1 INTERACT M5Wide_R4_VIA5) INTERACT VIA5_EXD
  Branch1Edge = M5Wide_R4_VIA5 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA5_R_4_D INSIDE OF Branch1HasVia STEP M5_S_1*0.5
  GoodBranch = (Branch AND M6) INTERACT VIA5_EXD > 1
  BranchSingleVia = (VIA5_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M6 INTERACT BranchSingleVia) AND M5) INTERACT BranchSingleVia) INTERACT VIA5_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA5.R.4.M6 { @ At least two VIAx must be used for a connection that is <= ^VIA5_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA5_R_4_W um (L) and width > ^VIA5_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA5_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA5_R_4_W um (L) and width > ^VIA5_R_4_W um (W)).   
  Branch1 = ((SIZE M6Wide_R4_VIA5 BY VIA5_R_4_D + GRID) NOT M6Wide_R4_VIA5) AND M6
  Branch1HasVia = (Branch1 INTERACT M6Wide_R4_VIA5) INTERACT VIA5_EXD
  Branch1Edge = M6Wide_R4_VIA5 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA5_R_4_D INSIDE OF Branch1HasVia STEP M6_S_1*0.5
  GoodBranch = (Branch AND M5) INTERACT VIA5_EXD > 1
  BranchSingleVia = (VIA5_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M5 INTERACT BranchSingleVia) AND M6) INTERACT BranchSingleVia) INTERACT VIA5_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA5.R.5.M5 { @ At least two VIAx must be used for a connection that is <= ^VIA5_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA5_R_5_W um (L) and width > ^VIA5_R_5_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA5_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA5_R_5_W um (L) and width > ^VIA5_R_5_W um (W)).
  Branch1 = ((SIZE M5Wide_R5_VIA5 BY VIA5_R_5_D + GRID) NOT M5Wide_R5_VIA5) AND M5
  Branch1HasVia = (Branch1 INTERACT M5Wide_R5_VIA5) INTERACT VIA5_EXD
  Branch1Edge = M5Wide_R5_VIA5 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA5_R_5_D INSIDE OF Branch1HasVia STEP M5_S_1*0.7
  GoodBranch = (Branch AND M6) INTERACT VIA5_EXD > 1
  BranchSingleVia = (VIA5_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M6 INTERACT BranchSingleVia) AND M5) INTERACT BranchSingleVia) INTERACT VIA5_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA5.R.5.M6 { @ At least two VIAx must be used for a connection that is <= ^VIA5_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA5_R_5_W um (L) and width > ^VIA5_R_5_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA5_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA5_R_5_W um (L) and width > ^VIA5_R_5_W um (W)).
  Branch1 = ((SIZE M6Wide_R5_VIA5 BY VIA5_R_5_D + GRID) NOT M6Wide_R5_VIA5) AND M6
  Branch1HasVia = (Branch1 INTERACT M6Wide_R5_VIA5) INTERACT VIA5_EXD
  Branch1Edge = M6Wide_R5_VIA5 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA5_R_5_D INSIDE OF Branch1HasVia STEP M6_S_1*0.7
  GoodBranch = (Branch AND M5) INTERACT VIA5_EXD > 1
  BranchSingleVia = (VIA5_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M5 INTERACT BranchSingleVia) AND M6) INTERACT BranchSingleVia) INTERACT VIA5_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M5Big_R6_VIA5 = ENCLOSE RECTANGLE M5Wide_R6_VIA5 VIA5_R_6_W VIA5_R_6_L+GRID

VIA5.R.6.M5 { @ At least two VIAx must be used for a connection that is <= ^VIA5_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA5_R_6_L um (L) and width > ^VIA5_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA5_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA5_R_6_L um (L) and width > ^VIA5_R_6_W um (W)).
  Branch1 = ((SIZE M5Big_R6_VIA5 BY VIA5_R_6_D + GRID) NOT M5Big_R6_VIA5) AND M5
  Branch1HasVia = (Branch1 INTERACT M5Big_R6_VIA5) INTERACT VIA5_EXD
  Branch1Edge = M5Big_R6_VIA5 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA5_R_6_D INSIDE OF Branch1HasVia STEP M5_S_1*0.7
  GoodBranch = (Branch AND M6) INTERACT VIA5_EXD > 1
  BranchSingleVia = (VIA5_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M6 INTERACT BranchSingleVia) AND M5) INTERACT BranchSingleVia) INTERACT VIA5_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M6Big_R6_VIA5 = ENCLOSE RECTANGLE M6Wide_R6_VIA5 VIA5_R_6_W VIA5_R_6_L+GRID

VIA5.R.6.M6 { @ At least two VIAx must be used for a connection that is <= ^VIA5_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA5_R_6_L um (L) and width > ^VIA5_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA5_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA5_R_6_L um (L) and width > ^VIA5_R_6_W um (W)).
  Branch1 = ((SIZE M6Big_R6_VIA5 BY VIA5_R_6_D + GRID) NOT M6Big_R6_VIA5) AND M6
  Branch1HasVia = (Branch1 INTERACT M6Big_R6_VIA5) INTERACT VIA5_EXD
  Branch1Edge = M6Big_R6_VIA5 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA5_R_6_D INSIDE OF Branch1HasVia STEP M6_S_1*0.7
  GoodBranch = (Branch AND M5) INTERACT VIA5_EXD > 1
  BranchSingleVia = (VIA5_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M5 INTERACT BranchSingleVia) AND M6) INTERACT BranchSingleVia) INTERACT VIA5_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}
// VIA5.R.7 is checked by VIA5.EN.1
// VIA5.R.9 can't be checked

VIA5.R.11 { @ Single VIAx is not allowed for H-shape Mx+1 when all of the following conditions come into existence: 1. The Mx+1 has H-shape interact with two metal holes: two metal hole length(L2) <= ^VIA5_R_11_L1 um and both two metal hole area <= ^VIA5_R_11_A um2 2. The VIAx overlaps on the center metal bar of this H-shape Mx+1 3. The length (L) of the center metal bar <= ^VIA5_R_11_L2 um and the width of metal bar is <= ^VIA5_R_11_W um.
  W = M6i WITH WIDTH <= VIA5_R_11_W   
  H_HOLE = HOLES M6i INNER <= VIA5_R_11_A
  A = M6i COIN OUTSIDE EDGE H_HOLE
  B0 = ((INT A <= VIA5_R_11_W ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE M6i) INTERACT H_HOLE == 2 
  B1 = (((INT A <= VIA5_R_11_L2 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE M6i) AND W) INTERACT H_HOLE == 2
  HOLE_NOTCH = EXT H_HOLE <= VIA5_R_11_W ABUT<90 OPPOSITE NOTCH REGION  
  B2 = (B1 NOT HOLE_NOTCH) OR B0
  CORNER_M = ((EXT B2 <= VIA5_R_11_W ABUT == 90 INTERSECTING ONLY REGION EXTENTS) TOUCH B2 == 2) AND W
  B = B2 OR CORNER_M
  CENTER_BAR1 = NOT ENCLOSE RECTANGLE B GRID VIA5_R_11_L2+GRID
  CENTER_BAR2 = CENTER_BAR1 INTERACT H_HOLE == 2
  C = CENTER_BAR2 COIN OUTSIDE EDGE H_HOLE 
  D = EXT [C] M6i <= VIA5_R_11_L1 OPPOSITE
  E = C NOT COIN INSIDE EDGE D
  CENTER_BAR3 = CENTER_BAR2 NOT WITH EDGE E
  CHECK_VIA = VIA5 NOT OUTSIDE CENTER_BAR3
  CHECK_VIA AND (((M6i INTERACT CHECK_VIA) AND (M5i INTERACT CHECK_VIA)) INTERACT VIA5i == 1)
}

VIA5.R.12 { @ VIA5 connected to DM5, DM5_O, DM6, DM6_O is not allowed
  VIA5 INTERACT DUM5
  VIA5 INTERACT DUM6
  VIA5 INTERACT DM5_O
  VIA5 INTERACT DM6_O
}  

//M6 CHECKS
//=========


M6_EDGE_45 = M6 ANGLE == 45

M6.W.1 { @ Width >= 0.07 
  INT M6 < M6_W_1 ABUT < 90 SINGULAR REGION
}
M6.W.2 { @ Width of 45-degree bent Mx. (Please make sure the vertex of 45 degree pattern is on 0.005 um grid (refer to the guideline, G.6gU, in section 3.7)) >= 0.17 
  INT M6_EDGE_45 < M6_W_2 ABUT < 90 REGION
}
M6.W.3 { @ Maximum width <= ^M6_W_3 um, exclude sealring 
  M6_MAX_WIDTH WITH WIDTH > M6_W_3
}

M6.S.1 { @ Space >= 0.07 
  EXT M6 < M6_S_1 ABUT < 90 SINGULAR REGION
}
M6.S.2 { @ Min. Metal space (for W> ^M6_S_2_W um & parallel length > ^M6_S_2_L um) >= ^M6_S_2 um
  X = EXT M6Wide_2_0 M6 < M6_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M6
  ENCLOSE RECTANGLE Y GRID M6_S_2_L+GRID
}
M6.S.2.1 { @ Min. Metal space (for W> ^M6_S_2_1_W um & parallel length > ^M6_S_2_1_L um) >= ^M6_S_2_1 um
  X = EXT M6Wide_2_1 M6 < M6_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M6
  ENCLOSE RECTANGLE Y GRID M6_S_2_1_L+GRID
}
M6.S.2.2 { @ Min. Metal space (for W> ^M6_S_2_2_W um & parallel length > ^M6_S_2_2_L um) >= ^M6_S_2_2 um
  X = EXT M6Wide_2_2 M6 < M6_S_2_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M6
  ENCLOSE RECTANGLE Y GRID M6_S_2_2_L+GRID
}
M6.S.2.3 { @ Min. Metal space (for W> ^M6_S_2_3_W um & parallel length > ^M6_S_2_3_L um) >= ^M6_S_2_3 um
  X = EXT M6Wide_2_3 M6 < M6_S_2_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M6
  ENCLOSE RECTANGLE Y GRID M6_S_2_3_L+GRID
}
#IFDEF WIDE_ADJUST
M6.S.2.4 { @ Min. Metal space (for W> ^M6_S_2_4_W um & parallel length > ^M6_S_2_4_L um) >= ^M6_S_2_4 um
  X = EXT M6Wide_2_4 M6 < M6_S_2_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M6
  ENCLOSE RECTANGLE Y GRID M6_S_2_4_L+GRID
}
M6.S.2.5 { @ Min. Metal space (for W> ^M6_S_2_5_W um & parallel length > ^M6_S_2_5_L um) >= ^M6_S_2_5 um
  X = EXT M6Wide_2_5 M6 < M6_S_2_5 OPPOSITE REGION MEASURE ALL
  Y = X NOT M6
  ENCLOSE RECTANGLE Y GRID M6_S_2_5_L+GRID
}
M6.S.2.6 { @ Min. Metal space (for W> ^M6_S_2_6_W um & parallel length > ^M6_S_2_6_L um) >= ^M6_S_2_6 um
  X = EXT M6Wide_2_6 M6 < M6_S_2_6 OPPOSITE REGION MEASURE ALL
  Y = X NOT M6
  ENCLOSE RECTANGLE Y GRID M6_S_2_6_L+GRID
}
M6.S.2.7 { @ Min. Metal space (for W> ^M6_S_2_7_W um & parallel length > ^M6_S_2_7_L um) >= ^M6_S_2_7 um
  X = EXT M6Wide_2_7 M6 < M6_S_2_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M6
  ENCLOSE RECTANGLE Y GRID M6_S_2_7_L+GRID
}
#ENDIF
M6.S.3 { @ Min. Metal space (for W> ^M6_S_3_W um & parallel length > ^M6_S_3_L um) >= ^M6_S_3 um
  X = EXT M6Wide_3_0 M6 < M6_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M6
  (ENCLOSE RECTANGLE Y 0.001 M6_S_3_L+0.001) NOT INSIDE IND_REGION
}
M6.S.5 { @ Space at Mx line-end (W < 0.10 um (Q)) in a dense-line-end configuration: If Mx has parallel run length with opposite Mx (measured with T = 0.035 um extension) along 2 adjacent edges of Mx [any one edge <Q distance from the corner of the two edges], then one of the space (S1 or S2) needs to be at least this value (This check doesn't include small jog with edge length < 0.07 um(R)) (M2.S.5 except SRAM (186;0) region) >= 0.10 
  A = CONVEX EDGE M6 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M6_S_5_W
  B = EXT [A] M6 < M6_S_5 ABUT < 90 OPPOSITE EXTENDED M6_S_5_T
  C = A TOUCH INSIDE EDGE B
  D = INT C [M6] < M6_S_5_W ABUT == 90 INTERSECTING ONLY
  I = LENGTH D >= M6_W_1
  J = EXPAND EDGE I INSIDE BY 0.001 EXTEND BY M6_S_5_T
  K = EXPAND EDGE I INSIDE BY 0.001 
  L = J NOT K
  M = L WITH EDGE A 
  N = M OR K
  O = N TOUCH EDGE I
  EXT O M6 < M6_S_5 ABUT < 90 OPPOSITE REGION

}

M6.S.5.1 { @ Space at Mx line-end (W<Q=^M6_S_5_1_W) in a dense-line-end configuration.If Mx has parallel run length with opposite Mx (measured with ^M6_S_5_1_T (T) extension) along two adjacent edges of Mx [any one edge < ^M6_S_5_1_W (W) from the corner of the two edges of Mx], and Mx enclosure of VIAx-1 < ^M6_S_5_1_E at line-end, then one of the space (S1 or S2) must be >= ^M6_S_5_1 um.
  A = CONVEX EDGE M6 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M6_S_5_1_W
  V5_EN = ENC [VIA5i] A < M6_S_5_1_E ABUT < 90 OPPOSITE
  M6_EN = ENC V5_EN [A] < M6_S_5_1_E ABUT < 90 OPPOSITE
  M6_SA = EXT A [M6] < M6_S_5_1 ABUT < 90 OPPOSITE EXTENDED M6_S_5_1_T
  M6_SB = EXT [A] M6_SA < M6_S_5_1 ABUT < 90 OPPOSITE EXTENDED M6_S_5_1_T
  M6_END = (A TOUCH INSIDE EDGE M6_EN) TOUCH INSIDE EDGE M6_SB
  EN_B = ENC V5_EN [M6_END] < M6_S_5_1_E2 OPPOSITE
  EN_C = ENC V5_EN [M6_END] < M6_S_5_1_E3 OPPOSITE
  EN_D = ENC V5_EN [M6_END] < M6_S_5_1_E4 OPPOSITE
  S1_B = EXT [M6_END] M6_SA < M6_S_5_1_S2 OPPOSITE EXTENDED M6_S_5_1_T
  S1_C = EXT [M6_END] M6_SA < M6_S_5_1_S3 OPPOSITE EXTENDED M6_S_5_1_T
  S1_D = EXT [M6_END] M6_SA < M6_S_5_1_S4 OPPOSITE EXTENDED M6_S_5_1_T
  PASS_B = (M6_END NOT TOUCH INSIDE EDGE EN_B) NOT TOUCH INSIDE EDGE S1_B
  PASS_C = (M6_END NOT TOUCH INSIDE EDGE EN_C) NOT TOUCH INSIDE EDGE S1_C
  PASS_D = (M6_END NOT TOUCH INSIDE EDGE EN_D) NOT TOUCH INSIDE EDGE S1_D
  M6_CHECK = ((M6_END NOT TOUCH INSIDE EDGE PASS_B) NOT TOUCH INSIDE EDGE PASS_C) NOT TOUCH INSIDE EDGE PASS_D
  H = INT M6_CHECK [M6] < M6_S_5_1_W ABUT == 90 INTERSECTING ONLY
  I = LENGTH H >= M6_W_1
  J = EXPAND EDGE I INSIDE BY GRID EXTEND BY M6_S_5_1_T
  K = EXPAND EDGE I INSIDE BY GRID
  L = J NOT K
  M = L WITH EDGE A 
  N = M OR K
  O = N TOUCH INSIDE EDGE I
  P = EXT [O] M6 < M6_S_5_1 ABUT < 90 OPPOSITE
  Q = ENC VIA5i (O TOUCH INSIDE EDGE P) < M6_S_5_1_E ABUT < 90 OPPOSITE REGION
  VIA_BAD1 = VIA5i INTERACT Q
  VIA_GOOD = VIA5i NOT VIA_BAD1
  VIA_BAD2 = VIA_BAD1 NOT INTERACT ((M6 AND M5) INTERACT VIA_GOOD)
  ENC VIA_BAD2 M6_CHECK < M6_S_5_1_E ABUT < 90 OPPOSITE REGION
}

M6.S.6 { @ Space to 45-degree bent Mx >= 0.17 
  X = EXPAND EDGE M6_EDGE_45 OUTSIDE BY M6_S_6
  X AND M6
}


M6_HVN_5V = NET AREA RATIO M6i OVER M10_HV_5V M9_HV_5V M8_HV_5V M7_HV_5V M6_HV_5V M5_HV_5V M4_HV_5V M3_HV_5V M2_HV_5V M1_HV_5V > 0 
M6_HVN = NET AREA RATIO M6i OVER M10_HV M9_HV M8_HV M7_HV M6_HV M5_HV M4_HV M3_HV M2_HV M1_HV > 0 
M6_MVN = NET AREA RATIO M6i OVER M10_MV M9_MV M8_MV M7_MV M6_MV M5_MV M4_MV M3_MV M2_MV M1_MV > 0
M6_LVN = NET AREA RATIO M6i OVER M10_LV M9_LV M8_LV M7_LV M6_LV M5_LV M4_LV M3_LV M2_LV M1_LV > 0

M6_NOMARK = (((M6i NOT M6_HVN_5V) NOT M6_HVN) NOT M6_MVN) NOT M6_LVN

#IFDEF Mx_S_8_IO_NET
  M6_NOMARK_5V = NET AREA RATIO M6_NOMARK PSD_HVD NSD_HVD S_HVD_GATE PSTPi > 0 
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD)+!!AREA(S_HVD_GATE))*!AREA(PSTPi)]
  M6_NOMARK_HV = NET AREA RATIO M6_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPi > 0 
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPi)]
  M6_NOMARK_MV = NET AREA RATIO M6_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPi > 0 
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPi)]
#ELSE  
  M6_NOMARK_5V = NET AREA RATIO M6_NOMARK PSD_HVD NSD_HVD S_HVD_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD)+!!AREA(S_HVD_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M6_NOMARK_HV = NET AREA RATIO M6_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M6_NOMARK_MV = NET AREA RATIO M6_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)] 
#ENDIF 

M6_5V_ALL = M6_HVN_5V OR M6_NOMARK_5V  
M6_HV_ALL = M6_HVN OR M6_NOMARK_HV
M6_MV_ALL = M6_MVN OR M6_NOMARK_MV

M6.S.1.1 { @ Space [any one of Mx connect to > 3.3V and <= 5V net] >= ^M6_S_1_1
  I = STAMP M6_5V_ALL BY M6i
  EXT I M6i < M6_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}
M6.S.8.2 { @ Space to neighboring {VIAx-1 or VIAx} [either VIAx-1, VIAx or Mx connects to > 3.3V and <= 5V net] >= ^M6_S_8_2
  I = STAMP M6_5V_ALL BY M6i
  J = STAMP (VIA5i AND M6_5V_ALL) BY M6i
  EXT I VIA5i < M6_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M6i < M6_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA6i AND M6_5V_ALL) BY M6i
  EXT I VIA6i < M6_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M6i < M6_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}
M6.S.8 { @ Space to {VIAx-1 OR VIAx} [different net, any one of VIAx-1, VIAx or Mx connects to 1.8V ~ 3.3V net] 0.1  
  I = STAMP M6_HV_ALL BY M6i
  J = STAMP (VIA5i AND M6_HV_ALL) BY M6i
  EXT I VIA5i < M6_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M6i < M6_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA6i AND M6_HV_ALL) BY M6i
  EXT I VIA6i < M6_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M6i < M6_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}
M6.S.8.1 { @ Space to {VIAx-1 OR VIAx} [different net, any one of VIAx-1, VIAx or Mx connects to >= 1.5V and < 1.8V net] 0.08  
  I = STAMP M6_MV_ALL BY M6i
  J = STAMP (VIA5i AND M6_MV_ALL) BY M6i
  EXT I VIA5i < M6_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M6i < M6_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA6i AND M6_MV_ALL) BY M6i
  EXT I VIA6i < M6_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M6i < M6_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}

M6.S.9 { @ This rule is to check Metal (A) space to neighboring VIAx [either VIAx or Mx connects to >3.3V and <= 5V net]. DRC methodology to find Metal (A) Find a edge (B) of metal line end [edge length <= 0.12um] Run length (C) from edge (B) inside metal >= 0.13um Jog length (D) <= 0.01um within 0.13um run length Extend 0.06um outside from edge (B) to form a polygon metal (A) Metal (A) is defined if conditions 1~4 are all satisfied. >= 0.15 
  LINE_END_pre   = CONVEX EDGE M6 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= M6_S_9_B
  LINE_END_pre1  = EXPAND EDGE LINE_END_pre INSIDE BY GRID EXTEND BY -M6_S_9_D    
  LINE_END_pre2  = LINE_END_pre COIN INSIDE EDGE LINE_END_pre1  
  LINE_END_pre3  = INT [LINE_END_pre2] M6 < M6_S_9_C OPPOSITE 
  LINE_END_pre4  = LINE_END_pre NOT TOUCH INSIDE EDGE LINE_END_pre3
  LINE_END_pre5  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M6_S_9_D+GRID
  LINE_END_pre6  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M6_S_9_D
  LINE_END_pre7  = LINE_END_pre5 NOT LINE_END_pre6
  LINE_END_pre8  = LINE_END_pre5 TOUCH OUTSIDE EDGE LINE_END_pre4
  LINE_END_pre9  = LINE_END_pre8 COIN INSIDE EDGE LINE_END_pre7 
  LINE_END_pre10 = EXT [LINE_END_pre9] M6 < M6_S_9_C OPPOSITE
  LINE_END = LINE_END_pre4 NOT TOUCH OUTSIDE EDGE (LINE_END_pre8 TOUCH INSIDE EDGE LINE_END_pre10)
  A = EXPAND EDGE LINE_END OUTSIDE BY M6_S_9_A INSIDE BY GRID
  B = STAMP A BY M6i
  I = STAMP (A INTERACT M6_5V_ALL) BY M6i
  J = STAMP (VIA5i AND M6_5V_ALL) BY M6i
  K = STAMP (VIA6i AND M6_5V_ALL) BY M6i
  X1 = EXT I VIA5i < M6_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X2 = EXT I VIA6i  < M6_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X3 = EXT J B < M6_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X4 = EXT K B < M6_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  Y = ((X1 OR X2) OR X3) OR X4   
  COPY Y
  A INTERACT Y
}

// M6.EN.0 is checked by M6.EN.1, and M6.EN.2_M6.EN.3_M6.EN.3.1

M6.EN.1 { @ Enclosure of VIAx-1 >= 0.00 
  VIA5 NOT M6
}
M6.EN.2__M6.EN.3__M6.EN.3.1 { @ Enclosure of VIAx-1 [at least two opposite sides] >= ^M6_EN_2, or [four sides] >= ^M6_EN_3 with [at least two opposite sides] >= ^M6_EN_3_1
  X = RECTANGLE ENCLOSURE (VIA5 NOT SEALRING_ALL) M6 ABUT < 90 SINGULAR GOOD 0 M6_EN_2 OPPOSITE 0 M6_EN_2 OPPOSITE
  Y = ENC X M6 < M6_EN_3 ABUT < 90 SINGULAR REGION
  Z = RECTANGLE ENCLOSURE (X NOT TOUCH Y) M6 ABUT < 90 GOOD M6_EN_3 M6_EN_3_1 OPPOSITE M6_EN_3 M6_EN_3_1 OPPOSITE
  Y OR (ENC Z M6 < M6_EN_3_1 ABUT < 90 SINGULAR REGION)
}
M6.A.1 { @ Area (M2.A.1 except SRAM (186;0) region) >= 0.027 
     AREA M6 < M6_A_1
}
M6.A.2 { @ Area [with all of edge length< 0.17 um] (This check doesn't include the patterns filling 0.07 um x 0.17 um rectangular tile) (M2.A.2 except SRAM (186;0) region) >= 0.06 
  A = AREA M6 < M6_A_2
  B = LENGTH A >= M6_A_2_L1
  C = A NOT WITH EDGE B
  NOT ENCLOSE RECTANGLE C M6_A_2_W M6_A_2_L2 ORTHOGONAL ONLY
}


VARIABLE M6_A_3pre ((M6_A_3 + (M6_S_1 * M6_S_1 * 3.142))/(2 * M6_S_1))*((M6_A_3 + (M6_S_1 * M6_S_1 * 3.142))/(2 * M6_S_1))/3.141

M6.A.3 { @ Enclosed area >= 0.2 
  X = HOLES M6 INNER < M6_A_3pre
  AREA ( X NOT M6 ) < M6_A_3
}

// M6.R.1 can not be checked


#IFDEF FULL_CHIP
CHIP_M6 = COPY CHIP
#ELSE
CHIP_M6 = CHIP INTERACT M6x
#ENDIF

#IFDEF CHECK_LOW_DENSITY
M6.DN.1 { @ Minimum local density [window ^M6_DN_1_W um x ^M6_DN_1_W um, stepping ^M6_DN_1_S um] >= ^M6_DN_1
  M6_CHECK = M6x NOT M6_EXC_LOW
  CHIP_CHECK = CHIP NOT M6_EXC_LOW
  
  ERR_WIN = DENSITY M6_CHECK CHIP_CHECK < M6_DN_1 WINDOW M6_DN_1_W STEP M6_DN_1_S INSIDE OF LAYER CHIP_M6 BACKUP 
	[ AREA(M6_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M6_EXC_LOW) >= M6_DN_1_E
  DENSITY F M6_CHECK CHIP_CHECK < M6_DN_1 WINDOW M6_DN_1_W STEP M6_DN_1_S INSIDE OF LAYER CHIP_M6 BACKUP PRINT M6.DN.1.density
         [ !AREA(F)+AREA(M6_CHECK)/AREA(CHIP_CHECK) ]
}
#ENDIF

M6.DN.1.1 { @ Maximum local density [window ^M6_DN_1_1_W um x ^M6_DN_1_1_W um, stepping ^M6_DN_1_1_S um] <= ^M6_DN_1_1
  M6_CHECK = M6x NOT M6_EXC_HIGH
  CHIP_CHECK = CHIP NOT M6_EXC_HIGH
  ERR_WIN = DENSITY M6_CHECK CHIP_CHECK > M6_DN_1_1 WINDOW M6_DN_1_1_W STEP M6_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M6_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M6_EXC_HIGH) >= M6_DN_1_1_E
  DENSITY F M6_CHECK CHIP_CHECK > M6_DN_1_1 WINDOW M6_DN_1_1_W STEP M6_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP PRINT M6.DN.1.1.density
         [ !!AREA(F)*AREA(M6_CHECK)/AREA(CHIP_CHECK) ]
}

M6.DN.4 { @ The metal density difference between any two neighboring checking windows including DM6EXCL [window ^M6_DN_4_W um x ^M6_DN_4_W um, stepping ^M6_DN_4_W um]  <= ^M6_DN_4
  DENSITY M6x CHIP <=1 WINDOW M6_DN_4_W BACKUP GRADIENT > M6_DN_4 ABSOLUTE CORNER INSIDE OF LAYER CHIPx PRINT M6.DN.4.density
  	[ AREA(M6x)/AREA(CHIP) ]    
}

#IFDEF CHECK_LOW_DENSITY
M6.DN.6 { @ Metal Desnsity >= ^M6_DN_6. All condition-A, Condition-B, and Condition-C must be followed.
@ (1) Condition-A: Metal density [window ^M6_DN_6_W_A um x ^M6_DN_6_W_A um, stepping ^M6_DN_6_S_A um] >= ^M6_DN_6
@ (2) Condition-B: Maximum area of merged low density windows [window ^M6_DN_6_W_BC um x ^M6_DN_6_W_BC um, stepping ^M6_DN_6_S_BC um < ^M6_DN_6] <= ^M6_DN_6_A_B um2, except merged low density windows width <= ^M6_DN_6_U um
@ (3) Condition-C: Maximum area of merged low density windows [window ^M6_DN_6_W_BC um x ^M6_DN_6_W_BC um, stepping ^M6_DN_6_S_BC um < ^M6_DN_6] <= ^M6_DN_6_A_C um2
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M6_DN_6_E_A um for condition-A and >= ^M6_DN_6_E_BC um for both condition-B/condition-C 
  M6_CHECK = M6x NOT NEW_DEN_EXC
  CHIP_CHECK = CHIP NOT NEW_DEN_EXC
  // Condition-A
  ERR_WIN_A = DENSITY M6_CHECK CHIP_CHECK < M6_DN_6 WINDOW M6_DN_6_W_A STEP M6_DN_6_S_A INSIDE OF LAYER CHIP_M6 BACKUP 
	[ AREA(M6_CHECK)/AREA(CHIP_CHECK) ]
  F_A = WITH WIDTH (ERR_WIN_A NOT NEW_DEN_EXC) >= M6_DN_6_E_A
  DENSITY F_A M6_CHECK CHIP_CHECK < M6_DN_6 WINDOW M6_DN_6_W_A STEP M6_DN_6_S_A INSIDE OF LAYER CHIP_M6 BACKUP PRINT M6.DN.6_A.density
         [ !AREA(F_A)+AREA(M6_CHECK)/AREA(CHIP_CHECK) ]
  // Condition-B 
  ERR_WIN_B = DENSITY M6_CHECK CHIP_CHECK < M6_DN_6 WINDOW M6_DN_6_W_BC STEP M6_DN_6_S_BC INSIDE OF LAYER CHIP_M6 BACKUP 
	[ AREA(M6_CHECK)/AREA(CHIP_CHECK) ]
  F_B = WITH WIDTH (ERR_WIN_B NOT NEW_DEN_EXC) >= M6_DN_6_E_BC
  A = DENSITY F_B M6_CHECK CHIP_CHECK < M6_DN_6 WINDOW M6_DN_6_W_BC STEP M6_DN_6_S_BC INSIDE OF LAYER CHIP_M6 BACKUP PRINT M6.DN.6_BC.density
         [ !AREA(F_B)+AREA(M6_CHECK)/AREA(CHIP_CHECK) ]
  B = AREA A > M6_DN_6_A_B
  C = SIZE B BY M6_DN_6_U/2 UNDEROVER
  B INTERACT C
  // Condition-C
  AREA B > M6_DN_6_A_C
}
#ENDIF


// Mx.DN.5
//===========
M6_CORE = M6x NOT SEALRING_EXCLUDE

Mx.DN.5:M4_M5_M6 { @ It is not allowed to have local density > 85% of all 3 consecutive metal (Mx, Mx+1 and Mx+2) over any window 62.5 um x 62.5 um (stepping 31.25 um), i.e. it is allowed for either one of Mx, Mx+1, or Mx+2 to have a local density <= 85%. 1. The metal layers include M1/Mx and dummy metals. 2. The check does not include chip corner stress relief pattern, sealring (162;2) and top2 metals at CUP area.   
    DENSITY  M4_CORE M5_CORE M6_CORE >0 WINDOW M4_DN_5_W STEP M4_DN_5_S BACKUP INSIDE OF LAYER CHIPx
  	  [ !~(AREA(M4_CORE)/AREA()- M4_DN_5)*!~(AREA(M5_CORE)/AREA()- M4_DN_5)*!~(AREA(M6_CORE)/AREA()- M4_DN_5) ]
 	  RDB Mx.DN.5:M4_M5_M6.density
}
#IFDEF CHECK_LOW_DENSITY
Mx.DN.7:M4_M5_M6 { @ It is not allowed to have local density < 5% of all 3 consecutive metal layer(M4,M5,M6) over any 30umx30um window (stepping 15um), i.e. it is allowed for either one of M4, M5, or M6 to have a local density >= 5 %.
@ 1. The metal layers include M1/Mx and dummy metals
@ 2. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 3. This rule is applied while the width of (checking window NOT above excluding region) >= 15 um    
   M4_CHECK = M4x NOT NEW_DEN_EXC
   M5_CHECK = M5x NOT NEW_DEN_EXC
   M6_CHECK = M6x NOT NEW_DEN_EXC
   CHIP_CHECK = CHIP NOT NEW_DEN_EXC
   ERR_WIN = DENSITY M4_CHECK M5_CHECK M6_CHECK CHIP_CHECK >0 WINDOW M4_DN_7_W STEP M4_DN_7_S BACKUP INSIDE OF LAYER CHIP_M6
   [ !~(M4_DN_7-AREA(M4_CHECK)/AREA(CHIP_CHECK))*!~(M4_DN_7-AREA(M5_CHECK)/AREA(CHIP_CHECK))*!~(M4_DN_7-AREA(M6_CHECK)/AREA(CHIP_CHECK)) ]
   F = WITH WIDTH (ERR_WIN NOT NEW_DEN_EXC) >= M4_DN_7_E
   DENSITY F M4_CHECK M5_CHECK M6_CHECK CHIP_CHECK >0 WINDOW M4_DN_7_W STEP M4_DN_7_S BACKUP INSIDE OF LAYER CHIP_M6
   [ !!AREA(F)*!~(M4_DN_7-AREA(M4_CHECK)/AREA(CHIP_CHECK))*!~(M4_DN_7-AREA(M5_CHECK)/AREA(CHIP_CHECK))*!~(M4_DN_7-AREA(M6_CHECK)/AREA(CHIP_CHECK)) ]
   RDB Mx.DN.7:M4_M5_M6.density
}
#ENDIF

M6.R.3 { @ Metal(pin) layers must be drawn only interact with one relative Metal(drawing) layers
   M6_PIN NOT INTERACT M6i == 1
}


//VIA6 CHECKS
//===========
#IFNDEF WIDE_ADJUST
M7Wide_2_0 = M7 WITH WIDTH > M7_S_2_W            // 0.17
M7Wide_2_1 = M7Wide_2_0 WITH WIDTH > M7_S_2_1_W  // 0.24
M7Wide_2_2 = M7Wide_2_1 WITH WIDTH > M7_S_2_2_W  // 0.31
M7Wide_2_3 = M7Wide_2_2 WITH WIDTH > M7_S_2_3_W  // 0.62
M7Wide_3_0 = M7Wide_2_3 WITH WIDTH > M7_S_3_W    // 1.65
#ELSE
M7Wide_2_4 = M7 WITH WIDTH > M7_S_2_4_W          // 0.17
M7Wide_2_0 = M7Wide_2_4 WITH WIDTH > M7_S_2_W    // 0.19
M7Wide_2_5 = M7Wide_2_0 WITH WIDTH > M7_S_2_5_W  // 0.24
M7Wide_2_1 = M7Wide_2_5 WITH WIDTH > M7_S_2_1_W  // 0.265
M7Wide_2_6 = M7Wide_2_1 WITH WIDTH > M7_S_2_6_W  // 0.31
M7Wide_2_2 = M7Wide_2_6 WITH WIDTH > M7_S_2_2_W  // 0.345
M7Wide_2_7 = M7Wide_2_2 WITH WIDTH > M7_S_2_7_W  // 0.62
M7Wide_2_3 = M7Wide_2_7 WITH WIDTH > M7_S_2_3_W  // 0.685
M7Wide_3_0 = M7Wide_2_3 WITH WIDTH > M7_S_3_W    // 1.65
#ENDIF

M6Wide_R2_VIA6 = M6Wide_2_0 WITH WIDTH > VIA6_R_2_W        // 0.21
M6Wide_R4_VIA6 = M6Wide_R2_VIA6 WITH WIDTH > VIA6_R_4_W    // 0.21
M6Wide_R3_VIA6 = M6Wide_R4_VIA6 WITH WIDTH > VIA6_R_3_W    // 0.55
M6Wide_R5_VIA6 = M6Wide_R3_VIA6 WITH WIDTH > VIA6_R_5_W    // 1.4
M6Wide_R6_VIA6 = M6Wide_R5_VIA6 WITH WIDTH > VIA6_R_6_W    // 2.1
M7Wide_R2_VIA6 = M7Wide_2_0 WITH WIDTH > VIA6_R_2_W      // 0.21
M7Wide_R4_VIA6 = M7Wide_R2_VIA6 WITH WIDTH > VIA6_R_4_W  // 0.21
M7Wide_R3_VIA6 = M7Wide_R4_VIA6 WITH WIDTH > VIA6_R_3_W  // 0.55
M7Wide_R5_VIA6 = M7Wide_R3_VIA6 WITH WIDTH > VIA6_R_5_W  // 1.4
M7Wide_R6_VIA6 = M7Wide_R5_VIA6 WITH WIDTH > VIA6_R_6_W  // 2.1

VIA6.W.1 { @ Width (maximum = minimum) (Except sealring (162,2) and {VIAx bar INSIDE {LOWMEDN NOT (LOWMEDN SIZING -4 um)}} region) = 0.07 
   NOT RECTANGLE (VIA6i NOT (SEALRING_EXCLUDE OR P_RING_REGION)) == VIA6_W_1 BY == VIA6_W_1 ORTHOGONAL ONLY
}
VIA6.S.1 { @ Space >= 0.07 
  EXT VIA6i < VIA6_S_1 ABUT < 90 SINGULAR REGION
}
VIA6.S.1.1 { @ Space [any one of VIAx connect to > 3.3V and <= 5V different net] >= ^VIA6_S_1_1
  J = STAMP (VIA6i AND M6_5V_ALL) BY M6i
  EXT J VIA6i < VIA6_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}
VIA6.S.2 { @ Space to 3-neighboring VIAx (distance < 0.098 um) >= 0.09 
  X = WITH NEIGHBOR VIA6i > 2 SPACE < VIA6_S_2_D
  EXT X VIA6i < VIA6_S_2 ABUT < 90 SINGULAR REGION
}
VIA6.S.3 { @ Space to neighboring VIAx [different net] >= 0.095 
  EXT VIA6i < VIA6_S_3 ABUT < 90 NOT CONNECTED REGION
}
VIA6.S.3.1 { @ Space to neighboring VIAx [different net and common parallel run length > 0 um] >= 0.11 
  EXT VIA6i < VIA6_S_3_1 ABUT < 90 NOT CONNECTED OPPOSITE REGION
}

// VIA6.EN.0 is checked by VIA6.EN.1, and VIA6.EN.2_VIA6.EN.4_VIA6.EN.4.1

VIA6.EN.1 { @ Enclosure by Mx or M1 >= 0.00 
  VIA6 NOT M6
}

VIA6.EN.2__VIA6.EN.4__VIA6.EN.4.1 { @ Enclosure by M6 [at least two opposite sides] >= ^VIA6_EN_2, or [four sides] >= ^VIA6_EN_4 with [at least two opposite sides] >= ^VIA6_EN_4_1
  X = RECTANGLE ENCLOSURE (VIA6 NOT SEALRING_EXCLUDE) M6 ABUT < 90 SINGULAR GOOD 0 VIA6_EN_2 OPPOSITE 0 VIA6_EN_2 OPPOSITE
  Y = ENC X M6 < VIA6_EN_4 ABUT < 90 SINGULAR REGION
  Z = RECTANGLE ENCLOSURE (X NOT TOUCH Y) M6 ABUT < 90 GOOD VIA6_EN_4 VIA6_EN_4_1 OPPOSITE VIA6_EN_4 VIA6_EN_4_1 OPPOSITE
  Y OR (ENC Z M6 < VIA6_EN_4_1 ABUT < 90 SINGULAR REGION)

}



// VIA6.R.1 is checked by VIA6.W.1
VIA6.R.2__VIA6.R.3 { @ When M6 or M7 width > ^VIA6_R_2_W um, more than one VIA6 is required.
                    @ 2 vias spacing should be <= ^VIA6_R_2_S1 um or 4 vias spacing should be <= ^VIA6_R_2_S2 um
                    @ When M6 or M7 width > ^VIA6_R_3_W um, more than three VIA6 is required.
                    @ 4 vias spacing should be <= ^VIA6_R_3_S1 um or 9 vias spacing should be <= ^VIA6_R_3_S2 um
                    @ not check SRAM region					
   M7OvpM6_W_ = (M6Wide_R2_VIA6 AND M7) OR (M7Wide_R2_VIA6 AND M6)
   M7OvpM6_B  = (M6Wide_R3_VIA6 AND M7) OR (M7Wide_R3_VIA6 AND M6)
   M7OvpM6_W  = M7OvpM6_W_ NOT M7OvpM6_B 
   Checked_VIA6_W_ = VIA6_EXD NOT OUTSIDE M7OvpM6_W
   Checked_VIA6_B  = VIA6_EXD NOT OUTSIDE M7OvpM6_B
   Checked_VIA6_W  = Checked_VIA6_W_ NOT Checked_VIA6_B
   M6_effect = M6i INTERACT M7OvpM6_W_
   M7_effect = M7i INTERACT M7OvpM6_W_
   effect_M7OvpM6_ = M6_effect AND M7_effect
   effect_M7OvpM6 = effect_M7OvpM6_ INTERACT M7OvpM6_W_
   effect_VIA = VIA6_EXD INTERACT effect_M7OvpM6

   V6Merged_A = SIZE effect_VIA BY VIA6_R_2_S1/2 INSIDE OF effect_M7OvpM6 STEP M6_S_1*0.7
   V6Merged_B = SIZE V6Merged_A BY (VIA6_R_2_S2 - VIA6_R_2_S1)/2 INSIDE OF effect_M7OvpM6 STEP M6_S_1*0.7
   V6Merged_C = SIZE V6Merged_B BY (VIA6_R_3_S2 - VIA6_R_2_S2)/2 INSIDE OF effect_M7OvpM6 STEP M6_S_1*0.7
   V6Merged_A2R = V6Merged_A INTERACT effect_VIA < 2
   V6Merged_A2 = V6Merged_A OUTSIDE V6Merged_A2R
   V6Merged_A4R = V6Merged_A2 INTERACT effect_VIA < 4
   V6Merged_A4 = V6Merged_A2 OUTSIDE V6Merged_A4R
   V6Merged_B4R = V6Merged_B INTERACT effect_VIA < 4
   V6Merged_B4 = V6Merged_B OUTSIDE V6Merged_B4R
   V6Merged_C9R = V6Merged_C INTERACT effect_VIA < 9
   V6Merged_C9 = V6Merged_C OUTSIDE V6Merged_C9R

   GMergeW = V6Merged_A2 OR V6Merged_B4
   GMergeB = V6Merged_A4 OR V6Merged_C9
   GVIA_W = Checked_VIA6_W INTERACT GMergeW
   GVIA_B = Checked_VIA6_B INTERACT GMergeB
   GOOD_AREA_W = M7OvpM6_W INTERACT GVIA_W
   GOOD_AREA_B = M7OvpM6_B INTERACT GVIA_B
   Checked_VIA6_W OUTSIDE GOOD_AREA_W
   Checked_VIA6_B OUTSIDE GOOD_AREA_B
}

VIA6.R.4.M6 { @ At least two VIAx must be used for a connection that is <= ^VIA6_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA6_R_4_W um (L) and width > ^VIA6_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA6_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA6_R_4_W um (L) and width > ^VIA6_R_4_W um (W).)   
  Branch1 = ((SIZE M6Wide_R4_VIA6 BY VIA6_R_4_D + GRID) NOT M6Wide_R4_VIA6) AND M6
  Branch1HasVia = (Branch1 INTERACT M6Wide_R4_VIA6) INTERACT VIA6_EXD
  Branch1Edge = M6Wide_R4_VIA6 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA6_R_4_D INSIDE OF Branch1HasVia STEP M6_S_1*0.5
  GoodBranch = (Branch AND M7) INTERACT VIA6_EXD > 1
  BranchSingleVia = (VIA6_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M7 INTERACT BranchSingleVia) AND M6) INTERACT BranchSingleVia) INTERACT VIA6_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA6.R.4.M7 { @ At least two VIAx must be used for a connection that is <= ^VIA6_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA6_R_4_W um (L) and width > ^VIA6_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA6_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA6_R_4_W um (L) and width > ^VIA6_R_4_W um (W)).   
  Branch1 = ((SIZE M7Wide_R4_VIA6 BY VIA6_R_4_D + GRID) NOT M7Wide_R4_VIA6) AND M7
  Branch1HasVia = (Branch1 INTERACT M7Wide_R4_VIA6) INTERACT VIA6_EXD
  Branch1Edge = M7Wide_R4_VIA6 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA6_R_4_D INSIDE OF Branch1HasVia STEP M7_S_1*0.5
  GoodBranch = (Branch AND M6) INTERACT VIA6_EXD > 1
  BranchSingleVia = (VIA6_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M6 INTERACT BranchSingleVia) AND M7) INTERACT BranchSingleVia) INTERACT VIA6_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA6.R.5.M6 { @ At least two VIAx must be used for a connection that is <= ^VIA6_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA6_R_5_W um (L) and width > ^VIA6_R_5_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA6_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA6_R_5_W um (L) and width > ^VIA6_R_5_W um (W)).
  Branch1 = ((SIZE M6Wide_R5_VIA6 BY VIA6_R_5_D + GRID) NOT M6Wide_R5_VIA6) AND M6
  Branch1HasVia = (Branch1 INTERACT M6Wide_R5_VIA6) INTERACT VIA6_EXD
  Branch1Edge = M6Wide_R5_VIA6 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA6_R_5_D INSIDE OF Branch1HasVia STEP M6_S_1*0.7
  GoodBranch = (Branch AND M7) INTERACT VIA6_EXD > 1
  BranchSingleVia = (VIA6_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M7 INTERACT BranchSingleVia) AND M6) INTERACT BranchSingleVia) INTERACT VIA6_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA6.R.5.M7 { @ At least two VIAx must be used for a connection that is <= ^VIA6_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA6_R_5_W um (L) and width > ^VIA6_R_5_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA6_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA6_R_5_W um (L) and width > ^VIA6_R_5_W um (W)).
  Branch1 = ((SIZE M7Wide_R5_VIA6 BY VIA6_R_5_D + GRID) NOT M7Wide_R5_VIA6) AND M7
  Branch1HasVia = (Branch1 INTERACT M7Wide_R5_VIA6) INTERACT VIA6_EXD
  Branch1Edge = M7Wide_R5_VIA6 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA6_R_5_D INSIDE OF Branch1HasVia STEP M7_S_1*0.7
  GoodBranch = (Branch AND M6) INTERACT VIA6_EXD > 1
  BranchSingleVia = (VIA6_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M6 INTERACT BranchSingleVia) AND M7) INTERACT BranchSingleVia) INTERACT VIA6_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M6Big_R6_VIA6 = ENCLOSE RECTANGLE M6Wide_R6_VIA6 VIA6_R_6_W VIA6_R_6_L+GRID

VIA6.R.6.M6 { @ At least two VIAx must be used for a connection that is <= ^VIA6_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA6_R_6_L um (L) and width > ^VIA6_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA6_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA6_R_6_L um (L) and width > ^VIA6_R_6_W um (W)).
  Branch1 = ((SIZE M6Big_R6_VIA6 BY VIA6_R_6_D + GRID) NOT M6Big_R6_VIA6) AND M6
  Branch1HasVia = (Branch1 INTERACT M6Big_R6_VIA6) INTERACT VIA6_EXD
  Branch1Edge = M6Big_R6_VIA6 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA6_R_6_D INSIDE OF Branch1HasVia STEP M6_S_1*0.7
  GoodBranch = (Branch AND M7) INTERACT VIA6_EXD > 1
  BranchSingleVia = (VIA6_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M7 INTERACT BranchSingleVia) AND M6) INTERACT BranchSingleVia) INTERACT VIA6_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M7Big_R6_VIA6 = ENCLOSE RECTANGLE M7Wide_R6_VIA6 VIA6_R_6_W VIA6_R_6_L+GRID

VIA6.R.6.M7 { @ At least two VIAx must be used for a connection that is <= ^VIA6_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA6_R_6_L um (L) and width > ^VIA6_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA6_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA6_R_6_L um (L) and width > ^VIA6_R_6_W um (W)).
  Branch1 = ((SIZE M7Big_R6_VIA6 BY VIA6_R_6_D + GRID) NOT M7Big_R6_VIA6) AND M7
  Branch1HasVia = (Branch1 INTERACT M7Big_R6_VIA6) INTERACT VIA6_EXD
  Branch1Edge = M7Big_R6_VIA6 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA6_R_6_D INSIDE OF Branch1HasVia STEP M7_S_1*0.7
  GoodBranch = (Branch AND M6) INTERACT VIA6_EXD > 1
  BranchSingleVia = (VIA6_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M6 INTERACT BranchSingleVia) AND M7) INTERACT BranchSingleVia) INTERACT VIA6_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}
// VIA6.R.7 is checked by VIA6.EN.1
// VIA6.R.9 can't be checked

VIA6.R.11 { @ Single VIAx is not allowed for H-shape Mx+1 when all of the following conditions come into existence: 1. The Mx+1 has H-shape interact with two metal holes: two metal hole length(L2) <= ^VIA6_R_11_L1 um and both two metal hole area <= ^VIA6_R_11_A um2 2. The VIAx overlaps on the center metal bar of this H-shape Mx+1 3. The length (L) of the center metal bar <= ^VIA6_R_11_L2 um and the width of metal bar is <= ^VIA6_R_11_W um.
  W = M7i WITH WIDTH <= VIA6_R_11_W   
  H_HOLE = HOLES M7i INNER <= VIA6_R_11_A
  A = M7i COIN OUTSIDE EDGE H_HOLE
  B0 = ((INT A <= VIA6_R_11_W ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE M7i) INTERACT H_HOLE == 2 
  B1 = (((INT A <= VIA6_R_11_L2 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE M7i) AND W) INTERACT H_HOLE == 2
  HOLE_NOTCH = EXT H_HOLE <= VIA6_R_11_W ABUT<90 OPPOSITE NOTCH REGION  
  B2 = (B1 NOT HOLE_NOTCH) OR B0
  CORNER_M = ((EXT B2 <= VIA6_R_11_W ABUT == 90 INTERSECTING ONLY REGION EXTENTS) TOUCH B2 == 2) AND W
  B = B2 OR CORNER_M
  CENTER_BAR1 = NOT ENCLOSE RECTANGLE B GRID VIA6_R_11_L2+GRID
  CENTER_BAR2 = CENTER_BAR1 INTERACT H_HOLE == 2
  C = CENTER_BAR2 COIN OUTSIDE EDGE H_HOLE 
  D = EXT [C] M7i <= VIA6_R_11_L1 OPPOSITE
  E = C NOT COIN INSIDE EDGE D
  CENTER_BAR3 = CENTER_BAR2 NOT WITH EDGE E
  CHECK_VIA = VIA6 NOT OUTSIDE CENTER_BAR3
  CHECK_VIA AND (((M7i INTERACT CHECK_VIA) AND (M6i INTERACT CHECK_VIA)) INTERACT VIA6i == 1)
}

VIA6.R.12 { @ VIA6 connected to DM6, DM6_O, DM7, DM7_O is not allowed
  VIA6 INTERACT DUM6
  VIA6 INTERACT DUM7
  VIA6 INTERACT DM6_O
  VIA6 INTERACT DM7_O
}  

//M7 CHECKS
//=========


M7_EDGE_45 = M7 ANGLE == 45

M7.W.1 { @ Width >= 0.07 
  INT M7 < M7_W_1 ABUT < 90 SINGULAR REGION
}
M7.W.2 { @ Width of 45-degree bent Mx. (Please make sure the vertex of 45 degree pattern is on 0.005 um grid (refer to the guideline, G.6gU, in section 3.7)) >= 0.17 
  INT M7_EDGE_45 < M7_W_2 ABUT < 90 REGION
}
M7.W.3 { @ Maximum width <= ^M7_W_3 um, exclude sealring 
  M7_MAX_WIDTH WITH WIDTH > M7_W_3
}

M7.S.1 { @ Space >= 0.07 
  EXT M7 < M7_S_1 ABUT < 90 SINGULAR REGION
}
M7.S.2 { @ Min. Metal space (for W> ^M7_S_2_W um & parallel length > ^M7_S_2_L um) >= ^M7_S_2 um
  X = EXT M7Wide_2_0 M7 < M7_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M7
  ENCLOSE RECTANGLE Y GRID M7_S_2_L+GRID
}
M7.S.2.1 { @ Min. Metal space (for W> ^M7_S_2_1_W um & parallel length > ^M7_S_2_1_L um) >= ^M7_S_2_1 um
  X = EXT M7Wide_2_1 M7 < M7_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M7
  ENCLOSE RECTANGLE Y GRID M7_S_2_1_L+GRID
}
M7.S.2.2 { @ Min. Metal space (for W> ^M7_S_2_2_W um & parallel length > ^M7_S_2_2_L um) >= ^M7_S_2_2 um
  X = EXT M7Wide_2_2 M7 < M7_S_2_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M7
  ENCLOSE RECTANGLE Y GRID M7_S_2_2_L+GRID
}
M7.S.2.3 { @ Min. Metal space (for W> ^M7_S_2_3_W um & parallel length > ^M7_S_2_3_L um) >= ^M7_S_2_3 um
  X = EXT M7Wide_2_3 M7 < M7_S_2_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M7
  ENCLOSE RECTANGLE Y GRID M7_S_2_3_L+GRID
}
#IFDEF WIDE_ADJUST
M7.S.2.4 { @ Min. Metal space (for W> ^M7_S_2_4_W um & parallel length > ^M7_S_2_4_L um) >= ^M7_S_2_4 um
  X = EXT M7Wide_2_4 M7 < M7_S_2_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M7
  ENCLOSE RECTANGLE Y GRID M7_S_2_4_L+GRID
}
M7.S.2.5 { @ Min. Metal space (for W> ^M7_S_2_5_W um & parallel length > ^M7_S_2_5_L um) >= ^M7_S_2_5 um
  X = EXT M7Wide_2_5 M7 < M7_S_2_5 OPPOSITE REGION MEASURE ALL
  Y = X NOT M7
  ENCLOSE RECTANGLE Y GRID M7_S_2_5_L+GRID
}
M7.S.2.6 { @ Min. Metal space (for W> ^M7_S_2_6_W um & parallel length > ^M7_S_2_6_L um) >= ^M7_S_2_6 um
  X = EXT M7Wide_2_6 M7 < M7_S_2_6 OPPOSITE REGION MEASURE ALL
  Y = X NOT M7
  ENCLOSE RECTANGLE Y GRID M7_S_2_6_L+GRID
}
M7.S.2.7 { @ Min. Metal space (for W> ^M7_S_2_7_W um & parallel length > ^M7_S_2_7_L um) >= ^M7_S_2_7 um
  X = EXT M7Wide_2_7 M7 < M7_S_2_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M7
  ENCLOSE RECTANGLE Y GRID M7_S_2_7_L+GRID
}
#ENDIF
M7.S.3 { @ Min. Metal space (for W> ^M7_S_3_W um & parallel length > ^M7_S_3_L um) >= ^M7_S_3 um
  X = EXT M7Wide_3_0 M7 < M7_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M7
  (ENCLOSE RECTANGLE Y 0.001 M7_S_3_L+0.001) NOT INSIDE IND_REGION
}
M7.S.5 { @ Space at Mx line-end (W < 0.10 um (Q)) in a dense-line-end configuration: If Mx has parallel run length with opposite Mx (measured with T = 0.035 um extension) along 2 adjacent edges of Mx [any one edge <Q distance from the corner of the two edges], then one of the space (S1 or S2) needs to be at least this value (This check doesn't include small jog with edge length < 0.07 um(R)) (M2.S.5 except SRAM (186;0) region) >= 0.10 
  A = CONVEX EDGE M7 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M7_S_5_W
  B = EXT [A] M7 < M7_S_5 ABUT < 90 OPPOSITE EXTENDED M7_S_5_T
  C = A TOUCH INSIDE EDGE B
  D = INT C [M7] < M7_S_5_W ABUT == 90 INTERSECTING ONLY
  I = LENGTH D >= M7_W_1
  J = EXPAND EDGE I INSIDE BY 0.001 EXTEND BY M7_S_5_T
  K = EXPAND EDGE I INSIDE BY 0.001 
  L = J NOT K
  M = L WITH EDGE A 
  N = M OR K
  O = N TOUCH EDGE I
  EXT O M7 < M7_S_5 ABUT < 90 OPPOSITE REGION

}

M7.S.5.1 { @ Space at Mx line-end (W<Q=^M7_S_5_1_W) in a dense-line-end configuration.If Mx has parallel run length with opposite Mx (measured with ^M7_S_5_1_T (T) extension) along two adjacent edges of Mx [any one edge < ^M7_S_5_1_W (W) from the corner of the two edges of Mx], and Mx enclosure of VIAx-1 < ^M7_S_5_1_E at line-end, then one of the space (S1 or S2) must be >= ^M7_S_5_1 um.
  A = CONVEX EDGE M7 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M7_S_5_1_W
  V6_EN = ENC [VIA6i] A < M7_S_5_1_E ABUT < 90 OPPOSITE
  M7_EN = ENC V6_EN [A] < M7_S_5_1_E ABUT < 90 OPPOSITE
  M7_SA = EXT A [M7] < M7_S_5_1 ABUT < 90 OPPOSITE EXTENDED M7_S_5_1_T
  M7_SB = EXT [A] M7_SA < M7_S_5_1 ABUT < 90 OPPOSITE EXTENDED M7_S_5_1_T
  M7_END = (A TOUCH INSIDE EDGE M7_EN) TOUCH INSIDE EDGE M7_SB
  EN_B = ENC V6_EN [M7_END] < M7_S_5_1_E2 OPPOSITE
  EN_C = ENC V6_EN [M7_END] < M7_S_5_1_E3 OPPOSITE
  EN_D = ENC V6_EN [M7_END] < M7_S_5_1_E4 OPPOSITE
  S1_B = EXT [M7_END] M7_SA < M7_S_5_1_S2 OPPOSITE EXTENDED M7_S_5_1_T
  S1_C = EXT [M7_END] M7_SA < M7_S_5_1_S3 OPPOSITE EXTENDED M7_S_5_1_T
  S1_D = EXT [M7_END] M7_SA < M7_S_5_1_S4 OPPOSITE EXTENDED M7_S_5_1_T
  PASS_B = (M7_END NOT TOUCH INSIDE EDGE EN_B) NOT TOUCH INSIDE EDGE S1_B
  PASS_C = (M7_END NOT TOUCH INSIDE EDGE EN_C) NOT TOUCH INSIDE EDGE S1_C
  PASS_D = (M7_END NOT TOUCH INSIDE EDGE EN_D) NOT TOUCH INSIDE EDGE S1_D
  M7_CHECK = ((M7_END NOT TOUCH INSIDE EDGE PASS_B) NOT TOUCH INSIDE EDGE PASS_C) NOT TOUCH INSIDE EDGE PASS_D
  H = INT M7_CHECK [M7] < M7_S_5_1_W ABUT == 90 INTERSECTING ONLY
  I = LENGTH H >= M7_W_1
  J = EXPAND EDGE I INSIDE BY GRID EXTEND BY M7_S_5_1_T
  K = EXPAND EDGE I INSIDE BY GRID
  L = J NOT K
  M = L WITH EDGE A 
  N = M OR K
  O = N TOUCH INSIDE EDGE I
  P = EXT [O] M7 < M7_S_5_1 ABUT < 90 OPPOSITE
  Q = ENC VIA6i (O TOUCH INSIDE EDGE P) < M7_S_5_1_E ABUT < 90 OPPOSITE REGION
  VIA_BAD1 = VIA6i INTERACT Q
  VIA_GOOD = VIA6i NOT VIA_BAD1
  VIA_BAD2 = VIA_BAD1 NOT INTERACT ((M7 AND M6) INTERACT VIA_GOOD)
  ENC VIA_BAD2 M7_CHECK < M7_S_5_1_E ABUT < 90 OPPOSITE REGION
}

M7.S.6 { @ Space to 45-degree bent Mx >= 0.17 
  X = EXPAND EDGE M7_EDGE_45 OUTSIDE BY M7_S_6
  X AND M7
}


M7_HVN_5V = NET AREA RATIO M7i OVER M10_HV_5V M9_HV_5V M8_HV_5V M7_HV_5V M6_HV_5V M5_HV_5V M4_HV_5V M3_HV_5V M2_HV_5V M1_HV_5V > 0 
M7_HVN = NET AREA RATIO M7i OVER M10_HV M9_HV M8_HV M7_HV M6_HV M5_HV M4_HV M3_HV M2_HV M1_HV > 0 
M7_MVN = NET AREA RATIO M7i OVER M10_MV M9_MV M8_MV M7_MV M6_MV M5_MV M4_MV M3_MV M2_MV M1_MV > 0
M7_LVN = NET AREA RATIO M7i OVER M10_LV M9_LV M8_LV M7_LV M6_LV M5_LV M4_LV M3_LV M2_LV M1_LV > 0

M7_NOMARK = (((M7i NOT M7_HVN_5V) NOT M7_HVN) NOT M7_MVN) NOT M7_LVN

#IFDEF Mx_S_8_IO_NET
  M7_NOMARK_5V = NET AREA RATIO M7_NOMARK PSD_HVD NSD_HVD S_HVD_GATE PSTPi > 0 
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD)+!!AREA(S_HVD_GATE))*!AREA(PSTPi)]
  M7_NOMARK_HV = NET AREA RATIO M7_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPi > 0 
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPi)]
  M7_NOMARK_MV = NET AREA RATIO M7_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPi > 0 
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPi)]
#ELSE  
  M7_NOMARK_5V = NET AREA RATIO M7_NOMARK PSD_HVD NSD_HVD S_HVD_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD)+!!AREA(S_HVD_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M7_NOMARK_HV = NET AREA RATIO M7_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M7_NOMARK_MV = NET AREA RATIO M7_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)] 
#ENDIF 

M7_5V_ALL = M7_HVN_5V OR M7_NOMARK_5V  
M7_HV_ALL = M7_HVN OR M7_NOMARK_HV
M7_MV_ALL = M7_MVN OR M7_NOMARK_MV

M7.S.1.1 { @ Space [any one of Mx connect to > 3.3V and <= 5V net] >= ^M7_S_1_1
  I = STAMP M7_5V_ALL BY M7i
  EXT I M7i < M7_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}
M7.S.8.2 { @ Space to neighboring {VIAx-1 or VIAx} [either VIAx-1, VIAx or Mx connects to > 3.3V and <= 5V net] >= ^M7_S_8_2
  I = STAMP M7_5V_ALL BY M7i
  J = STAMP (VIA6i AND M7_5V_ALL) BY M7i
  EXT I VIA6i < M7_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M7i < M7_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA7i AND M7_5V_ALL) BY M7i
  EXT I VIA7i < M7_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M7i < M7_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}
M7.S.8 { @ Space to {VIAx-1 OR VIAx} [different net, any one of VIAx-1, VIAx or Mx connects to 1.8V ~ 3.3V net] 0.1  
  I = STAMP M7_HV_ALL BY M7i
  J = STAMP (VIA6i AND M7_HV_ALL) BY M7i
  EXT I VIA6i < M7_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M7i < M7_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA7i AND M7_HV_ALL) BY M7i
  EXT I VIA7i < M7_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M7i < M7_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}
M7.S.8.1 { @ Space to {VIAx-1 OR VIAx} [different net, any one of VIAx-1, VIAx or Mx connects to >= 1.5V and < 1.8V net] 0.08  
  I = STAMP M7_MV_ALL BY M7i
  J = STAMP (VIA6i AND M7_MV_ALL) BY M7i
  EXT I VIA6i < M7_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M7i < M7_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA7i AND M7_MV_ALL) BY M7i
  EXT I VIA7i < M7_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M7i < M7_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}

M7.S.9 { @ This rule is to check Metal (A) space to neighboring VIAx [either VIAx or Mx connects to >3.3V and <= 5V net]. DRC methodology to find Metal (A) Find a edge (B) of metal line end [edge length <= 0.12um] Run length (C) from edge (B) inside metal >= 0.13um Jog length (D) <= 0.01um within 0.13um run length Extend 0.06um outside from edge (B) to form a polygon metal (A) Metal (A) is defined if conditions 1~4 are all satisfied. >= 0.15 
  LINE_END_pre   = CONVEX EDGE M7 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= M7_S_9_B
  LINE_END_pre1  = EXPAND EDGE LINE_END_pre INSIDE BY GRID EXTEND BY -M7_S_9_D    
  LINE_END_pre2  = LINE_END_pre COIN INSIDE EDGE LINE_END_pre1  
  LINE_END_pre3  = INT [LINE_END_pre2] M7 < M7_S_9_C OPPOSITE 
  LINE_END_pre4  = LINE_END_pre NOT TOUCH INSIDE EDGE LINE_END_pre3
  LINE_END_pre5  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M7_S_9_D+GRID
  LINE_END_pre6  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M7_S_9_D
  LINE_END_pre7  = LINE_END_pre5 NOT LINE_END_pre6
  LINE_END_pre8  = LINE_END_pre5 TOUCH OUTSIDE EDGE LINE_END_pre4
  LINE_END_pre9  = LINE_END_pre8 COIN INSIDE EDGE LINE_END_pre7 
  LINE_END_pre10 = EXT [LINE_END_pre9] M7 < M7_S_9_C OPPOSITE
  LINE_END = LINE_END_pre4 NOT TOUCH OUTSIDE EDGE (LINE_END_pre8 TOUCH INSIDE EDGE LINE_END_pre10)
  A = EXPAND EDGE LINE_END OUTSIDE BY M7_S_9_A INSIDE BY GRID
  B = STAMP A BY M7i
  I = STAMP (A INTERACT M7_5V_ALL) BY M7i
  J = STAMP (VIA6i AND M7_5V_ALL) BY M7i
  K = STAMP (VIA7i AND M7_5V_ALL) BY M7i
  X1 = EXT I VIA6i < M7_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X2 = EXT I VIA7i  < M7_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X3 = EXT J B < M7_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X4 = EXT K B < M7_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  Y = ((X1 OR X2) OR X3) OR X4   
  COPY Y
  A INTERACT Y
}

// M7.EN.0 is checked by M7.EN.1, and M7.EN.2_M7.EN.3_M7.EN.3.1

M7.EN.1 { @ Enclosure of VIAx-1 >= 0.00 
  VIA6 NOT M7
}
M7.EN.2__M7.EN.3__M7.EN.3.1 { @ Enclosure of VIAx-1 [at least two opposite sides] >= ^M7_EN_2, or [four sides] >= ^M7_EN_3 with [at least two opposite sides] >= ^M7_EN_3_1
  X = RECTANGLE ENCLOSURE (VIA6 NOT SEALRING_ALL) M7 ABUT < 90 SINGULAR GOOD 0 M7_EN_2 OPPOSITE 0 M7_EN_2 OPPOSITE
  Y = ENC X M7 < M7_EN_3 ABUT < 90 SINGULAR REGION
  Z = RECTANGLE ENCLOSURE (X NOT TOUCH Y) M7 ABUT < 90 GOOD M7_EN_3 M7_EN_3_1 OPPOSITE M7_EN_3 M7_EN_3_1 OPPOSITE
  Y OR (ENC Z M7 < M7_EN_3_1 ABUT < 90 SINGULAR REGION)
}
M7.A.1 { @ Area (M2.A.1 except SRAM (186;0) region) >= 0.027 
     AREA M7 < M7_A_1
}
M7.A.2 { @ Area [with all of edge length< 0.17 um] (This check doesn't include the patterns filling 0.07 um x 0.17 um rectangular tile) (M2.A.2 except SRAM (186;0) region) >= 0.06 
  A = AREA M7 < M7_A_2
  B = LENGTH A >= M7_A_2_L1
  C = A NOT WITH EDGE B
  NOT ENCLOSE RECTANGLE C M7_A_2_W M7_A_2_L2 ORTHOGONAL ONLY
}


VARIABLE M7_A_3pre ((M7_A_3 + (M7_S_1 * M7_S_1 * 3.142))/(2 * M7_S_1))*((M7_A_3 + (M7_S_1 * M7_S_1 * 3.142))/(2 * M7_S_1))/3.141

M7.A.3 { @ Enclosed area >= 0.2 
  X = HOLES M7 INNER < M7_A_3pre
  AREA ( X NOT M7 ) < M7_A_3
}

// M7.R.1 can not be checked


#IFDEF FULL_CHIP
CHIP_M7 = COPY CHIP
#ELSE
CHIP_M7 = CHIP INTERACT M7x
#ENDIF

#IFDEF CHECK_LOW_DENSITY
M7.DN.1 { @ Minimum local density [window ^M7_DN_1_W um x ^M7_DN_1_W um, stepping ^M7_DN_1_S um] >= ^M7_DN_1
  M7_CHECK = M7x NOT M7_EXC_LOW
  CHIP_CHECK = CHIP NOT M7_EXC_LOW
  
  ERR_WIN = DENSITY M7_CHECK CHIP_CHECK < M7_DN_1 WINDOW M7_DN_1_W STEP M7_DN_1_S INSIDE OF LAYER CHIP_M7 BACKUP 
	[ AREA(M7_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M7_EXC_LOW) >= M7_DN_1_E
  DENSITY F M7_CHECK CHIP_CHECK < M7_DN_1 WINDOW M7_DN_1_W STEP M7_DN_1_S INSIDE OF LAYER CHIP_M7 BACKUP PRINT M7.DN.1.density
         [ !AREA(F)+AREA(M7_CHECK)/AREA(CHIP_CHECK) ]
}
#ENDIF

M7.DN.1.1 { @ Maximum local density [window ^M7_DN_1_1_W um x ^M7_DN_1_1_W um, stepping ^M7_DN_1_1_S um] <= ^M7_DN_1_1
  M7_CHECK = M7x NOT M7_EXC_HIGH
  CHIP_CHECK = CHIP NOT M7_EXC_HIGH
  ERR_WIN = DENSITY M7_CHECK CHIP_CHECK > M7_DN_1_1 WINDOW M7_DN_1_1_W STEP M7_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M7_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M7_EXC_HIGH) >= M7_DN_1_1_E
  DENSITY F M7_CHECK CHIP_CHECK > M7_DN_1_1 WINDOW M7_DN_1_1_W STEP M7_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP PRINT M7.DN.1.1.density
         [ !!AREA(F)*AREA(M7_CHECK)/AREA(CHIP_CHECK) ]
}

M7.DN.4 { @ The metal density difference between any two neighboring checking windows including DM7EXCL [window ^M7_DN_4_W um x ^M7_DN_4_W um, stepping ^M7_DN_4_W um]  <= ^M7_DN_4
  DENSITY M7x CHIP <=1 WINDOW M7_DN_4_W BACKUP GRADIENT > M7_DN_4 ABSOLUTE CORNER INSIDE OF LAYER CHIPx PRINT M7.DN.4.density
  	[ AREA(M7x)/AREA(CHIP) ]    
}

#IFDEF CHECK_LOW_DENSITY
M7.DN.6 { @ Metal Desnsity >= ^M7_DN_6. All condition-A, Condition-B, and Condition-C must be followed.
@ (1) Condition-A: Metal density [window ^M7_DN_6_W_A um x ^M7_DN_6_W_A um, stepping ^M7_DN_6_S_A um] >= ^M7_DN_6
@ (2) Condition-B: Maximum area of merged low density windows [window ^M7_DN_6_W_BC um x ^M7_DN_6_W_BC um, stepping ^M7_DN_6_S_BC um < ^M7_DN_6] <= ^M7_DN_6_A_B um2, except merged low density windows width <= ^M7_DN_6_U um
@ (3) Condition-C: Maximum area of merged low density windows [window ^M7_DN_6_W_BC um x ^M7_DN_6_W_BC um, stepping ^M7_DN_6_S_BC um < ^M7_DN_6] <= ^M7_DN_6_A_C um2
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M7_DN_6_E_A um for condition-A and >= ^M7_DN_6_E_BC um for both condition-B/condition-C 
  M7_CHECK = M7x NOT NEW_DEN_EXC
  CHIP_CHECK = CHIP NOT NEW_DEN_EXC
  // Condition-A
  ERR_WIN_A = DENSITY M7_CHECK CHIP_CHECK < M7_DN_6 WINDOW M7_DN_6_W_A STEP M7_DN_6_S_A INSIDE OF LAYER CHIP_M7 BACKUP 
	[ AREA(M7_CHECK)/AREA(CHIP_CHECK) ]
  F_A = WITH WIDTH (ERR_WIN_A NOT NEW_DEN_EXC) >= M7_DN_6_E_A
  DENSITY F_A M7_CHECK CHIP_CHECK < M7_DN_6 WINDOW M7_DN_6_W_A STEP M7_DN_6_S_A INSIDE OF LAYER CHIP_M7 BACKUP PRINT M7.DN.6_A.density
         [ !AREA(F_A)+AREA(M7_CHECK)/AREA(CHIP_CHECK) ]
  // Condition-B 
  ERR_WIN_B = DENSITY M7_CHECK CHIP_CHECK < M7_DN_6 WINDOW M7_DN_6_W_BC STEP M7_DN_6_S_BC INSIDE OF LAYER CHIP_M7 BACKUP 
	[ AREA(M7_CHECK)/AREA(CHIP_CHECK) ]
  F_B = WITH WIDTH (ERR_WIN_B NOT NEW_DEN_EXC) >= M7_DN_6_E_BC
  A = DENSITY F_B M7_CHECK CHIP_CHECK < M7_DN_6 WINDOW M7_DN_6_W_BC STEP M7_DN_6_S_BC INSIDE OF LAYER CHIP_M7 BACKUP PRINT M7.DN.6_BC.density
         [ !AREA(F_B)+AREA(M7_CHECK)/AREA(CHIP_CHECK) ]
  B = AREA A > M7_DN_6_A_B
  C = SIZE B BY M7_DN_6_U/2 UNDEROVER
  B INTERACT C
  // Condition-C
  AREA B > M7_DN_6_A_C
}
#ENDIF


// Mx.DN.5
//===========
M7_CORE = M7x NOT SEALRING_EXCLUDE

Mx.DN.5:M5_M6_M7 { @ It is not allowed to have local density > 85% of all 3 consecutive metal (Mx, Mx+1 and Mx+2) over any window 62.5 um x 62.5 um (stepping 31.25 um), i.e. it is allowed for either one of Mx, Mx+1, or Mx+2 to have a local density <= 85%. 1. The metal layers include M1/Mx and dummy metals. 2. The check does not include chip corner stress relief pattern, sealring (162;2) and top2 metals at CUP area.   
    DENSITY  M5_CORE M6_CORE M7_CORE >0 WINDOW M5_DN_5_W STEP M5_DN_5_S BACKUP INSIDE OF LAYER CHIPx
  	  [ !~(AREA(M5_CORE)/AREA()- M5_DN_5)*!~(AREA(M6_CORE)/AREA()- M5_DN_5)*!~(AREA(M7_CORE)/AREA()- M5_DN_5) ]
 	  RDB Mx.DN.5:M5_M6_M7.density
}
#IFDEF CHECK_LOW_DENSITY
Mx.DN.7:M5_M6_M7 { @ It is not allowed to have local density < 5% of all 3 consecutive metal layer(M5,M6,M7) over any 30umx30um window (stepping 15um), i.e. it is allowed for either one of M5, M6, or M7 to have a local density >= 5 %.
@ 1. The metal layers include M1/Mx and dummy metals
@ 2. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 3. This rule is applied while the width of (checking window NOT above excluding region) >= 15 um    
   M5_CHECK = M5x NOT NEW_DEN_EXC
   M6_CHECK = M6x NOT NEW_DEN_EXC
   M7_CHECK = M7x NOT NEW_DEN_EXC
   CHIP_CHECK = CHIP NOT NEW_DEN_EXC
   ERR_WIN = DENSITY M5_CHECK M6_CHECK M7_CHECK CHIP_CHECK >0 WINDOW M5_DN_7_W STEP M5_DN_7_S BACKUP INSIDE OF LAYER CHIP_M7
   [ !~(M5_DN_7-AREA(M5_CHECK)/AREA(CHIP_CHECK))*!~(M5_DN_7-AREA(M6_CHECK)/AREA(CHIP_CHECK))*!~(M5_DN_7-AREA(M7_CHECK)/AREA(CHIP_CHECK)) ]
   F = WITH WIDTH (ERR_WIN NOT NEW_DEN_EXC) >= M5_DN_7_E
   DENSITY F M5_CHECK M6_CHECK M7_CHECK CHIP_CHECK >0 WINDOW M5_DN_7_W STEP M5_DN_7_S BACKUP INSIDE OF LAYER CHIP_M7
   [ !!AREA(F)*!~(M5_DN_7-AREA(M5_CHECK)/AREA(CHIP_CHECK))*!~(M5_DN_7-AREA(M6_CHECK)/AREA(CHIP_CHECK))*!~(M5_DN_7-AREA(M7_CHECK)/AREA(CHIP_CHECK)) ]
   RDB Mx.DN.7:M5_M6_M7.density
}
#ENDIF

M7.R.3 { @ Metal(pin) layers must be drawn only interact with one relative Metal(drawing) layers
   M7_PIN NOT INTERACT M7i == 1
}


//VIA7 CHECKS
//===========
#IFNDEF WIDE_ADJUST
M8Wide_2_0 = M8 WITH WIDTH > M8_S_2_W            // 0.17
M8Wide_2_1 = M8Wide_2_0 WITH WIDTH > M8_S_2_1_W  // 0.24
M8Wide_2_2 = M8Wide_2_1 WITH WIDTH > M8_S_2_2_W  // 0.31
M8Wide_2_3 = M8Wide_2_2 WITH WIDTH > M8_S_2_3_W  // 0.62
M8Wide_3_0 = M8Wide_2_3 WITH WIDTH > M8_S_3_W    // 1.65
#ELSE
M8Wide_2_4 = M8 WITH WIDTH > M8_S_2_4_W          // 0.17
M8Wide_2_0 = M8Wide_2_4 WITH WIDTH > M8_S_2_W    // 0.19
M8Wide_2_5 = M8Wide_2_0 WITH WIDTH > M8_S_2_5_W  // 0.24
M8Wide_2_1 = M8Wide_2_5 WITH WIDTH > M8_S_2_1_W  // 0.265
M8Wide_2_6 = M8Wide_2_1 WITH WIDTH > M8_S_2_6_W  // 0.31
M8Wide_2_2 = M8Wide_2_6 WITH WIDTH > M8_S_2_2_W  // 0.345
M8Wide_2_7 = M8Wide_2_2 WITH WIDTH > M8_S_2_7_W  // 0.62
M8Wide_2_3 = M8Wide_2_7 WITH WIDTH > M8_S_2_3_W  // 0.685
M8Wide_3_0 = M8Wide_2_3 WITH WIDTH > M8_S_3_W    // 1.65
#ENDIF

M7Wide_R2_VIA7 = M7Wide_2_0 WITH WIDTH > VIA7_R_2_W        // 0.21
M7Wide_R4_VIA7 = M7Wide_R2_VIA7 WITH WIDTH > VIA7_R_4_W    // 0.21
M7Wide_R3_VIA7 = M7Wide_R4_VIA7 WITH WIDTH > VIA7_R_3_W    // 0.55
M7Wide_R5_VIA7 = M7Wide_R3_VIA7 WITH WIDTH > VIA7_R_5_W    // 1.4
M7Wide_R6_VIA7 = M7Wide_R5_VIA7 WITH WIDTH > VIA7_R_6_W    // 2.1
M8Wide_R2_VIA7 = M8Wide_2_0 WITH WIDTH > VIA7_R_2_W      // 0.21
M8Wide_R4_VIA7 = M8Wide_R2_VIA7 WITH WIDTH > VIA7_R_4_W  // 0.21
M8Wide_R3_VIA7 = M8Wide_R4_VIA7 WITH WIDTH > VIA7_R_3_W  // 0.55
M8Wide_R5_VIA7 = M8Wide_R3_VIA7 WITH WIDTH > VIA7_R_5_W  // 1.4
M8Wide_R6_VIA7 = M8Wide_R5_VIA7 WITH WIDTH > VIA7_R_6_W  // 2.1

VIA7.W.1 { @ Width (maximum = minimum) (Except sealring (162,2) and {VIAx bar INSIDE {LOWMEDN NOT (LOWMEDN SIZING -4 um)}} region) = 0.07 
   NOT RECTANGLE (VIA7i NOT (SEALRING_EXCLUDE OR P_RING_REGION)) == VIA7_W_1 BY == VIA7_W_1 ORTHOGONAL ONLY
}
VIA7.S.1 { @ Space >= 0.07 
  EXT VIA7i < VIA7_S_1 ABUT < 90 SINGULAR REGION
}
VIA7.S.1.1 { @ Space [any one of VIAx connect to > 3.3V and <= 5V different net] >= ^VIA7_S_1_1
  J = STAMP (VIA7i AND M7_5V_ALL) BY M7i
  EXT J VIA7i < VIA7_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}
VIA7.S.2 { @ Space to 3-neighboring VIAx (distance < 0.098 um) >= 0.09 
  X = WITH NEIGHBOR VIA7i > 2 SPACE < VIA7_S_2_D
  EXT X VIA7i < VIA7_S_2 ABUT < 90 SINGULAR REGION
}
VIA7.S.3 { @ Space to neighboring VIAx [different net] >= 0.095 
  EXT VIA7i < VIA7_S_3 ABUT < 90 NOT CONNECTED REGION
}
VIA7.S.3.1 { @ Space to neighboring VIAx [different net and common parallel run length > 0 um] >= 0.11 
  EXT VIA7i < VIA7_S_3_1 ABUT < 90 NOT CONNECTED OPPOSITE REGION
}

// VIA7.EN.0 is checked by VIA7.EN.1, and VIA7.EN.2_VIA7.EN.4_VIA7.EN.4.1

VIA7.EN.1 { @ Enclosure by Mx or M1 >= 0.00 
  VIA7 NOT M7
}

VIA7.EN.2__VIA7.EN.4__VIA7.EN.4.1 { @ Enclosure by M7 [at least two opposite sides] >= ^VIA7_EN_2, or [four sides] >= ^VIA7_EN_4 with [at least two opposite sides] >= ^VIA7_EN_4_1
  X = RECTANGLE ENCLOSURE (VIA7 NOT SEALRING_EXCLUDE) M7 ABUT < 90 SINGULAR GOOD 0 VIA7_EN_2 OPPOSITE 0 VIA7_EN_2 OPPOSITE
  Y = ENC X M7 < VIA7_EN_4 ABUT < 90 SINGULAR REGION
  Z = RECTANGLE ENCLOSURE (X NOT TOUCH Y) M7 ABUT < 90 GOOD VIA7_EN_4 VIA7_EN_4_1 OPPOSITE VIA7_EN_4 VIA7_EN_4_1 OPPOSITE
  Y OR (ENC Z M7 < VIA7_EN_4_1 ABUT < 90 SINGULAR REGION)

}



// VIA7.R.1 is checked by VIA7.W.1
VIA7.R.2__VIA7.R.3 { @ When M7 or M8 width > ^VIA7_R_2_W um, more than one VIA7 is required.
                    @ 2 vias spacing should be <= ^VIA7_R_2_S1 um or 4 vias spacing should be <= ^VIA7_R_2_S2 um
                    @ When M7 or M8 width > ^VIA7_R_3_W um, more than three VIA7 is required.
                    @ 4 vias spacing should be <= ^VIA7_R_3_S1 um or 9 vias spacing should be <= ^VIA7_R_3_S2 um
                    @ not check SRAM region					
   M8OvpM7_W_ = (M7Wide_R2_VIA7 AND M8) OR (M8Wide_R2_VIA7 AND M7)
   M8OvpM7_B  = (M7Wide_R3_VIA7 AND M8) OR (M8Wide_R3_VIA7 AND M7)
   M8OvpM7_W  = M8OvpM7_W_ NOT M8OvpM7_B 
   Checked_VIA7_W_ = VIA7_EXD NOT OUTSIDE M8OvpM7_W
   Checked_VIA7_B  = VIA7_EXD NOT OUTSIDE M8OvpM7_B
   Checked_VIA7_W  = Checked_VIA7_W_ NOT Checked_VIA7_B
   M7_effect = M7i INTERACT M8OvpM7_W_
   M8_effect = M8i INTERACT M8OvpM7_W_
   effect_M8OvpM7_ = M7_effect AND M8_effect
   effect_M8OvpM7 = effect_M8OvpM7_ INTERACT M8OvpM7_W_
   effect_VIA = VIA7_EXD INTERACT effect_M8OvpM7

   V7Merged_A = SIZE effect_VIA BY VIA7_R_2_S1/2 INSIDE OF effect_M8OvpM7 STEP M7_S_1*0.7
   V7Merged_B = SIZE V7Merged_A BY (VIA7_R_2_S2 - VIA7_R_2_S1)/2 INSIDE OF effect_M8OvpM7 STEP M7_S_1*0.7
   V7Merged_C = SIZE V7Merged_B BY (VIA7_R_3_S2 - VIA7_R_2_S2)/2 INSIDE OF effect_M8OvpM7 STEP M7_S_1*0.7
   V7Merged_A2R = V7Merged_A INTERACT effect_VIA < 2
   V7Merged_A2 = V7Merged_A OUTSIDE V7Merged_A2R
   V7Merged_A4R = V7Merged_A2 INTERACT effect_VIA < 4
   V7Merged_A4 = V7Merged_A2 OUTSIDE V7Merged_A4R
   V7Merged_B4R = V7Merged_B INTERACT effect_VIA < 4
   V7Merged_B4 = V7Merged_B OUTSIDE V7Merged_B4R
   V7Merged_C9R = V7Merged_C INTERACT effect_VIA < 9
   V7Merged_C9 = V7Merged_C OUTSIDE V7Merged_C9R

   GMergeW = V7Merged_A2 OR V7Merged_B4
   GMergeB = V7Merged_A4 OR V7Merged_C9
   GVIA_W = Checked_VIA7_W INTERACT GMergeW
   GVIA_B = Checked_VIA7_B INTERACT GMergeB
   GOOD_AREA_W = M8OvpM7_W INTERACT GVIA_W
   GOOD_AREA_B = M8OvpM7_B INTERACT GVIA_B
   Checked_VIA7_W OUTSIDE GOOD_AREA_W
   Checked_VIA7_B OUTSIDE GOOD_AREA_B
}

VIA7.R.4.M7 { @ At least two VIAx must be used for a connection that is <= ^VIA7_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA7_R_4_W um (L) and width > ^VIA7_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA7_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA7_R_4_W um (L) and width > ^VIA7_R_4_W um (W).)   
  Branch1 = ((SIZE M7Wide_R4_VIA7 BY VIA7_R_4_D + GRID) NOT M7Wide_R4_VIA7) AND M7
  Branch1HasVia = (Branch1 INTERACT M7Wide_R4_VIA7) INTERACT VIA7_EXD
  Branch1Edge = M7Wide_R4_VIA7 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA7_R_4_D INSIDE OF Branch1HasVia STEP M7_S_1*0.5
  GoodBranch = (Branch AND M8) INTERACT VIA7_EXD > 1
  BranchSingleVia = (VIA7_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M8 INTERACT BranchSingleVia) AND M7) INTERACT BranchSingleVia) INTERACT VIA7_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA7.R.4.M8 { @ At least two VIAx must be used for a connection that is <= ^VIA7_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA7_R_4_W um (L) and width > ^VIA7_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA7_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA7_R_4_W um (L) and width > ^VIA7_R_4_W um (W)).   
  Branch1 = ((SIZE M8Wide_R4_VIA7 BY VIA7_R_4_D + GRID) NOT M8Wide_R4_VIA7) AND M8
  Branch1HasVia = (Branch1 INTERACT M8Wide_R4_VIA7) INTERACT VIA7_EXD
  Branch1Edge = M8Wide_R4_VIA7 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA7_R_4_D INSIDE OF Branch1HasVia STEP M8_S_1*0.5
  GoodBranch = (Branch AND M7) INTERACT VIA7_EXD > 1
  BranchSingleVia = (VIA7_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M7 INTERACT BranchSingleVia) AND M8) INTERACT BranchSingleVia) INTERACT VIA7_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA7.R.5.M7 { @ At least two VIAx must be used for a connection that is <= ^VIA7_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA7_R_5_W um (L) and width > ^VIA7_R_5_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA7_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA7_R_5_W um (L) and width > ^VIA7_R_5_W um (W)).
  Branch1 = ((SIZE M7Wide_R5_VIA7 BY VIA7_R_5_D + GRID) NOT M7Wide_R5_VIA7) AND M7
  Branch1HasVia = (Branch1 INTERACT M7Wide_R5_VIA7) INTERACT VIA7_EXD
  Branch1Edge = M7Wide_R5_VIA7 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA7_R_5_D INSIDE OF Branch1HasVia STEP M7_S_1*0.7
  GoodBranch = (Branch AND M8) INTERACT VIA7_EXD > 1
  BranchSingleVia = (VIA7_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M8 INTERACT BranchSingleVia) AND M7) INTERACT BranchSingleVia) INTERACT VIA7_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA7.R.5.M8 { @ At least two VIAx must be used for a connection that is <= ^VIA7_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA7_R_5_W um (L) and width > ^VIA7_R_5_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA7_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA7_R_5_W um (L) and width > ^VIA7_R_5_W um (W)).
  Branch1 = ((SIZE M8Wide_R5_VIA7 BY VIA7_R_5_D + GRID) NOT M8Wide_R5_VIA7) AND M8
  Branch1HasVia = (Branch1 INTERACT M8Wide_R5_VIA7) INTERACT VIA7_EXD
  Branch1Edge = M8Wide_R5_VIA7 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA7_R_5_D INSIDE OF Branch1HasVia STEP M8_S_1*0.7
  GoodBranch = (Branch AND M7) INTERACT VIA7_EXD > 1
  BranchSingleVia = (VIA7_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M7 INTERACT BranchSingleVia) AND M8) INTERACT BranchSingleVia) INTERACT VIA7_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M7Big_R6_VIA7 = ENCLOSE RECTANGLE M7Wide_R6_VIA7 VIA7_R_6_W VIA7_R_6_L+GRID

VIA7.R.6.M7 { @ At least two VIAx must be used for a connection that is <= ^VIA7_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA7_R_6_L um (L) and width > ^VIA7_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA7_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA7_R_6_L um (L) and width > ^VIA7_R_6_W um (W)).
  Branch1 = ((SIZE M7Big_R6_VIA7 BY VIA7_R_6_D + GRID) NOT M7Big_R6_VIA7) AND M7
  Branch1HasVia = (Branch1 INTERACT M7Big_R6_VIA7) INTERACT VIA7_EXD
  Branch1Edge = M7Big_R6_VIA7 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA7_R_6_D INSIDE OF Branch1HasVia STEP M7_S_1*0.7
  GoodBranch = (Branch AND M8) INTERACT VIA7_EXD > 1
  BranchSingleVia = (VIA7_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M8 INTERACT BranchSingleVia) AND M7) INTERACT BranchSingleVia) INTERACT VIA7_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M8Big_R6_VIA7 = ENCLOSE RECTANGLE M8Wide_R6_VIA7 VIA7_R_6_W VIA7_R_6_L+GRID

VIA7.R.6.M8 { @ At least two VIAx must be used for a connection that is <= ^VIA7_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA7_R_6_L um (L) and width > ^VIA7_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA7_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA7_R_6_L um (L) and width > ^VIA7_R_6_W um (W)).
  Branch1 = ((SIZE M8Big_R6_VIA7 BY VIA7_R_6_D + GRID) NOT M8Big_R6_VIA7) AND M8
  Branch1HasVia = (Branch1 INTERACT M8Big_R6_VIA7) INTERACT VIA7_EXD
  Branch1Edge = M8Big_R6_VIA7 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA7_R_6_D INSIDE OF Branch1HasVia STEP M8_S_1*0.7
  GoodBranch = (Branch AND M7) INTERACT VIA7_EXD > 1
  BranchSingleVia = (VIA7_EXD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M7 INTERACT BranchSingleVia) AND M8) INTERACT BranchSingleVia) INTERACT VIA7_EXD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}
// VIA7.R.7 is checked by VIA7.EN.1
// VIA7.R.9 can't be checked

VIA7.R.11 { @ Single VIAx is not allowed for H-shape Mx+1 when all of the following conditions come into existence: 1. The Mx+1 has H-shape interact with two metal holes: two metal hole length(L2) <= ^VIA7_R_11_L1 um and both two metal hole area <= ^VIA7_R_11_A um2 2. The VIAx overlaps on the center metal bar of this H-shape Mx+1 3. The length (L) of the center metal bar <= ^VIA7_R_11_L2 um and the width of metal bar is <= ^VIA7_R_11_W um.
  W = M8i WITH WIDTH <= VIA7_R_11_W   
  H_HOLE = HOLES M8i INNER <= VIA7_R_11_A
  A = M8i COIN OUTSIDE EDGE H_HOLE
  B0 = ((INT A <= VIA7_R_11_W ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE M8i) INTERACT H_HOLE == 2 
  B1 = (((INT A <= VIA7_R_11_L2 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE M8i) AND W) INTERACT H_HOLE == 2
  HOLE_NOTCH = EXT H_HOLE <= VIA7_R_11_W ABUT<90 OPPOSITE NOTCH REGION  
  B2 = (B1 NOT HOLE_NOTCH) OR B0
  CORNER_M = ((EXT B2 <= VIA7_R_11_W ABUT == 90 INTERSECTING ONLY REGION EXTENTS) TOUCH B2 == 2) AND W
  B = B2 OR CORNER_M
  CENTER_BAR1 = NOT ENCLOSE RECTANGLE B GRID VIA7_R_11_L2+GRID
  CENTER_BAR2 = CENTER_BAR1 INTERACT H_HOLE == 2
  C = CENTER_BAR2 COIN OUTSIDE EDGE H_HOLE 
  D = EXT [C] M8i <= VIA7_R_11_L1 OPPOSITE
  E = C NOT COIN INSIDE EDGE D
  CENTER_BAR3 = CENTER_BAR2 NOT WITH EDGE E
  CHECK_VIA = VIA7 NOT OUTSIDE CENTER_BAR3
  CHECK_VIA AND (((M8i INTERACT CHECK_VIA) AND (M7i INTERACT CHECK_VIA)) INTERACT VIA7i == 1)
}

VIA7.R.12 { @ VIA7 connected to DM7, DM7_O, DM8, DM8_O is not allowed
  VIA7 INTERACT DUM7
  VIA7 INTERACT DUM8
  VIA7 INTERACT DM7_O
  VIA7 INTERACT DM8_O
}  

//M8 CHECKS
//=========


M8_EDGE_45 = M8 ANGLE == 45

M8.W.1 { @ Width >= 0.07 
  INT M8 < M8_W_1 ABUT < 90 SINGULAR REGION
}
M8.W.2 { @ Width of 45-degree bent Mx. (Please make sure the vertex of 45 degree pattern is on 0.005 um grid (refer to the guideline, G.6gU, in section 3.7)) >= 0.17 
  INT M8_EDGE_45 < M8_W_2 ABUT < 90 REGION
}
M8.W.3 { @ Maximum width <= ^M8_W_3 um, exclude sealring 
  M8_MAX_WIDTH WITH WIDTH > M8_W_3
}

M8.S.1 { @ Space >= 0.07 
  EXT M8 < M8_S_1 ABUT < 90 SINGULAR REGION
}
M8.S.2 { @ Min. Metal space (for W> ^M8_S_2_W um & parallel length > ^M8_S_2_L um) >= ^M8_S_2 um
  X = EXT M8Wide_2_0 M8 < M8_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M8
  ENCLOSE RECTANGLE Y GRID M8_S_2_L+GRID
}
M8.S.2.1 { @ Min. Metal space (for W> ^M8_S_2_1_W um & parallel length > ^M8_S_2_1_L um) >= ^M8_S_2_1 um
  X = EXT M8Wide_2_1 M8 < M8_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M8
  ENCLOSE RECTANGLE Y GRID M8_S_2_1_L+GRID
}
M8.S.2.2 { @ Min. Metal space (for W> ^M8_S_2_2_W um & parallel length > ^M8_S_2_2_L um) >= ^M8_S_2_2 um
  X = EXT M8Wide_2_2 M8 < M8_S_2_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M8
  ENCLOSE RECTANGLE Y GRID M8_S_2_2_L+GRID
}
M8.S.2.3 { @ Min. Metal space (for W> ^M8_S_2_3_W um & parallel length > ^M8_S_2_3_L um) >= ^M8_S_2_3 um
  X = EXT M8Wide_2_3 M8 < M8_S_2_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M8
  ENCLOSE RECTANGLE Y GRID M8_S_2_3_L+GRID
}
#IFDEF WIDE_ADJUST
M8.S.2.4 { @ Min. Metal space (for W> ^M8_S_2_4_W um & parallel length > ^M8_S_2_4_L um) >= ^M8_S_2_4 um
  X = EXT M8Wide_2_4 M8 < M8_S_2_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M8
  ENCLOSE RECTANGLE Y GRID M8_S_2_4_L+GRID
}
M8.S.2.5 { @ Min. Metal space (for W> ^M8_S_2_5_W um & parallel length > ^M8_S_2_5_L um) >= ^M8_S_2_5 um
  X = EXT M8Wide_2_5 M8 < M8_S_2_5 OPPOSITE REGION MEASURE ALL
  Y = X NOT M8
  ENCLOSE RECTANGLE Y GRID M8_S_2_5_L+GRID
}
M8.S.2.6 { @ Min. Metal space (for W> ^M8_S_2_6_W um & parallel length > ^M8_S_2_6_L um) >= ^M8_S_2_6 um
  X = EXT M8Wide_2_6 M8 < M8_S_2_6 OPPOSITE REGION MEASURE ALL
  Y = X NOT M8
  ENCLOSE RECTANGLE Y GRID M8_S_2_6_L+GRID
}
M8.S.2.7 { @ Min. Metal space (for W> ^M8_S_2_7_W um & parallel length > ^M8_S_2_7_L um) >= ^M8_S_2_7 um
  X = EXT M8Wide_2_7 M8 < M8_S_2_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M8
  ENCLOSE RECTANGLE Y GRID M8_S_2_7_L+GRID
}
#ENDIF
M8.S.3 { @ Min. Metal space (for W> ^M8_S_3_W um & parallel length > ^M8_S_3_L um) >= ^M8_S_3 um
  X = EXT M8Wide_3_0 M8 < M8_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M8
  (ENCLOSE RECTANGLE Y 0.001 M8_S_3_L+0.001) NOT INSIDE IND_REGION
}
M8.S.5 { @ Space at Mx line-end (W < 0.10 um (Q)) in a dense-line-end configuration: If Mx has parallel run length with opposite Mx (measured with T = 0.035 um extension) along 2 adjacent edges of Mx [any one edge <Q distance from the corner of the two edges], then one of the space (S1 or S2) needs to be at least this value (This check doesn't include small jog with edge length < 0.07 um(R)) (M2.S.5 except SRAM (186;0) region) >= 0.10 
  A = CONVEX EDGE M8 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M8_S_5_W
  B = EXT [A] M8 < M8_S_5 ABUT < 90 OPPOSITE EXTENDED M8_S_5_T
  C = A TOUCH INSIDE EDGE B
  D = INT C [M8] < M8_S_5_W ABUT == 90 INTERSECTING ONLY
  I = LENGTH D >= M8_W_1
  J = EXPAND EDGE I INSIDE BY 0.001 EXTEND BY M8_S_5_T
  K = EXPAND EDGE I INSIDE BY 0.001 
  L = J NOT K
  M = L WITH EDGE A 
  N = M OR K
  O = N TOUCH EDGE I
  EXT O M8 < M8_S_5 ABUT < 90 OPPOSITE REGION

}

M8.S.5.1 { @ Space at Mx line-end (W<Q=^M8_S_5_1_W) in a dense-line-end configuration.If Mx has parallel run length with opposite Mx (measured with ^M8_S_5_1_T (T) extension) along two adjacent edges of Mx [any one edge < ^M8_S_5_1_W (W) from the corner of the two edges of Mx], and Mx enclosure of VIAx-1 < ^M8_S_5_1_E at line-end, then one of the space (S1 or S2) must be >= ^M8_S_5_1 um.
  A = CONVEX EDGE M8 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M8_S_5_1_W
  V7_EN = ENC [VIA7i] A < M8_S_5_1_E ABUT < 90 OPPOSITE
  M8_EN = ENC V7_EN [A] < M8_S_5_1_E ABUT < 90 OPPOSITE
  M8_SA = EXT A [M8] < M8_S_5_1 ABUT < 90 OPPOSITE EXTENDED M8_S_5_1_T
  M8_SB = EXT [A] M8_SA < M8_S_5_1 ABUT < 90 OPPOSITE EXTENDED M8_S_5_1_T
  M8_END = (A TOUCH INSIDE EDGE M8_EN) TOUCH INSIDE EDGE M8_SB
  EN_B = ENC V7_EN [M8_END] < M8_S_5_1_E2 OPPOSITE
  EN_C = ENC V7_EN [M8_END] < M8_S_5_1_E3 OPPOSITE
  EN_D = ENC V7_EN [M8_END] < M8_S_5_1_E4 OPPOSITE
  S1_B = EXT [M8_END] M8_SA < M8_S_5_1_S2 OPPOSITE EXTENDED M8_S_5_1_T
  S1_C = EXT [M8_END] M8_SA < M8_S_5_1_S3 OPPOSITE EXTENDED M8_S_5_1_T
  S1_D = EXT [M8_END] M8_SA < M8_S_5_1_S4 OPPOSITE EXTENDED M8_S_5_1_T
  PASS_B = (M8_END NOT TOUCH INSIDE EDGE EN_B) NOT TOUCH INSIDE EDGE S1_B
  PASS_C = (M8_END NOT TOUCH INSIDE EDGE EN_C) NOT TOUCH INSIDE EDGE S1_C
  PASS_D = (M8_END NOT TOUCH INSIDE EDGE EN_D) NOT TOUCH INSIDE EDGE S1_D
  M8_CHECK = ((M8_END NOT TOUCH INSIDE EDGE PASS_B) NOT TOUCH INSIDE EDGE PASS_C) NOT TOUCH INSIDE EDGE PASS_D
  H = INT M8_CHECK [M8] < M8_S_5_1_W ABUT == 90 INTERSECTING ONLY
  I = LENGTH H >= M8_W_1
  J = EXPAND EDGE I INSIDE BY GRID EXTEND BY M8_S_5_1_T
  K = EXPAND EDGE I INSIDE BY GRID
  L = J NOT K
  M = L WITH EDGE A 
  N = M OR K
  O = N TOUCH INSIDE EDGE I
  P = EXT [O] M8 < M8_S_5_1 ABUT < 90 OPPOSITE
  Q = ENC VIA7i (O TOUCH INSIDE EDGE P) < M8_S_5_1_E ABUT < 90 OPPOSITE REGION
  VIA_BAD1 = VIA7i INTERACT Q
  VIA_GOOD = VIA7i NOT VIA_BAD1
  VIA_BAD2 = VIA_BAD1 NOT INTERACT ((M8 AND M7) INTERACT VIA_GOOD)
  ENC VIA_BAD2 M8_CHECK < M8_S_5_1_E ABUT < 90 OPPOSITE REGION
}

M8.S.6 { @ Space to 45-degree bent Mx >= 0.17 
  X = EXPAND EDGE M8_EDGE_45 OUTSIDE BY M8_S_6
  X AND M8
}


M8_HVN_5V = NET AREA RATIO M8i OVER M10_HV_5V M9_HV_5V M8_HV_5V M7_HV_5V M6_HV_5V M5_HV_5V M4_HV_5V M3_HV_5V M2_HV_5V M1_HV_5V > 0 
M8_HVN = NET AREA RATIO M8i OVER M10_HV M9_HV M8_HV M7_HV M6_HV M5_HV M4_HV M3_HV M2_HV M1_HV > 0 
M8_MVN = NET AREA RATIO M8i OVER M10_MV M9_MV M8_MV M7_MV M6_MV M5_MV M4_MV M3_MV M2_MV M1_MV > 0
M8_LVN = NET AREA RATIO M8i OVER M10_LV M9_LV M8_LV M7_LV M6_LV M5_LV M4_LV M3_LV M2_LV M1_LV > 0

M8_NOMARK = (((M8i NOT M8_HVN_5V) NOT M8_HVN) NOT M8_MVN) NOT M8_LVN

#IFDEF Mx_S_8_IO_NET
  M8_NOMARK_5V = NET AREA RATIO M8_NOMARK PSD_HVD NSD_HVD S_HVD_GATE PSTPi > 0 
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD)+!!AREA(S_HVD_GATE))*!AREA(PSTPi)]
  M8_NOMARK_HV = NET AREA RATIO M8_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPi > 0 
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPi)]
  M8_NOMARK_MV = NET AREA RATIO M8_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPi > 0 
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPi)]
#ELSE  
  M8_NOMARK_5V = NET AREA RATIO M8_NOMARK PSD_HVD NSD_HVD S_HVD_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_HVD)+!!AREA(NSD_HVD)+!!AREA(S_HVD_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M8_NOMARK_HV = NET AREA RATIO M8_NOMARK PSD_OD2 NSD_OD2 S_HV_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_OD2)+!!AREA(NSD_OD2)+!!AREA(S_HV_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)]
  M8_NOMARK_MV = NET AREA RATIO M8_NOMARK PSD_UD15 NSD_UD15 S_MV_GATE PSTPi PSD_CORE NSD_CORE S_LV_GATE > 0
  [(!!AREA(PSD_UD15)+!!AREA(NSD_UD15)+!!AREA(S_MV_GATE))*!AREA(PSTPi)*!AREA(PSD_CORE)*!AREA(NSD_CORE)*!AREA(S_LV_GATE)] 
#ENDIF 

M8_5V_ALL = M8_HVN_5V OR M8_NOMARK_5V  
M8_HV_ALL = M8_HVN OR M8_NOMARK_HV
M8_MV_ALL = M8_MVN OR M8_NOMARK_MV

M8.S.1.1 { @ Space [any one of Mx connect to > 3.3V and <= 5V net] >= ^M8_S_1_1
  I = STAMP M8_5V_ALL BY M8i
  EXT I M8i < M8_S_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}
M8.S.8.2 { @ Space to neighboring {VIAx-1 or VIAx} [either VIAx-1, VIAx or Mx connects to > 3.3V and <= 5V net] >= ^M8_S_8_2
  I = STAMP M8_5V_ALL BY M8i
  J = STAMP (VIA7i AND M8_5V_ALL) BY M8i
  EXT I VIA7i < M8_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M8i < M8_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA8i AND M8_5V_ALL) BY M8i
  EXT I VIA8i < M8_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M8i < M8_S_8_2 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}
M8.S.8 { @ Space to {VIAx-1 OR VIAx} [different net, any one of VIAx-1, VIAx or Mx connects to 1.8V ~ 3.3V net] 0.1  
  I = STAMP M8_HV_ALL BY M8i
  J = STAMP (VIA7i AND M8_HV_ALL) BY M8i
  EXT I VIA7i < M8_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M8i < M8_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA8i AND M8_HV_ALL) BY M8i
  EXT I VIA8i < M8_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M8i < M8_S_8 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}
M8.S.8.1 { @ Space to {VIAx-1 OR VIAx} [different net, any one of VIAx-1, VIAx or Mx connects to >= 1.5V and < 1.8V net] 0.08  
  I = STAMP M8_MV_ALL BY M8i
  J = STAMP (VIA7i AND M8_MV_ALL) BY M8i
  EXT I VIA7i < M8_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT J M8i < M8_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  K = STAMP (VIA8i AND M8_MV_ALL) BY M8i
  EXT I VIA8i < M8_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  EXT K M8i < M8_S_8_1 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL  
}

M8.S.9 { @ This rule is to check Metal (A) space to neighboring VIAx [either VIAx or Mx connects to >3.3V and <= 5V net]. DRC methodology to find Metal (A) Find a edge (B) of metal line end [edge length <= 0.12um] Run length (C) from edge (B) inside metal >= 0.13um Jog length (D) <= 0.01um within 0.13um run length Extend 0.06um outside from edge (B) to form a polygon metal (A) Metal (A) is defined if conditions 1~4 are all satisfied. >= 0.15 
  LINE_END_pre   = CONVEX EDGE M8 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= M8_S_9_B
  LINE_END_pre1  = EXPAND EDGE LINE_END_pre INSIDE BY GRID EXTEND BY -M8_S_9_D    
  LINE_END_pre2  = LINE_END_pre COIN INSIDE EDGE LINE_END_pre1  
  LINE_END_pre3  = INT [LINE_END_pre2] M8 < M8_S_9_C OPPOSITE 
  LINE_END_pre4  = LINE_END_pre NOT TOUCH INSIDE EDGE LINE_END_pre3
  LINE_END_pre5  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M8_S_9_D+GRID
  LINE_END_pre6  = EXPAND EDGE LINE_END_pre4 OUTSIDE BY GRID EXTEND BY M8_S_9_D
  LINE_END_pre7  = LINE_END_pre5 NOT LINE_END_pre6
  LINE_END_pre8  = LINE_END_pre5 TOUCH OUTSIDE EDGE LINE_END_pre4
  LINE_END_pre9  = LINE_END_pre8 COIN INSIDE EDGE LINE_END_pre7 
  LINE_END_pre10 = EXT [LINE_END_pre9] M8 < M8_S_9_C OPPOSITE
  LINE_END = LINE_END_pre4 NOT TOUCH OUTSIDE EDGE (LINE_END_pre8 TOUCH INSIDE EDGE LINE_END_pre10)
  A = EXPAND EDGE LINE_END OUTSIDE BY M8_S_9_A INSIDE BY GRID
  B = STAMP A BY M8i
  I = STAMP (A INTERACT M8_5V_ALL) BY M8i
  J = STAMP (VIA7i AND M8_5V_ALL) BY M8i
  K = STAMP (VIA8i AND M8_5V_ALL) BY M8i
  X1 = EXT I VIA7i < M8_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X2 = EXT I VIA8i  < M8_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X3 = EXT J B < M8_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  X4 = EXT K B < M8_S_9 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
  Y = ((X1 OR X2) OR X3) OR X4   
  COPY Y
  A INTERACT Y
}

// M8.EN.0 is checked by M8.EN.1, and M8.EN.2_M8.EN.3_M8.EN.3.1

M8.EN.1 { @ Enclosure of VIAx-1 >= 0.00 
  VIA7 NOT M8
}
M8.EN.2__M8.EN.3__M8.EN.3.1 { @ Enclosure of VIAx-1 [at least two opposite sides] >= ^M8_EN_2, or [four sides] >= ^M8_EN_3 with [at least two opposite sides] >= ^M8_EN_3_1
  X = RECTANGLE ENCLOSURE (VIA7 NOT SEALRING_ALL) M8 ABUT < 90 SINGULAR GOOD 0 M8_EN_2 OPPOSITE 0 M8_EN_2 OPPOSITE
  Y = ENC X M8 < M8_EN_3 ABUT < 90 SINGULAR REGION
  Z = RECTANGLE ENCLOSURE (X NOT TOUCH Y) M8 ABUT < 90 GOOD M8_EN_3 M8_EN_3_1 OPPOSITE M8_EN_3 M8_EN_3_1 OPPOSITE
  Y OR (ENC Z M8 < M8_EN_3_1 ABUT < 90 SINGULAR REGION)
}
M8.A.1 { @ Area (M2.A.1 except SRAM (186;0) region) >= 0.027 
     AREA M8 < M8_A_1
}
M8.A.2 { @ Area [with all of edge length< 0.17 um] (This check doesn't include the patterns filling 0.07 um x 0.17 um rectangular tile) (M2.A.2 except SRAM (186;0) region) >= 0.06 
  A = AREA M8 < M8_A_2
  B = LENGTH A >= M8_A_2_L1
  C = A NOT WITH EDGE B
  NOT ENCLOSE RECTANGLE C M8_A_2_W M8_A_2_L2 ORTHOGONAL ONLY
}


VARIABLE M8_A_3pre ((M8_A_3 + (M8_S_1 * M8_S_1 * 3.142))/(2 * M8_S_1))*((M8_A_3 + (M8_S_1 * M8_S_1 * 3.142))/(2 * M8_S_1))/3.141

M8.A.3 { @ Enclosed area >= 0.2 
  X = HOLES M8 INNER < M8_A_3pre
  AREA ( X NOT M8 ) < M8_A_3
}

// M8.R.1 can not be checked


#IFDEF FULL_CHIP
CHIP_M8 = COPY CHIP
#ELSE
CHIP_M8 = CHIP INTERACT M8x
#ENDIF

#IFDEF CHECK_LOW_DENSITY
M8.DN.1 { @ Minimum local density [window ^M8_DN_1_W um x ^M8_DN_1_W um, stepping ^M8_DN_1_S um] >= ^M8_DN_1
  M8_CHECK = M8x NOT M8_EXC_LOW
  CHIP_CHECK = CHIP NOT M8_EXC_LOW
  
  ERR_WIN = DENSITY M8_CHECK CHIP_CHECK < M8_DN_1 WINDOW M8_DN_1_W STEP M8_DN_1_S INSIDE OF LAYER CHIP_M8 BACKUP 
	[ AREA(M8_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M8_EXC_LOW) >= M8_DN_1_E
  DENSITY F M8_CHECK CHIP_CHECK < M8_DN_1 WINDOW M8_DN_1_W STEP M8_DN_1_S INSIDE OF LAYER CHIP_M8 BACKUP PRINT M8.DN.1.density
         [ !AREA(F)+AREA(M8_CHECK)/AREA(CHIP_CHECK) ]
}
#ENDIF

M8.DN.1.1 { @ Maximum local density [window ^M8_DN_1_1_W um x ^M8_DN_1_1_W um, stepping ^M8_DN_1_1_S um] <= ^M8_DN_1_1
  M8_CHECK = M8x NOT M8_EXC_HIGH
  CHIP_CHECK = CHIP NOT M8_EXC_HIGH
  ERR_WIN = DENSITY M8_CHECK CHIP_CHECK > M8_DN_1_1 WINDOW M8_DN_1_1_W STEP M8_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M8_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M8_EXC_HIGH) >= M8_DN_1_1_E
  DENSITY F M8_CHECK CHIP_CHECK > M8_DN_1_1 WINDOW M8_DN_1_1_W STEP M8_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP PRINT M8.DN.1.1.density
         [ !!AREA(F)*AREA(M8_CHECK)/AREA(CHIP_CHECK) ]
}

M8.DN.4 { @ The metal density difference between any two neighboring checking windows including DM8EXCL [window ^M8_DN_4_W um x ^M8_DN_4_W um, stepping ^M8_DN_4_W um]  <= ^M8_DN_4
  DENSITY M8x CHIP <=1 WINDOW M8_DN_4_W BACKUP GRADIENT > M8_DN_4 ABSOLUTE CORNER INSIDE OF LAYER CHIPx PRINT M8.DN.4.density
  	[ AREA(M8x)/AREA(CHIP) ]    
}

#IFDEF CHECK_LOW_DENSITY
M8.DN.6 { @ Metal Desnsity >= ^M8_DN_6. All condition-A, Condition-B, and Condition-C must be followed.
@ (1) Condition-A: Metal density [window ^M8_DN_6_W_A um x ^M8_DN_6_W_A um, stepping ^M8_DN_6_S_A um] >= ^M8_DN_6
@ (2) Condition-B: Maximum area of merged low density windows [window ^M8_DN_6_W_BC um x ^M8_DN_6_W_BC um, stepping ^M8_DN_6_S_BC um < ^M8_DN_6] <= ^M8_DN_6_A_B um2, except merged low density windows width <= ^M8_DN_6_U um
@ (3) Condition-C: Maximum area of merged low density windows [window ^M8_DN_6_W_BC um x ^M8_DN_6_W_BC um, stepping ^M8_DN_6_S_BC um < ^M8_DN_6] <= ^M8_DN_6_A_C um2
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M8_DN_6_E_A um for condition-A and >= ^M8_DN_6_E_BC um for both condition-B/condition-C 
  M8_CHECK = M8x NOT NEW_DEN_EXC
  CHIP_CHECK = CHIP NOT NEW_DEN_EXC
  // Condition-A
  ERR_WIN_A = DENSITY M8_CHECK CHIP_CHECK < M8_DN_6 WINDOW M8_DN_6_W_A STEP M8_DN_6_S_A INSIDE OF LAYER CHIP_M8 BACKUP 
	[ AREA(M8_CHECK)/AREA(CHIP_CHECK) ]
  F_A = WITH WIDTH (ERR_WIN_A NOT NEW_DEN_EXC) >= M8_DN_6_E_A
  DENSITY F_A M8_CHECK CHIP_CHECK < M8_DN_6 WINDOW M8_DN_6_W_A STEP M8_DN_6_S_A INSIDE OF LAYER CHIP_M8 BACKUP PRINT M8.DN.6_A.density
         [ !AREA(F_A)+AREA(M8_CHECK)/AREA(CHIP_CHECK) ]
  // Condition-B 
  ERR_WIN_B = DENSITY M8_CHECK CHIP_CHECK < M8_DN_6 WINDOW M8_DN_6_W_BC STEP M8_DN_6_S_BC INSIDE OF LAYER CHIP_M8 BACKUP 
	[ AREA(M8_CHECK)/AREA(CHIP_CHECK) ]
  F_B = WITH WIDTH (ERR_WIN_B NOT NEW_DEN_EXC) >= M8_DN_6_E_BC
  A = DENSITY F_B M8_CHECK CHIP_CHECK < M8_DN_6 WINDOW M8_DN_6_W_BC STEP M8_DN_6_S_BC INSIDE OF LAYER CHIP_M8 BACKUP PRINT M8.DN.6_BC.density
         [ !AREA(F_B)+AREA(M8_CHECK)/AREA(CHIP_CHECK) ]
  B = AREA A > M8_DN_6_A_B
  C = SIZE B BY M8_DN_6_U/2 UNDEROVER
  B INTERACT C
  // Condition-C
  AREA B > M8_DN_6_A_C
}
#ENDIF


// Mx.DN.5
//===========
M8_CORE = M8x NOT SEALRING_EXCLUDE

Mx.DN.5:M6_M7_M8 { @ It is not allowed to have local density > 85% of all 3 consecutive metal (Mx, Mx+1 and Mx+2) over any window 62.5 um x 62.5 um (stepping 31.25 um), i.e. it is allowed for either one of Mx, Mx+1, or Mx+2 to have a local density <= 85%. 1. The metal layers include M1/Mx and dummy metals. 2. The check does not include chip corner stress relief pattern, sealring (162;2) and top2 metals at CUP area.   
    DENSITY  M6_CORE M7_CORE M8_CORE >0 WINDOW M6_DN_5_W STEP M6_DN_5_S BACKUP INSIDE OF LAYER CHIPx
  	  [ !~(AREA(M6_CORE)/AREA()- M6_DN_5)*!~(AREA(M7_CORE)/AREA()- M6_DN_5)*!~(AREA(M8_CORE)/AREA()- M6_DN_5) ]
 	  RDB Mx.DN.5:M6_M7_M8.density
}
#IFDEF CHECK_LOW_DENSITY
Mx.DN.7:M6_M7_M8 { @ It is not allowed to have local density < 5% of all 3 consecutive metal layer(M6,M7,M8) over any 30umx30um window (stepping 15um), i.e. it is allowed for either one of M6, M7, or M8 to have a local density >= 5 %.
@ 1. The metal layers include M1/Mx and dummy metals
@ 2. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 3. This rule is applied while the width of (checking window NOT above excluding region) >= 15 um    
   M6_CHECK = M6x NOT NEW_DEN_EXC
   M7_CHECK = M7x NOT NEW_DEN_EXC
   M8_CHECK = M8x NOT NEW_DEN_EXC
   CHIP_CHECK = CHIP NOT NEW_DEN_EXC
   ERR_WIN = DENSITY M6_CHECK M7_CHECK M8_CHECK CHIP_CHECK >0 WINDOW M6_DN_7_W STEP M6_DN_7_S BACKUP INSIDE OF LAYER CHIP_M8
   [ !~(M6_DN_7-AREA(M6_CHECK)/AREA(CHIP_CHECK))*!~(M6_DN_7-AREA(M7_CHECK)/AREA(CHIP_CHECK))*!~(M6_DN_7-AREA(M8_CHECK)/AREA(CHIP_CHECK)) ]
   F = WITH WIDTH (ERR_WIN NOT NEW_DEN_EXC) >= M6_DN_7_E
   DENSITY F M6_CHECK M7_CHECK M8_CHECK CHIP_CHECK >0 WINDOW M6_DN_7_W STEP M6_DN_7_S BACKUP INSIDE OF LAYER CHIP_M8
   [ !!AREA(F)*!~(M6_DN_7-AREA(M6_CHECK)/AREA(CHIP_CHECK))*!~(M6_DN_7-AREA(M7_CHECK)/AREA(CHIP_CHECK))*!~(M6_DN_7-AREA(M8_CHECK)/AREA(CHIP_CHECK)) ]
   RDB Mx.DN.7:M6_M7_M8.density
}
#ENDIF

M8.R.3 { @ Metal(pin) layers must be drawn only interact with one relative Metal(drawing) layers
   M8_PIN NOT INTERACT M8i == 1
}


//VIA8 CHECKS
//===========

VIA8.W.1 { @ Width (maximum = minimum) = 0.36 
  NOT RECTANGLE (VIA8 NOT SEALRING_EXCLUDE) == VIA8_W_1 BY == VIA8_W_1 ORTHOGONAL ONLY
}
VIA8.S.1 { @ Space >= 0.34 
  EXT VIA8 < VIA8_S_1 ABUT < 90 SINGULAR REGION
}
VIA8.S.2 { @ Space to 3-neighboring VIAz (distance < 0.56 um) >= 0.54 
  X = WITH NEIGHBOR VIA8 > 2 SPACE < VIA8_S_2_D
  EXT X VIA8 < VIA8_S_2 ABUT < 90 SINGULAR REGION
}
VIA8.EN.1 { @ Enclosure by Mx or My or Mz (This check doesn't include the sealring (162;2) region) >= 0.02 
  ENC (VIA8 NOT SEALRING_EXCLUDE) M8 < VIA8_EN_1 ABUT < 90 SINGULAR REGION
  VIA8 NOT M8 
}

VIA8.EN.2 { @ Enclosure by Mx or My or Mz [at least two opposite sides] >= 0.08 
  X = RECTANGLE ENCLOSURE VIA8 M8 ABUT < 90 SINGULAR GOOD VIA8_EN_1 VIA8_EN_2 OPPOSITE VIA8_EN_1 VIA8_EN_2 OPPOSITE
  Y = ENC [X] M8 < VIA8_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA8_W_1 ABUT == 90 INTERSECTING ONLY REGION   // adjacent narrow sides
}

// VIA8.R.1 is checked by VIA8.W.1

M9Wide_1.8_VIA8T = M9 WITH WIDTH > VIA8_R_2_W
M8Wide_1.8_VIA8T = M8 WITH WIDTH > VIA8_R_2_W
M9Wide_3_VIA8T = M9Wide_1.8_VIA8T WITH WIDTH > VIA8_R_3_W
M8Wide_3_VIA8T =  M8Wide_1.8_VIA8T WITH WIDTH > VIA8_R_3_W

VIA8.R.2 { @ At least two VIAz with spacing <= ^VIA8_R_2_S um are required to connect Mz and Mz+1 when one of these metals has a width and length > ^VIA8_R_2_W um.
   M9OvpM8W = (M9 AND M8Wide_1.8_VIA8T) OR (M8 AND M9Wide_1.8_VIA8T)
   Checked_VIA8 = VIA8_EXD NOT OUTSIDE M9OvpM8W
   M8_effect = M8i INTERACT M9OvpM8W
   M9_effect = M9i INTERACT M9OvpM8W
   effect_M9OvpM8_ = M8_effect AND M9_effect
   effect_M9OvpM8 = effect_M9OvpM8_ INTERACT M9OvpM8W
   Effect_VIA8 = VIA8_EXD INTERACT effect_M9OvpM8
   VIA8Merged = SIZE Effect_VIA8 BY VIA8_R_2_S /2 INSIDE OF effect_M9OvpM8 STEP M8_S_1*0.7
   VIA8Merged2 = VIA8Merged ENCLOSE Effect_VIA8 >=2
   GVIA = Checked_VIA8 INTERACT VIA8Merged2
   GM9OvpM8W = M9OvpM8W INTERACT GVIA
   Checked_VIA8 OUTSIDE GM9OvpM8W
}   

M8Big_3_VIA8T = ENCLOSE RECTANGLE M8Wide_3_VIA8T VIA8_R_3_W VIA8_R_3_L+GRID

VIA8.R.3.M8 { @ At least two VIAz must be used for a connection that is <= ^VIA8_R_3_D um (D) away from a metal plate (either Mz or Mz+1) with length  ^VIA8_R_3_L um (L) and width  ^VIA8_R_3_W um (W). (It is allowed to use one VIAz for a connection that is  ^VIA8_R_3_D um (D) away from a metal plate (either Mz or Mz+1) with length ^VIA8_R_3_L um (L) and width  ^VIA8_R_3_W um (W)).
  Branch1 = ((SIZE M8Big_3_VIA8T BY VIA8_R_3_D + GRID) NOT M8Big_3_VIA8T) AND M8
  Branch1HasVia = (Branch1 INTERACT M8Big_3_VIA8T) INTERACT VIA8
  Branch1Edge = M8Big_3_VIA8T COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA8_R_3_D INSIDE OF Branch1HasVia STEP M8_S_1*0.7
  GoodBranch = (Branch AND M9) INTERACT VIA8 > 1
  BranchSingleVia = (VIA8 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M9 INTERACT BranchSingleVia) AND M8) INTERACT BranchSingleVia) INTERACT VIA8 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M9Big_3_VIA8T = ENCLOSE RECTANGLE M9Wide_3_VIA8T VIA8_R_3_W VIA8_R_3_L+GRID

VIA8.R.3.M9 { @ At least two VIAz must be used for a connection that is <= ^VIA8_R_3_D um (D) away from a metal plate (either Mz or Mz+1) with length  ^VIA8_R_3_L um (L) and width  ^VIA8_R_3_W um (W). (It is allowed to use one VIAz for a connection that is  ^VIA8_R_3_D um (D) away from a metal plate (either Mz or Mz+1) with length ^VIA8_R_3_L um (L) and width  ^VIA8_R_3_W um (W)).
  Branch1 = ((SIZE M9Big_3_VIA8T BY VIA8_R_3_D + GRID) NOT M9Big_3_VIA8T) AND M9
  Branch1HasVia = (Branch1 INTERACT M9Big_3_VIA8T) INTERACT VIA8
  Branch1Edge = M9Big_3_VIA8T COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA8_R_3_D INSIDE OF Branch1HasVia STEP M9_S_1*0.7
  GoodBranch = (Branch AND M8) INTERACT VIA8 > 1
  BranchSingleVia = (VIA8 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M8 INTERACT BranchSingleVia) AND M9) INTERACT BranchSingleVia) INTERACT VIA8 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

// VIA8.R.4 is checked by VIA8.EN.1
// VIA8.R.5 can not be checked.

VIA8.R.6 { @ VIA8 connected to DM8, DM9 is not allowed
  VIA8 INTERACT DUM8
  VIA8 INTERACT DUM9
}  

//M9 CHECKS
//=============

M9Wide_1.5 =  M9 WITH WIDTH > M9_S_2_W
M9Wide_4.5 =  M9Wide_1.5 WITH WIDTH > M9_S_3_W


M9.W.1 { @ Width >= 0.4 
  (INT M9 < M9_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE IND_REGION
}

M9.W.2 { @ Maximun width <= ^M9_W_2 um 
  M9_MAX_WIDTH WITH WIDTH > M9_W_2
}

M9.S.1 { @ Space >= 0.4 
  (EXT M9 < M9_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE IND_REGION
}
M9.S.2 { @ Min. Metal space (for W > ^M9_S_2_W um & parallel length > ^M9_S_2_L um) >= ^M9_S_2 um
  X = EXT M9Wide_1.5 M9 < M9_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M9
  (ENCLOSE RECTANGLE Y 0.001 M9_S_2_L+0.001) NOT INSIDE IND_REGION
}
M9.S.3 { @ Min. Metal space (for W > ^M9_S_3_W um & parallel length > ^M9_S_3_L um) >= ^M9_S_3 um
  X = EXT M9Wide_4.5 M9 < M9_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M9
  (ENCLOSE RECTANGLE Y 0.001 M9_S_3_L+0.001) NOT INSIDE IND_REGION
}
M9.EN.1 { @ Enclosure of VIAz-1 (This check doesn't include the sealring (162;2) region) >= 0.02 
  ENC (VIA8 NOT SEALRING_EXCLUDE) M9 < M9_EN_1 ABUT < 90 SINGULAR REGION
  VIA8 NOT M9
}
M9.EN.2 { @ Enclosure of VIAz-1 [at least two opposite sides] >= 0.08 
  X = RECTANGLE ENCLOSURE VIA8 M9 ABUT < 90 SINGULAR GOOD M9_EN_1 M9_EN_2 OPPOSITE M9_EN_1 M9_EN_2 OPPOSITE
  Y = ENC [X] M9 < M9_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA8_W_1 ABUT == 90 INTERSECTING ONLY REGION   // adjacent narrow sides
}
M9.A.1 { @ Area >= 0.565 
  AREA M9 < M9_A_1
}


VARIABLE M9_A_2pre ((M9_A_2 + (M9_S_1 * M9_S_1 * 3.142))/(2 * M9_S_1))*((M9_A_2 + (M9_S_1 * M9_S_1 * 3.142))/(2 * M9_S_1))/3.141

M9.A.2 { @ Enclosed area >= 0.565 
  X = HOLES M9 INNER < M9_A_2pre
  AREA ( X NOT M9 ) < M9_A_2
}


#IFDEF FULL_CHIP
CHIP_M9 = COPY CHIP
#ELSE
CHIP_M9 = CHIP INTERACT M9x
#ENDIF

#IFDEF CHECK_LOW_DENSITY
M9.DN.1 { @ Minimum local density [window ^M9_DN_1_W um x ^M9_DN_1_W um, stepping ^M9_DN_1_S um] >= ^M9_DN_1
  M9_CHECK = M9x NOT M9_EXC_LOW
  CHIP_CHECK = CHIP NOT M9_EXC_LOW
  
  ERR_WIN = DENSITY M9_CHECK CHIP_CHECK < M9_DN_1 WINDOW M9_DN_1_W STEP M9_DN_1_S INSIDE OF LAYER CHIP_M9 BACKUP 
	[ AREA(M9_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M9_EXC_LOW) >= M9_DN_1_E
  DENSITY F M9_CHECK CHIP_CHECK < M9_DN_1 WINDOW M9_DN_1_W STEP M9_DN_1_S INSIDE OF LAYER CHIP_M9 BACKUP PRINT M9.DN.1.density
         [ !AREA(F)+AREA(M9_CHECK)/AREA(CHIP_CHECK) ]
}
#ENDIF

M9.DN.1.1 { @ Maximum local density [window ^M9_DN_1_1_W um x ^M9_DN_1_1_W um, stepping ^M9_DN_1_1_S um] <= ^M9_DN_1_1
  M9_CHECK = M9x NOT M9_EXC_HIGH
  CHIP_CHECK = CHIP NOT M9_EXC_HIGH
  ERR_WIN = DENSITY M9_CHECK CHIP_CHECK > M9_DN_1_1 WINDOW M9_DN_1_1_W STEP M9_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M9_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M9_EXC_HIGH) >= M9_DN_1_1_E
  DENSITY F M9_CHECK CHIP_CHECK > M9_DN_1_1 WINDOW M9_DN_1_1_W STEP M9_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP PRINT M9.DN.1.1.density
         [ !!AREA(F)*AREA(M9_CHECK)/AREA(CHIP_CHECK) ]
}

M9.DN.4 { @ The metal density difference between any two neighboring checking windows including DM9EXCL [window ^M9_DN_4_W um x ^M9_DN_4_W um, stepping ^M9_DN_4_W um]  <= ^M9_DN_4
  DENSITY M9x CHIP <=1 WINDOW M9_DN_4_W BACKUP GRADIENT > M9_DN_4 ABSOLUTE CORNER INSIDE OF LAYER CHIPx PRINT M9.DN.4.density
  	[ AREA(M9x)/AREA(CHIP) ]    
}



// M9.R.1 can't be checked

M9.R.2 { @ Metal(pin) layers must be drawn only interact with one relative Metal(drawing) layers
   M9_PIN NOT INTERACT M9i == 1
}


//VIA9 CHECKS
//===========

VIA9.W.1 { @ Width (maximum = minimum) = 0.36 
  NOT RECTANGLE (VIA9 NOT SEALRING_EXCLUDE) == VIA9_W_1 BY == VIA9_W_1 ORTHOGONAL ONLY
}
VIA9.S.1 { @ Space >= 0.34 
  EXT VIA9 < VIA9_S_1 ABUT < 90 SINGULAR REGION
}
VIA9.S.2 { @ Space to 3-neighboring VIAz (distance < 0.56 um) >= 0.54 
  X = WITH NEIGHBOR VIA9 > 2 SPACE < VIA9_S_2_D
  EXT X VIA9 < VIA9_S_2 ABUT < 90 SINGULAR REGION
}
VIA9.EN.1 { @ Enclosure by Mx or My or Mz (This check doesn't include the sealring (162;2) region) >= 0.02 
  ENC (VIA9 NOT SEALRING_EXCLUDE) M9 < VIA9_EN_1 ABUT < 90 SINGULAR REGION
  VIA9 NOT M9 
}

VIA9.EN.2 { @ Enclosure by Mx or My or Mz [at least two opposite sides] >= 0.08 
  X = RECTANGLE ENCLOSURE VIA9 M9 ABUT < 90 SINGULAR GOOD VIA9_EN_1 VIA9_EN_2 OPPOSITE VIA9_EN_1 VIA9_EN_2 OPPOSITE
  Y = ENC [X] M9 < VIA9_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA9_W_1 ABUT == 90 INTERSECTING ONLY REGION   // adjacent narrow sides
}

// VIA9.R.1 is checked by VIA9.W.1

M10Wide_1.8_VIA9T = M10 WITH WIDTH > VIA9_R_2_W
M9Wide_1.8_VIA9T = M9 WITH WIDTH > VIA9_R_2_W
M10Wide_3_VIA9T = M10Wide_1.8_VIA9T WITH WIDTH > VIA9_R_3_W
M9Wide_3_VIA9T =  M9Wide_1.8_VIA9T WITH WIDTH > VIA9_R_3_W

VIA9.R.2 { @ At least two VIAz with spacing <= ^VIA9_R_2_S um are required to connect Mz and Mz+1 when one of these metals has a width and length > ^VIA9_R_2_W um.
   M10OvpM9W = (M10 AND M9Wide_1.8_VIA9T) OR (M9 AND M10Wide_1.8_VIA9T)
   Checked_VIA9 = VIA9_EXD NOT OUTSIDE M10OvpM9W
   M9_effect = M9i INTERACT M10OvpM9W
   M10_effect = M10i INTERACT M10OvpM9W
   effect_M10OvpM9_ = M9_effect AND M10_effect
   effect_M10OvpM9 = effect_M10OvpM9_ INTERACT M10OvpM9W
   Effect_VIA9 = VIA9_EXD INTERACT effect_M10OvpM9
   VIA9Merged = SIZE Effect_VIA9 BY VIA9_R_2_S /2 INSIDE OF effect_M10OvpM9 STEP M9_S_1*0.7
   VIA9Merged2 = VIA9Merged ENCLOSE Effect_VIA9 >=2
   GVIA = Checked_VIA9 INTERACT VIA9Merged2
   GM10OvpM9W = M10OvpM9W INTERACT GVIA
   Checked_VIA9 OUTSIDE GM10OvpM9W
}   

M9Big_3_VIA9T = ENCLOSE RECTANGLE M9Wide_3_VIA9T VIA9_R_3_W VIA9_R_3_L+GRID

VIA9.R.3.M9 { @ At least two VIAz must be used for a connection that is <= ^VIA9_R_3_D um (D) away from a metal plate (either Mz or Mz+1) with length  ^VIA9_R_3_L um (L) and width  ^VIA9_R_3_W um (W). (It is allowed to use one VIAz for a connection that is  ^VIA9_R_3_D um (D) away from a metal plate (either Mz or Mz+1) with length ^VIA9_R_3_L um (L) and width  ^VIA9_R_3_W um (W)).
  Branch1 = ((SIZE M9Big_3_VIA9T BY VIA9_R_3_D + GRID) NOT M9Big_3_VIA9T) AND M9
  Branch1HasVia = (Branch1 INTERACT M9Big_3_VIA9T) INTERACT VIA9
  Branch1Edge = M9Big_3_VIA9T COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA9_R_3_D INSIDE OF Branch1HasVia STEP M9_S_1*0.7
  GoodBranch = (Branch AND M10) INTERACT VIA9 > 1
  BranchSingleVia = (VIA9 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M10 INTERACT BranchSingleVia) AND M9) INTERACT BranchSingleVia) INTERACT VIA9 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M10Big_3_VIA9T = ENCLOSE RECTANGLE M10Wide_3_VIA9T VIA9_R_3_W VIA9_R_3_L+GRID

VIA9.R.3.M10 { @ At least two VIAz must be used for a connection that is <= ^VIA9_R_3_D um (D) away from a metal plate (either Mz or Mz+1) with length  ^VIA9_R_3_L um (L) and width  ^VIA9_R_3_W um (W). (It is allowed to use one VIAz for a connection that is  ^VIA9_R_3_D um (D) away from a metal plate (either Mz or Mz+1) with length ^VIA9_R_3_L um (L) and width  ^VIA9_R_3_W um (W)).
  Branch1 = ((SIZE M10Big_3_VIA9T BY VIA9_R_3_D + GRID) NOT M10Big_3_VIA9T) AND M10
  Branch1HasVia = (Branch1 INTERACT M10Big_3_VIA9T) INTERACT VIA9
  Branch1Edge = M10Big_3_VIA9T COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA9_R_3_D INSIDE OF Branch1HasVia STEP M10_S_1*0.7
  GoodBranch = (Branch AND M9) INTERACT VIA9 > 1
  BranchSingleVia = (VIA9 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M9 INTERACT BranchSingleVia) AND M10) INTERACT BranchSingleVia) INTERACT VIA9 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

// VIA9.R.4 is checked by VIA9.EN.1
// VIA9.R.5 can not be checked.

VIA9.R.6 { @ VIA9 connected to DM9, DM10 is not allowed
  VIA9 INTERACT DUM9
  VIA9 INTERACT DUM10
}  

//M10 CHECKS
//=============

M10Wide_1.5 =  M10 WITH WIDTH > M10_S_2_W
M10Wide_4.5 =  M10Wide_1.5 WITH WIDTH > M10_S_3_W


M10.W.1 { @ Width >= 0.4 
  (INT M10 < M10_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE IND_REGION
}

M10.W.2 { @ Maximun width <= ^M10_W_2 um 
  M10_MAX_WIDTH WITH WIDTH > M10_W_2
}

M10.S.1 { @ Space >= 0.4 
  (EXT M10 < M10_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE IND_REGION
}
M10.S.2 { @ Min. Metal space (for W > ^M10_S_2_W um & parallel length > ^M10_S_2_L um) >= ^M10_S_2 um
  X = EXT M10Wide_1.5 M10 < M10_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M10
  (ENCLOSE RECTANGLE Y 0.001 M10_S_2_L+0.001) NOT INSIDE IND_REGION
}
M10.S.3 { @ Min. Metal space (for W > ^M10_S_3_W um & parallel length > ^M10_S_3_L um) >= ^M10_S_3 um
  X = EXT M10Wide_4.5 M10 < M10_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M10
  (ENCLOSE RECTANGLE Y 0.001 M10_S_3_L+0.001) NOT INSIDE IND_REGION
}
M10.EN.1 { @ Enclosure of VIAz-1 (This check doesn't include the sealring (162;2) region) >= 0.02 
  ENC (VIA9 NOT SEALRING_EXCLUDE) M10 < M10_EN_1 ABUT < 90 SINGULAR REGION
  VIA9 NOT M10
}
M10.EN.2 { @ Enclosure of VIAz-1 [at least two opposite sides] >= 0.08 
  X = RECTANGLE ENCLOSURE VIA9 M10 ABUT < 90 SINGULAR GOOD M10_EN_1 M10_EN_2 OPPOSITE M10_EN_1 M10_EN_2 OPPOSITE
  Y = ENC [X] M10 < M10_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA9_W_1 ABUT == 90 INTERSECTING ONLY REGION   // adjacent narrow sides
}
M10.A.1 { @ Area >= 0.565 
  AREA M10 < M10_A_1
}


VARIABLE M10_A_2pre ((M10_A_2 + (M10_S_1 * M10_S_1 * 3.142))/(2 * M10_S_1))*((M10_A_2 + (M10_S_1 * M10_S_1 * 3.142))/(2 * M10_S_1))/3.141

M10.A.2 { @ Enclosed area >= 0.565 
  X = HOLES M10 INNER < M10_A_2pre
  AREA ( X NOT M10 ) < M10_A_2
}


#IFDEF FULL_CHIP
CHIP_M10 = COPY CHIP
#ELSE
CHIP_M10 = CHIP INTERACT M10x
#ENDIF

#IFDEF CHECK_LOW_DENSITY
M10.DN.1 { @ Minimum local density [window ^M10_DN_1_W um x ^M10_DN_1_W um, stepping ^M10_DN_1_S um] >= ^M10_DN_1
  M10_CHECK = M10x NOT M10_EXC_LOW
  CHIP_CHECK = CHIP NOT M10_EXC_LOW
  
  ERR_WIN = DENSITY M10_CHECK CHIP_CHECK < M10_DN_1 WINDOW M10_DN_1_W STEP M10_DN_1_S INSIDE OF LAYER CHIP_M10 BACKUP 
	[ AREA(M10_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M10_EXC_LOW) >= M10_DN_1_E
  DENSITY F M10_CHECK CHIP_CHECK < M10_DN_1 WINDOW M10_DN_1_W STEP M10_DN_1_S INSIDE OF LAYER CHIP_M10 BACKUP PRINT M10.DN.1.density
         [ !AREA(F)+AREA(M10_CHECK)/AREA(CHIP_CHECK) ]
}
#ENDIF

M10.DN.1.1 { @ Maximum local density [window ^M10_DN_1_1_W um x ^M10_DN_1_1_W um, stepping ^M10_DN_1_1_S um] <= ^M10_DN_1_1
  M10_CHECK = M10x NOT M10_EXC_HIGH
  CHIP_CHECK = CHIP NOT M10_EXC_HIGH
  ERR_WIN = DENSITY M10_CHECK CHIP_CHECK > M10_DN_1_1 WINDOW M10_DN_1_1_W STEP M10_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M10_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M10_EXC_HIGH) >= M10_DN_1_1_E
  DENSITY F M10_CHECK CHIP_CHECK > M10_DN_1_1 WINDOW M10_DN_1_1_W STEP M10_DN_1_1_S INSIDE OF LAYER CHIPx BACKUP PRINT M10.DN.1.1.density
         [ !!AREA(F)*AREA(M10_CHECK)/AREA(CHIP_CHECK) ]
}

M10.DN.4 { @ The metal density difference between any two neighboring checking windows including DM10EXCL [window ^M10_DN_4_W um x ^M10_DN_4_W um, stepping ^M10_DN_4_W um]  <= ^M10_DN_4
  DENSITY M10x CHIP <=1 WINDOW M10_DN_4_W BACKUP GRADIENT > M10_DN_4 ABSOLUTE CORNER INSIDE OF LAYER CHIPx PRINT M10.DN.4.density
  	[ AREA(M10x)/AREA(CHIP) ]    
}



// M10.R.1 can't be checked

M10.R.2 { @ Metal(pin) layers must be drawn only interact with one relative Metal(drawing) layers
   M10_PIN NOT INTERACT M10i == 1
}



// LOWMEDN CHECKS
//===============
LOWMEDN.W.1 { @ Width of {(M1, DM1, DM1_O) AND LOWMEDN} >= 0.14
  A = M1x AND LOWMEDN
  INT A < LOWMEDN_W_1 ABUT < 90 SINGULAR REGION
}
LOWMEDN.W.2.M2 { @ Width of {(Mx, DMx, DMx_O) AND LOWMEDN} >= 0.14
  A = M2x AND LOWMEDN
  INT A < LOWMEDN_W_2 ABUT < 90 SINGULAR REGION
}
LOWMEDN.W.2.M3 { @ Width of {(Mx, DMx, DMx_O) AND LOWMEDN} >= 0.14
  A = M3x AND LOWMEDN
  INT A < LOWMEDN_W_2 ABUT < 90 SINGULAR REGION
}
LOWMEDN.W.2.M4 { @ Width of {(Mx, DMx, DMx_O) AND LOWMEDN} >= 0.14
  A = M4x AND LOWMEDN
  INT A < LOWMEDN_W_2 ABUT < 90 SINGULAR REGION
}
LOWMEDN.W.2.M5 { @ Width of {(Mx, DMx, DMx_O) AND LOWMEDN} >= 0.14
  A = M5x AND LOWMEDN
  INT A < LOWMEDN_W_2 ABUT < 90 SINGULAR REGION
}
LOWMEDN.W.2.M6 { @ Width of {(Mx, DMx, DMx_O) AND LOWMEDN} >= 0.14
  A = M6x AND LOWMEDN
  INT A < LOWMEDN_W_2 ABUT < 90 SINGULAR REGION
}
LOWMEDN.W.2.M7 { @ Width of {(Mx, DMx, DMx_O) AND LOWMEDN} >= 0.14
  A = M7x AND LOWMEDN
  INT A < LOWMEDN_W_2 ABUT < 90 SINGULAR REGION
}
LOWMEDN.W.2.M8 { @ Width of {(Mx, DMx, DMx_O) AND LOWMEDN} >= 0.14
  A = M8x AND LOWMEDN
  INT A < LOWMEDN_W_2 ABUT < 90 SINGULAR REGION
}
LOWMEDN.S.1 { @ Space of {(M1, DM1, DM1_O) AND LOWMEDN} >= 0.14
  A = M1x AND LOWMEDN
  EXT A < LOWMEDN_S_1 ABUT < 90 SINGULAR REGION
}
LOWMEDN.S.2.M2 { @ Space of {(Mx, DMx, DMx_O) AND LOWMEDN} >= 0.14
  A = M2x AND LOWMEDN
  EXT A < LOWMEDN_S_2 ABUT < 90 SINGULAR REGION
}
LOWMEDN.S.2.M3 { @ Space of {(Mx, DMx, DMx_O) AND LOWMEDN} >= 0.14
  A = M3x AND LOWMEDN
  EXT A < LOWMEDN_S_2 ABUT < 90 SINGULAR REGION
}
LOWMEDN.S.2.M4 { @ Space of {(Mx, DMx, DMx_O) AND LOWMEDN} >= 0.14
  A = M4x AND LOWMEDN
  EXT A < LOWMEDN_S_2 ABUT < 90 SINGULAR REGION
}
LOWMEDN.S.2.M5 { @ Space of {(Mx, DMx, DMx_O) AND LOWMEDN} >= 0.14
  A = M5x AND LOWMEDN
  EXT A < LOWMEDN_S_2 ABUT < 90 SINGULAR REGION
}
LOWMEDN.S.2.M6 { @ Space of {(Mx, DMx, DMx_O) AND LOWMEDN} >= 0.14
  A = M6x AND LOWMEDN
  EXT A < LOWMEDN_S_2 ABUT < 90 SINGULAR REGION
}
LOWMEDN.S.2.M7 { @ Space of {(Mx, DMx, DMx_O) AND LOWMEDN} >= 0.14
  A = M7x AND LOWMEDN
  EXT A < LOWMEDN_S_2 ABUT < 90 SINGULAR REGION
}
LOWMEDN.S.2.M8 { @ Space of {(Mx, DMx, DMx_O) AND LOWMEDN} >= 0.14
  A = M8x AND LOWMEDN
  EXT A < LOWMEDN_S_2 ABUT < 90 SINGULAR REGION
}

LOWMEDN.R.1 {@ Protection ring must be inside {LOWMEDN NOT (LOWMEDN SIZING -1 um)}. The protection ring must include all Mx/all VIAx/.../V1/M1 layers.			
  P_RING_REGION1 NOT ENCLOSE P_RING_VIA1
  P_RING_VIA1_end = CONVEX EDGE P_RING_VIA1 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  P_RING_VIA1_c = EXT P_RING_VIA1_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA1_o = P_RING_VIA1_c OR P_RING_VIA1
  LOWMEDN_CORE1 NOT INSIDE (HOLES P_RING_VIA1_o)
  P_RING_REGION1 NOT ENCLOSE P_RING_VIA2
  P_RING_VIA2_end = CONVEX EDGE P_RING_VIA2 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  P_RING_VIA2_c = EXT P_RING_VIA2_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA2_o = P_RING_VIA2_c OR P_RING_VIA2
  LOWMEDN_CORE1 NOT INSIDE (HOLES P_RING_VIA2_o)
  P_RING_REGION1 NOT ENCLOSE P_RING_VIA3
  P_RING_VIA3_end = CONVEX EDGE P_RING_VIA3 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  P_RING_VIA3_c = EXT P_RING_VIA3_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA3_o = P_RING_VIA3_c OR P_RING_VIA3
  LOWMEDN_CORE1 NOT INSIDE (HOLES P_RING_VIA3_o)
  P_RING_REGION1 NOT ENCLOSE P_RING_VIA4
  P_RING_VIA4_end = CONVEX EDGE P_RING_VIA4 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  P_RING_VIA4_c = EXT P_RING_VIA4_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA4_o = P_RING_VIA4_c OR P_RING_VIA4
  LOWMEDN_CORE1 NOT INSIDE (HOLES P_RING_VIA4_o)
  P_RING_REGION1 NOT ENCLOSE P_RING_VIA5
  P_RING_VIA5_end = CONVEX EDGE P_RING_VIA5 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  P_RING_VIA5_c = EXT P_RING_VIA5_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA5_o = P_RING_VIA5_c OR P_RING_VIA5
  LOWMEDN_CORE1 NOT INSIDE (HOLES P_RING_VIA5_o)
  P_RING_REGION1 NOT ENCLOSE P_RING_VIA6
  P_RING_VIA6_end = CONVEX EDGE P_RING_VIA6 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  P_RING_VIA6_c = EXT P_RING_VIA6_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA6_o = P_RING_VIA6_c OR P_RING_VIA6
  LOWMEDN_CORE1 NOT INSIDE (HOLES P_RING_VIA6_o)
  P_RING_REGION1 NOT ENCLOSE P_RING_VIA7
  P_RING_VIA7_end = CONVEX EDGE P_RING_VIA7 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  P_RING_VIA7_c = EXT P_RING_VIA7_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA7_o = P_RING_VIA7_c OR P_RING_VIA7
  LOWMEDN_CORE1 NOT INSIDE (HOLES P_RING_VIA7_o)
}

LOWMEDN.R.2 {@ There must be continuous VIAx bar as a ring within {LOWMEDN NOT (LOWMEDN SIZING -4 um)}. (except {LOWMEDN interact INDDMY}). 
  CONVEX EDGE P_RING_VIA1_noIND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  NOT DONUT P_RING_VIA1_noIND
  CONVEX EDGE P_RING_VIA2_noIND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  NOT DONUT P_RING_VIA2_noIND
  CONVEX EDGE P_RING_VIA3_noIND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  NOT DONUT P_RING_VIA3_noIND
  CONVEX EDGE P_RING_VIA4_noIND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  NOT DONUT P_RING_VIA4_noIND
  CONVEX EDGE P_RING_VIA5_noIND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  NOT DONUT P_RING_VIA5_noIND
  CONVEX EDGE P_RING_VIA6_noIND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  NOT DONUT P_RING_VIA6_noIND
  CONVEX EDGE P_RING_VIA7_noIND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  NOT DONUT P_RING_VIA7_noIND
}

//LOWMEDN.R.3 is checked by VIAx.W.1		

//LOWMEDN.R.4 is checked by VIAx.W.6/ VIAx.EN.8/ Mx.EN.4

LOWMEDN.R.5 {@ For {LOWMEDN interact INDDMY}, there must be either only one breach (C-shape ring) of metal/Via with via space <= 4um or VIAx bar must be continuous within {LOWMEDN NOT (LOWMEDN SIZING -4 um)}.
  P_RING_VIA1_IND_end = CONVEX EDGE P_RING_VIA1_IND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  P_RING_VIA1_IND_c = EXT P_RING_VIA1_IND_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA1_IND_end NOT COIN OUTSIDE EDGE P_RING_VIA1_IND_c 
  P_RING_VIA1_IND_c INTERACT P_RING_VIA1_IND > 1
  P_RING_VIA1_IND INTERACT P_RING_VIA1_IND_c > 1
  P_RING_VIA1_IND_o = P_RING_VIA1_IND_c OR P_RING_VIA1_IND
  NOT DONUT P_RING_VIA1_IND_o
  P_RING_VIA2_IND_end = CONVEX EDGE P_RING_VIA2_IND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  P_RING_VIA2_IND_c = EXT P_RING_VIA2_IND_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA2_IND_end NOT COIN OUTSIDE EDGE P_RING_VIA2_IND_c 
  P_RING_VIA2_IND_c INTERACT P_RING_VIA2_IND > 1
  P_RING_VIA2_IND INTERACT P_RING_VIA2_IND_c > 1
  P_RING_VIA2_IND_o = P_RING_VIA2_IND_c OR P_RING_VIA2_IND
  NOT DONUT P_RING_VIA2_IND_o
  P_RING_VIA3_IND_end = CONVEX EDGE P_RING_VIA3_IND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  P_RING_VIA3_IND_c = EXT P_RING_VIA3_IND_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA3_IND_end NOT COIN OUTSIDE EDGE P_RING_VIA3_IND_c 
  P_RING_VIA3_IND_c INTERACT P_RING_VIA3_IND > 1
  P_RING_VIA3_IND INTERACT P_RING_VIA3_IND_c > 1
  P_RING_VIA3_IND_o = P_RING_VIA3_IND_c OR P_RING_VIA3_IND
  NOT DONUT P_RING_VIA3_IND_o
  P_RING_VIA4_IND_end = CONVEX EDGE P_RING_VIA4_IND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  P_RING_VIA4_IND_c = EXT P_RING_VIA4_IND_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA4_IND_end NOT COIN OUTSIDE EDGE P_RING_VIA4_IND_c 
  P_RING_VIA4_IND_c INTERACT P_RING_VIA4_IND > 1
  P_RING_VIA4_IND INTERACT P_RING_VIA4_IND_c > 1
  P_RING_VIA4_IND_o = P_RING_VIA4_IND_c OR P_RING_VIA4_IND
  NOT DONUT P_RING_VIA4_IND_o
  P_RING_VIA5_IND_end = CONVEX EDGE P_RING_VIA5_IND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  P_RING_VIA5_IND_c = EXT P_RING_VIA5_IND_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA5_IND_end NOT COIN OUTSIDE EDGE P_RING_VIA5_IND_c 
  P_RING_VIA5_IND_c INTERACT P_RING_VIA5_IND > 1
  P_RING_VIA5_IND INTERACT P_RING_VIA5_IND_c > 1
  P_RING_VIA5_IND_o = P_RING_VIA5_IND_c OR P_RING_VIA5_IND
  NOT DONUT P_RING_VIA5_IND_o
  P_RING_VIA6_IND_end = CONVEX EDGE P_RING_VIA6_IND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  P_RING_VIA6_IND_c = EXT P_RING_VIA6_IND_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA6_IND_end NOT COIN OUTSIDE EDGE P_RING_VIA6_IND_c 
  P_RING_VIA6_IND_c INTERACT P_RING_VIA6_IND > 1
  P_RING_VIA6_IND INTERACT P_RING_VIA6_IND_c > 1
  P_RING_VIA6_IND_o = P_RING_VIA6_IND_c OR P_RING_VIA6_IND
  NOT DONUT P_RING_VIA6_IND_o
  P_RING_VIA7_IND_end = CONVEX EDGE P_RING_VIA7_IND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  P_RING_VIA7_IND_c = EXT P_RING_VIA7_IND_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA7_IND_end NOT COIN OUTSIDE EDGE P_RING_VIA7_IND_c 
  P_RING_VIA7_IND_c INTERACT P_RING_VIA7_IND > 1
  P_RING_VIA7_IND INTERACT P_RING_VIA7_IND_c > 1
  P_RING_VIA7_IND_o = P_RING_VIA7_IND_c OR P_RING_VIA7_IND
  NOT DONUT P_RING_VIA7_IND_o
}

LOWMEDN.R.6 {@ For C-shape ring, at least 2 protection rings are must in {LOWMEDN INTERACT INDDMY}. At least 2 VIAx bar in {LOWMEDN NOT (LOWMEDN SIZING -4 um)} for the protection ring with the breach.	
  P_RING_REGION_IND = P_RING_REGION INTERACT LOWMEDN_IND 
  P_RING_VIA1_IND_end = CONVEX EDGE P_RING_VIA1_IND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  P_RING_VIA1_IND_c = EXT P_RING_VIA1_IND_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA1_IND_o = (P_RING_VIA1_IND_c OR P_RING_VIA1_IND) INTERACT P_RING_VIA1_IND_c
  P_RING_VIA1_IND_ox = HOLES P_RING_VIA1_IND_o
  LOWMEDN_CORE2_IND_VIA1 = LOWMEDN_CORE2 INTERACT (LOWMEDN_IND INTERACT P_RING_VIA1_IND_c)
  LOWMEDN_CORE2_IND_VIA1 NOT INSIDE P_RING_VIA1_IND_ox
  P_RING_VIA1_IND_o2 = P_RING_VIA1_IND_o INSIDE P_RING_VIA1_IND_ox
  P_RING_VIA1_IND_o2x = HOLES P_RING_VIA1_IND_o2
  LOWMEDN_CORE2_IND_VIA1 NOT INSIDE P_RING_VIA1_IND_o2x
  P_RING_VIA2_IND_end = CONVEX EDGE P_RING_VIA2_IND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  P_RING_VIA2_IND_c = EXT P_RING_VIA2_IND_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA2_IND_o = (P_RING_VIA2_IND_c OR P_RING_VIA2_IND) INTERACT P_RING_VIA2_IND_c
  P_RING_VIA2_IND_ox = HOLES P_RING_VIA2_IND_o
  LOWMEDN_CORE2_IND_VIA2 = LOWMEDN_CORE2 INTERACT (LOWMEDN_IND INTERACT P_RING_VIA2_IND_c)
  LOWMEDN_CORE2_IND_VIA2 NOT INSIDE P_RING_VIA2_IND_ox
  P_RING_VIA2_IND_o2 = P_RING_VIA2_IND_o INSIDE P_RING_VIA2_IND_ox
  P_RING_VIA2_IND_o2x = HOLES P_RING_VIA2_IND_o2
  LOWMEDN_CORE2_IND_VIA2 NOT INSIDE P_RING_VIA2_IND_o2x
  P_RING_VIA3_IND_end = CONVEX EDGE P_RING_VIA3_IND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  P_RING_VIA3_IND_c = EXT P_RING_VIA3_IND_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA3_IND_o = (P_RING_VIA3_IND_c OR P_RING_VIA3_IND) INTERACT P_RING_VIA3_IND_c
  P_RING_VIA3_IND_ox = HOLES P_RING_VIA3_IND_o
  LOWMEDN_CORE2_IND_VIA3 = LOWMEDN_CORE2 INTERACT (LOWMEDN_IND INTERACT P_RING_VIA3_IND_c)
  LOWMEDN_CORE2_IND_VIA3 NOT INSIDE P_RING_VIA3_IND_ox
  P_RING_VIA3_IND_o2 = P_RING_VIA3_IND_o INSIDE P_RING_VIA3_IND_ox
  P_RING_VIA3_IND_o2x = HOLES P_RING_VIA3_IND_o2
  LOWMEDN_CORE2_IND_VIA3 NOT INSIDE P_RING_VIA3_IND_o2x
  P_RING_VIA4_IND_end = CONVEX EDGE P_RING_VIA4_IND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  P_RING_VIA4_IND_c = EXT P_RING_VIA4_IND_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA4_IND_o = (P_RING_VIA4_IND_c OR P_RING_VIA4_IND) INTERACT P_RING_VIA4_IND_c
  P_RING_VIA4_IND_ox = HOLES P_RING_VIA4_IND_o
  LOWMEDN_CORE2_IND_VIA4 = LOWMEDN_CORE2 INTERACT (LOWMEDN_IND INTERACT P_RING_VIA4_IND_c)
  LOWMEDN_CORE2_IND_VIA4 NOT INSIDE P_RING_VIA4_IND_ox
  P_RING_VIA4_IND_o2 = P_RING_VIA4_IND_o INSIDE P_RING_VIA4_IND_ox
  P_RING_VIA4_IND_o2x = HOLES P_RING_VIA4_IND_o2
  LOWMEDN_CORE2_IND_VIA4 NOT INSIDE P_RING_VIA4_IND_o2x
  P_RING_VIA5_IND_end = CONVEX EDGE P_RING_VIA5_IND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  P_RING_VIA5_IND_c = EXT P_RING_VIA5_IND_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA5_IND_o = (P_RING_VIA5_IND_c OR P_RING_VIA5_IND) INTERACT P_RING_VIA5_IND_c
  P_RING_VIA5_IND_ox = HOLES P_RING_VIA5_IND_o
  LOWMEDN_CORE2_IND_VIA5 = LOWMEDN_CORE2 INTERACT (LOWMEDN_IND INTERACT P_RING_VIA5_IND_c)
  LOWMEDN_CORE2_IND_VIA5 NOT INSIDE P_RING_VIA5_IND_ox
  P_RING_VIA5_IND_o2 = P_RING_VIA5_IND_o INSIDE P_RING_VIA5_IND_ox
  P_RING_VIA5_IND_o2x = HOLES P_RING_VIA5_IND_o2
  LOWMEDN_CORE2_IND_VIA5 NOT INSIDE P_RING_VIA5_IND_o2x
  P_RING_VIA6_IND_end = CONVEX EDGE P_RING_VIA6_IND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  P_RING_VIA6_IND_c = EXT P_RING_VIA6_IND_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA6_IND_o = (P_RING_VIA6_IND_c OR P_RING_VIA6_IND) INTERACT P_RING_VIA6_IND_c
  P_RING_VIA6_IND_ox = HOLES P_RING_VIA6_IND_o
  LOWMEDN_CORE2_IND_VIA6 = LOWMEDN_CORE2 INTERACT (LOWMEDN_IND INTERACT P_RING_VIA6_IND_c)
  LOWMEDN_CORE2_IND_VIA6 NOT INSIDE P_RING_VIA6_IND_ox
  P_RING_VIA6_IND_o2 = P_RING_VIA6_IND_o INSIDE P_RING_VIA6_IND_ox
  P_RING_VIA6_IND_o2x = HOLES P_RING_VIA6_IND_o2
  LOWMEDN_CORE2_IND_VIA6 NOT INSIDE P_RING_VIA6_IND_o2x
  P_RING_VIA7_IND_end = CONVEX EDGE P_RING_VIA7_IND ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH <= VIAx_W_6+GRID
  P_RING_VIA7_IND_c = EXT P_RING_VIA7_IND_end <= LOWMEDN_R_5 ABUT< 90 OPPOSITE NOTCH REGION
  P_RING_VIA7_IND_o = (P_RING_VIA7_IND_c OR P_RING_VIA7_IND) INTERACT P_RING_VIA7_IND_c
  P_RING_VIA7_IND_ox = HOLES P_RING_VIA7_IND_o
  LOWMEDN_CORE2_IND_VIA7 = LOWMEDN_CORE2 INTERACT (LOWMEDN_IND INTERACT P_RING_VIA7_IND_c)
  LOWMEDN_CORE2_IND_VIA7 NOT INSIDE P_RING_VIA7_IND_ox
  P_RING_VIA7_IND_o2 = P_RING_VIA7_IND_o INSIDE P_RING_VIA7_IND_ox
  P_RING_VIA7_IND_o2x = HOLES P_RING_VIA7_IND_o2
  LOWMEDN_CORE2_IND_VIA7 NOT INSIDE P_RING_VIA7_IND_o2x
}


VIA1.W.6 { @ Width of VIAx bar in protection ring = 0.07
  X1 = ANGLE P_RING_VIA1 != 45
  X2 = ANGLE P_RING_VIA1 == 45
  INT X1 > VIAx_W_6 < VIAx_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIAx_W_6+GRID < VIAx_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH P_RING_VIA1 >= VIAx_W_6*2
  INT X1 < VIAx_W_6 ABUT < 90 REGION
  INT X2 < VIAx_W_6-GRID ABUT < 90 REGION
}
VIA1.S.7 { @ Space of VIAx bar in LOWMEDN to VIAx hole >= 0.365
  EXT P_RING_VIA1 VIA1_EXD < VIAx_S_7 ABUT < 90 SINGULAR REGION
}
VIA1.S.8 { @ Space of VIAx bar in LOWMEDN >= 0.74
  EXT P_RING_VIA1 < VIAx_S_8 ABUT < 90 SINGULAR REGION
}
VIA1.EN.8 {@ VIAx bar enclosure by M1/Mx in LOWMEDN >= 0.21
  X1 = ANGLE P_RING_VIA1 != 45
  X3 = ANGLE M1 != 45
  ENC P_RING_VIA1 M1 < VIAx_EN_8-GRID ABUT < 90 REGION
  ENC X1 X3 < VIAx_EN_8 ABUT < 90 REGION
}
M2.EN.4 {@ Enclosure of VIAx-1 bar in LOWMEDN >= 0.21
  X1 = ANGLE P_RING_VIA1 != 45
  X3 = ANGLE M2 != 45
  ENC P_RING_VIA1 M2 < Mx_EN_4-GRID ABUT < 90 REGION
  ENC X1 X3 < Mx_EN_4 ABUT < 90 REGION
}
VIA2.W.6 { @ Width of VIAx bar in protection ring = 0.07
  X1 = ANGLE P_RING_VIA2 != 45
  X2 = ANGLE P_RING_VIA2 == 45
  INT X1 > VIAx_W_6 < VIAx_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIAx_W_6+GRID < VIAx_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH P_RING_VIA2 >= VIAx_W_6*2
  INT X1 < VIAx_W_6 ABUT < 90 REGION
  INT X2 < VIAx_W_6-GRID ABUT < 90 REGION
}
VIA2.S.7 { @ Space of VIAx bar in LOWMEDN to VIAx hole >= 0.365
  EXT P_RING_VIA2 VIA2_EXD < VIAx_S_7 ABUT < 90 SINGULAR REGION
}
VIA2.S.8 { @ Space of VIAx bar in LOWMEDN >= 0.74
  EXT P_RING_VIA2 < VIAx_S_8 ABUT < 90 SINGULAR REGION
}
VIA2.EN.8 {@ VIAx bar enclosure by M1/Mx in LOWMEDN >= 0.21
  X1 = ANGLE P_RING_VIA2 != 45
  X3 = ANGLE M2 != 45
  ENC P_RING_VIA2 M2 < VIAx_EN_8-GRID ABUT < 90 REGION
  ENC X1 X3 < VIAx_EN_8 ABUT < 90 REGION
}
M3.EN.4 {@ Enclosure of VIAx-1 bar in LOWMEDN >= 0.21
  X1 = ANGLE P_RING_VIA2 != 45
  X3 = ANGLE M3 != 45
  ENC P_RING_VIA2 M3 < Mx_EN_4-GRID ABUT < 90 REGION
  ENC X1 X3 < Mx_EN_4 ABUT < 90 REGION
}
VIA3.W.6 { @ Width of VIAx bar in protection ring = 0.07
  X1 = ANGLE P_RING_VIA3 != 45
  X2 = ANGLE P_RING_VIA3 == 45
  INT X1 > VIAx_W_6 < VIAx_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIAx_W_6+GRID < VIAx_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH P_RING_VIA3 >= VIAx_W_6*2
  INT X1 < VIAx_W_6 ABUT < 90 REGION
  INT X2 < VIAx_W_6-GRID ABUT < 90 REGION
}
VIA3.S.7 { @ Space of VIAx bar in LOWMEDN to VIAx hole >= 0.365
  EXT P_RING_VIA3 VIA3_EXD < VIAx_S_7 ABUT < 90 SINGULAR REGION
}
VIA3.S.8 { @ Space of VIAx bar in LOWMEDN >= 0.74
  EXT P_RING_VIA3 < VIAx_S_8 ABUT < 90 SINGULAR REGION
}
VIA3.EN.8 {@ VIAx bar enclosure by M1/Mx in LOWMEDN >= 0.21
  X1 = ANGLE P_RING_VIA3 != 45
  X3 = ANGLE M3 != 45
  ENC P_RING_VIA3 M3 < VIAx_EN_8-GRID ABUT < 90 REGION
  ENC X1 X3 < VIAx_EN_8 ABUT < 90 REGION
}
M4.EN.4 {@ Enclosure of VIAx-1 bar in LOWMEDN >= 0.21
  X1 = ANGLE P_RING_VIA3 != 45
  X3 = ANGLE M4 != 45
  ENC P_RING_VIA3 M4 < Mx_EN_4-GRID ABUT < 90 REGION
  ENC X1 X3 < Mx_EN_4 ABUT < 90 REGION
}
VIA4.W.6 { @ Width of VIAx bar in protection ring = 0.07
  X1 = ANGLE P_RING_VIA4 != 45
  X2 = ANGLE P_RING_VIA4 == 45
  INT X1 > VIAx_W_6 < VIAx_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIAx_W_6+GRID < VIAx_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH P_RING_VIA4 >= VIAx_W_6*2
  INT X1 < VIAx_W_6 ABUT < 90 REGION
  INT X2 < VIAx_W_6-GRID ABUT < 90 REGION
}
VIA4.S.7 { @ Space of VIAx bar in LOWMEDN to VIAx hole >= 0.365
  EXT P_RING_VIA4 VIA4_EXD < VIAx_S_7 ABUT < 90 SINGULAR REGION
}
VIA4.S.8 { @ Space of VIAx bar in LOWMEDN >= 0.74
  EXT P_RING_VIA4 < VIAx_S_8 ABUT < 90 SINGULAR REGION
}
VIA4.EN.8 {@ VIAx bar enclosure by M1/Mx in LOWMEDN >= 0.21
  X1 = ANGLE P_RING_VIA4 != 45
  X3 = ANGLE M4 != 45
  ENC P_RING_VIA4 M4 < VIAx_EN_8-GRID ABUT < 90 REGION
  ENC X1 X3 < VIAx_EN_8 ABUT < 90 REGION
}
M5.EN.4 {@ Enclosure of VIAx-1 bar in LOWMEDN >= 0.21
  X1 = ANGLE P_RING_VIA4 != 45
  X3 = ANGLE M5 != 45
  ENC P_RING_VIA4 M5 < Mx_EN_4-GRID ABUT < 90 REGION
  ENC X1 X3 < Mx_EN_4 ABUT < 90 REGION
}
VIA5.W.6 { @ Width of VIAx bar in protection ring = 0.07
  X1 = ANGLE P_RING_VIA5 != 45
  X2 = ANGLE P_RING_VIA5 == 45
  INT X1 > VIAx_W_6 < VIAx_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIAx_W_6+GRID < VIAx_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH P_RING_VIA5 >= VIAx_W_6*2
  INT X1 < VIAx_W_6 ABUT < 90 REGION
  INT X2 < VIAx_W_6-GRID ABUT < 90 REGION
}
VIA5.S.7 { @ Space of VIAx bar in LOWMEDN to VIAx hole >= 0.365
  EXT P_RING_VIA5 VIA5_EXD < VIAx_S_7 ABUT < 90 SINGULAR REGION
}
VIA5.S.8 { @ Space of VIAx bar in LOWMEDN >= 0.74
  EXT P_RING_VIA5 < VIAx_S_8 ABUT < 90 SINGULAR REGION
}
VIA5.EN.8 {@ VIAx bar enclosure by M1/Mx in LOWMEDN >= 0.21
  X1 = ANGLE P_RING_VIA5 != 45
  X3 = ANGLE M5 != 45
  ENC P_RING_VIA5 M5 < VIAx_EN_8-GRID ABUT < 90 REGION
  ENC X1 X3 < VIAx_EN_8 ABUT < 90 REGION
}
M6.EN.4 {@ Enclosure of VIAx-1 bar in LOWMEDN >= 0.21
  X1 = ANGLE P_RING_VIA5 != 45
  X3 = ANGLE M6 != 45
  ENC P_RING_VIA5 M6 < Mx_EN_4-GRID ABUT < 90 REGION
  ENC X1 X3 < Mx_EN_4 ABUT < 90 REGION
}
VIA6.W.6 { @ Width of VIAx bar in protection ring = 0.07
  X1 = ANGLE P_RING_VIA6 != 45
  X2 = ANGLE P_RING_VIA6 == 45
  INT X1 > VIAx_W_6 < VIAx_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIAx_W_6+GRID < VIAx_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH P_RING_VIA6 >= VIAx_W_6*2
  INT X1 < VIAx_W_6 ABUT < 90 REGION
  INT X2 < VIAx_W_6-GRID ABUT < 90 REGION
}
VIA6.S.7 { @ Space of VIAx bar in LOWMEDN to VIAx hole >= 0.365
  EXT P_RING_VIA6 VIA6_EXD < VIAx_S_7 ABUT < 90 SINGULAR REGION
}
VIA6.S.8 { @ Space of VIAx bar in LOWMEDN >= 0.74
  EXT P_RING_VIA6 < VIAx_S_8 ABUT < 90 SINGULAR REGION
}
VIA6.EN.8 {@ VIAx bar enclosure by M1/Mx in LOWMEDN >= 0.21
  X1 = ANGLE P_RING_VIA6 != 45
  X3 = ANGLE M6 != 45
  ENC P_RING_VIA6 M6 < VIAx_EN_8-GRID ABUT < 90 REGION
  ENC X1 X3 < VIAx_EN_8 ABUT < 90 REGION
}
M7.EN.4 {@ Enclosure of VIAx-1 bar in LOWMEDN >= 0.21
  X1 = ANGLE P_RING_VIA6 != 45
  X3 = ANGLE M7 != 45
  ENC P_RING_VIA6 M7 < Mx_EN_4-GRID ABUT < 90 REGION
  ENC X1 X3 < Mx_EN_4 ABUT < 90 REGION
}
VIA7.W.6 { @ Width of VIAx bar in protection ring = 0.07
  X1 = ANGLE P_RING_VIA7 != 45
  X2 = ANGLE P_RING_VIA7 == 45
  INT X1 > VIAx_W_6 < VIAx_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIAx_W_6+GRID < VIAx_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH P_RING_VIA7 >= VIAx_W_6*2
  INT X1 < VIAx_W_6 ABUT < 90 REGION
  INT X2 < VIAx_W_6-GRID ABUT < 90 REGION
}
VIA7.S.7 { @ Space of VIAx bar in LOWMEDN to VIAx hole >= 0.365
  EXT P_RING_VIA7 VIA7_EXD < VIAx_S_7 ABUT < 90 SINGULAR REGION
}
VIA7.S.8 { @ Space of VIAx bar in LOWMEDN >= 0.74
  EXT P_RING_VIA7 < VIAx_S_8 ABUT < 90 SINGULAR REGION
}
VIA7.EN.8 {@ VIAx bar enclosure by M1/Mx in LOWMEDN >= 0.21
  X1 = ANGLE P_RING_VIA7 != 45
  X3 = ANGLE M7 != 45
  ENC P_RING_VIA7 M7 < VIAx_EN_8-GRID ABUT < 90 REGION
  ENC X1 X3 < VIAx_EN_8 ABUT < 90 REGION
}
M8.EN.4 {@ Enclosure of VIAx-1 bar in LOWMEDN >= 0.21
  X1 = ANGLE P_RING_VIA7 != 45
  X3 = ANGLE M8 != 45
  ENC P_RING_VIA7 M8 < Mx_EN_4-GRID ABUT < 90 REGION
  ENC X1 X3 < Mx_EN_4 ABUT < 90 REGION
}



// RV CHECKS
//==========
RV_CHECK = RV NOT SEALRING_EXCLUDE
RV_NIND = RV_CHECK NOT INSIDE IND_EXD
RV_IND = RV_CHECK INSIDE IND_EXD

RV.W.1 { @ Width (maximum =minimum) (It is allowed to have both via dimensions in same chip.This check doesn't include the sealring region) = 3 or 2 
  A = NOT RECTANGLE RV_NIND == RV_W_1A BY == RV_W_1A ORTHOGONAL ONLY
  NOT RECTANGLE A == RV_W_1B BY == RV_W_1B ORTHOGONAL ONLY
  B = NOT RECTANGLE RV_IND >= (RV_W_1A-2*GRID) <= (RV_W_1A+2*GRID) BY >= (RV_W_1A-2*GRID) <= (RV_W_1A+2*GRID)
  NOT RECTANGLE B >= (RV_W_1B-2*GRID) <= (RV_W_1B+2*GRID) BY >= (RV_W_1B-2*GRID) <= (RV_W_1B+2*GRID)

}
RV.S.1 { @ Space >= 2 
  EXT RV_NIND RV < RV_S_1 ABUT < 90 SINGULAR REGION
  EXT RV_IND RV < RV_S_1-2*GRID ABUT < 90 SINGULAR REGION
}
RV.EN.1 { @ Enclosure by top metal >= 0.5 
  ENC RV_NIND M10 < RV_EN_1 ABUT < 90 SINGULAR REGION OUTSIDE ALSO
  ENC RV_IND M10 < RV_EN_1-2*GRID ABUT < 90 SINGULAR REGION OUTSIDE ALSO
}
RV.R.1 { @ A 45-degree rotated RV is not allowed (Except INDDMY)   
  (NOT RECTANGLE RV_CHECK ORTHOGONAL ONLY) NOT INSIDE IND_EXD
}

// AP CHECKS
//==========
AP.W.1 { @ Width (as interconnect) >= ^AP_W_1 um
  (INT AP < AP_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE IND_EXD
  (INT AP < AP_W_1-2*GRID ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_EXD
}
AP.W.2 { @ Maximum width (as interconnect) {Not inside UBM, CB or CB2} <= 35 
  A = (((AP NOT UBMi) NOT CBi) NOT CB2Fi) NOT CB2Wi
  (A WITH WIDTH > AP_W_2) NOT INSIDE IND_EXD
  (A WITH WIDTH > AP_W_2+2*GRID) NOT OUTSIDE IND_EXD
}
AP.S.1 { @ Space >= 2 
  (EXT AP < AP_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE IND_EXD
  (EXT AP < AP_S_1-2*GRID ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_EXD
}
AP.EN.1 { @ Enclosure of RV >= 0.5 
  ENC RV_NIND AP < AP_EN_1 ABUT < 90 SINGULAR REGION OUTSIDE ALSO
  ENC RV_IND AP < AP_EN_1-2*GRID ABUT < 90 SINGULAR REGION OUTSIDE ALSO
}

#IFDEF FULL_CHIP
AP.DN.1 { @ AP density across full chip >= ^AP_DN_1
  DENSITY APi CHIP > 0 < AP_DN_1 INSIDE OF LAYER CHIPx PRINT AP.DN.1.density
   [AREA(APi)/AREA(CHIP)]   
}
AP.DN.1.1 { @ AP density across full chip <= ^AP_DN_1_1
  DENSITY APi CHIP > AP_DN_1_1 INSIDE OF LAYER CHIPx PRINT AP.DN.1.1.density
   [AREA(APi)/AREA(CHIP)]   
}
#ENDIF


#IFDEF HALF_NODE
VARIABLE m1_thickness 0.125
#ELSE
VARIABLE m1_thickness 0.13
#ENDIF
#IFDEF HALF_NODE
VARIABLE m2_thickness 0.15
#ELSE
VARIABLE m2_thickness 0.14
#ENDIF
#IFDEF HALF_NODE
VARIABLE m3_thickness 0.15
#ELSE
VARIABLE m3_thickness 0.14
#ENDIF
#IFDEF HALF_NODE
VARIABLE m4_thickness 0.15
#ELSE
VARIABLE m4_thickness 0.14
#ENDIF
#IFDEF HALF_NODE
VARIABLE m5_thickness 0.15
#ELSE
VARIABLE m5_thickness 0.14
#ENDIF
#IFDEF HALF_NODE
VARIABLE m6_thickness 0.15
#ELSE
VARIABLE m6_thickness 0.14
#ENDIF
#IFDEF HALF_NODE
VARIABLE m7_thickness 0.15
#ELSE
VARIABLE m7_thickness 0.14
#ENDIF
#IFDEF HALF_NODE
VARIABLE m8_thickness 0.15
#ELSE
VARIABLE m8_thickness 0.14
#ENDIF
#IFDEF HALF_NODE
VARIABLE m9_thickness 0.85
#ELSE
VARIABLE m9_thickness 0.9
#ENDIF
#IFDEF HALF_NODE
VARIABLE m10_thickness 0.85
#ELSE
VARIABLE m10_thickness 0.9
#ENDIF
#IFDEF AP_36K_THICKNESS 
VARIABLE ap_thickness 3.6
#ELSE
#IFDEF AP_28K_THICKNESS
VARIABLE ap_thickness 2.8
#ELSE
#IFDEF AP_20K_THICKNESS
VARIABLE ap_thickness 2.0
#ELSE
VARIABLE ap_thickness 1.45
#ENDIF
#ENDIF
#ENDIF

// MOM CHECKS
//===========
CHIP_MOM = COPY CHIPx
CONNECT CHIP_MOM

MOM_M1 = MOMDMY_1 AND M1
MOM_M1_EDGE = M1 COIN INSIDE EDGE MOM_M1
MOM_M1_LINE_END = CONVEX EDGE MOM_M1_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_M1_SIDE_EDGE = MOM_M1_EDGE NOT COIN INSIDE EDGE MOM_M1_LINE_END
MOM_M1_CAP_EDGE = EXT [MOM_M1_SIDE_EDGE] < (M1_W_1+2*M1_S_1) OPPOSITE SPACE
MOM_M1_CAP_EDGE_EXP = EXPAND EDGE MOM_M1_CAP_EDGE INSIDE BY 0.001
MOM_M1_CAP_EDGE_EXP_C = STAMP MOM_M1_CAP_EDGE_EXP BY CHIP_MOM

MOM_M2 = MOMDMY_2 AND M2
MOM_M2_EDGE = M2 COIN INSIDE EDGE MOM_M2
MOM_M2_LINE_END = CONVEX EDGE MOM_M2_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_M2_SIDE_EDGE = MOM_M2_EDGE NOT COIN INSIDE EDGE MOM_M2_LINE_END
MOM_M2_CAP_EDGE = EXT [MOM_M2_SIDE_EDGE] < (M2_W_1+2*M2_S_1) OPPOSITE SPACE
MOM_M2_CAP_EDGE_EXP = EXPAND EDGE MOM_M2_CAP_EDGE INSIDE BY 0.001
MOM_M2_CAP_EDGE_EXP_C = STAMP MOM_M2_CAP_EDGE_EXP BY CHIP_MOM

MOM_M3 = MOMDMY_3 AND M3
MOM_M3_EDGE = M3 COIN INSIDE EDGE MOM_M3
MOM_M3_LINE_END = CONVEX EDGE MOM_M3_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_M3_SIDE_EDGE = MOM_M3_EDGE NOT COIN INSIDE EDGE MOM_M3_LINE_END
MOM_M3_CAP_EDGE = EXT [MOM_M3_SIDE_EDGE] < (M3_W_1+2*M3_S_1) OPPOSITE SPACE
MOM_M3_CAP_EDGE_EXP = EXPAND EDGE MOM_M3_CAP_EDGE INSIDE BY 0.001
MOM_M3_CAP_EDGE_EXP_C = STAMP MOM_M3_CAP_EDGE_EXP BY CHIP_MOM

MOM_M4 = MOMDMY_4 AND M4
MOM_M4_EDGE = M4 COIN INSIDE EDGE MOM_M4
MOM_M4_LINE_END = CONVEX EDGE MOM_M4_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_M4_SIDE_EDGE = MOM_M4_EDGE NOT COIN INSIDE EDGE MOM_M4_LINE_END
MOM_M4_CAP_EDGE = EXT [MOM_M4_SIDE_EDGE] < (M4_W_1+2*M4_S_1) OPPOSITE SPACE
MOM_M4_CAP_EDGE_EXP = EXPAND EDGE MOM_M4_CAP_EDGE INSIDE BY 0.001
MOM_M4_CAP_EDGE_EXP_C = STAMP MOM_M4_CAP_EDGE_EXP BY CHIP_MOM

MOM_M5 = MOMDMY_5 AND M5
MOM_M5_EDGE = M5 COIN INSIDE EDGE MOM_M5
MOM_M5_LINE_END = CONVEX EDGE MOM_M5_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_M5_SIDE_EDGE = MOM_M5_EDGE NOT COIN INSIDE EDGE MOM_M5_LINE_END
MOM_M5_CAP_EDGE = EXT [MOM_M5_SIDE_EDGE] < (M5_W_1+2*M5_S_1) OPPOSITE SPACE
MOM_M5_CAP_EDGE_EXP = EXPAND EDGE MOM_M5_CAP_EDGE INSIDE BY 0.001
MOM_M5_CAP_EDGE_EXP_C = STAMP MOM_M5_CAP_EDGE_EXP BY CHIP_MOM

MOM_M6 = MOMDMY_6 AND M6
MOM_M6_EDGE = M6 COIN INSIDE EDGE MOM_M6
MOM_M6_LINE_END = CONVEX EDGE MOM_M6_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_M6_SIDE_EDGE = MOM_M6_EDGE NOT COIN INSIDE EDGE MOM_M6_LINE_END
MOM_M6_CAP_EDGE = EXT [MOM_M6_SIDE_EDGE] < (M6_W_1+2*M6_S_1) OPPOSITE SPACE
MOM_M6_CAP_EDGE_EXP = EXPAND EDGE MOM_M6_CAP_EDGE INSIDE BY 0.001
MOM_M6_CAP_EDGE_EXP_C = STAMP MOM_M6_CAP_EDGE_EXP BY CHIP_MOM

MOM_M7 = MOMDMY_7 AND M7
MOM_M7_EDGE = M7 COIN INSIDE EDGE MOM_M7
MOM_M7_LINE_END = CONVEX EDGE MOM_M7_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_M7_SIDE_EDGE = MOM_M7_EDGE NOT COIN INSIDE EDGE MOM_M7_LINE_END
MOM_M7_CAP_EDGE = EXT [MOM_M7_SIDE_EDGE] < (M7_W_1+2*M7_S_1) OPPOSITE SPACE
MOM_M7_CAP_EDGE_EXP = EXPAND EDGE MOM_M7_CAP_EDGE INSIDE BY 0.001
MOM_M7_CAP_EDGE_EXP_C = STAMP MOM_M7_CAP_EDGE_EXP BY CHIP_MOM

MOM_M8 = MOMDMY_8 AND M8
MOM_M8_EDGE = M8 COIN INSIDE EDGE MOM_M8
MOM_M8_LINE_END = CONVEX EDGE MOM_M8_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_M8_SIDE_EDGE = MOM_M8_EDGE NOT COIN INSIDE EDGE MOM_M8_LINE_END
MOM_M8_CAP_EDGE = EXT [MOM_M8_SIDE_EDGE] < (M8_W_1+2*M8_S_1) OPPOSITE SPACE
MOM_M8_CAP_EDGE_EXP = EXPAND EDGE MOM_M8_CAP_EDGE INSIDE BY 0.001
MOM_M8_CAP_EDGE_EXP_C = STAMP MOM_M8_CAP_EDGE_EXP BY CHIP_MOM

MOM_M9 = MOMDMY_9 AND M9
MOM_M9_EDGE = M9 COIN INSIDE EDGE MOM_M9
MOM_M9_LINE_END = CONVEX EDGE MOM_M9_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_M9_SIDE_EDGE = MOM_M9_EDGE NOT COIN INSIDE EDGE MOM_M9_LINE_END
MOM_M9_CAP_EDGE = EXT [MOM_M9_SIDE_EDGE] < (M9_W_1+2*M9_S_1) OPPOSITE SPACE
MOM_M9_CAP_EDGE_EXP = EXPAND EDGE MOM_M9_CAP_EDGE INSIDE BY 0.001
MOM_M9_CAP_EDGE_EXP_C = STAMP MOM_M9_CAP_EDGE_EXP BY CHIP_MOM

MOM_M10 = MOMDMY_10 AND M10
MOM_M10_EDGE = M10 COIN INSIDE EDGE MOM_M10
MOM_M10_LINE_END = CONVEX EDGE MOM_M10_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_M10_SIDE_EDGE = MOM_M10_EDGE NOT COIN INSIDE EDGE MOM_M10_LINE_END
MOM_M10_CAP_EDGE = EXT [MOM_M10_SIDE_EDGE] < (M10_W_1+2*M10_S_1) OPPOSITE SPACE
MOM_M10_CAP_EDGE_EXP = EXPAND EDGE MOM_M10_CAP_EDGE INSIDE BY 0.001
MOM_M10_CAP_EDGE_EXP_C = STAMP MOM_M10_CAP_EDGE_EXP BY CHIP_MOM

MOM_AP = MOMDMY_AP AND AP
MOM_AP_EDGE = AP COIN INSIDE EDGE MOM_AP
MOM_AP_LINE_END = CONVEX EDGE MOM_AP_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_AP_SIDE_EDGE = MOM_AP_EDGE NOT COIN INSIDE EDGE MOM_AP_LINE_END
MOM_AP_CAP_EDGE = EXT [MOM_AP_SIDE_EDGE] < (AP_W_1+2*AP_S_1) OPPOSITE SPACE
MOM_AP_CAP_EDGE_EXP = EXPAND EDGE MOM_AP_CAP_EDGE INSIDE BY 0.001
MOM_AP_CAP_EDGE_EXP_C = STAMP MOM_AP_CAP_EDGE_EXP BY CHIP_MOM

MOM.S.2.M1 { @ Space of metal (M1/Mx) line end in MOMDMY_n >= 0.10 
  EXT MOM_M1_LINE_END M1 < MOM_S_2 ABUT < 90 REGION
}
MOM.S.2.M2 { @ Space of metal (M1/Mx) line end in MOMDMY_n >= 0.10 
  EXT MOM_M2_LINE_END M2 < MOM_S_2 ABUT < 90 REGION
}
MOM.S.2.M3 { @ Space of metal (M1/Mx) line end in MOMDMY_n >= 0.10 
  EXT MOM_M3_LINE_END M3 < MOM_S_2 ABUT < 90 REGION
}
MOM.S.2.M4 { @ Space of metal (M1/Mx) line end in MOMDMY_n >= 0.10 
  EXT MOM_M4_LINE_END M4 < MOM_S_2 ABUT < 90 REGION
}
MOM.S.2.M5 { @ Space of metal (M1/Mx) line end in MOMDMY_n >= 0.10 
  EXT MOM_M5_LINE_END M5 < MOM_S_2 ABUT < 90 REGION
}
MOM.S.2.M6 { @ Space of metal (M1/Mx) line end in MOMDMY_n >= 0.10 
  EXT MOM_M6_LINE_END M6 < MOM_S_2 ABUT < 90 REGION
}
MOM.S.2.M7 { @ Space of metal (M1/Mx) line end in MOMDMY_n >= 0.10 
  EXT MOM_M7_LINE_END M7 < MOM_S_2 ABUT < 90 REGION
}
MOM.S.2.M8 { @ Space of metal (M1/Mx) line end in MOMDMY_n >= 0.10 
  EXT MOM_M8_LINE_END M8 < MOM_S_2 ABUT < 90 REGION
}

MOM.A.1 { @ Maximum sidewall area of total metals in MOM without Via. For the definition of the sidewall area of total metals, please refer to the following figure <= 1.31E+06 
   NET AREA RATIO CHIP_MOM MOM_M1_CAP_EDGE_EXP_C MOM_M2_CAP_EDGE_EXP_C MOM_M3_CAP_EDGE_EXP_C MOM_M4_CAP_EDGE_EXP_C MOM_M5_CAP_EDGE_EXP_C MOM_M6_CAP_EDGE_EXP_C MOM_M7_CAP_EDGE_EXP_C MOM_M8_CAP_EDGE_EXP_C MOM_M9_CAP_EDGE_EXP_C MOM_M10_CAP_EDGE_EXP_C MOM_AP_CAP_EDGE_EXP_C > MOM_A_1
  [
    ( AREA(MOM_M1_CAP_EDGE_EXP_C)*500*m1_thickness+ AREA(MOM_M2_CAP_EDGE_EXP_C)*500*m2_thickness+ AREA(MOM_M3_CAP_EDGE_EXP_C)*500*m3_thickness+ AREA(MOM_M4_CAP_EDGE_EXP_C)*500*m4_thickness+ AREA(MOM_M5_CAP_EDGE_EXP_C)*500*m5_thickness+ AREA(MOM_M6_CAP_EDGE_EXP_C)*500*m6_thickness+ AREA(MOM_M7_CAP_EDGE_EXP_C)*500*m7_thickness+ AREA(MOM_M8_CAP_EDGE_EXP_C)*500*m8_thickness+ AREA(MOM_M9_CAP_EDGE_EXP_C)*500*m9_thickness+ AREA(MOM_M10_CAP_EDGE_EXP_C)*500*m10_thickness+ AREA(MOM_AP_CAP_EDGE_EXP_C)*500*ap_thickness)
  ] RDB MOM.A.1.rep
}

MOM.R.1 { @ VIA in MOMDMY is not allowed.   
  MOMDMY_1 AND VIA1
  MOMDMY_2 AND VIA1
  MOMDMY_2 AND VIA2
  MOMDMY_3 AND VIA2
  MOMDMY_3 AND VIA3
  MOMDMY_4 AND VIA3
  MOMDMY_4 AND VIA4
  MOMDMY_5 AND VIA4
  MOMDMY_5 AND VIA5
  MOMDMY_6 AND VIA5
  MOMDMY_6 AND VIA6
  MOMDMY_7 AND VIA6
  MOMDMY_7 AND VIA7
  MOMDMY_8 AND VIA7
  MOMDMY_8 AND VIA8
  MOMDMY_9 AND VIA8
  MOMDMY_9 AND VIA9
  MOMDMY_10 AND VIA9
  MOMDMY_10 AND RV
  MOMDMY_AP AND RV
}

#IFDEF FULL_CHIP
MOM.R.2 { @ Each MOM cell must be covered by MOMDMY_n (n=155;0~10/20/21/100). DRC only flags no MOMDMY_n(n=155;0~10/20/21/100) in the chip. But if there is no MOM cell in the chip, the violation can be waived.
  MOMDMY_LAYERS = ((((((((((((MOMDMY_1 OR MOMDMY_2) OR MOMDMY_3) OR MOMDMY_4) OR MOMDMY_5) OR MOMDMY_6) OR MOMDMY_7) OR MOMDMY_8) OR MOMDMY_9) OR MOMDMY_10) OR MOMDMY_AP) OR MOMDMY) OR MOMDMY_0) OR MOMDMY_100
  CHIPx NOT INTERACT MOMDMY_LAYERS
}
#ENDIF



//DM1 CHECKS
//===========

DM1.W.1 { @ Width >= ^DM1_W_1 um
  INT DUM1 < DM1_W_1 ABUT < 90 SINGULAR REGION
}
DM1.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= 3.0 
  SIZE DUM1 BY DM1_W_2 /2 UNDEROVER
}
DM1.S.1 { @ Space >= ^DM1_S_1 um
  EXT DUM1 < DM1_S_1 ABUT < 90 SINGULAR REGION
}
DM1.S.2 { @ Space to Mx (Overlap is not allowed) >= ^DM1_S_2a/^DM1_S_2b um
  DUM1a = DUM1 WITH WIDTH <= 1
  DUM1b = DUM1 WITH WIDTH >  1	
  EXT M1i DUM1a < DM1_S_2a ABUT < 90 SINGULAR REGION
  EXT M1i DUM1b < DM1_S_2b ABUT < 90 SINGULAR REGION
  M1i AND DUM1
}
DM1.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= 1.5 
  M1_Wide = M1Wide_3_0 WITH WIDTH > DM1_S_3_W
  X = EXT M1_Wide DUM1 < DM1_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM1_S_2a DM1_S_3_L+GRID
}

#IFDEF FULL_CHIP
DM1.EN.1 { @ Enclosure by chip edge >= 2.5 
    DUM1 NOT (SIZE CHIP_EDGE BY -DM1_EN_1)
}
#ENDIF


DM1.A.1 { @ Min. area >= ^DM1_A_1 um2
  AREA DUM1 < DM1_A_1 
}
DM1.A.2 { @ Max. area <= ^DM1_A_2 um2
  AREA DUM1 > DM1_A_2 
}

#IFDEF FULL_CHIP
DM1.R.1 { @ DM1 is a must. The DM1 CAD layer (TSMC default, 31;1 for DM1) must be different from the M1 CAD layer.
  CHIPx NOT INTERACT DUM1
}
#ENDIF

// DM1.R.2 is checked by CSR.R.1.DUM1

DM1.R.3 { @ Only rectangle and solid dummy is allowed
  NOT RECTANGLE DUM1
}

DM1_O.R.1 { @ DMx_O INTERACT Mx is not allowed
   DM1_O INTERACT M1i_R
}    

//DM2 CHECKS
//===========

DM2.W.1 { @ Width >= ^DM2_W_1 um
  INT DUM2 < DM2_W_1 ABUT < 90 SINGULAR REGION
}
DM2.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= 3.0 
  SIZE DUM2 BY DM2_W_2 /2 UNDEROVER
}
DM2.S.1 { @ Space >= ^DM2_S_1 um
  EXT DUM2 < DM2_S_1 ABUT < 90 SINGULAR REGION
}
DM2.S.2 { @ Space to Mx (Overlap is not allowed) >= ^DM2_S_2a/^DM2_S_2b um
  DUM2a = DUM2 WITH WIDTH <= 1
  DUM2b = DUM2 WITH WIDTH >  1	
  EXT M2i DUM2a < DM2_S_2a ABUT < 90 SINGULAR REGION
  EXT M2i DUM2b < DM2_S_2b ABUT < 90 SINGULAR REGION
  M2i AND DUM2
}
DM2.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= 1.5 
  M2_Wide = M2Wide_3_0 WITH WIDTH > DM2_S_3_W
  X = EXT M2_Wide DUM2 < DM2_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM2_S_2a DM2_S_3_L+GRID
}

#IFDEF FULL_CHIP
DM2.EN.1 { @ Enclosure by chip edge >= 2.5 
    DUM2 NOT (SIZE CHIP_EDGE BY -DM2_EN_1)
}
#ENDIF

DM2.EN.2 { @ Enclosure of DVIAx 0.01  
   ENC DVIA1 DUM2 < DM2_EN_2 ABUT < 90 SINGULAR REGION
}

DM2.A.1 { @ Min. area >= ^DM2_A_1 um2
  AREA DUM2 < DM2_A_1 
}
DM2.A.2 { @ Max. area <= ^DM2_A_2 um2
  AREA DUM2 > DM2_A_2 
}

#IFDEF FULL_CHIP
DM2.R.1 { @ DM2 is a must. The DM2 CAD layer (TSMC default, 32;1 for DM2) must be different from the M2 CAD layer.
  CHIPx NOT INTERACT DUM2
}
#ENDIF

// DM2.R.2 is checked by CSR.R.1.DUM2

DM2.R.3 { @ Only rectangle and solid dummy is allowed
  NOT RECTANGLE DUM2
}

DM2_O.R.1 { @ DMx_O INTERACT Mx is not allowed
   DM2_O INTERACT M2i_R
}    

//DM3 CHECKS
//===========

DM3.W.1 { @ Width >= ^DM3_W_1 um
  INT DUM3 < DM3_W_1 ABUT < 90 SINGULAR REGION
}
DM3.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= 3.0 
  SIZE DUM3 BY DM3_W_2 /2 UNDEROVER
}
DM3.S.1 { @ Space >= ^DM3_S_1 um
  EXT DUM3 < DM3_S_1 ABUT < 90 SINGULAR REGION
}
DM3.S.2 { @ Space to Mx (Overlap is not allowed) >= ^DM3_S_2a/^DM3_S_2b um
  DUM3a = DUM3 WITH WIDTH <= 1
  DUM3b = DUM3 WITH WIDTH >  1	
  EXT M3i DUM3a < DM3_S_2a ABUT < 90 SINGULAR REGION
  EXT M3i DUM3b < DM3_S_2b ABUT < 90 SINGULAR REGION
  M3i AND DUM3
}
DM3.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= 1.5 
  M3_Wide = M3Wide_3_0 WITH WIDTH > DM3_S_3_W
  X = EXT M3_Wide DUM3 < DM3_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM3_S_2a DM3_S_3_L+GRID
}

#IFDEF FULL_CHIP
DM3.EN.1 { @ Enclosure by chip edge >= 2.5 
    DUM3 NOT (SIZE CHIP_EDGE BY -DM3_EN_1)
}
#ENDIF

DM3.EN.2 { @ Enclosure of DVIAx 0.01  
   ENC DVIA2 DUM3 < DM3_EN_2 ABUT < 90 SINGULAR REGION
}

DM3.A.1 { @ Min. area >= ^DM3_A_1 um2
  AREA DUM3 < DM3_A_1 
}
DM3.A.2 { @ Max. area <= ^DM3_A_2 um2
  AREA DUM3 > DM3_A_2 
}

#IFDEF FULL_CHIP
DM3.R.1 { @ DM3 is a must. The DM3 CAD layer (TSMC default, 33;1 for DM3) must be different from the M3 CAD layer.
  CHIPx NOT INTERACT DUM3
}
#ENDIF

// DM3.R.2 is checked by CSR.R.1.DUM3

DM3.R.3 { @ Only rectangle and solid dummy is allowed
  NOT RECTANGLE DUM3
}

DM3_O.R.1 { @ DMx_O INTERACT Mx is not allowed
   DM3_O INTERACT M3i_R
}    

//DM4 CHECKS
//===========

DM4.W.1 { @ Width >= ^DM4_W_1 um
  INT DUM4 < DM4_W_1 ABUT < 90 SINGULAR REGION
}
DM4.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= 3.0 
  SIZE DUM4 BY DM4_W_2 /2 UNDEROVER
}
DM4.S.1 { @ Space >= ^DM4_S_1 um
  EXT DUM4 < DM4_S_1 ABUT < 90 SINGULAR REGION
}
DM4.S.2 { @ Space to Mx (Overlap is not allowed) >= ^DM4_S_2a/^DM4_S_2b um
  DUM4a = DUM4 WITH WIDTH <= 1
  DUM4b = DUM4 WITH WIDTH >  1	
  EXT M4i DUM4a < DM4_S_2a ABUT < 90 SINGULAR REGION
  EXT M4i DUM4b < DM4_S_2b ABUT < 90 SINGULAR REGION
  M4i AND DUM4
}
DM4.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= 1.5 
  M4_Wide = M4Wide_3_0 WITH WIDTH > DM4_S_3_W
  X = EXT M4_Wide DUM4 < DM4_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM4_S_2a DM4_S_3_L+GRID
}

#IFDEF FULL_CHIP
DM4.EN.1 { @ Enclosure by chip edge >= 2.5 
    DUM4 NOT (SIZE CHIP_EDGE BY -DM4_EN_1)
}
#ENDIF

DM4.EN.2 { @ Enclosure of DVIAx 0.01  
   ENC DVIA3 DUM4 < DM4_EN_2 ABUT < 90 SINGULAR REGION
}

DM4.A.1 { @ Min. area >= ^DM4_A_1 um2
  AREA DUM4 < DM4_A_1 
}
DM4.A.2 { @ Max. area <= ^DM4_A_2 um2
  AREA DUM4 > DM4_A_2 
}

#IFDEF FULL_CHIP
DM4.R.1 { @ DM4 is a must. The DM4 CAD layer (TSMC default, 34;1 for DM4) must be different from the M4 CAD layer.
  CHIPx NOT INTERACT DUM4
}
#ENDIF

// DM4.R.2 is checked by CSR.R.1.DUM4

DM4.R.3 { @ Only rectangle and solid dummy is allowed
  NOT RECTANGLE DUM4
}

DM4_O.R.1 { @ DMx_O INTERACT Mx is not allowed
   DM4_O INTERACT M4i_R
}    

//DM5 CHECKS
//===========

DM5.W.1 { @ Width >= ^DM5_W_1 um
  INT DUM5 < DM5_W_1 ABUT < 90 SINGULAR REGION
}
DM5.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= 3.0 
  SIZE DUM5 BY DM5_W_2 /2 UNDEROVER
}
DM5.S.1 { @ Space >= ^DM5_S_1 um
  EXT DUM5 < DM5_S_1 ABUT < 90 SINGULAR REGION
}
DM5.S.2 { @ Space to Mx (Overlap is not allowed) >= ^DM5_S_2a/^DM5_S_2b um
  DUM5a = DUM5 WITH WIDTH <= 1
  DUM5b = DUM5 WITH WIDTH >  1	
  EXT M5i DUM5a < DM5_S_2a ABUT < 90 SINGULAR REGION
  EXT M5i DUM5b < DM5_S_2b ABUT < 90 SINGULAR REGION
  M5i AND DUM5
}
DM5.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= 1.5 
  M5_Wide = M5Wide_3_0 WITH WIDTH > DM5_S_3_W
  X = EXT M5_Wide DUM5 < DM5_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM5_S_2a DM5_S_3_L+GRID
}

#IFDEF FULL_CHIP
DM5.EN.1 { @ Enclosure by chip edge >= 2.5 
    DUM5 NOT (SIZE CHIP_EDGE BY -DM5_EN_1)
}
#ENDIF

DM5.EN.2 { @ Enclosure of DVIAx 0.01  
   ENC DVIA4 DUM5 < DM5_EN_2 ABUT < 90 SINGULAR REGION
}

DM5.A.1 { @ Min. area >= ^DM5_A_1 um2
  AREA DUM5 < DM5_A_1 
}
DM5.A.2 { @ Max. area <= ^DM5_A_2 um2
  AREA DUM5 > DM5_A_2 
}

#IFDEF FULL_CHIP
DM5.R.1 { @ DM5 is a must. The DM5 CAD layer (TSMC default, 35;1 for DM5) must be different from the M5 CAD layer.
  CHIPx NOT INTERACT DUM5
}
#ENDIF

// DM5.R.2 is checked by CSR.R.1.DUM5

DM5.R.3 { @ Only rectangle and solid dummy is allowed
  NOT RECTANGLE DUM5
}

DM5_O.R.1 { @ DMx_O INTERACT Mx is not allowed
   DM5_O INTERACT M5i_R
}    

//DM6 CHECKS
//===========

DM6.W.1 { @ Width >= ^DM6_W_1 um
  INT DUM6 < DM6_W_1 ABUT < 90 SINGULAR REGION
}
DM6.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= 3.0 
  SIZE DUM6 BY DM6_W_2 /2 UNDEROVER
}
DM6.S.1 { @ Space >= ^DM6_S_1 um
  EXT DUM6 < DM6_S_1 ABUT < 90 SINGULAR REGION
}
DM6.S.2 { @ Space to Mx (Overlap is not allowed) >= ^DM6_S_2a/^DM6_S_2b um
  DUM6a = DUM6 WITH WIDTH <= 1
  DUM6b = DUM6 WITH WIDTH >  1	
  EXT M6i DUM6a < DM6_S_2a ABUT < 90 SINGULAR REGION
  EXT M6i DUM6b < DM6_S_2b ABUT < 90 SINGULAR REGION
  M6i AND DUM6
}
DM6.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= 1.5 
  M6_Wide = M6Wide_3_0 WITH WIDTH > DM6_S_3_W
  X = EXT M6_Wide DUM6 < DM6_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM6_S_2a DM6_S_3_L+GRID
}

#IFDEF FULL_CHIP
DM6.EN.1 { @ Enclosure by chip edge >= 2.5 
    DUM6 NOT (SIZE CHIP_EDGE BY -DM6_EN_1)
}
#ENDIF

DM6.EN.2 { @ Enclosure of DVIAx 0.01  
   ENC DVIA5 DUM6 < DM6_EN_2 ABUT < 90 SINGULAR REGION
}

DM6.A.1 { @ Min. area >= ^DM6_A_1 um2
  AREA DUM6 < DM6_A_1 
}
DM6.A.2 { @ Max. area <= ^DM6_A_2 um2
  AREA DUM6 > DM6_A_2 
}

#IFDEF FULL_CHIP
DM6.R.1 { @ DM6 is a must. The DM6 CAD layer (TSMC default, 36;1 for DM6) must be different from the M6 CAD layer.
  CHIPx NOT INTERACT DUM6
}
#ENDIF

// DM6.R.2 is checked by CSR.R.1.DUM6

DM6.R.3 { @ Only rectangle and solid dummy is allowed
  NOT RECTANGLE DUM6
}

DM6_O.R.1 { @ DMx_O INTERACT Mx is not allowed
   DM6_O INTERACT M6i_R
}    

//DM7 CHECKS
//===========

DM7.W.1 { @ Width >= ^DM7_W_1 um
  INT DUM7 < DM7_W_1 ABUT < 90 SINGULAR REGION
}
DM7.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= 3.0 
  SIZE DUM7 BY DM7_W_2 /2 UNDEROVER
}
DM7.S.1 { @ Space >= ^DM7_S_1 um
  EXT DUM7 < DM7_S_1 ABUT < 90 SINGULAR REGION
}
DM7.S.2 { @ Space to Mx (Overlap is not allowed) >= ^DM7_S_2a/^DM7_S_2b um
  DUM7a = DUM7 WITH WIDTH <= 1
  DUM7b = DUM7 WITH WIDTH >  1	
  EXT M7i DUM7a < DM7_S_2a ABUT < 90 SINGULAR REGION
  EXT M7i DUM7b < DM7_S_2b ABUT < 90 SINGULAR REGION
  M7i AND DUM7
}
DM7.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= 1.5 
  M7_Wide = M7Wide_3_0 WITH WIDTH > DM7_S_3_W
  X = EXT M7_Wide DUM7 < DM7_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM7_S_2a DM7_S_3_L+GRID
}

#IFDEF FULL_CHIP
DM7.EN.1 { @ Enclosure by chip edge >= 2.5 
    DUM7 NOT (SIZE CHIP_EDGE BY -DM7_EN_1)
}
#ENDIF

DM7.EN.2 { @ Enclosure of DVIAx 0.01  
   ENC DVIA6 DUM7 < DM7_EN_2 ABUT < 90 SINGULAR REGION
}

DM7.A.1 { @ Min. area >= ^DM7_A_1 um2
  AREA DUM7 < DM7_A_1 
}
DM7.A.2 { @ Max. area <= ^DM7_A_2 um2
  AREA DUM7 > DM7_A_2 
}

#IFDEF FULL_CHIP
DM7.R.1 { @ DM7 is a must. The DM7 CAD layer (TSMC default, 37;1 for DM7) must be different from the M7 CAD layer.
  CHIPx NOT INTERACT DUM7
}
#ENDIF

// DM7.R.2 is checked by CSR.R.1.DUM7

DM7.R.3 { @ Only rectangle and solid dummy is allowed
  NOT RECTANGLE DUM7
}

DM7_O.R.1 { @ DMx_O INTERACT Mx is not allowed
   DM7_O INTERACT M7i_R
}    

//DM8 CHECKS
//===========

DM8.W.1 { @ Width >= ^DM8_W_1 um
  INT DUM8 < DM8_W_1 ABUT < 90 SINGULAR REGION
}
DM8.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= 3.0 
  SIZE DUM8 BY DM8_W_2 /2 UNDEROVER
}
DM8.S.1 { @ Space >= ^DM8_S_1 um
  EXT DUM8 < DM8_S_1 ABUT < 90 SINGULAR REGION
}
DM8.S.2 { @ Space to Mx (Overlap is not allowed) >= ^DM8_S_2a/^DM8_S_2b um
  DUM8a = DUM8 WITH WIDTH <= 1
  DUM8b = DUM8 WITH WIDTH >  1	
  EXT M8i DUM8a < DM8_S_2a ABUT < 90 SINGULAR REGION
  EXT M8i DUM8b < DM8_S_2b ABUT < 90 SINGULAR REGION
  M8i AND DUM8
}
DM8.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= 1.5 
  M8_Wide = M8Wide_3_0 WITH WIDTH > DM8_S_3_W
  X = EXT M8_Wide DUM8 < DM8_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM8_S_2a DM8_S_3_L+GRID
}

#IFDEF FULL_CHIP
DM8.EN.1 { @ Enclosure by chip edge >= 2.5 
    DUM8 NOT (SIZE CHIP_EDGE BY -DM8_EN_1)
}
#ENDIF

DM8.EN.2 { @ Enclosure of DVIAx 0.01  
   ENC DVIA7 DUM8 < DM8_EN_2 ABUT < 90 SINGULAR REGION
}

DM8.A.1 { @ Min. area >= ^DM8_A_1 um2
  AREA DUM8 < DM8_A_1 
}
DM8.A.2 { @ Max. area <= ^DM8_A_2 um2
  AREA DUM8 > DM8_A_2 
}

#IFDEF FULL_CHIP
DM8.R.1 { @ DM8 is a must. The DM8 CAD layer (TSMC default, 38;1 for DM8) must be different from the M8 CAD layer.
  CHIPx NOT INTERACT DUM8
}
#ENDIF

// DM8.R.2 is checked by CSR.R.1.DUM8

DM8.R.3 { @ Only rectangle and solid dummy is allowed
  NOT RECTANGLE DUM8
}

DM8_O.R.1 { @ DMx_O INTERACT Mx is not allowed
   DM8_O INTERACT M8i_R
}    

//DM9 CHECKS
//===========

DM9.W.1 { @ Width >= ^DM9_W_1 um
  INT DUM9 < DM9_W_1 ABUT < 90 SINGULAR REGION
}
DM9.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= 3.0 
  SIZE DUM9 BY DM9_W_2 /2 UNDEROVER
}
DM9.S.1 { @ Space >= ^DM9_S_1 um
  EXT DUM9 < DM9_S_1 ABUT < 90 SINGULAR REGION
}
DM9.S.2 { @ Space to Mx (Overlap is not allowed) >= ^DM9_S_2 um
  EXT M9i DUM9 < DM9_S_2 ABUT < 90 SINGULAR REGION
  M9i AND DUM9
}
DM9.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= 1.5 
  M9_Wide = M9Wide_1.5 WITH WIDTH > DM9_S_3_W
  X = EXT M9_Wide DUM9 < DM9_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM9_S_2 DM9_S_3_L+GRID
}


#IFDEF FULL_CHIP
DM9.EN.1 { @ Enclosure by chip edge >= 2.5 
    DUM9 NOT (SIZE CHIP_EDGE BY -DM9_EN_1)
}
#ENDIF


DM9.A.1 { @ Min. area >= ^DM9_A_1 um2
  AREA DUM9 < DM9_A_1 
}
DM9.A.2 { @ Max. area <= ^DM9_A_2 um2
  AREA DUM9 > DM9_A_2 
}

#IFDEF FULL_CHIP
DM9.R.1 { @ DM9 is a must. The DM9 CAD layer (TSMC default, 39;41 for DM9) must be different from the M9 CAD layer.
  CHIPx NOT INTERACT DUM9
}
#ENDIF

// DM9.R.2 is checked by CSR.R.1.DUM9

DM9.R.3 { @ Only rectangle and solid dummy is allowed
  NOT RECTANGLE DUM9
}


//DM10 CHECKS
//===========

DM10.W.1 { @ Width >= ^DM10_W_1 um
  INT DUM10 < DM10_W_1 ABUT < 90 SINGULAR REGION
}
DM10.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= 3.0 
  SIZE DUM10 BY DM10_W_2 /2 UNDEROVER
}
DM10.S.1 { @ Space >= ^DM10_S_1 um
  EXT DUM10 < DM10_S_1 ABUT < 90 SINGULAR REGION
}
DM10.S.2 { @ Space to Mx (Overlap is not allowed) >= ^DM10_S_2 um
  EXT M10i DUM10 < DM10_S_2 ABUT < 90 SINGULAR REGION
  M10i AND DUM10
}
DM10.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= 1.5 
  M10_Wide = M10Wide_1.5 WITH WIDTH > DM10_S_3_W
  X = EXT M10_Wide DUM10 < DM10_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM10_S_2 DM10_S_3_L+GRID
}


#IFDEF FULL_CHIP
DM10.EN.1 { @ Enclosure by chip edge >= 2.5 
    DUM10 NOT (SIZE CHIP_EDGE BY -DM10_EN_1)
}
#ENDIF


DM10.A.1 { @ Min. area >= ^DM10_A_1 um2
  AREA DUM10 < DM10_A_1 
}
DM10.A.2 { @ Max. area <= ^DM10_A_2 um2
  AREA DUM10 > DM10_A_2 
}

#IFDEF FULL_CHIP
DM10.R.1 { @ DM10 is a must. The DM10 CAD layer (TSMC default, 40;41 for DM10) must be different from the M10 CAD layer.
  CHIPx NOT INTERACT DUM10
}
#ENDIF

// DM10.R.2 is checked by CSR.R.1.DUM10

DM10.R.3 { @ Only rectangle and solid dummy is allowed
  NOT RECTANGLE DUM10
}



//DVIA1 CHECK
//=============

DVIA1.W.1 {@  Width (maximum = minimum) = 0.12
   NOT RECTANGLE DVIA1 == DVIA1_W_1 BY == DVIA1_W_1 ORTHOGONAL ONLY   
}
DVIA1.S.1 {@ Space >= 0.20
   EXT DVIA1 < DVIA1_S_1 ABUT<90 SINGULAR REGION
}
DVIA1.S.2 {@ Space to VIAx >= 0.20
   EXT DVIA1 VIA1 < DVIA1_S_2 ABUT<90 SINGULAR REGION 
}
DVIA1.EN.1 {@ Enclosure by DMx >= 0.01
   ENC DVIA1 DUM1 < DVIA1_EN_1 ABUT<90 SINGULAR REGION 
}
DVIA1.R.1 {@ DVIAx must be fully inside DMx and DMx+1.
   DVIA1 NOT DUM1
   DVIA1 NOT DUM2
}
DVIA1.R.2 {@ DVIAx interact Mx, Mx+1, DMx_O, DMx+1_O is not allowed	
   DVIA1 INTERACT M1
   DVIA1 INTERACT M2
}

#IFDEF FULL_CHIP
#IFDEF DVIAxR3_For_NonFlipChip
DVIAxR3_CHECK = COPY CHIPx
#ELSE
DVIAxR3_CHECK = CHIPx INTERACT UBMi
#ENDIF
DVIA1.R.3 { @ DVIA1 is a must for Flip Chip. 
@ To comply tsmc dummy utility, DRC will flag as violation when the area ratio of (DVIA1 to DM1) and (DVIA1 to DM2) are < 1% at the same time
  A = DENSITY DVIA1 DUM1 < DVIA1_R_3 INSIDE OF LAYER DVIAxR3_CHECK PRINT DVIA1DM1.R.3.density
    	[AREA(DVIA1)/AREA(DUM1)]
  B = DENSITY DVIA1 DUM2 < DVIA1_R_3 INSIDE OF LAYER DVIAxR3_CHECK PRINT DVIA1DM2.R.3.density
    	[AREA(DVIA1)/AREA(DUM2)]
  (CHIPx INTERACT A) INTERACT B
}
#ENDIF


//DVIA2 CHECK
//=============

DVIA2.W.1 {@  Width (maximum = minimum) = 0.12
   NOT RECTANGLE DVIA2 == DVIA2_W_1 BY == DVIA2_W_1 ORTHOGONAL ONLY   
}
DVIA2.S.1 {@ Space >= 0.20
   EXT DVIA2 < DVIA2_S_1 ABUT<90 SINGULAR REGION
}
DVIA2.S.2 {@ Space to VIAx >= 0.20
   EXT DVIA2 VIA2 < DVIA2_S_2 ABUT<90 SINGULAR REGION 
}
DVIA2.EN.1 {@ Enclosure by DMx >= 0.01
   ENC DVIA2 DUM2 < DVIA2_EN_1 ABUT<90 SINGULAR REGION 
}
DVIA2.R.1 {@ DVIAx must be fully inside DMx and DMx+1.
   DVIA2 NOT DUM2
   DVIA2 NOT DUM3
}
DVIA2.R.2 {@ DVIAx interact Mx, Mx+1, DMx_O, DMx+1_O is not allowed	
   DVIA2 INTERACT M2
   DVIA2 INTERACT M3
}

#IFDEF FULL_CHIP
DVIA2.R.3 { @ DVIA2 is a must for Flip Chip. 
@ To comply tsmc dummy utility, DRC will flag as violation when the area ratio of (DVIA2 to DM2) and (DVIA2 to DM3) are < 1% at the same time
  A = DENSITY DVIA2 DUM2 < DVIA2_R_3 INSIDE OF LAYER DVIAxR3_CHECK PRINT DVIA2DM2.R.3.density
    	[AREA(DVIA2)/AREA(DUM2)]
  B = DENSITY DVIA2 DUM3 < DVIA2_R_3 INSIDE OF LAYER DVIAxR3_CHECK PRINT DVIA2DM3.R.3.density
    	[AREA(DVIA2)/AREA(DUM3)]
  (CHIPx INTERACT A) INTERACT B
}
#ENDIF


//DVIA3 CHECK
//=============

DVIA3.W.1 {@  Width (maximum = minimum) = 0.12
   NOT RECTANGLE DVIA3 == DVIA3_W_1 BY == DVIA3_W_1 ORTHOGONAL ONLY   
}
DVIA3.S.1 {@ Space >= 0.20
   EXT DVIA3 < DVIA3_S_1 ABUT<90 SINGULAR REGION
}
DVIA3.S.2 {@ Space to VIAx >= 0.20
   EXT DVIA3 VIA3 < DVIA3_S_2 ABUT<90 SINGULAR REGION 
}
DVIA3.EN.1 {@ Enclosure by DMx >= 0.01
   ENC DVIA3 DUM3 < DVIA3_EN_1 ABUT<90 SINGULAR REGION 
}
DVIA3.R.1 {@ DVIAx must be fully inside DMx and DMx+1.
   DVIA3 NOT DUM3
   DVIA3 NOT DUM4
}
DVIA3.R.2 {@ DVIAx interact Mx, Mx+1, DMx_O, DMx+1_O is not allowed	
   DVIA3 INTERACT M3
   DVIA3 INTERACT M4
}

#IFDEF FULL_CHIP
DVIA3.R.3 { @ DVIA3 is a must for Flip Chip. 
@ To comply tsmc dummy utility, DRC will flag as violation when the area ratio of (DVIA3 to DM3) and (DVIA3 to DM4) are < 1% at the same time
  A = DENSITY DVIA3 DUM3 < DVIA3_R_3 INSIDE OF LAYER DVIAxR3_CHECK PRINT DVIA3DM3.R.3.density
    	[AREA(DVIA3)/AREA(DUM3)]
  B = DENSITY DVIA3 DUM4 < DVIA3_R_3 INSIDE OF LAYER DVIAxR3_CHECK PRINT DVIA3DM4.R.3.density
    	[AREA(DVIA3)/AREA(DUM4)]
  (CHIPx INTERACT A) INTERACT B
}
#ENDIF


//DVIA4 CHECK
//=============

DVIA4.W.1 {@  Width (maximum = minimum) = 0.12
   NOT RECTANGLE DVIA4 == DVIA4_W_1 BY == DVIA4_W_1 ORTHOGONAL ONLY   
}
DVIA4.S.1 {@ Space >= 0.20
   EXT DVIA4 < DVIA4_S_1 ABUT<90 SINGULAR REGION
}
DVIA4.S.2 {@ Space to VIAx >= 0.20
   EXT DVIA4 VIA4 < DVIA4_S_2 ABUT<90 SINGULAR REGION 
}
DVIA4.EN.1 {@ Enclosure by DMx >= 0.01
   ENC DVIA4 DUM4 < DVIA4_EN_1 ABUT<90 SINGULAR REGION 
}
DVIA4.R.1 {@ DVIAx must be fully inside DMx and DMx+1.
   DVIA4 NOT DUM4
   DVIA4 NOT DUM5
}
DVIA4.R.2 {@ DVIAx interact Mx, Mx+1, DMx_O, DMx+1_O is not allowed	
   DVIA4 INTERACT M4
   DVIA4 INTERACT M5
}

#IFDEF FULL_CHIP
DVIA4.R.3 { @ DVIA4 is a must for Flip Chip. 
@ To comply tsmc dummy utility, DRC will flag as violation when the area ratio of (DVIA4 to DM4) and (DVIA4 to DM5) are < 1% at the same time
  A = DENSITY DVIA4 DUM4 < DVIA4_R_3 INSIDE OF LAYER DVIAxR3_CHECK PRINT DVIA4DM4.R.3.density
    	[AREA(DVIA4)/AREA(DUM4)]
  B = DENSITY DVIA4 DUM5 < DVIA4_R_3 INSIDE OF LAYER DVIAxR3_CHECK PRINT DVIA4DM5.R.3.density
    	[AREA(DVIA4)/AREA(DUM5)]
  (CHIPx INTERACT A) INTERACT B
}
#ENDIF


//DVIA5 CHECK
//=============

DVIA5.W.1 {@  Width (maximum = minimum) = 0.12
   NOT RECTANGLE DVIA5 == DVIA5_W_1 BY == DVIA5_W_1 ORTHOGONAL ONLY   
}
DVIA5.S.1 {@ Space >= 0.20
   EXT DVIA5 < DVIA5_S_1 ABUT<90 SINGULAR REGION
}
DVIA5.S.2 {@ Space to VIAx >= 0.20
   EXT DVIA5 VIA5 < DVIA5_S_2 ABUT<90 SINGULAR REGION 
}
DVIA5.EN.1 {@ Enclosure by DMx >= 0.01
   ENC DVIA5 DUM5 < DVIA5_EN_1 ABUT<90 SINGULAR REGION 
}
DVIA5.R.1 {@ DVIAx must be fully inside DMx and DMx+1.
   DVIA5 NOT DUM5
   DVIA5 NOT DUM6
}
DVIA5.R.2 {@ DVIAx interact Mx, Mx+1, DMx_O, DMx+1_O is not allowed	
   DVIA5 INTERACT M5
   DVIA5 INTERACT M6
}

#IFDEF FULL_CHIP
DVIA5.R.3 { @ DVIA5 is a must for Flip Chip. 
@ To comply tsmc dummy utility, DRC will flag as violation when the area ratio of (DVIA5 to DM5) and (DVIA5 to DM6) are < 1% at the same time
  A = DENSITY DVIA5 DUM5 < DVIA5_R_3 INSIDE OF LAYER DVIAxR3_CHECK PRINT DVIA5DM5.R.3.density
    	[AREA(DVIA5)/AREA(DUM5)]
  B = DENSITY DVIA5 DUM6 < DVIA5_R_3 INSIDE OF LAYER DVIAxR3_CHECK PRINT DVIA5DM6.R.3.density
    	[AREA(DVIA5)/AREA(DUM6)]
  (CHIPx INTERACT A) INTERACT B
}
#ENDIF


//DVIA6 CHECK
//=============

DVIA6.W.1 {@  Width (maximum = minimum) = 0.12
   NOT RECTANGLE DVIA6 == DVIA6_W_1 BY == DVIA6_W_1 ORTHOGONAL ONLY   
}
DVIA6.S.1 {@ Space >= 0.20
   EXT DVIA6 < DVIA6_S_1 ABUT<90 SINGULAR REGION
}
DVIA6.S.2 {@ Space to VIAx >= 0.20
   EXT DVIA6 VIA6 < DVIA6_S_2 ABUT<90 SINGULAR REGION 
}
DVIA6.EN.1 {@ Enclosure by DMx >= 0.01
   ENC DVIA6 DUM6 < DVIA6_EN_1 ABUT<90 SINGULAR REGION 
}
DVIA6.R.1 {@ DVIAx must be fully inside DMx and DMx+1.
   DVIA6 NOT DUM6
   DVIA6 NOT DUM7
}
DVIA6.R.2 {@ DVIAx interact Mx, Mx+1, DMx_O, DMx+1_O is not allowed	
   DVIA6 INTERACT M6
   DVIA6 INTERACT M7
}

#IFDEF FULL_CHIP
DVIA6.R.3 { @ DVIA6 is a must for Flip Chip. 
@ To comply tsmc dummy utility, DRC will flag as violation when the area ratio of (DVIA6 to DM6) and (DVIA6 to DM7) are < 1% at the same time
  A = DENSITY DVIA6 DUM6 < DVIA6_R_3 INSIDE OF LAYER DVIAxR3_CHECK PRINT DVIA6DM6.R.3.density
    	[AREA(DVIA6)/AREA(DUM6)]
  B = DENSITY DVIA6 DUM7 < DVIA6_R_3 INSIDE OF LAYER DVIAxR3_CHECK PRINT DVIA6DM7.R.3.density
    	[AREA(DVIA6)/AREA(DUM7)]
  (CHIPx INTERACT A) INTERACT B
}
#ENDIF


//DVIA7 CHECK
//=============

DVIA7.W.1 {@  Width (maximum = minimum) = 0.12
   NOT RECTANGLE DVIA7 == DVIA7_W_1 BY == DVIA7_W_1 ORTHOGONAL ONLY   
}
DVIA7.S.1 {@ Space >= 0.20
   EXT DVIA7 < DVIA7_S_1 ABUT<90 SINGULAR REGION
}
DVIA7.S.2 {@ Space to VIAx >= 0.20
   EXT DVIA7 VIA7 < DVIA7_S_2 ABUT<90 SINGULAR REGION 
}
DVIA7.EN.1 {@ Enclosure by DMx >= 0.01
   ENC DVIA7 DUM7 < DVIA7_EN_1 ABUT<90 SINGULAR REGION 
}
DVIA7.R.1 {@ DVIAx must be fully inside DMx and DMx+1.
   DVIA7 NOT DUM7
   DVIA7 NOT DUM8
}
DVIA7.R.2 {@ DVIAx interact Mx, Mx+1, DMx_O, DMx+1_O is not allowed	
   DVIA7 INTERACT M7
   DVIA7 INTERACT M8
}

#IFDEF FULL_CHIP
DVIA7.R.3 { @ DVIA7 is a must for Flip Chip. 
@ To comply tsmc dummy utility, DRC will flag as violation when the area ratio of (DVIA7 to DM7) and (DVIA7 to DM8) are < 1% at the same time
  A = DENSITY DVIA7 DUM7 < DVIA7_R_3 INSIDE OF LAYER DVIAxR3_CHECK PRINT DVIA7DM7.R.3.density
    	[AREA(DVIA7)/AREA(DUM7)]
  B = DENSITY DVIA7 DUM8 < DVIA7_R_3 INSIDE OF LAYER DVIAxR3_CHECK PRINT DVIA7DM8.R.3.density
    	[AREA(DVIA7)/AREA(DUM8)]
  (CHIPx INTERACT A) INTERACT B
}
#ENDIF


#ENDIF


//LOGO CHECKS
//============

LOGO.S.1 { @ Space to OD, PO, or Metals (non-dummy patterns, and non-dummy TCD) (This check doesn't include the M1/ Mx protection ring inside {LOWMEDN NOT (LOWMEDN SIZING -4 um)} region) >=  10 
  LOGO_EXT = (SIZE LOGO BY LOGO_S_1) NOT LOGO
  LOGO_EXT AND (ODi NOT TCDDMY)
  LOGO_EXT AND (POi NOT TCDDMY)
  LOGO_EXT AND (M1i_R NOT P_RING_REGION)
  LOGO_EXT AND (M2i_R NOT P_RING_REGION)
  LOGO_EXT AND (M3i_R NOT P_RING_REGION)
  LOGO_EXT AND (M4i_R NOT P_RING_REGION)
  LOGO_EXT AND (M5i_R NOT P_RING_REGION)
  LOGO_EXT AND (M6i_R NOT P_RING_REGION)
  LOGO_EXT AND (M7i_R NOT P_RING_REGION)
  LOGO_EXT AND (M8i_R NOT P_RING_REGION)
  LOGO_EXT AND M9i
  LOGO_EXT AND M10i
}
LOGO.O.1 { @ Overlap of CB, CBD, PM, UBM is not allowed.   
  LOGO AND CBi
  LOGO AND CBDi
  LOGO AND PMi
  LOGO AND UBMi
}

// LOGO.R.1 can not be checked.
// LOGO.R.2 is checked by related rules.



#IFDEF FULL_CHIP

//CSR CHECKS
//===========
#IFNDEF WITH_SEALRING
CSR.R.1.DNWi { @ DNWi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DNWi
}
CSR.R.1.NWi { @ NWi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND NWi
}
CSR.R.1.OD12i { @ OD12i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD12i
}
CSR.R.1.OD18i { @ OD18i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD18i
}
CSR.R.1.OD1815 { @ OD1815 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD1815
}
CSR.R.1.OD25i { @ OD25i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD25i
}
CSR.R.1.OD2533 { @ OD2533 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD2533
}
CSR.R.1.OD2518 { @ OD2518 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD2518
}
CSR.R.1.OD25_LK { @ OD25_LK is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD25_LK
}
CSR.R.1.OD33i { @ OD33i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD33i
}
CSR.R.1.ODDECAP { @ ODDECAP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND ODDECAP
}
CSR.R.1.PPi { @ PPi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND PPi
}
CSR.R.1.NPi { @ NPi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND NPi
}
CSR.R.1.HVD_N { @ HVD_N is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND HVD_N
}
CSR.R.1.HVD_P { @ HVD_P is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND HVD_P
}
CSR.R.1.COi { @ COi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND COi
}
CSR.R.1.COPUSH { @ COPUSH is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND COPUSH
}
CSR.R.1.COiSRAM { @ COiSRAM is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND COiSRAM
}
CSR.R.1.CBi { @ CBi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CBi
}
CSR.R.1.CB2Fi { @ CB2Fi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CB2Fi
}
CSR.R.1.CB2Wi { @ CB2Wi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CB2Wi
}
CSR.R.1.RPOi { @ RPOi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND RPOi
}
CSR.R.1.NTNi { @ NTNi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND NTNi
}
CSR.R.1.NCapNTNi { @ NCapNTNi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND NCapNTNi
}
CSR.R.1.LPP_NTNi { @ LPP_NTNi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND LPP_NTNi
}
CSR.R.1.LPP_NTN_21i { @ LPP_NTN_21i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND LPP_NTN_21i
}
CSR.R.1.LPP_NTN_DPOi { @ LPP_NTN_DPOi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND LPP_NTN_DPOi
}
CSR.R.1.LPP_NTN_120i { @ LPP_NTN_120i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND LPP_NTN_120i
}
CSR.R.1.POFUSE { @ POFUSE is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND POFUSE
}
CSR.R.1.FUSELINK { @ FUSELINK is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND FUSELINK
}
CSR.R.1.PMi { @ PMi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND PMi
}
CSR.R.1.PM1i { @ PM1i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND PM1i
}
CSR.R.1.PM2i { @ PM2i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND PM2i
}
CSR.R.1.SEALRING_ORI { @ SEALRING_ORI is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SEALRING_ORI
}
CSR.R.1.SEALRING_DB { @ SEALRING_DB is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SEALRING_DB
}
CSR.R.1.SEALRING_ALL { @ SEALRING_ALL is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SEALRING_ALL
}
CSR.R.1.VTHNi { @ VTHNi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VTHNi
}
CSR.R.1.VTHPi { @ VTHPi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VTHPi
}
CSR.R.1.VTLNi { @ VTLNi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VTLNi
}
CSR.R.1.VTLPi { @ VTLPi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VTLPi
}
CSR.R.1.VTULNi { @ VTULNi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VTULNi
}
CSR.R.1.VTULPi { @ VTULPi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VTULPi
}
CSR.R.1.VTLN18 { @ VTLN18 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VTLN18
}
CSR.R.1.CBDi { @ CBDi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CBDi
}
CSR.R.1.CBDB { @ CBDB is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CBDB
}
CSR.R.1.UBMi { @ UBMi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND UBMi
}
CSR.R.1.UBMB { @ UBMB is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND UBMB
}
CSR.R.1.RH { @ RH is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND RH
}
CSR.R.1.ESDIMP { @ ESDIMP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND ESDIMP
}
CSR.R.1.VARi { @ VARi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VARi
}
CSR.R.1.DVAR { @ DVAR is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DVAR
}
CSR.R.1.APi { @ APi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND APi
}
CSR.R.1.Cu_PPIi { @ Cu_PPIi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND Cu_PPIi
}
CSR.R.1.AP_BSL { @ AP_BSL is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND AP_BSL
}
CSR.R.1.AP_BSP { @ AP_BSP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND AP_BSP
}
CSR.R.1.CBMi { @ CBMi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CBMi
}
CSR.R.1.CTMi { @ CTMi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CTMi
}
CSR.R.1.RVi { @ RVi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND RVi
}
CSR.R.1.RV_BSL { @ RV_BSL is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND RV_BSL
}
CSR.R.1.DCOi { @ DCOi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DCOi
}
CSR.R.1.LMARK { @ LMARK is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND LMARK
}
CSR.R.1.SRM { @ SRM is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRM
}
CSR.R.1.SRMN { @ SRMN is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRMN
}
CSR.R.1.SRMP { @ SRMP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRMP
}
CSR.R.1.SRMRP { @ SRMRP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRMRP
}
CSR.R.1.NPreDOSRM { @ NPreDOSRM is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND NPreDOSRM
}
CSR.R.1.ROM { @ ROM is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND ROM
}
CSR.R.1.SRM_HS { @ SRM_HS is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRM_HS
}
CSR.R.1.SRAMDMY { @ SRAMDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRAMDMY
}
CSR.R.1.SRAMDMY_PAS { @ SRAMDMY_PAS is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRAMDMY_PAS
}
CSR.R.1.SRAMDMY_PERI_LP { @ SRAMDMY_PERI_LP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRAMDMY_PERI_LP
}
CSR.R.1.SRAMDMY_PERI_G { @ SRAMDMY_PERI_G is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRAMDMY_PERI_G
}
CSR.R.1.CO2 { @ CO2 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CO2
}
CSR.R.1.DPSRM { @ DPSRM is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DPSRM
}
CSR.R.1.PRSRM { @ PRSRM is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND PRSRM
}
CSR.R.1.SRMLOP12 { @ SRMLOP12 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRMLOP12
}
CSR.R.1.SRMLOP13 { @ SRMLOP13 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRMLOP13
}
CSR.R.1.SRMLOP14 { @ SRMLOP14 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRMLOP14
}
CSR.R.1.LVLOP { @ LVLOP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND LVLOP
}
CSR.R.1.HCDPLOP { @ HCDPLOP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND HCDPLOP
}
CSR.R.1.TPLOP_8T { @ TPLOP_8T is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND TPLOP_8T
}
CSR.R.1.TPLOP_10T { @ TPLOP_10T is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND TPLOP_10T
}
CSR.R.1.RAM1TDMY { @ RAM1TDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND RAM1TDMY
}
CSR.R.1.OD1T { @ OD1T is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD1T
}
CSR.R.1.OD1TH { @ OD1TH is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD1TH
}
CSR.R.1.OD1TM { @ OD1TM is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD1TM
}
CSR.R.1.OD1T_WLD { @ OD1T_WLD is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD1T_WLD
}
CSR.R.1.OD1T_MOSCAP { @ OD1T_MOSCAP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD1T_MOSCAP
}
CSR.R.1.OD1T_CP { @ OD1T_CP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD1T_CP
}
CSR.R.1.OD1T_20 { @ OD1T_20 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD1T_20
}
CSR.R.1.OD1T_18 { @ OD1T_18 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD1T_18
}
CSR.R.1.OD1T_16 { @ OD1T_16 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND OD1T_16
}
CSR.R.1.CLDD { @ CLDD is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CLDD
}
CSR.R.1.EDRAM_DECAP { @ EDRAM_DECAP is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND EDRAM_DECAP
}
CSR.R.1.SNCT { @ SNCT is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SNCT
}
CSR.R.1.CROWN { @ CROWN is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CROWN
}
CSR.R.1.P3 { @ P3 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND P3
}
CSR.R.1.LDDBLK { @ LDDBLK is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND LDDBLK
}
CSR.R.1.CSRDMY { @ CSRDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CSRDMY
}
CSR.R.1.CSRBIB1DMY { @ CSRBIB1DMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CSRBIB1DMY
}
CSR.R.1.CSRBIB2DMY { @ CSRBIB2DMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CSRBIB2DMY
}
CSR.R.1.CDUDMY { @ CDUDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND CDUDMY
}
CSR.R.1.TCDDMY { @ TCDDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND TCDDMY
}
CSR.R.1.TCDDMY_H { @ TCDDMY_H is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND TCDDMY_H
}
CSR.R.1.TCDDMY_V { @ TCDDMY_V is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND TCDDMY_V
}
CSR.R.1.ICOVL { @ ICOVL is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND ICOVL
}
CSR.R.1.LOGO { @ LOGO is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND LOGO
}
CSR.R.1.INDDMY { @ INDDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND INDDMY
}
CSR.R.1.TLDMY { @ TLDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND TLDMY
}
CSR.R.1.WBDMY { @ WBDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND WBDMY
}
CSR.R.1.DIODMY { @ DIODMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DIODMY
}
CSR.R.1.RFDMY { @ RFDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND RFDMY
}
CSR.R.1.RFIPDMY { @ RFIPDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND RFIPDMY
}
CSR.R.1.LUPWDMY { @ LUPWDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND LUPWDMY
}
CSR.R.1.M1i { @ M1i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND M1i
}
CSR.R.1.DM1_O { @ DM1_O is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DM1_O
}
CSR.R.1.DUM1 { @ DUM1 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DUM1
}
CSR.R.1.M2i { @ M2i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND M2i
}
CSR.R.1.DM2_O { @ DM2_O is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DM2_O
}
CSR.R.1.DUM2 { @ DUM2 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DUM2
}
CSR.R.1.M3i { @ M3i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND M3i
}
CSR.R.1.DM3_O { @ DM3_O is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DM3_O
}
CSR.R.1.DUM3 { @ DUM3 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DUM3
}
CSR.R.1.M4i { @ M4i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND M4i
}
CSR.R.1.DM4_O { @ DM4_O is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DM4_O
}
CSR.R.1.DUM4 { @ DUM4 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DUM4
}
CSR.R.1.M5i { @ M5i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND M5i
}
CSR.R.1.DM5_O { @ DM5_O is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DM5_O
}
CSR.R.1.DUM5 { @ DUM5 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DUM5
}
CSR.R.1.M6i { @ M6i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND M6i
}
CSR.R.1.DM6_O { @ DM6_O is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DM6_O
}
CSR.R.1.DUM6 { @ DUM6 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DUM6
}
CSR.R.1.M7i { @ M7i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND M7i
}
CSR.R.1.DM7_O { @ DM7_O is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DM7_O
}
CSR.R.1.DUM7 { @ DUM7 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DUM7
}
CSR.R.1.M8i { @ M8i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND M8i
}
CSR.R.1.DM8_O { @ DM8_O is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DM8_O
}
CSR.R.1.DUM8 { @ DUM8 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DUM8
}
CSR.R.1.M9_OLD { @ M9_OLD is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND M9_OLD
}
CSR.R.1.M9_NEW { @ M9_NEW is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND M9_NEW
}
CSR.R.1.DUM9_OLD { @ DUM9_OLD is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DUM9_OLD
}
CSR.R.1.DUM9_NEW { @ DUM9_NEW is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DUM9_NEW
}
CSR.R.1.M10_OLD { @ M10_OLD is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND M10_OLD
}
CSR.R.1.M10_NEW { @ M10_NEW is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND M10_NEW
}
CSR.R.1.DUM10_OLD { @ DUM10_OLD is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DUM10_OLD
}
CSR.R.1.DUM10_NEW { @ DUM10_NEW is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DUM10_NEW
}
CSR.R.1.VIA1i { @ VIA1i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VIA1i
}
CSR.R.1.DVIA1 { @ DVIA1 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DVIA1
}
CSR.R.1.VIA2i { @ VIA2i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VIA2i
}
CSR.R.1.DVIA2 { @ DVIA2 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DVIA2
}
CSR.R.1.VIA3i { @ VIA3i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VIA3i
}
CSR.R.1.DVIA3 { @ DVIA3 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DVIA3
}
CSR.R.1.VIA4i { @ VIA4i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VIA4i
}
CSR.R.1.DVIA4 { @ DVIA4 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DVIA4
}
CSR.R.1.VIA5i { @ VIA5i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VIA5i
}
CSR.R.1.DVIA5 { @ DVIA5 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DVIA5
}
CSR.R.1.VIA6i { @ VIA6i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VIA6i
}
CSR.R.1.DVIA6 { @ DVIA6 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DVIA6
}
CSR.R.1.VIA7i { @ VIA7i is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VIA7i
}
CSR.R.1.DVIA7 { @ DVIA7 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DVIA7
}
CSR.R.1.VIA8_OLD { @ VIA8_OLD is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VIA8_OLD
}
CSR.R.1.VIA8_NEW { @ VIA8_NEW is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VIA8_NEW
}
CSR.R.1.VIA9_OLD { @ VIA9_OLD is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VIA9_OLD
}
CSR.R.1.VIA9_NEW { @ VIA9_NEW is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND VIA9_NEW
}
CSR.R.1.ODi { @ ODi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND ODi
}
CSR.R.1.ODiRFDRAIN { @ ODiRFDRAIN is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND ODiRFDRAIN
}
CSR.R.1.ODiSRAM { @ ODiSRAM is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND ODiSRAM
}
CSR.R.1.DOD { @ DOD is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DOD
}
CSR.R.1.SRDOD { @ SRDOD is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRDOD
}
CSR.R.1.POi { @ POi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND POi
}
CSR.R.1.POiSRAM { @ POiSRAM is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND POiSRAM
}
CSR.R.1.DPO { @ DPO is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND DPO
}
CSR.R.1.SRDPO { @ SRDPO is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND SRDPO
}
CSR.R.1.mVTLi { @ mVTLi is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND mVTLi
}
CSR.R.1.BJTDMY { @ BJTDMY is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND BJTDMY
}
CSR.R.1.POS1 { @ POS1 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND POS1
}
CSR.R.1.POS2 { @ POS2 is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND POS2
}
CSR.R.1.POS_OTHERS { @ POS_OTHERS is not allowed inside triangle empty areas( ^CSR_R_1 um) at 4 chip corners.
  EMPTY_AREA AND POS_OTHERS
}
#ELSE
SEALRING_INNER = SEALRING_ORI INSIDE (HOLES SEALRING_ORI)
SEALRING_OUTER = SEALRING_ORI NOT SEALRING_INNER

CSR_M1 = M1i AND CSRDMY
Reinforced_M1 = (CSR_M1 NOT SEALRING_ORI) INTERACT SEALRING_ORI
SR_M1 = M1i AND SEALRING_ORI 
SR_M1_INNER = SR_M1 INTERACT SEALRING_INNER
SR_M1_OUTER = SR_M1 INTERACT SEALRING_OUTER
CSR_M2 = M2i AND CSRDMY
Reinforced_M2 = (CSR_M2 NOT SEALRING_ORI) INTERACT SEALRING_ORI
SR_M2 = M2i AND SEALRING_ORI 
SR_M2_INNER = SR_M2 INTERACT SEALRING_INNER
SR_M2_OUTER = SR_M2 INTERACT SEALRING_OUTER
CSR_M3 = M3i AND CSRDMY
Reinforced_M3 = (CSR_M3 NOT SEALRING_ORI) INTERACT SEALRING_ORI
SR_M3 = M3i AND SEALRING_ORI 
SR_M3_INNER = SR_M3 INTERACT SEALRING_INNER
SR_M3_OUTER = SR_M3 INTERACT SEALRING_OUTER
CSR_M4 = M4i AND CSRDMY
Reinforced_M4 = (CSR_M4 NOT SEALRING_ORI) INTERACT SEALRING_ORI
SR_M4 = M4i AND SEALRING_ORI 
SR_M4_INNER = SR_M4 INTERACT SEALRING_INNER
SR_M4_OUTER = SR_M4 INTERACT SEALRING_OUTER
CSR_M5 = M5i AND CSRDMY
Reinforced_M5 = (CSR_M5 NOT SEALRING_ORI) INTERACT SEALRING_ORI
SR_M5 = M5i AND SEALRING_ORI 
SR_M5_INNER = SR_M5 INTERACT SEALRING_INNER
SR_M5_OUTER = SR_M5 INTERACT SEALRING_OUTER
CSR_M6 = M6i AND CSRDMY
Reinforced_M6 = (CSR_M6 NOT SEALRING_ORI) INTERACT SEALRING_ORI
SR_M6 = M6i AND SEALRING_ORI 
SR_M6_INNER = SR_M6 INTERACT SEALRING_INNER
SR_M6_OUTER = SR_M6 INTERACT SEALRING_OUTER
CSR_M7 = M7i AND CSRDMY
Reinforced_M7 = (CSR_M7 NOT SEALRING_ORI) INTERACT SEALRING_ORI
SR_M7 = M7i AND SEALRING_ORI 
SR_M7_INNER = SR_M7 INTERACT SEALRING_INNER
SR_M7_OUTER = SR_M7 INTERACT SEALRING_OUTER
CSR_M8 = M8i AND CSRDMY
Reinforced_M8 = (CSR_M8 NOT SEALRING_ORI) INTERACT SEALRING_ORI
SR_M8 = M8i AND SEALRING_ORI 
SR_M8_INNER = SR_M8 INTERACT SEALRING_INNER
SR_M8_OUTER = SR_M8 INTERACT SEALRING_OUTER
CSR_M9 = M9i AND CSRDMY
Reinforced_M9 = (CSR_M9 NOT SEALRING_ORI) INTERACT SEALRING_ORI
SR_M9 = M9i AND SEALRING_ORI 
SR_M9_INNER = SR_M9 INTERACT SEALRING_INNER
SR_M9_OUTER = SR_M9 INTERACT SEALRING_OUTER
CSR_M10 = M10i AND CSRDMY
Reinforced_M10 = (CSR_M10 NOT SEALRING_ORI) INTERACT SEALRING_ORI
SR_M10 = M10i AND SEALRING_ORI 
SR_M10_INNER = SR_M10 INTERACT SEALRING_INNER
SR_M10_OUTER = SR_M10 INTERACT SEALRING_OUTER
SR_CO = CO INTERACT (SEALRING_ORI OR SEALRING_DB)
SR_VIA1 = VIA1 INTERACT (SEALRING_ORI OR SEALRING_DB)
SR_VIA1_BAR = NOT RECTANGLE SR_VIA1    
SR_VIA1_HOLE = SR_VIA1 NOT SR_VIA1_BAR
SR_VIA1_BAR_INNER = SR_VIA1_BAR INTERACT SEALRING_INNER
SR_VIA1_BAR_OUTER = SR_VIA1_BAR INTERACT SEALRING_OUTER
SR_VIA2 = VIA2 INTERACT (SEALRING_ORI OR SEALRING_DB)
SR_VIA2_BAR = NOT RECTANGLE SR_VIA2    
SR_VIA2_HOLE = SR_VIA2 NOT SR_VIA2_BAR
SR_VIA2_BAR_INNER = SR_VIA2_BAR INTERACT SEALRING_INNER
SR_VIA2_BAR_OUTER = SR_VIA2_BAR INTERACT SEALRING_OUTER
SR_VIA3 = VIA3 INTERACT (SEALRING_ORI OR SEALRING_DB)
SR_VIA3_BAR = NOT RECTANGLE SR_VIA3    
SR_VIA3_HOLE = SR_VIA3 NOT SR_VIA3_BAR
SR_VIA3_BAR_INNER = SR_VIA3_BAR INTERACT SEALRING_INNER
SR_VIA3_BAR_OUTER = SR_VIA3_BAR INTERACT SEALRING_OUTER
SR_VIA4 = VIA4 INTERACT (SEALRING_ORI OR SEALRING_DB)
SR_VIA4_BAR = NOT RECTANGLE SR_VIA4    
SR_VIA4_HOLE = SR_VIA4 NOT SR_VIA4_BAR
SR_VIA4_BAR_INNER = SR_VIA4_BAR INTERACT SEALRING_INNER
SR_VIA4_BAR_OUTER = SR_VIA4_BAR INTERACT SEALRING_OUTER
SR_VIA5 = VIA5 INTERACT (SEALRING_ORI OR SEALRING_DB)
SR_VIA5_BAR = NOT RECTANGLE SR_VIA5    
SR_VIA5_HOLE = SR_VIA5 NOT SR_VIA5_BAR
SR_VIA5_BAR_INNER = SR_VIA5_BAR INTERACT SEALRING_INNER
SR_VIA5_BAR_OUTER = SR_VIA5_BAR INTERACT SEALRING_OUTER
SR_VIA6 = VIA6 INTERACT (SEALRING_ORI OR SEALRING_DB)
SR_VIA6_BAR = NOT RECTANGLE SR_VIA6    
SR_VIA6_HOLE = SR_VIA6 NOT SR_VIA6_BAR
SR_VIA6_BAR_INNER = SR_VIA6_BAR INTERACT SEALRING_INNER
SR_VIA6_BAR_OUTER = SR_VIA6_BAR INTERACT SEALRING_OUTER
SR_VIA7 = VIA7 INTERACT (SEALRING_ORI OR SEALRING_DB)
SR_VIA7_BAR = NOT RECTANGLE SR_VIA7    
SR_VIA7_HOLE = SR_VIA7 NOT SR_VIA7_BAR
SR_VIA7_BAR_INNER = SR_VIA7_BAR INTERACT SEALRING_INNER
SR_VIA7_BAR_OUTER = SR_VIA7_BAR INTERACT SEALRING_OUTER
SR_VIA8 = VIA8 INTERACT (SEALRING_ORI OR SEALRING_DB)
SR_VIA8_BAR = NOT RECTANGLE SR_VIA8    
SR_VIA8_HOLE = SR_VIA8 NOT SR_VIA8_BAR
SR_VIA8_BAR_INNER = SR_VIA8_BAR INTERACT SEALRING_INNER
SR_VIA8_BAR_OUTER = SR_VIA8_BAR INTERACT SEALRING_OUTER
SR_VIA9 = VIA9 INTERACT (SEALRING_ORI OR SEALRING_DB)
SR_VIA9_BAR = NOT RECTANGLE SR_VIA9    
SR_VIA9_HOLE = SR_VIA9 NOT SR_VIA9_BAR
SR_VIA9_BAR_INNER = SR_VIA9_BAR INTERACT SEALRING_INNER
SR_VIA9_BAR_OUTER = SR_VIA9_BAR INTERACT SEALRING_OUTER
#IFNDEF OLD_SEALRING
CHIP_CORNER_C = (CHIP NOT ((HOLES SEALRING_DB) OR SEALRING_DB)) AND SEALRING_ALL
CSR_M1_D =  ((CSR_M1 NOT SEALRING_ORI) NOT Reinforced_M1) OR (M1i AND CHIP_CORNER_C)
ISO_M1_D = (M1 INSIDE ISO_REGION) NOT CDUDMY
SLDB_M1 = M1 INTERACT SEALRING_DB                            // Metal1 in SLDB
CSR_M2_D =  ((CSR_M2 NOT SEALRING_ORI) NOT Reinforced_M2) OR (M2i AND CHIP_CORNER_C)
ISO_M2_D = (M2 INSIDE ISO_REGION) NOT CDUDMY
SLDB_M2 = M2 INTERACT SEALRING_DB                            // Metal2 in SLDB
CSR_M3_D =  ((CSR_M3 NOT SEALRING_ORI) NOT Reinforced_M3) OR (M3i AND CHIP_CORNER_C)
ISO_M3_D = (M3 INSIDE ISO_REGION) NOT CDUDMY
SLDB_M3 = M3 INTERACT SEALRING_DB                            // Metal3 in SLDB
CSR_M4_D =  ((CSR_M4 NOT SEALRING_ORI) NOT Reinforced_M4) OR (M4i AND CHIP_CORNER_C)
ISO_M4_D = (M4 INSIDE ISO_REGION) NOT CDUDMY
SLDB_M4 = M4 INTERACT SEALRING_DB                            // Metal4 in SLDB
CSR_M5_D =  ((CSR_M5 NOT SEALRING_ORI) NOT Reinforced_M5) OR (M5i AND CHIP_CORNER_C)
ISO_M5_D = (M5 INSIDE ISO_REGION) NOT CDUDMY
SLDB_M5 = M5 INTERACT SEALRING_DB                            // Metal5 in SLDB
CSR_M6_D =  ((CSR_M6 NOT SEALRING_ORI) NOT Reinforced_M6) OR (M6i AND CHIP_CORNER_C)
ISO_M6_D = (M6 INSIDE ISO_REGION) NOT CDUDMY
SLDB_M6 = M6 INTERACT SEALRING_DB                            // Metal6 in SLDB
CSR_M7_D =  ((CSR_M7 NOT SEALRING_ORI) NOT Reinforced_M7) OR (M7i AND CHIP_CORNER_C)
ISO_M7_D = (M7 INSIDE ISO_REGION) NOT CDUDMY
SLDB_M7 = M7 INTERACT SEALRING_DB                            // Metal7 in SLDB
CSR_M8_D =  ((CSR_M8 NOT SEALRING_ORI) NOT Reinforced_M8) OR (M8i AND CHIP_CORNER_C)
ISO_M8_D = (M8 INSIDE ISO_REGION) NOT CDUDMY
SLDB_M8 = M8 INTERACT SEALRING_DB                            // Metal8 in SLDB
CSR_M9_D =  ((CSR_M9 NOT SEALRING_ORI) NOT Reinforced_M9) OR (M9i AND CHIP_CORNER_C)
ISO_M9_D = (M9 INSIDE ISO_REGION) NOT CDUDMY
SLDB_M9 = M9 INTERACT SEALRING_DB                            // Metal9 in SLDB
CSR_M10_D =  ((CSR_M10 NOT SEALRING_ORI) NOT Reinforced_M10) OR (M10i AND CHIP_CORNER_C)
ISO_M10_D = (M10 INSIDE ISO_REGION) NOT CDUDMY
SLDB_M10 = M10 INTERACT SEALRING_DB                            // Metal10 in SLDB
CSR_VIA1_D = (((VIA1i AND CSRDMY) NOT SEALRING_ORI) NOT Reinforced_M1) OR (VIA1i AND CHIP_CORNER_C)
ISO_VIA1_D = (VIA1 INSIDE ISO_REGION) NOT CDUDMY
SR_VIA1_BAR_SLDB = SR_VIA1_BAR AND SEALRING_DB	
SR_VIA1_BAR_SR = SR_VIA1_BAR NOT SEALRING_DB	
SR_VIA1_HOLE_SLDB = SR_VIA1_HOLE AND SEALRING_DB
SR_VIA1_HOLE_SR = SR_VIA1_HOLE NOT SEALRING_DB
CSR_VIA2_D = (((VIA2i AND CSRDMY) NOT SEALRING_ORI) NOT Reinforced_M2) OR (VIA2i AND CHIP_CORNER_C)
ISO_VIA2_D = (VIA2 INSIDE ISO_REGION) NOT CDUDMY
SR_VIA2_BAR_SLDB = SR_VIA2_BAR AND SEALRING_DB	
SR_VIA2_BAR_SR = SR_VIA2_BAR NOT SEALRING_DB	
SR_VIA2_HOLE_SLDB = SR_VIA2_HOLE AND SEALRING_DB
SR_VIA2_HOLE_SR = SR_VIA2_HOLE NOT SEALRING_DB
CSR_VIA3_D = (((VIA3i AND CSRDMY) NOT SEALRING_ORI) NOT Reinforced_M3) OR (VIA3i AND CHIP_CORNER_C)
ISO_VIA3_D = (VIA3 INSIDE ISO_REGION) NOT CDUDMY
SR_VIA3_BAR_SLDB = SR_VIA3_BAR AND SEALRING_DB	
SR_VIA3_BAR_SR = SR_VIA3_BAR NOT SEALRING_DB	
SR_VIA3_HOLE_SLDB = SR_VIA3_HOLE AND SEALRING_DB
SR_VIA3_HOLE_SR = SR_VIA3_HOLE NOT SEALRING_DB
CSR_VIA4_D = (((VIA4i AND CSRDMY) NOT SEALRING_ORI) NOT Reinforced_M4) OR (VIA4i AND CHIP_CORNER_C)
ISO_VIA4_D = (VIA4 INSIDE ISO_REGION) NOT CDUDMY
SR_VIA4_BAR_SLDB = SR_VIA4_BAR AND SEALRING_DB	
SR_VIA4_BAR_SR = SR_VIA4_BAR NOT SEALRING_DB	
SR_VIA4_HOLE_SLDB = SR_VIA4_HOLE AND SEALRING_DB
SR_VIA4_HOLE_SR = SR_VIA4_HOLE NOT SEALRING_DB
CSR_VIA5_D = (((VIA5i AND CSRDMY) NOT SEALRING_ORI) NOT Reinforced_M5) OR (VIA5i AND CHIP_CORNER_C)
ISO_VIA5_D = (VIA5 INSIDE ISO_REGION) NOT CDUDMY
SR_VIA5_BAR_SLDB = SR_VIA5_BAR AND SEALRING_DB	
SR_VIA5_BAR_SR = SR_VIA5_BAR NOT SEALRING_DB	
SR_VIA5_HOLE_SLDB = SR_VIA5_HOLE AND SEALRING_DB
SR_VIA5_HOLE_SR = SR_VIA5_HOLE NOT SEALRING_DB
CSR_VIA6_D = (((VIA6i AND CSRDMY) NOT SEALRING_ORI) NOT Reinforced_M6) OR (VIA6i AND CHIP_CORNER_C)
ISO_VIA6_D = (VIA6 INSIDE ISO_REGION) NOT CDUDMY
SR_VIA6_BAR_SLDB = SR_VIA6_BAR AND SEALRING_DB	
SR_VIA6_BAR_SR = SR_VIA6_BAR NOT SEALRING_DB	
SR_VIA6_HOLE_SLDB = SR_VIA6_HOLE AND SEALRING_DB
SR_VIA6_HOLE_SR = SR_VIA6_HOLE NOT SEALRING_DB
CSR_VIA7_D = (((VIA7i AND CSRDMY) NOT SEALRING_ORI) NOT Reinforced_M7) OR (VIA7i AND CHIP_CORNER_C)
ISO_VIA7_D = (VIA7 INSIDE ISO_REGION) NOT CDUDMY
SR_VIA7_BAR_SLDB = SR_VIA7_BAR AND SEALRING_DB	
SR_VIA7_BAR_SR = SR_VIA7_BAR NOT SEALRING_DB	
SR_VIA7_HOLE_SLDB = SR_VIA7_HOLE AND SEALRING_DB
SR_VIA7_HOLE_SR = SR_VIA7_HOLE NOT SEALRING_DB
CSR_VIA8_D = (((VIA8i AND CSRDMY) NOT SEALRING_ORI) NOT Reinforced_M8) OR (VIA8i AND CHIP_CORNER_C)
ISO_VIA8_D = (VIA8 INSIDE ISO_REGION) NOT CDUDMY
SR_VIA8_BAR_SLDB = SR_VIA8_BAR AND SEALRING_DB	
SR_VIA8_BAR_SR = SR_VIA8_BAR NOT SEALRING_DB	
SR_VIA8_HOLE_SLDB = SR_VIA8_HOLE AND SEALRING_DB
SR_VIA8_HOLE_SR = SR_VIA8_HOLE NOT SEALRING_DB
CSR_VIA9_D = (((VIA9i AND CSRDMY) NOT SEALRING_ORI) NOT Reinforced_M9) OR (VIA9i AND CHIP_CORNER_C)
ISO_VIA9_D = (VIA9 INSIDE ISO_REGION) NOT CDUDMY
SR_VIA9_BAR_SLDB = SR_VIA9_BAR AND SEALRING_DB	
SR_VIA9_BAR_SR = SR_VIA9_BAR NOT SEALRING_DB	
SR_VIA9_HOLE_SLDB = SR_VIA9_HOLE AND SEALRING_DB
SR_VIA9_HOLE_SR = SR_VIA9_HOLE NOT SEALRING_DB
SR_CB_BAR_INNER = (CBi OR CBDi) INTERACT SEALRING_INNER
#IFDEF SINGLE_PASSIVATION
SR_CB_BAR_OUTER = (CBi OR CBDi) INTERACT SEALRING_OUTER
#ENDIF
SR_CB_BAR_SLDB = (CBi OR CBDi) INTERACT SEALRING_DB
SR_AP_BAR_INNER = AP AND SEALRING_INNER
SR_AP_BAR_SLDB = AP INTERACT SEALRING_DB
SR_CB2_BAR_OUTER = (CB2Fi OR CB2Wi) INTERACT SEALRING_OUTER
SR_CB2_BAR_SLDB = (CB2Fi OR CB2Wi) INTERACT SEALRING_DB
#ENDIF

CSR.R.2 { @ CSR/Sealring structure must include CB2_FC or CB2_WB, AP, CB or CBD, Mtop~M1, VIAtop~VIA1, CO, PP, OD.
  SEALRING_ORI NOT ODi
  SEALRING_ORI NOT PPi 
  SEALRING_ORI NOT M1x
  SEALRING_ORI NOT M2x
  SEALRING_ORI NOT M3x
  SEALRING_ORI NOT M4x
  SEALRING_ORI NOT M5x
  SEALRING_ORI NOT M6x
  SEALRING_ORI NOT M7x
  SEALRING_ORI NOT M8x
  SEALRING_ORI NOT M9x
  SEALRING_ORI NOT M10x
  (SR_M1 AND CSRDMY) NOT ENCLOSE (SR_CO AND CSRDMY)
  (SR_M1 NOT CSRDMY) NOT ENCLOSE (SR_CO NOT CSRDMY)
  (SR_M2 AND CSRDMY) NOT ENCLOSE (SR_VIA1 AND CSRDMY)
  (SR_M2 NOT CSRDMY) NOT ENCLOSE (SR_VIA1 NOT CSRDMY)
  (SR_M3 AND CSRDMY) NOT ENCLOSE (SR_VIA2 AND CSRDMY)
  (SR_M3 NOT CSRDMY) NOT ENCLOSE (SR_VIA2 NOT CSRDMY)
  (SR_M4 AND CSRDMY) NOT ENCLOSE (SR_VIA3 AND CSRDMY)
  (SR_M4 NOT CSRDMY) NOT ENCLOSE (SR_VIA3 NOT CSRDMY)
  (SR_M5 AND CSRDMY) NOT ENCLOSE (SR_VIA4 AND CSRDMY)
  (SR_M5 NOT CSRDMY) NOT ENCLOSE (SR_VIA4 NOT CSRDMY)
  (SR_M6 AND CSRDMY) NOT ENCLOSE (SR_VIA5 AND CSRDMY)
  (SR_M6 NOT CSRDMY) NOT ENCLOSE (SR_VIA5 NOT CSRDMY)
  (SR_M7 AND CSRDMY) NOT ENCLOSE (SR_VIA6 AND CSRDMY)
  (SR_M7 NOT CSRDMY) NOT ENCLOSE (SR_VIA6 NOT CSRDMY)
  (SR_M8 AND CSRDMY) NOT ENCLOSE (SR_VIA7 AND CSRDMY)
  (SR_M8 NOT CSRDMY) NOT ENCLOSE (SR_VIA7 NOT CSRDMY)
  (SR_M9 AND CSRDMY) NOT ENCLOSE (SR_VIA8 AND CSRDMY)
  (SR_M9 NOT CSRDMY) NOT ENCLOSE (SR_VIA8 NOT CSRDMY)
  (SR_M10 AND CSRDMY) NOT ENCLOSE (SR_VIA9 AND CSRDMY)
  (SR_M10 NOT CSRDMY) NOT ENCLOSE (SR_VIA9 NOT CSRDMY)
  CHIP_FC = CHIP INTERACT UBMi
  SEALRING_IN_FC = SEALRING_INNER INTERACT CHIP_FC
  SEALRING_IN_WB = SEALRING_INNER NOT INTERACT CHIP_FC
  SEALRING_OUT_FC = SEALRING_OUTER INTERACT CHIP_FC
  SEALRING_OUT_WB = SEALRING_OUTER NOT INTERACT CHIP_FC
#IFDEF SINGLE_PASSIVATION 
  (SEALRING_OUT_FC AND CSRDMY) NOT INTERACT (CBDi AND CSRDMY)
  (SEALRING_OUT_FC NOT CSRDMY) NOT INTERACT (CBDi NOT CSRDMY)
  (SEALRING_OUT_WB AND CSRDMY) NOT INTERACT (CBi AND CSRDMY)
  (SEALRING_OUT_WB NOT CSRDMY) NOT INTERACT (CBi NOT CSRDMY)
#ELSE 
  (SEALRING_IN_FC AND CSRDMY) NOT ENCLOSE (CBDi AND CSRDMY)
  (SEALRING_IN_FC NOT CSRDMY) NOT ENCLOSE (CBDi NOT CSRDMY)
  (SEALRING_IN_WB AND CSRDMY) NOT ENCLOSE (CBi AND CSRDMY)
  (SEALRING_IN_WB NOT CSRDMY) NOT ENCLOSE (CBi NOT CSRDMY)
  (SEALRING_INNER AND CSRDMY) NOT INTERACT (APi AND CSRDMY)
  (SEALRING_INNER NOT CSRDMY) NOT INTERACT (APi NOT CSRDMY)
  (SEALRING_OUT_FC AND CSRDMY) NOT ENCLOSE (CB2Fi AND CSRDMY)
  (SEALRING_OUT_FC NOT CSRDMY) NOT ENCLOSE (CB2Fi NOT CSRDMY)
  (SEALRING_OUT_WB AND CSRDMY) NOT ENCLOSE (CB2Wi AND CSRDMY)
  (SEALRING_OUT_WB NOT CSRDMY) NOT ENCLOSE (CB2Wi NOT CSRDMY)
#ENDIF  
}

//CSR.R.2_PM is checked by PM.R.3

CSR.W.1.M1 { @ Width of reinforced metal structure >= ^CSR_W_1A um <= ^CSR_W_1B um
  Reinforced_M1 NOT WITH WIDTH >= CSR_W_1A <= CSR_W_1B
}
CSR.L.1.M1 { @ Length of reinforced metal structure >= ^CSR_L_1A um <= ^CSR_L_1B um
  CSR_M1_HOLE_R = HOLES CSR_M1
  A = INT [CSR_M1_HOLE_R] >= CSR_L_1A <= CSR_L_1B OPPOSITE ANGLED == 0
  B = NOT ANGLE CSR_M1_HOLE_R == 45
  B NOT TOUCH INSIDE EDGE A
}
CSR.W.1.M2 { @ Width of reinforced metal structure >= ^CSR_W_1A um <= ^CSR_W_1B um
  Reinforced_M2 NOT WITH WIDTH >= CSR_W_1A <= CSR_W_1B
}
CSR.L.1.M2 { @ Length of reinforced metal structure >= ^CSR_L_1A um <= ^CSR_L_1B um
  CSR_M2_HOLE_R = HOLES CSR_M2
  A = INT [CSR_M2_HOLE_R] >= CSR_L_1A <= CSR_L_1B OPPOSITE ANGLED == 0
  B = NOT ANGLE CSR_M2_HOLE_R == 45
  B NOT TOUCH INSIDE EDGE A
}
CSR.W.1.M3 { @ Width of reinforced metal structure >= ^CSR_W_1A um <= ^CSR_W_1B um
  Reinforced_M3 NOT WITH WIDTH >= CSR_W_1A <= CSR_W_1B
}
CSR.L.1.M3 { @ Length of reinforced metal structure >= ^CSR_L_1A um <= ^CSR_L_1B um
  CSR_M3_HOLE_R = HOLES CSR_M3
  A = INT [CSR_M3_HOLE_R] >= CSR_L_1A <= CSR_L_1B OPPOSITE ANGLED == 0
  B = NOT ANGLE CSR_M3_HOLE_R == 45
  B NOT TOUCH INSIDE EDGE A
}
CSR.W.1.M4 { @ Width of reinforced metal structure >= ^CSR_W_1A um <= ^CSR_W_1B um
  Reinforced_M4 NOT WITH WIDTH >= CSR_W_1A <= CSR_W_1B
}
CSR.L.1.M4 { @ Length of reinforced metal structure >= ^CSR_L_1A um <= ^CSR_L_1B um
  CSR_M4_HOLE_R = HOLES CSR_M4
  A = INT [CSR_M4_HOLE_R] >= CSR_L_1A <= CSR_L_1B OPPOSITE ANGLED == 0
  B = NOT ANGLE CSR_M4_HOLE_R == 45
  B NOT TOUCH INSIDE EDGE A
}
CSR.W.1.M5 { @ Width of reinforced metal structure >= ^CSR_W_1A um <= ^CSR_W_1B um
  Reinforced_M5 NOT WITH WIDTH >= CSR_W_1A <= CSR_W_1B
}
CSR.L.1.M5 { @ Length of reinforced metal structure >= ^CSR_L_1A um <= ^CSR_L_1B um
  CSR_M5_HOLE_R = HOLES CSR_M5
  A = INT [CSR_M5_HOLE_R] >= CSR_L_1A <= CSR_L_1B OPPOSITE ANGLED == 0
  B = NOT ANGLE CSR_M5_HOLE_R == 45
  B NOT TOUCH INSIDE EDGE A
}
CSR.W.1.M6 { @ Width of reinforced metal structure >= ^CSR_W_1A um <= ^CSR_W_1B um
  Reinforced_M6 NOT WITH WIDTH >= CSR_W_1A <= CSR_W_1B
}
CSR.L.1.M6 { @ Length of reinforced metal structure >= ^CSR_L_1A um <= ^CSR_L_1B um
  CSR_M6_HOLE_R = HOLES CSR_M6
  A = INT [CSR_M6_HOLE_R] >= CSR_L_1A <= CSR_L_1B OPPOSITE ANGLED == 0
  B = NOT ANGLE CSR_M6_HOLE_R == 45
  B NOT TOUCH INSIDE EDGE A
}
CSR.W.1.M7 { @ Width of reinforced metal structure >= ^CSR_W_1A um <= ^CSR_W_1B um
  Reinforced_M7 NOT WITH WIDTH >= CSR_W_1A <= CSR_W_1B
}
CSR.L.1.M7 { @ Length of reinforced metal structure >= ^CSR_L_1A um <= ^CSR_L_1B um
  CSR_M7_HOLE_R = HOLES CSR_M7
  A = INT [CSR_M7_HOLE_R] >= CSR_L_1A <= CSR_L_1B OPPOSITE ANGLED == 0
  B = NOT ANGLE CSR_M7_HOLE_R == 45
  B NOT TOUCH INSIDE EDGE A
}
CSR.W.1.M8 { @ Width of reinforced metal structure >= ^CSR_W_1A um <= ^CSR_W_1B um
  Reinforced_M8 NOT WITH WIDTH >= CSR_W_1A <= CSR_W_1B
}
CSR.L.1.M8 { @ Length of reinforced metal structure >= ^CSR_L_1A um <= ^CSR_L_1B um
  CSR_M8_HOLE_R = HOLES CSR_M8
  A = INT [CSR_M8_HOLE_R] >= CSR_L_1A <= CSR_L_1B OPPOSITE ANGLED == 0
  B = NOT ANGLE CSR_M8_HOLE_R == 45
  B NOT TOUCH INSIDE EDGE A
}
CSR.W.1.M9 { @ Width of reinforced metal structure >= ^CSR_W_1A um <= ^CSR_W_1B um
  Reinforced_M9 NOT WITH WIDTH >= CSR_W_1A <= CSR_W_1B
}
CSR.L.1.M9 { @ Length of reinforced metal structure >= ^CSR_L_1A um <= ^CSR_L_1B um
  CSR_M9_HOLE_R = HOLES CSR_M9
  A = INT [CSR_M9_HOLE_R] >= CSR_L_1A <= CSR_L_1B OPPOSITE ANGLED == 0
  B = NOT ANGLE CSR_M9_HOLE_R == 45
  B NOT TOUCH INSIDE EDGE A
}
CSR.W.1.M10 { @ Width of reinforced metal structure >= ^CSR_W_1A um <= ^CSR_W_1B um
  Reinforced_M10 NOT WITH WIDTH >= CSR_W_1A <= CSR_W_1B
}
CSR.L.1.M10 { @ Length of reinforced metal structure >= ^CSR_L_1A um <= ^CSR_L_1B um
  CSR_M10_HOLE_R = HOLES CSR_M10
  A = INT [CSR_M10_HOLE_R] >= CSR_L_1A <= CSR_L_1B OPPOSITE ANGLED == 0
  B = NOT ANGLE CSR_M10_HOLE_R == 45
  B NOT TOUCH INSIDE EDGE A
}

CSR.R.3 { @ Distance between 45 degree 1st seal ring and seal ring corner >= ^CSR_R_3A um <= ^CSR_R_3B um
  X = EXTENT SEALRING_OUTER
  CHIP_CORNER_A = INT X  <= CSR_R_3A ABUT == 90 REGION INTERSECTING ONLY
  CHIP_CORNER_B = INT X  <= CSR_R_3B ABUT == 90 REGION INTERSECTING ONLY
  CHIP_CORNER_A AND SEALRING_ORI
  CHIP_CORNER_B NOT INTERACT SEALRING_ORI
}

#IFNDEF OLD_SEALRING
CSR.R.4 { @ CSRDMY layer (CAD layer: 166;0), CSRBIB1DMY (166;1) and CSRBIB2DMY (166;2) are must if customers add seal ring by themselves.
  CHIP NOT INTERACT CSRDMY
  CHIP NOT INTERACT CSRBIB1DMY
  CHIP NOT INTERACT CSRBIB2DMY
}

CSR.R.5 { @ DMV pattern in CSR must include Mtop/VIAtop/Mtop-1/VIAtop-1/Mtop-2/VIAtop-2/.../V1/M1, except for Mu design. 
    CSRDMY NOT INTERACT CSR_M1_D
    CSRDMY NOT INTERACT CSR_M2_D
    CSRDMY NOT INTERACT CSR_M3_D
    CSRDMY NOT INTERACT CSR_M4_D
    CSRDMY NOT INTERACT CSR_M5_D
    CSRDMY NOT INTERACT CSR_M6_D
    CSRDMY NOT INTERACT CSR_M7_D
    CSRDMY NOT INTERACT CSR_M8_D
    CSRDMY NOT INTERACT CSR_M9_D
    CSRDMY NOT INTERACT CSR_M10_D
    CSRDMY NOT INTERACT CSR_VIA1_D
    CSRDMY NOT INTERACT CSR_VIA2_D
    CSRDMY NOT INTERACT CSR_VIA3_D
    CSRDMY NOT INTERACT CSR_VIA4_D
    CSRDMY NOT INTERACT CSR_VIA5_D
    CSRDMY NOT INTERACT CSR_VIA6_D
    CSRDMY NOT INTERACT CSR_VIA7_D
    CSRDMY NOT INTERACT CSR_VIA8_D
    CSRDMY NOT INTERACT CSR_VIA9_D
}

SR.R.2 { @ DMV pattern in assembly isolation region must include Mtop/VIAtop/ Mtop-1/VIAtop-1/Mtop-2/VIAtop-2/.../V1/M1, except Mu design. 
    ISO_REGION NOT INTERACT ISO_M1_D
    ISO_REGION NOT INTERACT ISO_M2_D
    ISO_REGION NOT INTERACT ISO_M3_D
    ISO_REGION NOT INTERACT ISO_M4_D
    ISO_REGION NOT INTERACT ISO_M5_D
    ISO_REGION NOT INTERACT ISO_M6_D
    ISO_REGION NOT INTERACT ISO_M7_D
    ISO_REGION NOT INTERACT ISO_M8_D
    ISO_REGION NOT INTERACT ISO_M9_D
    ISO_REGION NOT INTERACT ISO_M10_D
    ISO_REGION NOT INTERACT ISO_VIA1_D
    ISO_REGION NOT INTERACT ISO_VIA2_D
    ISO_REGION NOT INTERACT ISO_VIA3_D
    ISO_REGION NOT INTERACT ISO_VIA4_D
    ISO_REGION NOT INTERACT ISO_VIA5_D
    ISO_REGION NOT INTERACT ISO_VIA6_D
    ISO_REGION NOT INTERACT ISO_VIA7_D
    ISO_REGION NOT INTERACT ISO_VIA8_D
    ISO_REGION NOT INTERACT ISO_VIA9_D
}

CSR_DM1.W.1 { @ Metal width of DMV in CSR region =  ^CSR_DM1_W_1
  NOT RECTANGLE CSR_M1_D == CSR_DM1_W_1 BY == CSR_DM1_W_1 ORTHOGONAL ONLY
}
CSR_DM1.S.1 { @ Metal space of DMV in CSR region >= ^CSR_DM1_S_1
  EXT CSR_M1_D < CSR_DM1_S_1 ABUT < 90 SINGULAR REGION
}
CSR_DM1.S.2 { @ Metal space of DMV to CSR metal bar >= ^CSR_DM1_S_2
  EXT CSR_M1_D (M1i NOT CSR_M1_D) < CSR_DM1_S_2 ABUT < 90 SINGULAR REGION
}
CSR_DM1.O.1 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu = ^CSR_DM1_O_1 
 CSR_M1_M2 = CSR_M1_D AND CSR_M2_D
 NOT RECTANGLE CSR_M1_M2 == CSR_DM1_O_1 BY == CSR_DM1_O_1 ORTHOGONAL ONLY
}
SR_DM1.W.1  { @ Metal width of DMV in Assembly isolation region = ^SR_DM1_W_1
  NOT RECTANGLE ISO_M1_D == SR_DM1_W_1 BY == SR_DM1_W_1 ORTHOGONAL ONLY
}
SR_DM1.S.1 { @ Metal space of DMV in Assembly isolation region >= ^SR_DM1_S_1
  EXT ISO_M1_D < SR_DM1_S_1 ABUT < 90 SINGULAR REGION
}
SR_DM1.S.2 { @ Metal space of DMV to seal ring metal bar. >= ^SR_DM1_S_2
  EXT ISO_M1_D SR_M1_INNER < SR_DM1_S_2 ABUT < 90 SINGULAR REGION
}
SR_DM1.O.1 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu. = ^SR_DM1_O_1
 ISO_M1_M2 = ISO_M1_D AND ISO_M2_D
 NOT RECTANGLE ISO_M1_M2 == SR_DM1_O_1 BY == SR_DM1_O_1 ORTHOGONAL ONLY
}


CSR_DM2.W.1 { @ Metal width of DMV in CSR region =  ^CSR_DM2_W_1
  NOT RECTANGLE CSR_M2_D == CSR_DM2_W_1 BY == CSR_DM2_W_1 ORTHOGONAL ONLY
}
CSR_DM2.S.1 { @ Metal space of DMV in CSR region >= ^CSR_DM2_S_1
  EXT CSR_M2_D < CSR_DM2_S_1 ABUT < 90 SINGULAR REGION
}
CSR_DM2.S.2 { @ Metal space of DMV to CSR metal bar >= ^CSR_DM2_S_2
  EXT CSR_M2_D (M2i NOT CSR_M2_D) < CSR_DM2_S_2 ABUT < 90 SINGULAR REGION
}
CSR_DM2.O.1 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu = ^CSR_DM2_O_1 
 CSR_M2_M3 = CSR_M2_D AND CSR_M3_D
 NOT RECTANGLE CSR_M2_M3 == CSR_DM2_O_1 BY == CSR_DM2_O_1 ORTHOGONAL ONLY
}
SR_DM2.W.1  { @ Metal width of DMV in Assembly isolation region = ^SR_DM2_W_1
  NOT RECTANGLE ISO_M2_D == SR_DM2_W_1 BY == SR_DM2_W_1 ORTHOGONAL ONLY
}
SR_DM2.S.1 { @ Metal space of DMV in Assembly isolation region >= ^SR_DM2_S_1
  EXT ISO_M2_D < SR_DM2_S_1 ABUT < 90 SINGULAR REGION
}
SR_DM2.S.2 { @ Metal space of DMV to seal ring metal bar. >= ^SR_DM2_S_2
  EXT ISO_M2_D SR_M2_INNER < SR_DM2_S_2 ABUT < 90 SINGULAR REGION
}
SR_DM2.O.1 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu. = ^SR_DM2_O_1
 ISO_M2_M3 = ISO_M2_D AND ISO_M3_D
 NOT RECTANGLE ISO_M2_M3 == SR_DM2_O_1 BY == SR_DM2_O_1 ORTHOGONAL ONLY
}


CSR_DM3.W.1 { @ Metal width of DMV in CSR region =  ^CSR_DM3_W_1
  NOT RECTANGLE CSR_M3_D == CSR_DM3_W_1 BY == CSR_DM3_W_1 ORTHOGONAL ONLY
}
CSR_DM3.S.1 { @ Metal space of DMV in CSR region >= ^CSR_DM3_S_1
  EXT CSR_M3_D < CSR_DM3_S_1 ABUT < 90 SINGULAR REGION
}
CSR_DM3.S.2 { @ Metal space of DMV to CSR metal bar >= ^CSR_DM3_S_2
  EXT CSR_M3_D (M3i NOT CSR_M3_D) < CSR_DM3_S_2 ABUT < 90 SINGULAR REGION
}
CSR_DM3.O.1 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu = ^CSR_DM3_O_1 
 CSR_M3_M4 = CSR_M3_D AND CSR_M4_D
 NOT RECTANGLE CSR_M3_M4 == CSR_DM3_O_1 BY == CSR_DM3_O_1 ORTHOGONAL ONLY
}
SR_DM3.W.1  { @ Metal width of DMV in Assembly isolation region = ^SR_DM3_W_1
  NOT RECTANGLE ISO_M3_D == SR_DM3_W_1 BY == SR_DM3_W_1 ORTHOGONAL ONLY
}
SR_DM3.S.1 { @ Metal space of DMV in Assembly isolation region >= ^SR_DM3_S_1
  EXT ISO_M3_D < SR_DM3_S_1 ABUT < 90 SINGULAR REGION
}
SR_DM3.S.2 { @ Metal space of DMV to seal ring metal bar. >= ^SR_DM3_S_2
  EXT ISO_M3_D SR_M3_INNER < SR_DM3_S_2 ABUT < 90 SINGULAR REGION
}
SR_DM3.O.1 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu. = ^SR_DM3_O_1
 ISO_M3_M4 = ISO_M3_D AND ISO_M4_D
 NOT RECTANGLE ISO_M3_M4 == SR_DM3_O_1 BY == SR_DM3_O_1 ORTHOGONAL ONLY
}


CSR_DM4.W.1 { @ Metal width of DMV in CSR region =  ^CSR_DM4_W_1
  NOT RECTANGLE CSR_M4_D == CSR_DM4_W_1 BY == CSR_DM4_W_1 ORTHOGONAL ONLY
}
CSR_DM4.S.1 { @ Metal space of DMV in CSR region >= ^CSR_DM4_S_1
  EXT CSR_M4_D < CSR_DM4_S_1 ABUT < 90 SINGULAR REGION
}
CSR_DM4.S.2 { @ Metal space of DMV to CSR metal bar >= ^CSR_DM4_S_2
  EXT CSR_M4_D (M4i NOT CSR_M4_D) < CSR_DM4_S_2 ABUT < 90 SINGULAR REGION
}
CSR_DM4.O.1 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu = ^CSR_DM4_O_1 
 CSR_M4_M5 = CSR_M4_D AND CSR_M5_D
 NOT RECTANGLE CSR_M4_M5 == CSR_DM4_O_1 BY == CSR_DM4_O_1 ORTHOGONAL ONLY
}
SR_DM4.W.1  { @ Metal width of DMV in Assembly isolation region = ^SR_DM4_W_1
  NOT RECTANGLE ISO_M4_D == SR_DM4_W_1 BY == SR_DM4_W_1 ORTHOGONAL ONLY
}
SR_DM4.S.1 { @ Metal space of DMV in Assembly isolation region >= ^SR_DM4_S_1
  EXT ISO_M4_D < SR_DM4_S_1 ABUT < 90 SINGULAR REGION
}
SR_DM4.S.2 { @ Metal space of DMV to seal ring metal bar. >= ^SR_DM4_S_2
  EXT ISO_M4_D SR_M4_INNER < SR_DM4_S_2 ABUT < 90 SINGULAR REGION
}
SR_DM4.O.1 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu. = ^SR_DM4_O_1
 ISO_M4_M5 = ISO_M4_D AND ISO_M5_D
 NOT RECTANGLE ISO_M4_M5 == SR_DM4_O_1 BY == SR_DM4_O_1 ORTHOGONAL ONLY
}


CSR_DM5.W.1 { @ Metal width of DMV in CSR region =  ^CSR_DM5_W_1
  NOT RECTANGLE CSR_M5_D == CSR_DM5_W_1 BY == CSR_DM5_W_1 ORTHOGONAL ONLY
}
CSR_DM5.S.1 { @ Metal space of DMV in CSR region >= ^CSR_DM5_S_1
  EXT CSR_M5_D < CSR_DM5_S_1 ABUT < 90 SINGULAR REGION
}
CSR_DM5.S.2 { @ Metal space of DMV to CSR metal bar >= ^CSR_DM5_S_2
  EXT CSR_M5_D (M5i NOT CSR_M5_D) < CSR_DM5_S_2 ABUT < 90 SINGULAR REGION
}
CSR_DM5.O.1 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu = ^CSR_DM5_O_1 
 CSR_M5_M6 = CSR_M5_D AND CSR_M6_D
 NOT RECTANGLE CSR_M5_M6 == CSR_DM5_O_1 BY == CSR_DM5_O_1 ORTHOGONAL ONLY
}
SR_DM5.W.1  { @ Metal width of DMV in Assembly isolation region = ^SR_DM5_W_1
  NOT RECTANGLE ISO_M5_D == SR_DM5_W_1 BY == SR_DM5_W_1 ORTHOGONAL ONLY
}
SR_DM5.S.1 { @ Metal space of DMV in Assembly isolation region >= ^SR_DM5_S_1
  EXT ISO_M5_D < SR_DM5_S_1 ABUT < 90 SINGULAR REGION
}
SR_DM5.S.2 { @ Metal space of DMV to seal ring metal bar. >= ^SR_DM5_S_2
  EXT ISO_M5_D SR_M5_INNER < SR_DM5_S_2 ABUT < 90 SINGULAR REGION
}
SR_DM5.O.1 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu. = ^SR_DM5_O_1
 ISO_M5_M6 = ISO_M5_D AND ISO_M6_D
 NOT RECTANGLE ISO_M5_M6 == SR_DM5_O_1 BY == SR_DM5_O_1 ORTHOGONAL ONLY
}


CSR_DM6.W.1 { @ Metal width of DMV in CSR region =  ^CSR_DM6_W_1
  NOT RECTANGLE CSR_M6_D == CSR_DM6_W_1 BY == CSR_DM6_W_1 ORTHOGONAL ONLY
}
CSR_DM6.S.1 { @ Metal space of DMV in CSR region >= ^CSR_DM6_S_1
  EXT CSR_M6_D < CSR_DM6_S_1 ABUT < 90 SINGULAR REGION
}
CSR_DM6.S.2 { @ Metal space of DMV to CSR metal bar >= ^CSR_DM6_S_2
  EXT CSR_M6_D (M6i NOT CSR_M6_D) < CSR_DM6_S_2 ABUT < 90 SINGULAR REGION
}
CSR_DM6.O.1 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu = ^CSR_DM6_O_1 
 CSR_M6_M7 = CSR_M6_D AND CSR_M7_D
 NOT RECTANGLE CSR_M6_M7 == CSR_DM6_O_1 BY == CSR_DM6_O_1 ORTHOGONAL ONLY
}
SR_DM6.W.1  { @ Metal width of DMV in Assembly isolation region = ^SR_DM6_W_1
  NOT RECTANGLE ISO_M6_D == SR_DM6_W_1 BY == SR_DM6_W_1 ORTHOGONAL ONLY
}
SR_DM6.S.1 { @ Metal space of DMV in Assembly isolation region >= ^SR_DM6_S_1
  EXT ISO_M6_D < SR_DM6_S_1 ABUT < 90 SINGULAR REGION
}
SR_DM6.S.2 { @ Metal space of DMV to seal ring metal bar. >= ^SR_DM6_S_2
  EXT ISO_M6_D SR_M6_INNER < SR_DM6_S_2 ABUT < 90 SINGULAR REGION
}
SR_DM6.O.1 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu. = ^SR_DM6_O_1
 ISO_M6_M7 = ISO_M6_D AND ISO_M7_D
 NOT RECTANGLE ISO_M6_M7 == SR_DM6_O_1 BY == SR_DM6_O_1 ORTHOGONAL ONLY
}


CSR_DM7.W.1 { @ Metal width of DMV in CSR region =  ^CSR_DM7_W_1
  NOT RECTANGLE CSR_M7_D == CSR_DM7_W_1 BY == CSR_DM7_W_1 ORTHOGONAL ONLY
}
CSR_DM7.S.1 { @ Metal space of DMV in CSR region >= ^CSR_DM7_S_1
  EXT CSR_M7_D < CSR_DM7_S_1 ABUT < 90 SINGULAR REGION
}
CSR_DM7.S.2 { @ Metal space of DMV to CSR metal bar >= ^CSR_DM7_S_2
  EXT CSR_M7_D (M7i NOT CSR_M7_D) < CSR_DM7_S_2 ABUT < 90 SINGULAR REGION
}
CSR_DM7.O.1 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu = ^CSR_DM7_O_1 
 CSR_M7_M8 = CSR_M7_D AND CSR_M8_D
 NOT RECTANGLE CSR_M7_M8 == CSR_DM7_O_1 BY == CSR_DM7_O_1 ORTHOGONAL ONLY
}
SR_DM7.W.1  { @ Metal width of DMV in Assembly isolation region = ^SR_DM7_W_1
  NOT RECTANGLE ISO_M7_D == SR_DM7_W_1 BY == SR_DM7_W_1 ORTHOGONAL ONLY
}
SR_DM7.S.1 { @ Metal space of DMV in Assembly isolation region >= ^SR_DM7_S_1
  EXT ISO_M7_D < SR_DM7_S_1 ABUT < 90 SINGULAR REGION
}
SR_DM7.S.2 { @ Metal space of DMV to seal ring metal bar. >= ^SR_DM7_S_2
  EXT ISO_M7_D SR_M7_INNER < SR_DM7_S_2 ABUT < 90 SINGULAR REGION
}
SR_DM7.O.1 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu. = ^SR_DM7_O_1
 ISO_M7_M8 = ISO_M7_D AND ISO_M8_D
 NOT RECTANGLE ISO_M7_M8 == SR_DM7_O_1 BY == SR_DM7_O_1 ORTHOGONAL ONLY
}


CSR_DM8.W.1 { @ Metal width of DMV in CSR region =  ^CSR_DM8_W_1
  NOT RECTANGLE CSR_M8_D == CSR_DM8_W_1 BY == CSR_DM8_W_1 ORTHOGONAL ONLY
}
CSR_DM8.S.1 { @ Metal space of DMV in CSR region >= ^CSR_DM8_S_1
  EXT CSR_M8_D < CSR_DM8_S_1 ABUT < 90 SINGULAR REGION
}
CSR_DM8.S.2 { @ Metal space of DMV to CSR metal bar >= ^CSR_DM8_S_2
  EXT CSR_M8_D (M8i NOT CSR_M8_D) < CSR_DM8_S_2 ABUT < 90 SINGULAR REGION
}
CSR_DM8.O.1 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu = ^CSR_DM8_O_1 
 CSR_M8_M9 = CSR_M8_D AND CSR_M9_D
 NOT RECTANGLE CSR_M8_M9 == CSR_DM8_O_1 BY == CSR_DM8_O_1 ORTHOGONAL ONLY
}
SR_DM8.W.1  { @ Metal width of DMV in Assembly isolation region = ^SR_DM8_W_1
  NOT RECTANGLE ISO_M8_D == SR_DM8_W_1 BY == SR_DM8_W_1 ORTHOGONAL ONLY
}
SR_DM8.S.1 { @ Metal space of DMV in Assembly isolation region >= ^SR_DM8_S_1
  EXT ISO_M8_D < SR_DM8_S_1 ABUT < 90 SINGULAR REGION
}
SR_DM8.S.2 { @ Metal space of DMV to seal ring metal bar. >= ^SR_DM8_S_2
  EXT ISO_M8_D SR_M8_INNER < SR_DM8_S_2 ABUT < 90 SINGULAR REGION
}
SR_DM8.O.1 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu. = ^SR_DM8_O_1
 ISO_M8_M9 = ISO_M8_D AND ISO_M9_D
 NOT RECTANGLE ISO_M8_M9 == SR_DM8_O_1 BY == SR_DM8_O_1 ORTHOGONAL ONLY
}


CSR_DM9.W.1 { @ Metal width of DMV in CSR region =  ^CSR_DM9_W_1
  NOT RECTANGLE CSR_M9_D == CSR_DM9_W_1 BY == CSR_DM9_W_1 ORTHOGONAL ONLY
}
CSR_DM9.S.1 { @ Metal space of DMV in CSR region >= ^CSR_DM9_S_1
  EXT CSR_M9_D < CSR_DM9_S_1 ABUT < 90 SINGULAR REGION
}
CSR_DM9.S.2 { @ Metal space of DMV to CSR metal bar >= ^CSR_DM9_S_2
  EXT CSR_M9_D (M9i NOT CSR_M9_D) < CSR_DM9_S_2 ABUT < 90 SINGULAR REGION
}
CSR_DM9.O.1 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu = ^CSR_DM9_O_1 
 CSR_M9_M10 = CSR_M9_D AND CSR_M10_D
 NOT RECTANGLE CSR_M9_M10 == CSR_DM9_O_1 BY == CSR_DM9_O_1 ORTHOGONAL ONLY
}
SR_DM9.W.1  { @ Metal width of DMV in Assembly isolation region = ^SR_DM9_W_1
  NOT RECTANGLE ISO_M9_D == SR_DM9_W_1 BY == SR_DM9_W_1 ORTHOGONAL ONLY
}
SR_DM9.S.1 { @ Metal space of DMV in Assembly isolation region >= ^SR_DM9_S_1
  EXT ISO_M9_D < SR_DM9_S_1 ABUT < 90 SINGULAR REGION
}
SR_DM9.S.2 { @ Metal space of DMV to seal ring metal bar. >= ^SR_DM9_S_2
  EXT ISO_M9_D SR_M9_INNER < SR_DM9_S_2 ABUT < 90 SINGULAR REGION
}
SR_DM9.O.1 { @ Overlay of two adjacent DMV metal layers, except Mr and Mu. = ^SR_DM9_O_1
 ISO_M9_M10 = ISO_M9_D AND ISO_M10_D
 NOT RECTANGLE ISO_M9_M10 == SR_DM9_O_1 BY == SR_DM9_O_1 ORTHOGONAL ONLY
}


CSR_DM10.W.1 { @ Metal width of DMV in CSR region =  ^CSR_DM10_W_1
  NOT RECTANGLE CSR_M10_D == CSR_DM10_W_1 BY == CSR_DM10_W_1 ORTHOGONAL ONLY
}
CSR_DM10.S.1 { @ Metal space of DMV in CSR region >= ^CSR_DM10_S_1
  EXT CSR_M10_D < CSR_DM10_S_1 ABUT < 90 SINGULAR REGION
}
CSR_DM10.S.2 { @ Metal space of DMV to CSR metal bar >= ^CSR_DM10_S_2
  EXT CSR_M10_D (M10i NOT CSR_M10_D) < CSR_DM10_S_2 ABUT < 90 SINGULAR REGION
}
SR_DM10.W.1  { @ Metal width of DMV in Assembly isolation region = ^SR_DM10_W_1
  NOT RECTANGLE ISO_M10_D == SR_DM10_W_1 BY == SR_DM10_W_1 ORTHOGONAL ONLY
}
SR_DM10.S.1 { @ Metal space of DMV in Assembly isolation region >= ^SR_DM10_S_1
  EXT ISO_M10_D < SR_DM10_S_1 ABUT < 90 SINGULAR REGION
}
SR_DM10.S.2 { @ Metal space of DMV to seal ring metal bar. >= ^SR_DM10_S_2
  EXT ISO_M10_D SR_M10_INNER < SR_DM10_S_2 ABUT < 90 SINGULAR REGION
}



CSR_DV1.W.1 { @ Via width of DMV in CSR region. = ^CSR_DV1_W_1
  NOT RECTANGLE CSR_VIA1_D == CSR_DV1_W_1 BY == CSR_DV1_W_1 ORTHOGONAL ONLY
}
CSR_DV1.S.1 { @ Via space of DMV in CSR region. >= ^CSR_DV1_S_1
  EXT CSR_VIA1_D < CSR_DV1_S_1 ABUT < 90 SINGULAR REGION
}
CSR_DV1.EN.1 { @ DMV via enclosure by DMV metal in CSR region. DMV via must be inside DMV metal. >= ^CSR_DV1_EN_1 
  ENC CSR_VIA1_D CSR_M2_D < CSR_DV1_EN_1 ABUT < 90 SINGULAR REGION
  CSR_VIA1_D NOT CSR_M2_D 
}

SR_DV1.W.1 { @ Via width of DMV in Assembly isolation region. = ^SR_DV1_W_1
  NOT RECTANGLE ISO_VIA1_D == SR_DV1_W_1 BY == SR_DV1_W_1 ORTHOGONAL ONLY
}
SR_DV1.S.1 { @ Via space of DMV in Assembly isolation region. >= ^SR_DV1_S_1
  EXT ISO_VIA1_D < SR_DV1_S_1 ABUT < 90 SINGULAR REGION
}
SR_DV1.EN.1 { @ DMV via enclosure by DMV metal in Assembly isolation region. DMV via must be inside DMV metal. >= ^SR_DV1_EN_1
  ENC ISO_VIA1_D ISO_M2_D < SR_DV1_EN_1 ABUT < 90 SINGULAR REGION
  ISO_VIA1_D NOT ISO_M2_D 
}

CSR_DV2.W.1 { @ Via width of DMV in CSR region. = ^CSR_DV2_W_1
  NOT RECTANGLE CSR_VIA2_D == CSR_DV2_W_1 BY == CSR_DV2_W_1 ORTHOGONAL ONLY
}
CSR_DV2.S.1 { @ Via space of DMV in CSR region. >= ^CSR_DV2_S_1
  EXT CSR_VIA2_D < CSR_DV2_S_1 ABUT < 90 SINGULAR REGION
}
CSR_DV2.EN.1 { @ DMV via enclosure by DMV metal in CSR region. DMV via must be inside DMV metal. >= ^CSR_DV2_EN_1 
  ENC CSR_VIA2_D CSR_M3_D < CSR_DV2_EN_1 ABUT < 90 SINGULAR REGION
  CSR_VIA2_D NOT CSR_M3_D 
}

SR_DV2.W.1 { @ Via width of DMV in Assembly isolation region. = ^SR_DV2_W_1
  NOT RECTANGLE ISO_VIA2_D == SR_DV2_W_1 BY == SR_DV2_W_1 ORTHOGONAL ONLY
}
SR_DV2.S.1 { @ Via space of DMV in Assembly isolation region. >= ^SR_DV2_S_1
  EXT ISO_VIA2_D < SR_DV2_S_1 ABUT < 90 SINGULAR REGION
}
SR_DV2.EN.1 { @ DMV via enclosure by DMV metal in Assembly isolation region. DMV via must be inside DMV metal. >= ^SR_DV2_EN_1
  ENC ISO_VIA2_D ISO_M3_D < SR_DV2_EN_1 ABUT < 90 SINGULAR REGION
  ISO_VIA2_D NOT ISO_M3_D 
}

CSR_DV3.W.1 { @ Via width of DMV in CSR region. = ^CSR_DV3_W_1
  NOT RECTANGLE CSR_VIA3_D == CSR_DV3_W_1 BY == CSR_DV3_W_1 ORTHOGONAL ONLY
}
CSR_DV3.S.1 { @ Via space of DMV in CSR region. >= ^CSR_DV3_S_1
  EXT CSR_VIA3_D < CSR_DV3_S_1 ABUT < 90 SINGULAR REGION
}
CSR_DV3.EN.1 { @ DMV via enclosure by DMV metal in CSR region. DMV via must be inside DMV metal. >= ^CSR_DV3_EN_1 
  ENC CSR_VIA3_D CSR_M4_D < CSR_DV3_EN_1 ABUT < 90 SINGULAR REGION
  CSR_VIA3_D NOT CSR_M4_D 
}

SR_DV3.W.1 { @ Via width of DMV in Assembly isolation region. = ^SR_DV3_W_1
  NOT RECTANGLE ISO_VIA3_D == SR_DV3_W_1 BY == SR_DV3_W_1 ORTHOGONAL ONLY
}
SR_DV3.S.1 { @ Via space of DMV in Assembly isolation region. >= ^SR_DV3_S_1
  EXT ISO_VIA3_D < SR_DV3_S_1 ABUT < 90 SINGULAR REGION
}
SR_DV3.EN.1 { @ DMV via enclosure by DMV metal in Assembly isolation region. DMV via must be inside DMV metal. >= ^SR_DV3_EN_1
  ENC ISO_VIA3_D ISO_M4_D < SR_DV3_EN_1 ABUT < 90 SINGULAR REGION
  ISO_VIA3_D NOT ISO_M4_D 
}

CSR_DV4.W.1 { @ Via width of DMV in CSR region. = ^CSR_DV4_W_1
  NOT RECTANGLE CSR_VIA4_D == CSR_DV4_W_1 BY == CSR_DV4_W_1 ORTHOGONAL ONLY
}
CSR_DV4.S.1 { @ Via space of DMV in CSR region. >= ^CSR_DV4_S_1
  EXT CSR_VIA4_D < CSR_DV4_S_1 ABUT < 90 SINGULAR REGION
}
CSR_DV4.EN.1 { @ DMV via enclosure by DMV metal in CSR region. DMV via must be inside DMV metal. >= ^CSR_DV4_EN_1 
  ENC CSR_VIA4_D CSR_M5_D < CSR_DV4_EN_1 ABUT < 90 SINGULAR REGION
  CSR_VIA4_D NOT CSR_M5_D 
}

SR_DV4.W.1 { @ Via width of DMV in Assembly isolation region. = ^SR_DV4_W_1
  NOT RECTANGLE ISO_VIA4_D == SR_DV4_W_1 BY == SR_DV4_W_1 ORTHOGONAL ONLY
}
SR_DV4.S.1 { @ Via space of DMV in Assembly isolation region. >= ^SR_DV4_S_1
  EXT ISO_VIA4_D < SR_DV4_S_1 ABUT < 90 SINGULAR REGION
}
SR_DV4.EN.1 { @ DMV via enclosure by DMV metal in Assembly isolation region. DMV via must be inside DMV metal. >= ^SR_DV4_EN_1
  ENC ISO_VIA4_D ISO_M5_D < SR_DV4_EN_1 ABUT < 90 SINGULAR REGION
  ISO_VIA4_D NOT ISO_M5_D 
}

CSR_DV5.W.1 { @ Via width of DMV in CSR region. = ^CSR_DV5_W_1
  NOT RECTANGLE CSR_VIA5_D == CSR_DV5_W_1 BY == CSR_DV5_W_1 ORTHOGONAL ONLY
}
CSR_DV5.S.1 { @ Via space of DMV in CSR region. >= ^CSR_DV5_S_1
  EXT CSR_VIA5_D < CSR_DV5_S_1 ABUT < 90 SINGULAR REGION
}
CSR_DV5.EN.1 { @ DMV via enclosure by DMV metal in CSR region. DMV via must be inside DMV metal. >= ^CSR_DV5_EN_1 
  ENC CSR_VIA5_D CSR_M6_D < CSR_DV5_EN_1 ABUT < 90 SINGULAR REGION
  CSR_VIA5_D NOT CSR_M6_D 
}

SR_DV5.W.1 { @ Via width of DMV in Assembly isolation region. = ^SR_DV5_W_1
  NOT RECTANGLE ISO_VIA5_D == SR_DV5_W_1 BY == SR_DV5_W_1 ORTHOGONAL ONLY
}
SR_DV5.S.1 { @ Via space of DMV in Assembly isolation region. >= ^SR_DV5_S_1
  EXT ISO_VIA5_D < SR_DV5_S_1 ABUT < 90 SINGULAR REGION
}
SR_DV5.EN.1 { @ DMV via enclosure by DMV metal in Assembly isolation region. DMV via must be inside DMV metal. >= ^SR_DV5_EN_1
  ENC ISO_VIA5_D ISO_M6_D < SR_DV5_EN_1 ABUT < 90 SINGULAR REGION
  ISO_VIA5_D NOT ISO_M6_D 
}

CSR_DV6.W.1 { @ Via width of DMV in CSR region. = ^CSR_DV6_W_1
  NOT RECTANGLE CSR_VIA6_D == CSR_DV6_W_1 BY == CSR_DV6_W_1 ORTHOGONAL ONLY
}
CSR_DV6.S.1 { @ Via space of DMV in CSR region. >= ^CSR_DV6_S_1
  EXT CSR_VIA6_D < CSR_DV6_S_1 ABUT < 90 SINGULAR REGION
}
CSR_DV6.EN.1 { @ DMV via enclosure by DMV metal in CSR region. DMV via must be inside DMV metal. >= ^CSR_DV6_EN_1 
  ENC CSR_VIA6_D CSR_M7_D < CSR_DV6_EN_1 ABUT < 90 SINGULAR REGION
  CSR_VIA6_D NOT CSR_M7_D 
}

SR_DV6.W.1 { @ Via width of DMV in Assembly isolation region. = ^SR_DV6_W_1
  NOT RECTANGLE ISO_VIA6_D == SR_DV6_W_1 BY == SR_DV6_W_1 ORTHOGONAL ONLY
}
SR_DV6.S.1 { @ Via space of DMV in Assembly isolation region. >= ^SR_DV6_S_1
  EXT ISO_VIA6_D < SR_DV6_S_1 ABUT < 90 SINGULAR REGION
}
SR_DV6.EN.1 { @ DMV via enclosure by DMV metal in Assembly isolation region. DMV via must be inside DMV metal. >= ^SR_DV6_EN_1
  ENC ISO_VIA6_D ISO_M7_D < SR_DV6_EN_1 ABUT < 90 SINGULAR REGION
  ISO_VIA6_D NOT ISO_M7_D 
}

CSR_DV7.W.1 { @ Via width of DMV in CSR region. = ^CSR_DV7_W_1
  NOT RECTANGLE CSR_VIA7_D == CSR_DV7_W_1 BY == CSR_DV7_W_1 ORTHOGONAL ONLY
}
CSR_DV7.S.1 { @ Via space of DMV in CSR region. >= ^CSR_DV7_S_1
  EXT CSR_VIA7_D < CSR_DV7_S_1 ABUT < 90 SINGULAR REGION
}
CSR_DV7.EN.1 { @ DMV via enclosure by DMV metal in CSR region. DMV via must be inside DMV metal. >= ^CSR_DV7_EN_1 
  ENC CSR_VIA7_D CSR_M8_D < CSR_DV7_EN_1 ABUT < 90 SINGULAR REGION
  CSR_VIA7_D NOT CSR_M8_D 
}

SR_DV7.W.1 { @ Via width of DMV in Assembly isolation region. = ^SR_DV7_W_1
  NOT RECTANGLE ISO_VIA7_D == SR_DV7_W_1 BY == SR_DV7_W_1 ORTHOGONAL ONLY
}
SR_DV7.S.1 { @ Via space of DMV in Assembly isolation region. >= ^SR_DV7_S_1
  EXT ISO_VIA7_D < SR_DV7_S_1 ABUT < 90 SINGULAR REGION
}
SR_DV7.EN.1 { @ DMV via enclosure by DMV metal in Assembly isolation region. DMV via must be inside DMV metal. >= ^SR_DV7_EN_1
  ENC ISO_VIA7_D ISO_M8_D < SR_DV7_EN_1 ABUT < 90 SINGULAR REGION
  ISO_VIA7_D NOT ISO_M8_D 
}

CSR_DV8.W.1 { @ Via width of DMV in CSR region. = ^CSR_DV8_W_1
  NOT RECTANGLE CSR_VIA8_D == CSR_DV8_W_1 BY == CSR_DV8_W_1 ORTHOGONAL ONLY
}
CSR_DV8.S.1 { @ Via space of DMV in CSR region. >= ^CSR_DV8_S_1
  EXT CSR_VIA8_D < CSR_DV8_S_1 ABUT < 90 SINGULAR REGION
}
CSR_DV8.EN.1 { @ DMV via enclosure by DMV metal in CSR region. DMV via must be inside DMV metal. >= ^CSR_DV8_EN_1 
  ENC CSR_VIA8_D CSR_M9_D < CSR_DV8_EN_1 ABUT < 90 SINGULAR REGION
  CSR_VIA8_D NOT CSR_M9_D 
}

SR_DV8.W.1 { @ Via width of DMV in Assembly isolation region. = ^SR_DV8_W_1
  NOT RECTANGLE ISO_VIA8_D == SR_DV8_W_1 BY == SR_DV8_W_1 ORTHOGONAL ONLY
}
SR_DV8.S.1 { @ Via space of DMV in Assembly isolation region. >= ^SR_DV8_S_1
  EXT ISO_VIA8_D < SR_DV8_S_1 ABUT < 90 SINGULAR REGION
}
SR_DV8.EN.1 { @ DMV via enclosure by DMV metal in Assembly isolation region. DMV via must be inside DMV metal. >= ^SR_DV8_EN_1
  ENC ISO_VIA8_D ISO_M9_D < SR_DV8_EN_1 ABUT < 90 SINGULAR REGION
  ISO_VIA8_D NOT ISO_M9_D 
}

CSR_DV9.W.1 { @ Via width of DMV in CSR region. = ^CSR_DV9_W_1
  NOT RECTANGLE CSR_VIA9_D == CSR_DV9_W_1 BY == CSR_DV9_W_1 ORTHOGONAL ONLY
}
CSR_DV9.S.1 { @ Via space of DMV in CSR region. >= ^CSR_DV9_S_1
  EXT CSR_VIA9_D < CSR_DV9_S_1 ABUT < 90 SINGULAR REGION
}
CSR_DV9.EN.1 { @ DMV via enclosure by DMV metal in CSR region. DMV via must be inside DMV metal. >= ^CSR_DV9_EN_1 
  ENC CSR_VIA9_D CSR_M10_D < CSR_DV9_EN_1 ABUT < 90 SINGULAR REGION
  CSR_VIA9_D NOT CSR_M10_D 
}

SR_DV9.W.1 { @ Via width of DMV in Assembly isolation region. = ^SR_DV9_W_1
  NOT RECTANGLE ISO_VIA9_D == SR_DV9_W_1 BY == SR_DV9_W_1 ORTHOGONAL ONLY
}
SR_DV9.S.1 { @ Via space of DMV in Assembly isolation region. >= ^SR_DV9_S_1
  EXT ISO_VIA9_D < SR_DV9_S_1 ABUT < 90 SINGULAR REGION
}
SR_DV9.EN.1 { @ DMV via enclosure by DMV metal in Assembly isolation region. DMV via must be inside DMV metal. >= ^SR_DV9_EN_1
  ENC ISO_VIA9_D ISO_M10_D < SR_DV9_EN_1 ABUT < 90 SINGULAR REGION
  ISO_VIA9_D NOT ISO_M10_D 
}



//Box in Box (BIB) pattern inside CSR
//=======================

CSR_OD_HOLE = (HOLES SEALRING_INNER) INTERACT CSRDMY

OD_RING_BIB = OD INSIDE CSR_OD_HOLE
#IFDEF P4_SEALRING
PO_RING_BIB = POLY INSIDE CSR_OD_HOLE
#ELSE
PO_RING_BIB = CSR_OD_HOLE NOT POLY
#ENDIF
CO_BIB = CO INSIDE CSR_OD_HOLE

#IFNDEF P4_SEALRING
CO_BIB_GROUP = SIZE CO_BIB BY 0.05 OVERUNDER
#ENDIF

OD_BULK_BIB = EXTENTS OD_RING_BIB
PO_BULK_BIB = EXTENTS PO_RING_BIB

OD_BULK_BIB_POOD = OD_BULK_BIB ENCLOSE PO_RING_BIB
PO_BULK_BIB_POOD = PO_BULK_BIB INSIDE OD_BULK_BIB
#IFDEF P4_SEALRING
OD_BULK_BIB_COOD = OD_BULK_BIB INTERACT CO_BIB == BIB_R_2+BIB_R_3
PO_BULK_BIB_COOD = PO_BULK_BIB INTERACT CO_BIB == BIB_R_2+BIB_R_3
CO_BULK_BIB_pre1 = SIZE CO_BIB BY BIB_L_1-2*BIB_EN_2 OVERUNDER
CO_BULK_OUTER_BIB = EXTENTS CO_BULK_BIB_pre1
CO_RING_OUTER_BIB = CO_BULK_OUTER_BIB NOT (SIZE CO_BULK_OUTER_BIB BY -BIB_W_2)
CO_BULK_BIB_pre2 = SIZE (CO_BIB NOT CO_RING_OUTER_BIB) BY BIB_L_1-2*BIB_EN_4 OVERUNDER
CO_BULK_INNER_BIB = EXTENTS CO_BULK_BIB_pre2
#ELSE
OD_BULK_BIB_COOD = OD_BULK_BIB INTERACT CO_BIB_GROUP == 4
PO_BULK_BIB_COOD = PO_BULK_BIB INTERACT CO_BIB_GROUP == 4
#ENDIF 

OD_HOLE_BIB_POOD = OD_BULK_BIB_POOD NOT OD_RING_BIB
OD_HOLE_BIB_COOD = OD_BULK_BIB_COOD NOT OD_RING_BIB
PO_HOLE_BIB_POOD = PO_BULK_BIB_POOD NOT PO_RING_BIB
PO_HOLE_BIB_COOD = PO_BULK_BIB_COOD NOT PO_RING_BIB


BiB.R.1 { @ PO_OD, CO_OD and CO_PO BiB patterns must inside CSR. 
          @ PO_OD BiB pattern is formed by [OD ring + PO ring inside OD ring] 
	  @ CO_PO {CO_OD} BiB pattern is formed by [PO {OD} ring + CO ring inside PO {OD} ring (inner and outer)]
  (CSR_OD_HOLE NOT INTERACT CSRBIB1DMY) NOT INTERACT CSRBIB2DMY
  (CSR_OD_HOLE INTERACT CSRBIB1DMY) INTERACT CSRBIB2DMY
  A = CSR_OD_HOLE INTERACT CSRBIB1DMY
  A NOT ENCLOSE OD_BULK_BIB_COOD
  A NOT ENCLOSE PO_BULK_BIB_COOD
  B = CSR_OD_HOLE INTERACT CSRBIB2DMY
  B NOT ENCLOSE OD_BULK_BIB_POOD
  B NOT ENCLOSE PO_BULK_BIB_COOD
  CHIPx NOT INTERACT A == 2
  CHIPx NOT INTERACT B == 2
}

BiB.W.1 { @ Width of OD ring and PO ring. == ^BIB_W_1
  NOT WITH WIDTH OD_RING_BIB == BIB_W_1
  NOT WITH WIDTH PO_RING_BIB == BIB_W_1
}

BiB.W.2 { @ Width of CO (maximum = minimum). == ^BIB_W_2
  NOT RECTANGLE CO_BIB == BIB_W_2 BY ==BIB_W_2 ORTHOGONAL ONLY
}

BiB.S.1 { @ Space of {OD ring or PO ring} to sealring OD 
@ DRC only select one side of OD ring or PO ring for space check == ^BIB_S_1
  A = EXT [OD_BULK_BIB] OD == BIB_S_1 OPPOSITE
  OD_BULK_BIB NOT WITH EDGE A
  
  B = EXT [PO_BULK_BIB_COOD] OD == BIB_S_1 OPPOSITE
  PO_BULK_BIB_COOD NOT WITH EDGE B
}

BiB.S.2 { @ Space of {OD ring or PO ring} corner to 45 degree seal ring OD edge. >= ^BIB_S_2
  A = CONVEX EDGE CSR_OD_HOLE ANGLE1 == 45 ANGLE2 == 45 WITH LENGTH > 20
  B = EXPAND EDGE A OUTSIDE BY 0.005
  EXT B OD_BULK_BIB < BIB_S_2 ABUT < 90 SINGULAR REGION
}

BiB.L.1 { @ Length of OD ring inner edge. == ^BIB_L_1
  NOT RECTANGLE OD_HOLE_BIB_POOD == BIB_L_1 BY ==BIB_L_1 ORTHOGONAL ONLY
  NOT RECTANGLE OD_HOLE_BIB_COOD == BIB_L_1 BY ==BIB_L_1 ORTHOGONAL ONLY
}

BiB.L.2 { @ Length of PO ring inner edge [in PO_OD BiB pattern]. == ^BIB_L_2
  NOT RECTANGLE PO_HOLE_BIB_POOD == BIB_L_2 BY ==BIB_L_2 ORTHOGONAL ONLY
}

BiB.L.3 { @ Length of PO ring inner edge [in CO_OD BiB pattern]. == ^BIB_L_3
  NOT RECTANGLE PO_HOLE_BIB_COOD == BIB_L_3 BY ==BIB_L_3 ORTHOGONAL ONLY
}

BiB.EN.1 { @ Enclosure of PO to OD [opposite edge in PO_OD BiB pattern]. == ^BIB_EN_1
  NOT WITH WIDTH ((OD_BULK_BIB_POOD NOT PO_BULK_BIB_POOD) NOT OD_RING_BIB) == BIB_EN_1
}

#IFDEF P4_SEALRING
BiB.S.3 { @ Space of CO to CO [in the same ring]. == ^BIB_S_3
  CO_BAR_BIB = SIZE CO_BIB BY BIB_S_3 OVERUNDER
  CO_SPACE_BIB = CO_BAR_BIB NOT CO_BIB
  NOT RECTANGLE CO_SPACE_BIB == BIB_W_2 BY == BIB_S_3 ORTHOGONAL ONLY
}

BiB.EN.2 { @ Enclosure of outer CO ring to OD [opposite edge in CO_OD BiB pattern]. == ^BIB_EN_2
  NOT WITH WIDTH ((OD_BULK_BIB_COOD NOT CO_BULK_OUTER_BIB) NOT OD_RING_BIB) == BIB_EN_2
}

BiB.EN.3 { @ Enclosure of outer CO ring to PO [opposite edge in CO_OD BiB pattern]. == ^BIB_EN_3
  NOT WITH WIDTH ((PO_BULK_BIB_COOD NOT CO_BULK_OUTER_BIB) NOT PO_RING_BIB) == BIB_EN_3
}

BiB.EN.4 { @ Enclosure of inner CO ring to OD [opposite edge in CO_OD BiB pattern]. == ^BIB_EN_4
  NOT WITH WIDTH ((OD_BULK_BIB_COOD NOT CO_BULK_INNER_BIB) NOT OD_RING_BIB) == BIB_EN_4
}

BiB.EN.5 { @ Enclosure of inner CO ring to PO [opposite edge in CO_OD BiB pattern]. == ^BIB_EN_5
  NOT WITH WIDTH ((PO_BULK_BIB_COOD NOT CO_BULK_INNER_BIB) NOT PO_RING_BIB) == BIB_EN_5
}

BiB.R.2 { @ Total CO number of outer CO ring. == ^BIB_R_2
  CO_RING_OUTER_BIB NOT INTERACT CO_BIB == BIB_R_2
}

BiB.R.3 { @ Total CO number of inner CO ring. == ^BIB_R_3
  CO_BULK_INNER_BIB NOT INTERACT CO_BIB == BIB_R_3
}
#ELSE
BIB.W.3__BIB.L.4 { @ Width x Length of {(CO SIZE 0.05) SIZE -0.05} = ^BIB_W_3 x ^BIB_L_4_1 or ^BIB_W_3 x ^BIB_L_4_2
   A = NOT RECTANGLE CO_BIB_GROUP == BIB_W_3 BY == BIB_L_4_1 ORTHOGONAL ONLY
   NOT RECTANGLE A == BIB_W_3 BY == BIB_L_4_2 ORTHOGONAL ONLY
}
BiB.S.3 { @ Space of CO to CO [in the same ring]. == ^BIB_S_3
  A = CO_BIB NOT COIN INSIDE EDGE CO_BIB_GROUP
  B = EXT [A] CO_BIB == BIB_S_3 OPPOSITE
  A NOT COIN INSIDE EDGE B
}
BiB.EN.2 { @ Enclosure of outer CO ring to OD [opposite edge in CO_OD BiB pattern]. == ^BIB_EN_2
   A = LENGTH CO_BIB_GROUP > BIB_W_3
   B = OD_BULK_BIB_COOD NOT OD_RING_BIB    
   C = ENC A [B] == BIB_EN_2 OPPOSITE
   B NOT TOUCH INSIDE EDGE C
}

BiB.EN.3 { @ Enclosure of outer CO ring to PO [opposite edge in CO_OD BiB pattern]. == ^BIB_EN_3
   A = LENGTH CO_BIB_GROUP > BIB_W_3
   B = PO_BULK_BIB_COOD NOT PO_RING_BIB    
   C = ENC A [B] == BIB_EN_3 OPPOSITE
   B NOT TOUCH INSIDE EDGE C
}
#ENDIF

BiB.R.4 { @ Overlap of OD, PO, CO patterns are not allowed.
  OD_RING_BIB AND PO_RING_BIB
  OD_RING_BIB AND CO_BIB
  PO_RING_BIB AND CO_BIB
}


#ENDIF
#ENDIF
#ENDIF


// Seal-Ring Rule Check
//=====================

#IFDEF FULL_CHIP
#IFDEF WITH_SEALRING
SR.S.1 { @ Width of assembly isolation >= ^SR_S_1 um (layout forbidden area.) Only DMV pattern and CDU allowed in assembly isolation region. (DMV pattern: metal/via dummy pattern)
  ISO_REGION AND DNWi
  ISO_REGION AND NWi
  (ISO_REGION AND POi) NOT INSIDE CDUDMY
  ISO_REGION AND DPO
  (ISO_REGION AND ODi) NOT INSIDE CDUDMY
  ISO_REGION AND DOD
  (ISO_REGION AND COi) NOT INSIDE CDUDMY
  ISO_REGION AND RVi 
  ISO_REGION AND UBMi
  ISO_REGION AND CBDi
  ISO_REGION AND CBi
  ISO_REGION AND CB2Fi
  ISO_REGION AND CB2Wi
}
SR.S.1.M1 {@ Width of assembly isolation >= ^SR_S_1 um (layout forbidden area.) Only DMV pattern and CDU allowed in assembly isolation region. (DMV pattern: metal/via dummy pattern).
   #IFDEF OLD_SEALRING 
   (M1i NOT INTERACT SEALRING_ORI) AND ISO_REGION
   #ELSE 
   (M1i NOT INTERACT SEALRING_ORI) CUT ISO_REGION
   #ENDIF
   DUM1 AND ISO_REGION
}
SR.S.1.M2 {@ Width of assembly isolation >= ^SR_S_1 um (layout forbidden area.) Only DMV pattern and CDU allowed in assembly isolation region. (DMV pattern: metal/via dummy pattern).
   #IFDEF OLD_SEALRING 
   (M2i NOT INTERACT SEALRING_ORI) AND ISO_REGION
   #ELSE 
   (M2i NOT INTERACT SEALRING_ORI) CUT ISO_REGION
   #ENDIF
   DUM2 AND ISO_REGION
}
SR.S.1.M3 {@ Width of assembly isolation >= ^SR_S_1 um (layout forbidden area.) Only DMV pattern and CDU allowed in assembly isolation region. (DMV pattern: metal/via dummy pattern).
   #IFDEF OLD_SEALRING 
   (M3i NOT INTERACT SEALRING_ORI) AND ISO_REGION
   #ELSE 
   (M3i NOT INTERACT SEALRING_ORI) CUT ISO_REGION
   #ENDIF
   DUM3 AND ISO_REGION
}
SR.S.1.M4 {@ Width of assembly isolation >= ^SR_S_1 um (layout forbidden area.) Only DMV pattern and CDU allowed in assembly isolation region. (DMV pattern: metal/via dummy pattern).
   #IFDEF OLD_SEALRING 
   (M4i NOT INTERACT SEALRING_ORI) AND ISO_REGION
   #ELSE 
   (M4i NOT INTERACT SEALRING_ORI) CUT ISO_REGION
   #ENDIF
   DUM4 AND ISO_REGION
}
SR.S.1.M5 {@ Width of assembly isolation >= ^SR_S_1 um (layout forbidden area.) Only DMV pattern and CDU allowed in assembly isolation region. (DMV pattern: metal/via dummy pattern).
   #IFDEF OLD_SEALRING 
   (M5i NOT INTERACT SEALRING_ORI) AND ISO_REGION
   #ELSE 
   (M5i NOT INTERACT SEALRING_ORI) CUT ISO_REGION
   #ENDIF
   DUM5 AND ISO_REGION
}
SR.S.1.M6 {@ Width of assembly isolation >= ^SR_S_1 um (layout forbidden area.) Only DMV pattern and CDU allowed in assembly isolation region. (DMV pattern: metal/via dummy pattern).
   #IFDEF OLD_SEALRING 
   (M6i NOT INTERACT SEALRING_ORI) AND ISO_REGION
   #ELSE 
   (M6i NOT INTERACT SEALRING_ORI) CUT ISO_REGION
   #ENDIF
   DUM6 AND ISO_REGION
}
SR.S.1.M7 {@ Width of assembly isolation >= ^SR_S_1 um (layout forbidden area.) Only DMV pattern and CDU allowed in assembly isolation region. (DMV pattern: metal/via dummy pattern).
   #IFDEF OLD_SEALRING 
   (M7i NOT INTERACT SEALRING_ORI) AND ISO_REGION
   #ELSE 
   (M7i NOT INTERACT SEALRING_ORI) CUT ISO_REGION
   #ENDIF
   DUM7 AND ISO_REGION
}
SR.S.1.M8 {@ Width of assembly isolation >= ^SR_S_1 um (layout forbidden area.) Only DMV pattern and CDU allowed in assembly isolation region. (DMV pattern: metal/via dummy pattern).
   #IFDEF OLD_SEALRING 
   (M8i NOT INTERACT SEALRING_ORI) AND ISO_REGION
   #ELSE 
   (M8i NOT INTERACT SEALRING_ORI) CUT ISO_REGION
   #ENDIF
   DUM8 AND ISO_REGION
}
SR.S.1.M9 {@ Width of assembly isolation >= ^SR_S_1 um (layout forbidden area.) Only DMV pattern and CDU allowed in assembly isolation region. (DMV pattern: metal/via dummy pattern).
   #IFDEF OLD_SEALRING 
   (M9i NOT INTERACT SEALRING_ORI) AND ISO_REGION
   #ELSE 
   (M9i NOT INTERACT SEALRING_ORI) CUT ISO_REGION
   #ENDIF
   DUM9 AND ISO_REGION
}
SR.S.1.M10 {@ Width of assembly isolation >= ^SR_S_1 um (layout forbidden area.) Only DMV pattern and CDU allowed in assembly isolation region. (DMV pattern: metal/via dummy pattern).
   #IFDEF OLD_SEALRING 
   (M10i NOT INTERACT SEALRING_ORI) AND ISO_REGION
   #ELSE 
   (M10i NOT INTERACT SEALRING_ORI) CUT ISO_REGION
   #ENDIF
   DUM10 AND ISO_REGION
}


SR.S.1.AP {@ Width of assembly isolation >= ^SR_S_1 um (layout forbidden area.) Only DMV pattern and CDU allowed in assembly isolation region. (DMV pattern: metal/via dummy pattern). AP overlap with CB2 is not allowed.
   (APi NOT INTERACT SEALRING_ORI) CUT ISO_REGION
    (APi AND SEALRING_EXCLUDE) AND (CB2Fi OR CB2Wi)
}

SR.R.1 { @ SEALRING layer (CAD layer: 162;0) and SEALRING_DB layer (CAD layer: 162;1) are Must if customers add seal ring by themselves.
         @ 162;0 is used to cover the outer seal ring (2um) and inner seal ring (6um);
         @ 162;1 is used to cover SLDB (3.5um duplicate).
         @ 162;2 is used to cover SEALRING, SLDB, and Assembly Isolation Region.
         @ SEALRING layer (162;0) , SEALRING_DB layer (162;1), and SEALRING_ALL layer (162;2) must exist.
         @ All the drawing of seal ring and SLDB structures must be inside of SEALRING (162;0) and SEALRING_DB (162;1). (except Mu)
         @ Please follow the CAD layers usage of 162;0, 162;1, and 162;2.
  CHIP NOT INTERACT SEALRING_ORI
  SR_CO NOT (SEALRING_ORI OR SEALRING_DB)
  SR_VIA1 NOT (SEALRING_ORI OR SEALRING_DB)
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA1
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA1_BAR
  SR_VIA2 NOT (SEALRING_ORI OR SEALRING_DB)
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA2
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA2_BAR
  SR_VIA3 NOT (SEALRING_ORI OR SEALRING_DB)
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA3
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA3_BAR
  SR_VIA4 NOT (SEALRING_ORI OR SEALRING_DB)
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA4
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA4_BAR
  SR_VIA5 NOT (SEALRING_ORI OR SEALRING_DB)
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA5
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA5_BAR
  SR_VIA6 NOT (SEALRING_ORI OR SEALRING_DB)
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA6
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA6_BAR
  SR_VIA7 NOT (SEALRING_ORI OR SEALRING_DB)
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA7
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA7_BAR
  SR_VIA8 NOT (SEALRING_ORI OR SEALRING_DB)
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA8
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA8_BAR
  SR_VIA9 NOT (SEALRING_ORI OR SEALRING_DB)
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA9
  (SEALRING_ORI OR SEALRING_DB) NOT INTERACT SR_VIA9_BAR
#IFNDEF OLD_SEALRING
  CHIP NOT INTERACT SEALRING_DB
  CHIP NOT INTERACT SEALRING_ALL
  (SEALRING_ORI OR SEALRING_DB) NOT SEALRING_ALL
#ENDIF  
}

SR.R.7 { @ co bar and via bar must be continuous as a ring
  NOT DONUT SR_CO
  CONVEX EDGE SR_CO ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*CO_W_2
  NOT DONUT SR_VIA1_BAR
  CONVEX EDGE SR_VIA1_BAR ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA1_W_2
  NOT DONUT SR_VIA2_BAR
  CONVEX EDGE SR_VIA2_BAR ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA2_W_2
  NOT DONUT SR_VIA3_BAR
  CONVEX EDGE SR_VIA3_BAR ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA3_W_2
  NOT DONUT SR_VIA4_BAR
  CONVEX EDGE SR_VIA4_BAR ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA4_W_2
  NOT DONUT SR_VIA5_BAR
  CONVEX EDGE SR_VIA5_BAR ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA5_W_2
  NOT DONUT SR_VIA6_BAR
  CONVEX EDGE SR_VIA6_BAR ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA6_W_2
  NOT DONUT SR_VIA7_BAR
  CONVEX EDGE SR_VIA7_BAR ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA7_W_2
  NOT DONUT SR_VIA8_BAR
  CONVEX EDGE SR_VIA8_BAR ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA8_W_2
  NOT DONUT SR_VIA9_BAR
  CONVEX EDGE SR_VIA9_BAR ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA9_W_2
}

SR.UBM.WARN { @ Do not draw UBM on Chip corner stress relief pattern/Seal ring/Assembly isolation  
  SRCSR AND UBMi
}

#IFNDEF OLD_SEALRING
#IFDEF SINGLE_PASSIVATION
CB.O.1 { @ Overlap of CB and top metal in outer sealring. == ^CB_O_1
  SR_CB_BAR_OUTER_M10 = SR_CB_BAR_OUTER AND M10
  X1 = ANGLE SR_CB_BAR_OUTER_M10 != 45
  X2 = ANGLE SR_CB_BAR_OUTER_M10 == 45
  INT X1 > CB_O_1 < CB_O_1*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > CB_O_1+GRID < CB_O_1*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_CB_BAR_OUTER_M10 >= CB_O_1*2
  INT X1 < CB_O_1 ABUT < 90 REGION
  INT X2 < CB_O_1-GRID ABUT < 90 REGION
}
#ELSE    
CB.W.3 { @ Width of CB/CBD line opening in inner seal ring. == ^CB_W_3 
  X1 = ANGLE SR_CB_BAR_INNER != 45
  X2 = ANGLE SR_CB_BAR_INNER == 45
  INT X1 > CB_W_3 < CB_W_3*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > CB_W_3+GRID < CB_W_3*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_CB_BAR_INNER >= CB_W_3*2
  INT X1 < CB_W_3 ABUT < 90 REGION
  INT X2 < CB_W_3-GRID ABUT < 90 REGION
}
CB.W.4 { @ Width of CB/CBD line opening in SLDB. == ^CB_W_4
  X1 = ANGLE SR_CB_BAR_SLDB != 45
  X2 = ANGLE SR_CB_BAR_SLDB == 45
  INT X1 > CB_W_4 < CB_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > CB_W_4+GRID < CB_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_CB_BAR_SLDB >= CB_W_4*2
  INT X1 < CB_W_4 ABUT < 90 REGION
  INT X2 < CB_W_4-GRID ABUT < 90 REGION
}
CB.EN.2 { @ Enclousure of CB/CBD by AP. >= ^CB_EN_2
  ENC SR_CB_BAR_INNER SR_AP_BAR_INNER < CB_EN_2 ABUT < 90 OPPOSITE REGION
  SR_CB_BAR_INNER NOT SR_AP_BAR_INNER
}
CB.EN.3 { @ Enclousure of CB/CBD by AP in SLDB. >= ^CB_EN_3
  ENC SR_CB_BAR_SLDB SR_AP_BAR_SLDB < CB_EN_3 ABUT < 90 OPPOSITE REGION
  SR_CB_BAR_SLDB NOT SR_AP_BAR_SLDB
}
AP.W.3 { @ Width of AP bar in inner seal ring. == ^AP_W_3 
  X = EXPAND EDGE (SEALRING_INNER INSIDE EDGE APi) INSIDE BY 6
  SR_AP_BAR_INNER_x = SR_AP_BAR_INNER NOT X    
  X1 = ANGLE SR_AP_BAR_INNER_x != 45
  X2 = ANGLE SR_AP_BAR_INNER_x == 45
  INT X1 > AP_W_3 < AP_W_3*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > AP_W_3+GRID < AP_W_3*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_AP_BAR_INNER_x >= AP_W_3*2
  INT X1 < AP_W_3 ABUT < 90 REGION
  INT X2 < AP_W_3-GRID ABUT < 90 REGION
}
AP.W.4 { @ Width of AP bar in SLDB. == ^AP_W_4
  X1 = ANGLE SR_AP_BAR_SLDB != 45
  X2 = ANGLE SR_AP_BAR_SLDB == 45
  INT X1 > AP_W_4 < AP_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > AP_W_4+GRID < AP_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_AP_BAR_SLDB >= AP_W_4*2
  INT X1 < AP_W_4 ABUT < 90 REGION
  INT X2 < AP_W_4-GRID ABUT < 90 REGION
}
CB2.W.5 { @ Width of CB2_WB/CB2_FC line opening in outer seal ring. == ^CB2_W_5
  X1 = ANGLE SR_CB2_BAR_OUTER != 45
  X2 = ANGLE SR_CB2_BAR_OUTER == 45
  INT X1 > CB2_W_5 < CB2_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > CB2_W_5+GRID < CB2_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_CB2_BAR_OUTER >= CB2_W_5*2
  INT X1 < CB2_W_5 ABUT < 90 REGION
  INT X2 < CB2_W_5-GRID ABUT < 90 REGION
}
CB2.W.6 { @ Width of CB2_WB/CB2_FC line opening in SLDB. == ^CB2_W_6
  X1 = ANGLE SR_CB2_BAR_SLDB != 45
  X2 = ANGLE SR_CB2_BAR_SLDB == 45
  INT X1 > CB2_W_6 < CB2_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > CB2_W_6+GRID < CB2_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_CB2_BAR_SLDB >= CB2_W_6*2
  INT X1 < CB2_W_6 ABUT < 90 REGION
  INT X2 < CB2_W_6-GRID ABUT < 90 REGION
}
#ENDIF

#IFDEF WITH_POLYIMIDE
PM.R.3 { @ Polyimide is prohibited over outer seal ring and SLDB regions.
         @ It only covers inner seal ring area (6um/5.4um for N45/N40).
         @ Please see Fig. 2.5.1.1. (PM drawn pattern must cover outer seal ring and SLDB regions.)
  (SEALRING_OUTER OR SEALRING_DB) NOT PMi
   SEALRING_INNER AND PMi
}
#ENDIF

#ENDIF
#ENDIF
#ENDIF


// Seal-Ring Wall Layout Rule Check
//=====================
#IFDEF FULL_CHIP
#IFDEF WITH_SEALRING

CO.W.2 { @ Width of CO bar. CO bar is only allowed in seal ring and SLDB. == ^CO_W_2  
  X1 = ANGLE SR_CO != 45
  X2 = ANGLE SR_CO == 45
  INT X1 > CO_W_2 < CO_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > CO_W_2+GRID < CO_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_CO >= CO_W_2*2) ENCLOSE RECTANGLE 1 GRID
  INT X1 < CO_W_2 ABUT < 90 REGION
  INT X2 < CO_W_2-GRID ABUT < 90 REGION
}
#IFNDEF OLD_SEALRING
M1.W.4 { @ Width of M1 metal line in outer seal ring == ^M1_W_4
  X1 = ANGLE SR_M1_OUTER != 45
  X2 = ANGLE SR_M1_OUTER == 45
  INT X1 > M1_W_4 < M1_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M1_W_4+GRID < M1_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M1_OUTER >= M1_W_4*2
  INT X1 < M1_W_4 ABUT < 90 REGION
  INT X2 < M1_W_4-GRID ABUT < 90 REGION
}
M1.W.5 { @ Width of M1 metal line in inner seal ring == ^M1_W_5
  X1 = ANGLE SR_M1_INNER != 45
  X2 = ANGLE SR_M1_INNER == 45
  INT X1 > M1_W_5 < M1_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M1_W_5+GRID < M1_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M1_INNER >= M1_W_5*2
  INT X1 < M1_W_5 ABUT < 90 REGION
  INT X2 < M1_W_5-GRID ABUT < 90 REGION
}
M1.W.6 { @ Width of M1 metal line in SLDB == ^M1_W_6
  X1 = ANGLE SLDB_M1 != 45
  X2 = ANGLE SLDB_M1 == 45
  INT X1 > M1_W_6 < M1_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M1_W_6+GRID < M1_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SLDB_M1 >= M1_W_6*2
  INT X1 < M1_W_6 ABUT < 90 REGION
  INT X2 < M1_W_6-GRID ABUT < 90 REGION
}
#ENDIF
#IFNDEF P3_SEALRING
VIA1.W.2__VIA1.W.4 { @ Width of VIA1 bar of sealring/SLDB = ^VIA1_W_2
  X1 = ANGLE SR_VIA1_BAR != 45
  X2 = ANGLE SR_VIA1_BAR == 45
  INT X1 > VIA1_W_2 < VIA1_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA1_W_2+GRID < VIA1_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA1_BAR >= VIA1_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA1_W_2 ABUT < 90 REGION
  INT X2 < VIA1_W_2-GRID ABUT < 90 REGION
}
VIA1.W.3__VIA1.W.5 { @ Width of VIA1 hole of sealring/SLDB = ^VIA1_W_3
  NOT RECTANGLE SR_VIA1_HOLE == VIA1_W_3 BY == VIA1_W_3 ORTHOGONAL ONLY
}
#ELSE
VIA1.W.2 { @ Width of VIA1 bar of sealring = ^VIA1_W_2
  X1 = ANGLE SR_VIA1_BAR != 45
  X2 = ANGLE SR_VIA1_BAR == 45
  INT X1 > VIA1_W_2 < VIA1_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA1_W_2+GRID < VIA1_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA1_BAR >= VIA1_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA1_W_2 ABUT < 90 REGION
  INT X2 < VIA1_W_2-GRID ABUT < 90 REGION
}
VIA1.W.3 { @ Width of VIA1 hole of sealring = ^VIA1_W_3
  NOT RECTANGLE SR_VIA1_HOLE == VIA1_W_3 BY == VIA1_W_3 ORTHOGONAL ONLY
}
#ENDIF
#IFNDEF OLD_SEALRING
VIA1.EN.5 { @ Enclosure of VIA1 bar by M1 of seal ring >= ^VIA1_EN_5
  ENC SR_VIA1_BAR_SR M1 < VIA1_EN_5 ABUT < 90 SINGULAR REGION
}
VIA1.EN.6 { @ Enclosure of VIA1 hole by M1 of seal ring >= ^VIA1_EN_6
  ENC SR_VIA1_HOLE_SR M1 < VIA1_EN_6 ABUT < 90 SINGULAR REGION
}
VIA1.EN.7 { @ Enclosure of VIA1 hole by M1 of SLDB >= ^VIA1_EN_7
  ENC SR_VIA1_HOLE_SLDB M1 < VIA1_EN_7 ABUT < 90 SINGULAR REGION
}
VIA1.S.4 { @ Space of VIA1 hole in seal ring. >= ^VIA1_S_4
  EXT SR_VIA1_HOLE_SR < VIA1_S_4 ABUT < 90 SINGULAR REGION
}
VIA1.S.5 { @ Space of VIA1 hole to VIAx bar in seal ring. >= ^VIA1_S_5 
  EXT SR_VIA1_HOLE_SR SR_VIA1_BAR_SR < VIA1_S_5 ABUT < 90 SINGULAR REGION
}
VIA1.S.6 { @ Space of VIA1 hole in SLDB.>= ^VIA1_S_6
  EXT SR_VIA1_HOLE_SLDB < VIA1_S_6 ABUT < 90 SINGULAR REGION
}
#ENDIF
#IFNDEF OLD_SEALRING
M2.W.4 { @ Width of M2 metal line in outer seal ring == ^M2_W_4
  X1 = ANGLE SR_M2_OUTER != 45
  X2 = ANGLE SR_M2_OUTER == 45
  INT X1 > M2_W_4 < M2_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M2_W_4+GRID < M2_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M2_OUTER >= M2_W_4*2
  INT X1 < M2_W_4 ABUT < 90 REGION
  INT X2 < M2_W_4-GRID ABUT < 90 REGION
}
M2.W.5 { @ Width of M2 metal line in inner seal ring == ^M2_W_5
  X1 = ANGLE SR_M2_INNER != 45
  X2 = ANGLE SR_M2_INNER == 45
  INT X1 > M2_W_5 < M2_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M2_W_5+GRID < M2_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M2_INNER >= M2_W_5*2
  INT X1 < M2_W_5 ABUT < 90 REGION
  INT X2 < M2_W_5-GRID ABUT < 90 REGION
}
M2.W.6 { @ Width of M2 metal line in SLDB == ^M2_W_6
  X1 = ANGLE SLDB_M2 != 45
  X2 = ANGLE SLDB_M2 == 45
  INT X1 > M2_W_6 < M2_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M2_W_6+GRID < M2_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SLDB_M2 >= M2_W_6*2
  INT X1 < M2_W_6 ABUT < 90 REGION
  INT X2 < M2_W_6-GRID ABUT < 90 REGION
}
#ENDIF
#IFNDEF P3_SEALRING
VIA2.W.2__VIA2.W.4 { @ Width of VIA2 bar of sealring/SLDB = ^VIA2_W_2
  X1 = ANGLE SR_VIA2_BAR != 45
  X2 = ANGLE SR_VIA2_BAR == 45
  INT X1 > VIA2_W_2 < VIA2_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA2_W_2+GRID < VIA2_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA2_BAR >= VIA2_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA2_W_2 ABUT < 90 REGION
  INT X2 < VIA2_W_2-GRID ABUT < 90 REGION
}
VIA2.W.3__VIA2.W.5 { @ Width of VIA2 hole of sealring/SLDB = ^VIA2_W_3
  NOT RECTANGLE SR_VIA2_HOLE == VIA2_W_3 BY == VIA2_W_3 ORTHOGONAL ONLY
}
#ELSE
VIA2.W.2 { @ Width of VIA2 bar of sealring = ^VIA2_W_2
  X1 = ANGLE SR_VIA2_BAR != 45
  X2 = ANGLE SR_VIA2_BAR == 45
  INT X1 > VIA2_W_2 < VIA2_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA2_W_2+GRID < VIA2_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA2_BAR >= VIA2_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA2_W_2 ABUT < 90 REGION
  INT X2 < VIA2_W_2-GRID ABUT < 90 REGION
}
VIA2.W.3 { @ Width of VIA2 hole of sealring = ^VIA2_W_3
  NOT RECTANGLE SR_VIA2_HOLE == VIA2_W_3 BY == VIA2_W_3 ORTHOGONAL ONLY
}
#ENDIF
#IFNDEF OLD_SEALRING
VIA2.EN.5 { @ Enclosure of VIA2 bar by M2 of seal ring >= ^VIA2_EN_5
  ENC SR_VIA2_BAR_SR M2 < VIA2_EN_5 ABUT < 90 SINGULAR REGION
}
VIA2.EN.6 { @ Enclosure of VIA2 hole by M2 of seal ring >= ^VIA2_EN_6
  ENC SR_VIA2_HOLE_SR M2 < VIA2_EN_6 ABUT < 90 SINGULAR REGION
}
VIA2.EN.7 { @ Enclosure of VIA2 hole by M2 of SLDB >= ^VIA2_EN_7
  ENC SR_VIA2_HOLE_SLDB M2 < VIA2_EN_7 ABUT < 90 SINGULAR REGION
}
VIA2.S.4 { @ Space of VIA2 hole in seal ring. >= ^VIA2_S_4
  EXT SR_VIA2_HOLE_SR < VIA2_S_4 ABUT < 90 SINGULAR REGION
}
VIA2.S.5 { @ Space of VIA2 hole to VIAx bar in seal ring. >= ^VIA2_S_5 
  EXT SR_VIA2_HOLE_SR SR_VIA2_BAR_SR < VIA2_S_5 ABUT < 90 SINGULAR REGION
}
VIA2.S.6 { @ Space of VIA2 hole in SLDB.>= ^VIA2_S_6
  EXT SR_VIA2_HOLE_SLDB < VIA2_S_6 ABUT < 90 SINGULAR REGION
}
#ENDIF
#IFNDEF OLD_SEALRING
M3.W.4 { @ Width of M3 metal line in outer seal ring == ^M3_W_4
  X1 = ANGLE SR_M3_OUTER != 45
  X2 = ANGLE SR_M3_OUTER == 45
  INT X1 > M3_W_4 < M3_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M3_W_4+GRID < M3_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M3_OUTER >= M3_W_4*2
  INT X1 < M3_W_4 ABUT < 90 REGION
  INT X2 < M3_W_4-GRID ABUT < 90 REGION
}
M3.W.5 { @ Width of M3 metal line in inner seal ring == ^M3_W_5
  X1 = ANGLE SR_M3_INNER != 45
  X2 = ANGLE SR_M3_INNER == 45
  INT X1 > M3_W_5 < M3_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M3_W_5+GRID < M3_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M3_INNER >= M3_W_5*2
  INT X1 < M3_W_5 ABUT < 90 REGION
  INT X2 < M3_W_5-GRID ABUT < 90 REGION
}
M3.W.6 { @ Width of M3 metal line in SLDB == ^M3_W_6
  X1 = ANGLE SLDB_M3 != 45
  X2 = ANGLE SLDB_M3 == 45
  INT X1 > M3_W_6 < M3_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M3_W_6+GRID < M3_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SLDB_M3 >= M3_W_6*2
  INT X1 < M3_W_6 ABUT < 90 REGION
  INT X2 < M3_W_6-GRID ABUT < 90 REGION
}
#ENDIF
#IFNDEF P3_SEALRING
VIA3.W.2__VIA3.W.4 { @ Width of VIA3 bar of sealring/SLDB = ^VIA3_W_2
  X1 = ANGLE SR_VIA3_BAR != 45
  X2 = ANGLE SR_VIA3_BAR == 45
  INT X1 > VIA3_W_2 < VIA3_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA3_W_2+GRID < VIA3_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA3_BAR >= VIA3_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA3_W_2 ABUT < 90 REGION
  INT X2 < VIA3_W_2-GRID ABUT < 90 REGION
}
VIA3.W.3__VIA3.W.5 { @ Width of VIA3 hole of sealring/SLDB = ^VIA3_W_3
  NOT RECTANGLE SR_VIA3_HOLE == VIA3_W_3 BY == VIA3_W_3 ORTHOGONAL ONLY
}
#ELSE
VIA3.W.2 { @ Width of VIA3 bar of sealring = ^VIA3_W_2
  X1 = ANGLE SR_VIA3_BAR != 45
  X2 = ANGLE SR_VIA3_BAR == 45
  INT X1 > VIA3_W_2 < VIA3_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA3_W_2+GRID < VIA3_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA3_BAR >= VIA3_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA3_W_2 ABUT < 90 REGION
  INT X2 < VIA3_W_2-GRID ABUT < 90 REGION
}
VIA3.W.3 { @ Width of VIA3 hole of sealring = ^VIA3_W_3
  NOT RECTANGLE SR_VIA3_HOLE == VIA3_W_3 BY == VIA3_W_3 ORTHOGONAL ONLY
}
#ENDIF
#IFNDEF OLD_SEALRING
VIA3.EN.5 { @ Enclosure of VIA3 bar by M3 of seal ring >= ^VIA3_EN_5
  ENC SR_VIA3_BAR_SR M3 < VIA3_EN_5 ABUT < 90 SINGULAR REGION
}
VIA3.EN.6 { @ Enclosure of VIA3 hole by M3 of seal ring >= ^VIA3_EN_6
  ENC SR_VIA3_HOLE_SR M3 < VIA3_EN_6 ABUT < 90 SINGULAR REGION
}
VIA3.EN.7 { @ Enclosure of VIA3 hole by M3 of SLDB >= ^VIA3_EN_7
  ENC SR_VIA3_HOLE_SLDB M3 < VIA3_EN_7 ABUT < 90 SINGULAR REGION
}
VIA3.S.4 { @ Space of VIA3 hole in seal ring. >= ^VIA3_S_4
  EXT SR_VIA3_HOLE_SR < VIA3_S_4 ABUT < 90 SINGULAR REGION
}
VIA3.S.5 { @ Space of VIA3 hole to VIAx bar in seal ring. >= ^VIA3_S_5 
  EXT SR_VIA3_HOLE_SR SR_VIA3_BAR_SR < VIA3_S_5 ABUT < 90 SINGULAR REGION
}
VIA3.S.6 { @ Space of VIA3 hole in SLDB.>= ^VIA3_S_6
  EXT SR_VIA3_HOLE_SLDB < VIA3_S_6 ABUT < 90 SINGULAR REGION
}
#ENDIF
#IFNDEF OLD_SEALRING
M4.W.4 { @ Width of M4 metal line in outer seal ring == ^M4_W_4
  X1 = ANGLE SR_M4_OUTER != 45
  X2 = ANGLE SR_M4_OUTER == 45
  INT X1 > M4_W_4 < M4_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M4_W_4+GRID < M4_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M4_OUTER >= M4_W_4*2
  INT X1 < M4_W_4 ABUT < 90 REGION
  INT X2 < M4_W_4-GRID ABUT < 90 REGION
}
M4.W.5 { @ Width of M4 metal line in inner seal ring == ^M4_W_5
  X1 = ANGLE SR_M4_INNER != 45
  X2 = ANGLE SR_M4_INNER == 45
  INT X1 > M4_W_5 < M4_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M4_W_5+GRID < M4_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M4_INNER >= M4_W_5*2
  INT X1 < M4_W_5 ABUT < 90 REGION
  INT X2 < M4_W_5-GRID ABUT < 90 REGION
}
M4.W.6 { @ Width of M4 metal line in SLDB == ^M4_W_6
  X1 = ANGLE SLDB_M4 != 45
  X2 = ANGLE SLDB_M4 == 45
  INT X1 > M4_W_6 < M4_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M4_W_6+GRID < M4_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SLDB_M4 >= M4_W_6*2
  INT X1 < M4_W_6 ABUT < 90 REGION
  INT X2 < M4_W_6-GRID ABUT < 90 REGION
}
#ENDIF
#IFNDEF P3_SEALRING
VIA4.W.2__VIA4.W.4 { @ Width of VIA4 bar of sealring/SLDB = ^VIA4_W_2
  X1 = ANGLE SR_VIA4_BAR != 45
  X2 = ANGLE SR_VIA4_BAR == 45
  INT X1 > VIA4_W_2 < VIA4_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA4_W_2+GRID < VIA4_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA4_BAR >= VIA4_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA4_W_2 ABUT < 90 REGION
  INT X2 < VIA4_W_2-GRID ABUT < 90 REGION
}
VIA4.W.3__VIA4.W.5 { @ Width of VIA4 hole of sealring/SLDB = ^VIA4_W_3
  NOT RECTANGLE SR_VIA4_HOLE == VIA4_W_3 BY == VIA4_W_3 ORTHOGONAL ONLY
}
#ELSE
VIA4.W.2 { @ Width of VIA4 bar of sealring = ^VIA4_W_2
  X1 = ANGLE SR_VIA4_BAR != 45
  X2 = ANGLE SR_VIA4_BAR == 45
  INT X1 > VIA4_W_2 < VIA4_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA4_W_2+GRID < VIA4_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA4_BAR >= VIA4_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA4_W_2 ABUT < 90 REGION
  INT X2 < VIA4_W_2-GRID ABUT < 90 REGION
}
VIA4.W.3 { @ Width of VIA4 hole of sealring = ^VIA4_W_3
  NOT RECTANGLE SR_VIA4_HOLE == VIA4_W_3 BY == VIA4_W_3 ORTHOGONAL ONLY
}
#ENDIF
#IFNDEF OLD_SEALRING
VIA4.EN.5 { @ Enclosure of VIA4 bar by M4 of seal ring >= ^VIA4_EN_5
  ENC SR_VIA4_BAR_SR M4 < VIA4_EN_5 ABUT < 90 SINGULAR REGION
}
VIA4.EN.6 { @ Enclosure of VIA4 hole by M4 of seal ring >= ^VIA4_EN_6
  ENC SR_VIA4_HOLE_SR M4 < VIA4_EN_6 ABUT < 90 SINGULAR REGION
}
VIA4.EN.7 { @ Enclosure of VIA4 hole by M4 of SLDB >= ^VIA4_EN_7
  ENC SR_VIA4_HOLE_SLDB M4 < VIA4_EN_7 ABUT < 90 SINGULAR REGION
}
VIA4.S.4 { @ Space of VIA4 hole in seal ring. >= ^VIA4_S_4
  EXT SR_VIA4_HOLE_SR < VIA4_S_4 ABUT < 90 SINGULAR REGION
}
VIA4.S.5 { @ Space of VIA4 hole to VIAx bar in seal ring. >= ^VIA4_S_5 
  EXT SR_VIA4_HOLE_SR SR_VIA4_BAR_SR < VIA4_S_5 ABUT < 90 SINGULAR REGION
}
VIA4.S.6 { @ Space of VIA4 hole in SLDB.>= ^VIA4_S_6
  EXT SR_VIA4_HOLE_SLDB < VIA4_S_6 ABUT < 90 SINGULAR REGION
}
#ENDIF
#IFNDEF OLD_SEALRING
M5.W.4 { @ Width of M5 metal line in outer seal ring == ^M5_W_4
  X1 = ANGLE SR_M5_OUTER != 45
  X2 = ANGLE SR_M5_OUTER == 45
  INT X1 > M5_W_4 < M5_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M5_W_4+GRID < M5_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M5_OUTER >= M5_W_4*2
  INT X1 < M5_W_4 ABUT < 90 REGION
  INT X2 < M5_W_4-GRID ABUT < 90 REGION
}
M5.W.5 { @ Width of M5 metal line in inner seal ring == ^M5_W_5
  X1 = ANGLE SR_M5_INNER != 45
  X2 = ANGLE SR_M5_INNER == 45
  INT X1 > M5_W_5 < M5_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M5_W_5+GRID < M5_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M5_INNER >= M5_W_5*2
  INT X1 < M5_W_5 ABUT < 90 REGION
  INT X2 < M5_W_5-GRID ABUT < 90 REGION
}
M5.W.6 { @ Width of M5 metal line in SLDB == ^M5_W_6
  X1 = ANGLE SLDB_M5 != 45
  X2 = ANGLE SLDB_M5 == 45
  INT X1 > M5_W_6 < M5_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M5_W_6+GRID < M5_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SLDB_M5 >= M5_W_6*2
  INT X1 < M5_W_6 ABUT < 90 REGION
  INT X2 < M5_W_6-GRID ABUT < 90 REGION
}
#ENDIF
#IFNDEF P3_SEALRING
VIA5.W.2__VIA5.W.4 { @ Width of VIA5 bar of sealring/SLDB = ^VIA5_W_2
  X1 = ANGLE SR_VIA5_BAR != 45
  X2 = ANGLE SR_VIA5_BAR == 45
  INT X1 > VIA5_W_2 < VIA5_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA5_W_2+GRID < VIA5_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA5_BAR >= VIA5_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA5_W_2 ABUT < 90 REGION
  INT X2 < VIA5_W_2-GRID ABUT < 90 REGION
}
VIA5.W.3__VIA5.W.5 { @ Width of VIA5 hole of sealring/SLDB = ^VIA5_W_3
  NOT RECTANGLE SR_VIA5_HOLE == VIA5_W_3 BY == VIA5_W_3 ORTHOGONAL ONLY
}
#ELSE
VIA5.W.2 { @ Width of VIA5 bar of sealring = ^VIA5_W_2
  X1 = ANGLE SR_VIA5_BAR != 45
  X2 = ANGLE SR_VIA5_BAR == 45
  INT X1 > VIA5_W_2 < VIA5_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA5_W_2+GRID < VIA5_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA5_BAR >= VIA5_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA5_W_2 ABUT < 90 REGION
  INT X2 < VIA5_W_2-GRID ABUT < 90 REGION
}
VIA5.W.3 { @ Width of VIA5 hole of sealring = ^VIA5_W_3
  NOT RECTANGLE SR_VIA5_HOLE == VIA5_W_3 BY == VIA5_W_3 ORTHOGONAL ONLY
}
#ENDIF
#IFNDEF OLD_SEALRING
VIA5.EN.5 { @ Enclosure of VIA5 bar by M5 of seal ring >= ^VIA5_EN_5
  ENC SR_VIA5_BAR_SR M5 < VIA5_EN_5 ABUT < 90 SINGULAR REGION
}
VIA5.EN.6 { @ Enclosure of VIA5 hole by M5 of seal ring >= ^VIA5_EN_6
  ENC SR_VIA5_HOLE_SR M5 < VIA5_EN_6 ABUT < 90 SINGULAR REGION
}
VIA5.EN.7 { @ Enclosure of VIA5 hole by M5 of SLDB >= ^VIA5_EN_7
  ENC SR_VIA5_HOLE_SLDB M5 < VIA5_EN_7 ABUT < 90 SINGULAR REGION
}
VIA5.S.4 { @ Space of VIA5 hole in seal ring. >= ^VIA5_S_4
  EXT SR_VIA5_HOLE_SR < VIA5_S_4 ABUT < 90 SINGULAR REGION
}
VIA5.S.5 { @ Space of VIA5 hole to VIAx bar in seal ring. >= ^VIA5_S_5 
  EXT SR_VIA5_HOLE_SR SR_VIA5_BAR_SR < VIA5_S_5 ABUT < 90 SINGULAR REGION
}
VIA5.S.6 { @ Space of VIA5 hole in SLDB.>= ^VIA5_S_6
  EXT SR_VIA5_HOLE_SLDB < VIA5_S_6 ABUT < 90 SINGULAR REGION
}
#ENDIF
#IFNDEF OLD_SEALRING
M6.W.4 { @ Width of M6 metal line in outer seal ring == ^M6_W_4
  X1 = ANGLE SR_M6_OUTER != 45
  X2 = ANGLE SR_M6_OUTER == 45
  INT X1 > M6_W_4 < M6_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M6_W_4+GRID < M6_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M6_OUTER >= M6_W_4*2
  INT X1 < M6_W_4 ABUT < 90 REGION
  INT X2 < M6_W_4-GRID ABUT < 90 REGION
}
M6.W.5 { @ Width of M6 metal line in inner seal ring == ^M6_W_5
  X1 = ANGLE SR_M6_INNER != 45
  X2 = ANGLE SR_M6_INNER == 45
  INT X1 > M6_W_5 < M6_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M6_W_5+GRID < M6_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M6_INNER >= M6_W_5*2
  INT X1 < M6_W_5 ABUT < 90 REGION
  INT X2 < M6_W_5-GRID ABUT < 90 REGION
}
M6.W.6 { @ Width of M6 metal line in SLDB == ^M6_W_6
  X1 = ANGLE SLDB_M6 != 45
  X2 = ANGLE SLDB_M6 == 45
  INT X1 > M6_W_6 < M6_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M6_W_6+GRID < M6_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SLDB_M6 >= M6_W_6*2
  INT X1 < M6_W_6 ABUT < 90 REGION
  INT X2 < M6_W_6-GRID ABUT < 90 REGION
}
#ENDIF
#IFNDEF P3_SEALRING
VIA6.W.2__VIA6.W.4 { @ Width of VIA6 bar of sealring/SLDB = ^VIA6_W_2
  X1 = ANGLE SR_VIA6_BAR != 45
  X2 = ANGLE SR_VIA6_BAR == 45
  INT X1 > VIA6_W_2 < VIA6_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA6_W_2+GRID < VIA6_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA6_BAR >= VIA6_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA6_W_2 ABUT < 90 REGION
  INT X2 < VIA6_W_2-GRID ABUT < 90 REGION
}
VIA6.W.3__VIA6.W.5 { @ Width of VIA6 hole of sealring/SLDB = ^VIA6_W_3
  NOT RECTANGLE SR_VIA6_HOLE == VIA6_W_3 BY == VIA6_W_3 ORTHOGONAL ONLY
}
#ELSE
VIA6.W.2 { @ Width of VIA6 bar of sealring = ^VIA6_W_2
  X1 = ANGLE SR_VIA6_BAR != 45
  X2 = ANGLE SR_VIA6_BAR == 45
  INT X1 > VIA6_W_2 < VIA6_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA6_W_2+GRID < VIA6_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA6_BAR >= VIA6_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA6_W_2 ABUT < 90 REGION
  INT X2 < VIA6_W_2-GRID ABUT < 90 REGION
}
VIA6.W.3 { @ Width of VIA6 hole of sealring = ^VIA6_W_3
  NOT RECTANGLE SR_VIA6_HOLE == VIA6_W_3 BY == VIA6_W_3 ORTHOGONAL ONLY
}
#ENDIF
#IFNDEF OLD_SEALRING
VIA6.EN.5 { @ Enclosure of VIA6 bar by M6 of seal ring >= ^VIA6_EN_5
  ENC SR_VIA6_BAR_SR M6 < VIA6_EN_5 ABUT < 90 SINGULAR REGION
}
VIA6.EN.6 { @ Enclosure of VIA6 hole by M6 of seal ring >= ^VIA6_EN_6
  ENC SR_VIA6_HOLE_SR M6 < VIA6_EN_6 ABUT < 90 SINGULAR REGION
}
VIA6.EN.7 { @ Enclosure of VIA6 hole by M6 of SLDB >= ^VIA6_EN_7
  ENC SR_VIA6_HOLE_SLDB M6 < VIA6_EN_7 ABUT < 90 SINGULAR REGION
}
VIA6.S.4 { @ Space of VIA6 hole in seal ring. >= ^VIA6_S_4
  EXT SR_VIA6_HOLE_SR < VIA6_S_4 ABUT < 90 SINGULAR REGION
}
VIA6.S.5 { @ Space of VIA6 hole to VIAx bar in seal ring. >= ^VIA6_S_5 
  EXT SR_VIA6_HOLE_SR SR_VIA6_BAR_SR < VIA6_S_5 ABUT < 90 SINGULAR REGION
}
VIA6.S.6 { @ Space of VIA6 hole in SLDB.>= ^VIA6_S_6
  EXT SR_VIA6_HOLE_SLDB < VIA6_S_6 ABUT < 90 SINGULAR REGION
}
#ENDIF
#IFNDEF OLD_SEALRING
M7.W.4 { @ Width of M7 metal line in outer seal ring == ^M7_W_4
  X1 = ANGLE SR_M7_OUTER != 45
  X2 = ANGLE SR_M7_OUTER == 45
  INT X1 > M7_W_4 < M7_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M7_W_4+GRID < M7_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M7_OUTER >= M7_W_4*2
  INT X1 < M7_W_4 ABUT < 90 REGION
  INT X2 < M7_W_4-GRID ABUT < 90 REGION
}
M7.W.5 { @ Width of M7 metal line in inner seal ring == ^M7_W_5
  X1 = ANGLE SR_M7_INNER != 45
  X2 = ANGLE SR_M7_INNER == 45
  INT X1 > M7_W_5 < M7_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M7_W_5+GRID < M7_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M7_INNER >= M7_W_5*2
  INT X1 < M7_W_5 ABUT < 90 REGION
  INT X2 < M7_W_5-GRID ABUT < 90 REGION
}
M7.W.6 { @ Width of M7 metal line in SLDB == ^M7_W_6
  X1 = ANGLE SLDB_M7 != 45
  X2 = ANGLE SLDB_M7 == 45
  INT X1 > M7_W_6 < M7_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M7_W_6+GRID < M7_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SLDB_M7 >= M7_W_6*2
  INT X1 < M7_W_6 ABUT < 90 REGION
  INT X2 < M7_W_6-GRID ABUT < 90 REGION
}
#ENDIF
#IFNDEF P3_SEALRING
VIA7.W.2__VIA7.W.4 { @ Width of VIA7 bar of sealring/SLDB = ^VIA7_W_2
  X1 = ANGLE SR_VIA7_BAR != 45
  X2 = ANGLE SR_VIA7_BAR == 45
  INT X1 > VIA7_W_2 < VIA7_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA7_W_2+GRID < VIA7_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA7_BAR >= VIA7_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA7_W_2 ABUT < 90 REGION
  INT X2 < VIA7_W_2-GRID ABUT < 90 REGION
}
VIA7.W.3__VIA7.W.5 { @ Width of VIA7 hole of sealring/SLDB = ^VIA7_W_3
  NOT RECTANGLE SR_VIA7_HOLE == VIA7_W_3 BY == VIA7_W_3 ORTHOGONAL ONLY
}
#ELSE
VIA7.W.2 { @ Width of VIA7 bar of sealring = ^VIA7_W_2
  X1 = ANGLE SR_VIA7_BAR != 45
  X2 = ANGLE SR_VIA7_BAR == 45
  INT X1 > VIA7_W_2 < VIA7_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA7_W_2+GRID < VIA7_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA7_BAR >= VIA7_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA7_W_2 ABUT < 90 REGION
  INT X2 < VIA7_W_2-GRID ABUT < 90 REGION
}
VIA7.W.3 { @ Width of VIA7 hole of sealring = ^VIA7_W_3
  NOT RECTANGLE SR_VIA7_HOLE == VIA7_W_3 BY == VIA7_W_3 ORTHOGONAL ONLY
}
#ENDIF
#IFNDEF OLD_SEALRING
VIA7.EN.5 { @ Enclosure of VIA7 bar by M7 of seal ring >= ^VIA7_EN_5
  ENC SR_VIA7_BAR_SR M7 < VIA7_EN_5 ABUT < 90 SINGULAR REGION
}
VIA7.EN.6 { @ Enclosure of VIA7 hole by M7 of seal ring >= ^VIA7_EN_6
  ENC SR_VIA7_HOLE_SR M7 < VIA7_EN_6 ABUT < 90 SINGULAR REGION
}
VIA7.EN.7 { @ Enclosure of VIA7 hole by M7 of SLDB >= ^VIA7_EN_7
  ENC SR_VIA7_HOLE_SLDB M7 < VIA7_EN_7 ABUT < 90 SINGULAR REGION
}
VIA7.S.4 { @ Space of VIA7 hole in seal ring. >= ^VIA7_S_4
  EXT SR_VIA7_HOLE_SR < VIA7_S_4 ABUT < 90 SINGULAR REGION
}
VIA7.S.5 { @ Space of VIA7 hole to VIAx bar in seal ring. >= ^VIA7_S_5 
  EXT SR_VIA7_HOLE_SR SR_VIA7_BAR_SR < VIA7_S_5 ABUT < 90 SINGULAR REGION
}
VIA7.S.6 { @ Space of VIA7 hole in SLDB.>= ^VIA7_S_6
  EXT SR_VIA7_HOLE_SLDB < VIA7_S_6 ABUT < 90 SINGULAR REGION
}
#ENDIF
#IFNDEF OLD_SEALRING
M8.W.4 { @ Width of M8 metal line in outer seal ring == ^M8_W_4
  X1 = ANGLE SR_M8_OUTER != 45
  X2 = ANGLE SR_M8_OUTER == 45
  INT X1 > M8_W_4 < M8_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M8_W_4+GRID < M8_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M8_OUTER >= M8_W_4*2
  INT X1 < M8_W_4 ABUT < 90 REGION
  INT X2 < M8_W_4-GRID ABUT < 90 REGION
}
M8.W.5 { @ Width of M8 metal line in inner seal ring == ^M8_W_5
  X1 = ANGLE SR_M8_INNER != 45
  X2 = ANGLE SR_M8_INNER == 45
  INT X1 > M8_W_5 < M8_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M8_W_5+GRID < M8_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M8_INNER >= M8_W_5*2
  INT X1 < M8_W_5 ABUT < 90 REGION
  INT X2 < M8_W_5-GRID ABUT < 90 REGION
}
M8.W.6 { @ Width of M8 metal line in SLDB == ^M8_W_6
  X1 = ANGLE SLDB_M8 != 45
  X2 = ANGLE SLDB_M8 == 45
  INT X1 > M8_W_6 < M8_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M8_W_6+GRID < M8_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SLDB_M8 >= M8_W_6*2
  INT X1 < M8_W_6 ABUT < 90 REGION
  INT X2 < M8_W_6-GRID ABUT < 90 REGION
}
#ENDIF
#IFNDEF P3_SEALRING
VIA8.W.2__VIA8.W.4 { @ Width of VIA8 bar of sealring/SLDB = ^VIA8_W_2
  X1 = ANGLE SR_VIA8_BAR != 45
  X2 = ANGLE SR_VIA8_BAR == 45
  INT X1 > VIA8_W_2 < VIA8_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA8_W_2+GRID < VIA8_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA8_BAR >= VIA8_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA8_W_2 ABUT < 90 REGION
  INT X2 < VIA8_W_2-GRID ABUT < 90 REGION
}
VIA8.W.3__VIA8.W.5 { @ Width of VIA8 hole of sealring/SLDB = ^VIA8_W_3
  NOT RECTANGLE SR_VIA8_HOLE == VIA8_W_3 BY == VIA8_W_3 ORTHOGONAL ONLY
}
#ELSE
VIA8.W.2 { @ Width of VIA8 bar of outer sealring = ^VIA8_W_2_P3
  X1 = ANGLE SR_VIA8_BAR_OUTER != 45
  X2 = ANGLE SR_VIA8_BAR_OUTER == 45
  INT X1 > VIA8_W_2_P3 < VIA8_W_2_P3*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA8_W_2_P3+2*GRID < VIA8_W_2_P3*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_VIA8_BAR_OUTER >= VIA8_W_2_P3*2
  INT X1 < VIA8_W_2_P3 ABUT < 90 REGION
  INT X2 < VIA8_W_2_P3-2*GRID ABUT < 90 REGION
}
VIA8.W.3 { @ Width of VIA8 bar of inner sealring = ^VIA8_W_3_P3
  X1 = ANGLE SR_VIA8_BAR_INNER != 45
  X2 = ANGLE SR_VIA8_BAR_INNER == 45
  INT X1 > VIA8_W_3_P3 < VIA8_W_3_P3*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA8_W_3_P3+2*GRID < VIA8_W_3_P3*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_VIA8_BAR_INNER >= VIA8_W_3_P3*2
  INT X1 < VIA8_W_3_P3 ABUT < 90 REGION
  INT X2 < VIA8_W_3_P3-2*GRID ABUT < 90 REGION
}
#ENDIF
#IFNDEF OLD_SEALRING
VIA8.EN.5 { @ Enclosure of VIA8 bar by M8 of seal ring >= ^VIA8_EN_5
  ENC SR_VIA8_BAR_SR M8 < VIA8_EN_5 ABUT < 90 SINGULAR REGION
}
VIA8.EN.6 { @ Enclosure of VIA8 hole by M8 of seal ring >= ^VIA8_EN_6
  ENC SR_VIA8_HOLE_SR M8 < VIA8_EN_6 ABUT < 90 SINGULAR REGION
}
VIA8.S.4 { @ Space of VIA8 hole in seal ring. >= ^VIA8_S_4
  EXT SR_VIA8_HOLE_SR < VIA8_S_4 ABUT < 90 SINGULAR REGION
}
VIA8.S.5 { @ Space of VIA8 hole to VIAx bar in seal ring. >= ^VIA8_S_5 
  EXT SR_VIA8_HOLE_SR SR_VIA8_BAR_SR < VIA8_S_5 ABUT < 90 SINGULAR REGION
}
VIA8.S.6 { @ Space of VIA8 hole in SLDB.>= ^VIA8_S_6
  EXT SR_VIA8_HOLE_SLDB < VIA8_S_6 ABUT < 90 SINGULAR REGION
}
VIA8.S.7 { @ Space of VIA8 hole to VIA8 bar in SLDB. >= ^VIA8_S_7 
  EXT SR_VIA8_HOLE_SLDB SR_VIA8_BAR_SLDB < VIA8_S_7 ABUT < 90 SINGULAR REGION
}
#ENDIF
#IFNDEF OLD_SEALRING
M9.W.4 { @ Width of M9 metal line in outer seal ring == ^M9_W_4
  X1 = ANGLE SR_M9_OUTER != 45
  X2 = ANGLE SR_M9_OUTER == 45
  INT X1 > M9_W_4 < M9_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M9_W_4+GRID < M9_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M9_OUTER >= M9_W_4*2
  INT X1 < M9_W_4 ABUT < 90 REGION
  INT X2 < M9_W_4-GRID ABUT < 90 REGION
}
M9.W.5 { @ Width of M9 metal line in inner seal ring == ^M9_W_5
  X1 = ANGLE SR_M9_INNER != 45
  X2 = ANGLE SR_M9_INNER == 45
  INT X1 > M9_W_5 < M9_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M9_W_5+GRID < M9_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M9_INNER >= M9_W_5*2
  INT X1 < M9_W_5 ABUT < 90 REGION
  INT X2 < M9_W_5-GRID ABUT < 90 REGION
}
M9.W.6 { @ Width of M9 metal line in SLDB == ^M9_W_6
  X1 = ANGLE SLDB_M9 != 45
  X2 = ANGLE SLDB_M9 == 45
  INT X1 > M9_W_6 < M9_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M9_W_6+4*GRID < M9_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SLDB_M9 >= M9_W_6*2
  INT X1 < M9_W_6 ABUT < 90 REGION
  INT X2 < M9_W_6-4*GRID ABUT < 90 REGION
}
#ENDIF
#IFNDEF P3_SEALRING
VIA9.W.2__VIA9.W.4 { @ Width of VIA9 bar of sealring/SLDB = ^VIA9_W_2
  X1 = ANGLE SR_VIA9_BAR != 45
  X2 = ANGLE SR_VIA9_BAR == 45
  INT X1 > VIA9_W_2 < VIA9_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA9_W_2+GRID < VIA9_W_2*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  (WITH WIDTH SR_VIA9_BAR >= VIA9_W_2*2) ENCLOSE RECTANGLE 2 GRID
  INT X1 < VIA9_W_2 ABUT < 90 REGION
  INT X2 < VIA9_W_2-GRID ABUT < 90 REGION
}
VIA9.W.3__VIA9.W.5 { @ Width of VIA9 hole of sealring/SLDB = ^VIA9_W_3
  NOT RECTANGLE SR_VIA9_HOLE == VIA9_W_3 BY == VIA9_W_3 ORTHOGONAL ONLY
}
#ELSE
VIA9.W.2 { @ Width of VIA9 bar of outer sealring = ^VIA9_W_2_P3
  X1 = ANGLE SR_VIA9_BAR_OUTER != 45
  X2 = ANGLE SR_VIA9_BAR_OUTER == 45
  INT X1 > VIA9_W_2_P3 < VIA9_W_2_P3*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA9_W_2_P3+2*GRID < VIA9_W_2_P3*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_VIA9_BAR_OUTER >= VIA9_W_2_P3*2
  INT X1 < VIA9_W_2_P3 ABUT < 90 REGION
  INT X2 < VIA9_W_2_P3-2*GRID ABUT < 90 REGION
}
VIA9.W.3 { @ Width of VIA9 bar of inner sealring = ^VIA9_W_3_P3
  X1 = ANGLE SR_VIA9_BAR_INNER != 45
  X2 = ANGLE SR_VIA9_BAR_INNER == 45
  INT X1 > VIA9_W_3_P3 < VIA9_W_3_P3*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > VIA9_W_3_P3+2*GRID < VIA9_W_3_P3*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_VIA9_BAR_INNER >= VIA9_W_3_P3*2
  INT X1 < VIA9_W_3_P3 ABUT < 90 REGION
  INT X2 < VIA9_W_3_P3-2*GRID ABUT < 90 REGION
}
#ENDIF
#IFNDEF OLD_SEALRING
VIA9.EN.5 { @ Enclosure of VIA9 bar by M9 of seal ring >= ^VIA9_EN_5
  ENC SR_VIA9_BAR_SR M9 < VIA9_EN_5 ABUT < 90 SINGULAR REGION
}
VIA9.EN.6 { @ Enclosure of VIA9 hole by M9 of seal ring >= ^VIA9_EN_6
  ENC SR_VIA9_HOLE_SR M9 < VIA9_EN_6 ABUT < 90 SINGULAR REGION
}
VIA9.S.4 { @ Space of VIA9 hole in seal ring. >= ^VIA9_S_4
  EXT SR_VIA9_HOLE_SR < VIA9_S_4 ABUT < 90 SINGULAR REGION
}
VIA9.S.5 { @ Space of VIA9 hole to VIAx bar in seal ring. >= ^VIA9_S_5 
  EXT SR_VIA9_HOLE_SR SR_VIA9_BAR_SR < VIA9_S_5 ABUT < 90 SINGULAR REGION
}
VIA9.S.6 { @ Space of VIA9 hole in SLDB.>= ^VIA9_S_6
  EXT SR_VIA9_HOLE_SLDB < VIA9_S_6 ABUT < 90 SINGULAR REGION
}
VIA9.S.7 { @ Space of VIA9 hole to VIA9 bar in SLDB. >= ^VIA9_S_7 
  EXT SR_VIA9_HOLE_SLDB SR_VIA9_BAR_SLDB < VIA9_S_7 ABUT < 90 SINGULAR REGION
}
#ENDIF
#IFNDEF OLD_SEALRING
M10.W.4 { @ Width of M10 metal line in outer seal ring == ^M10_W_4
  X1 = ANGLE SR_M10_OUTER != 45
  X2 = ANGLE SR_M10_OUTER == 45
  INT X1 > M10_W_4 < M10_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M10_W_4+GRID < M10_W_4*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M10_OUTER >= M10_W_4*2
  INT X1 < M10_W_4 ABUT < 90 REGION
  INT X2 < M10_W_4-GRID ABUT < 90 REGION
}
M10.W.5 { @ Width of M10 metal line in inner seal ring == ^M10_W_5
  X1 = ANGLE SR_M10_INNER != 45
  X2 = ANGLE SR_M10_INNER == 45
  INT X1 > M10_W_5 < M10_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M10_W_5+GRID < M10_W_5*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SR_M10_INNER >= M10_W_5*2
  INT X1 < M10_W_5 ABUT < 90 REGION
  INT X2 < M10_W_5-GRID ABUT < 90 REGION
}
M10.W.6 { @ Width of M10 metal line in SLDB == ^M10_W_6
  X1 = ANGLE SLDB_M10 != 45
  X2 = ANGLE SLDB_M10 == 45
  INT X1 > M10_W_6 < M10_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  INT X2 > M10_W_6+4*GRID < M10_W_6*2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  WITH WIDTH SLDB_M10 >= M10_W_6*2
  INT X1 < M10_W_6 ABUT < 90 REGION
  INT X2 < M10_W_6-4*GRID ABUT < 90 REGION
}
#ENDIF


//CDU CHECKS
//===================

#IFNDEF OLD_SEALRING
CDU.R.1 { @ CDUDMY must be inside the assembly isolation beside seal ring.
  CDUDMY NOT INSIDE ISO_REGION
  ISO_REGION NOT INTERACT CDUDMY
}
CDU.R.2 { @ OD/POLY/NPi/CO/M1/VIAx/Mx must be inside layer CDUDMY. 
  CDUDMY NOT ENCLOSE ODi
  CDUDMY NOT ENCLOSE POi
  CDUDMY NOT ENCLOSE NPi
  CDUDMY NOT ENCLOSE COi
  CDUDMY NOT ENCLOSE M1i
  CDUDMY NOT ENCLOSE VIA1i
  CDUDMY NOT ENCLOSE M2i
  CDUDMY NOT ENCLOSE VIA2i
  CDUDMY NOT ENCLOSE M3i
  CDUDMY NOT ENCLOSE VIA3i
  CDUDMY NOT ENCLOSE M4i
  CDUDMY NOT ENCLOSE VIA4i
  CDUDMY NOT ENCLOSE M5i
  CDUDMY NOT ENCLOSE VIA5i
  CDUDMY NOT ENCLOSE M6i
  CDUDMY NOT ENCLOSE VIA6i
  CDUDMY NOT ENCLOSE M7i
  CDUDMY NOT ENCLOSE VIA7i
  CDUDMY NOT ENCLOSE M8i
}
#ENDIF

#ENDIF
#ENDIF

#IFDEF FRONT_END


// Latch-Up CHECKS
//================
#IFDEF DISCONNECT_ALL_RESISTOR
NSTPiu = NSTPi NOT EMPTYi
PSTPiu = PSTPi NOT EMPTYi
NSDiu  = NSDc  NOT EMPTYi
PSDiu  = PSDc  NOT EMPTYi
CBiu   = CBi   NOT EMPTYi 
CB2Fiu = CB2Fi NOT EMPTYi
CB2Wiu = CB2Wi NOT EMPTYi
UBMiu  = UBMi  NOT EMPTYi
PWR_M1iu_BY_TEXT = M1i WITH TEXT VDD_TEXT M1_PIN_TEXT PRIMARY ONLY
GND_M1iu_BY_TEXT = M1i WITH TEXT VSS_TEXT M1_PIN_TEXT PRIMARY ONLY
PAD_M1iu_BY_TEXT = M1i WITH TEXT PAD_TEXT M1_PIN_TEXT PRIMARY ONLY
PWR_M2iu_BY_TEXT = M2i WITH TEXT VDD_TEXT M2_PIN_TEXT PRIMARY ONLY
GND_M2iu_BY_TEXT = M2i WITH TEXT VSS_TEXT M2_PIN_TEXT PRIMARY ONLY
PAD_M2iu_BY_TEXT = M2i WITH TEXT PAD_TEXT M2_PIN_TEXT PRIMARY ONLY
PWR_M3iu_BY_TEXT = M3i WITH TEXT VDD_TEXT M3_PIN_TEXT PRIMARY ONLY
GND_M3iu_BY_TEXT = M3i WITH TEXT VSS_TEXT M3_PIN_TEXT PRIMARY ONLY
PAD_M3iu_BY_TEXT = M3i WITH TEXT PAD_TEXT M3_PIN_TEXT PRIMARY ONLY
PWR_M4iu_BY_TEXT = M4i WITH TEXT VDD_TEXT M4_PIN_TEXT PRIMARY ONLY
GND_M4iu_BY_TEXT = M4i WITH TEXT VSS_TEXT M4_PIN_TEXT PRIMARY ONLY
PAD_M4iu_BY_TEXT = M4i WITH TEXT PAD_TEXT M4_PIN_TEXT PRIMARY ONLY
PWR_M5iu_BY_TEXT = M5i WITH TEXT VDD_TEXT M5_PIN_TEXT PRIMARY ONLY
GND_M5iu_BY_TEXT = M5i WITH TEXT VSS_TEXT M5_PIN_TEXT PRIMARY ONLY
PAD_M5iu_BY_TEXT = M5i WITH TEXT PAD_TEXT M5_PIN_TEXT PRIMARY ONLY
PWR_M6iu_BY_TEXT = M6i WITH TEXT VDD_TEXT M6_PIN_TEXT PRIMARY ONLY
GND_M6iu_BY_TEXT = M6i WITH TEXT VSS_TEXT M6_PIN_TEXT PRIMARY ONLY
PAD_M6iu_BY_TEXT = M6i WITH TEXT PAD_TEXT M6_PIN_TEXT PRIMARY ONLY
PWR_M7iu_BY_TEXT = M7i WITH TEXT VDD_TEXT M7_PIN_TEXT PRIMARY ONLY
GND_M7iu_BY_TEXT = M7i WITH TEXT VSS_TEXT M7_PIN_TEXT PRIMARY ONLY
PAD_M7iu_BY_TEXT = M7i WITH TEXT PAD_TEXT M7_PIN_TEXT PRIMARY ONLY
PWR_M8iu_BY_TEXT = M8i WITH TEXT VDD_TEXT M8_PIN_TEXT PRIMARY ONLY
GND_M8iu_BY_TEXT = M8i WITH TEXT VSS_TEXT M8_PIN_TEXT PRIMARY ONLY
PAD_M8iu_BY_TEXT = M8i WITH TEXT PAD_TEXT M8_PIN_TEXT PRIMARY ONLY
PWR_M9iu_BY_TEXT = M9i WITH TEXT VDD_TEXT M9_PIN_TEXT PRIMARY ONLY
GND_M9iu_BY_TEXT = M9i WITH TEXT VSS_TEXT M9_PIN_TEXT PRIMARY ONLY
PAD_M9iu_BY_TEXT = M9i WITH TEXT PAD_TEXT M9_PIN_TEXT PRIMARY ONLY
PWR_M10iu_BY_TEXT = M10i WITH TEXT VDD_TEXT M10_PIN_TEXT PRIMARY ONLY
GND_M10iu_BY_TEXT = M10i WITH TEXT VSS_TEXT M10_PIN_TEXT PRIMARY ONLY
PAD_M10iu_BY_TEXT = M10i WITH TEXT PAD_TEXT M10_PIN_TEXT PRIMARY ONLY
PWR_APiu_BY_TEXT = APi WITH TEXT VDD_TEXT AP_PIN_TEXT PRIMARY ONLY
GND_APiu_BY_TEXT = APi WITH TEXT VSS_TEXT AP_PIN_TEXT PRIMARY ONLY
PAD_APiu_BY_TEXT = APi WITH TEXT PAD_TEXT AP_PIN_TEXT PRIMARY ONLY
#ELSE
#IFDEF CONNECT_ALL_RESISTOR 
NSTPiu = NSTPu NOT EMPTYi
PSTPiu = PSTPu NOT EMPTYi
NSDiu  = NSDu  NOT EMPTYi
PSDiu  = PSDu  NOT EMPTYi
CBiu   = CBu   NOT EMPTYi 
CB2Fiu = CB2Fu NOT EMPTYi
CB2Wiu = CB2Wu NOT EMPTYi
UBMiu  = UBMu  NOT EMPTYi
PWR_M1iu_BY_TEXT = M1u WITH TEXT VDD_TEXT M1_PIN_TEXT PRIMARY ONLY
GND_M1iu_BY_TEXT = M1u WITH TEXT VSS_TEXT M1_PIN_TEXT PRIMARY ONLY
PAD_M1iu_BY_TEXT = M1u WITH TEXT PAD_TEXT M1_PIN_TEXT PRIMARY ONLY
PWR_M2iu_BY_TEXT = M2u WITH TEXT VDD_TEXT M2_PIN_TEXT PRIMARY ONLY
GND_M2iu_BY_TEXT = M2u WITH TEXT VSS_TEXT M2_PIN_TEXT PRIMARY ONLY
PAD_M2iu_BY_TEXT = M2u WITH TEXT PAD_TEXT M2_PIN_TEXT PRIMARY ONLY
PWR_M3iu_BY_TEXT = M3u WITH TEXT VDD_TEXT M3_PIN_TEXT PRIMARY ONLY
GND_M3iu_BY_TEXT = M3u WITH TEXT VSS_TEXT M3_PIN_TEXT PRIMARY ONLY
PAD_M3iu_BY_TEXT = M3u WITH TEXT PAD_TEXT M3_PIN_TEXT PRIMARY ONLY
PWR_M4iu_BY_TEXT = M4u WITH TEXT VDD_TEXT M4_PIN_TEXT PRIMARY ONLY
GND_M4iu_BY_TEXT = M4u WITH TEXT VSS_TEXT M4_PIN_TEXT PRIMARY ONLY
PAD_M4iu_BY_TEXT = M4u WITH TEXT PAD_TEXT M4_PIN_TEXT PRIMARY ONLY
PWR_M5iu_BY_TEXT = M5u WITH TEXT VDD_TEXT M5_PIN_TEXT PRIMARY ONLY
GND_M5iu_BY_TEXT = M5u WITH TEXT VSS_TEXT M5_PIN_TEXT PRIMARY ONLY
PAD_M5iu_BY_TEXT = M5u WITH TEXT PAD_TEXT M5_PIN_TEXT PRIMARY ONLY
PWR_M6iu_BY_TEXT = M6u WITH TEXT VDD_TEXT M6_PIN_TEXT PRIMARY ONLY
GND_M6iu_BY_TEXT = M6u WITH TEXT VSS_TEXT M6_PIN_TEXT PRIMARY ONLY
PAD_M6iu_BY_TEXT = M6u WITH TEXT PAD_TEXT M6_PIN_TEXT PRIMARY ONLY
PWR_M7iu_BY_TEXT = M7u WITH TEXT VDD_TEXT M7_PIN_TEXT PRIMARY ONLY
GND_M7iu_BY_TEXT = M7u WITH TEXT VSS_TEXT M7_PIN_TEXT PRIMARY ONLY
PAD_M7iu_BY_TEXT = M7u WITH TEXT PAD_TEXT M7_PIN_TEXT PRIMARY ONLY
PWR_M8iu_BY_TEXT = M8u WITH TEXT VDD_TEXT M8_PIN_TEXT PRIMARY ONLY
GND_M8iu_BY_TEXT = M8u WITH TEXT VSS_TEXT M8_PIN_TEXT PRIMARY ONLY
PAD_M8iu_BY_TEXT = M8u WITH TEXT PAD_TEXT M8_PIN_TEXT PRIMARY ONLY
PWR_M9iu_BY_TEXT = M9u WITH TEXT VDD_TEXT M9_PIN_TEXT PRIMARY ONLY
GND_M9iu_BY_TEXT = M9u WITH TEXT VSS_TEXT M9_PIN_TEXT PRIMARY ONLY
PAD_M9iu_BY_TEXT = M9u WITH TEXT PAD_TEXT M9_PIN_TEXT PRIMARY ONLY
PWR_M10iu_BY_TEXT = M10u WITH TEXT VDD_TEXT M10_PIN_TEXT PRIMARY ONLY
GND_M10iu_BY_TEXT = M10u WITH TEXT VSS_TEXT M10_PIN_TEXT PRIMARY ONLY
PAD_M10iu_BY_TEXT = M10u WITH TEXT PAD_TEXT M10_PIN_TEXT PRIMARY ONLY
PWR_APiu_BY_TEXT = APu WITH TEXT VDD_TEXT AP_PIN_TEXT PRIMARY ONLY
GND_APiu_BY_TEXT = APu WITH TEXT VSS_TEXT AP_PIN_TEXT PRIMARY ONLY
PAD_APiu_BY_TEXT = APu WITH TEXT PAD_TEXT AP_PIN_TEXT PRIMARY ONLY
#ELSE
NSTPiu = NSTPj NOT EMPTYi
PSTPiu = PSTPj NOT EMPTYi
NSDiu  = NSDj  NOT EMPTYi
PSDiu  = PSDj  NOT EMPTYi
CBiu   = CBj   NOT EMPTYi 
CB2Fiu = CB2Fj NOT EMPTYi
CB2Wiu = CB2Wj NOT EMPTYi
UBMiu  = UBMj  NOT EMPTYi
PWR_M1iu_BY_TEXT = M1j WITH TEXT VDD_TEXT M1_PIN_TEXT PRIMARY ONLY
GND_M1iu_BY_TEXT = M1j WITH TEXT VSS_TEXT M1_PIN_TEXT PRIMARY ONLY
PAD_M1iu_BY_TEXT = M1j WITH TEXT PAD_TEXT M1_PIN_TEXT PRIMARY ONLY
PWR_M2iu_BY_TEXT = M2j WITH TEXT VDD_TEXT M2_PIN_TEXT PRIMARY ONLY
GND_M2iu_BY_TEXT = M2j WITH TEXT VSS_TEXT M2_PIN_TEXT PRIMARY ONLY
PAD_M2iu_BY_TEXT = M2j WITH TEXT PAD_TEXT M2_PIN_TEXT PRIMARY ONLY
PWR_M3iu_BY_TEXT = M3j WITH TEXT VDD_TEXT M3_PIN_TEXT PRIMARY ONLY
GND_M3iu_BY_TEXT = M3j WITH TEXT VSS_TEXT M3_PIN_TEXT PRIMARY ONLY
PAD_M3iu_BY_TEXT = M3j WITH TEXT PAD_TEXT M3_PIN_TEXT PRIMARY ONLY
PWR_M4iu_BY_TEXT = M4j WITH TEXT VDD_TEXT M4_PIN_TEXT PRIMARY ONLY
GND_M4iu_BY_TEXT = M4j WITH TEXT VSS_TEXT M4_PIN_TEXT PRIMARY ONLY
PAD_M4iu_BY_TEXT = M4j WITH TEXT PAD_TEXT M4_PIN_TEXT PRIMARY ONLY
PWR_M5iu_BY_TEXT = M5j WITH TEXT VDD_TEXT M5_PIN_TEXT PRIMARY ONLY
GND_M5iu_BY_TEXT = M5j WITH TEXT VSS_TEXT M5_PIN_TEXT PRIMARY ONLY
PAD_M5iu_BY_TEXT = M5j WITH TEXT PAD_TEXT M5_PIN_TEXT PRIMARY ONLY
PWR_M6iu_BY_TEXT = M6j WITH TEXT VDD_TEXT M6_PIN_TEXT PRIMARY ONLY
GND_M6iu_BY_TEXT = M6j WITH TEXT VSS_TEXT M6_PIN_TEXT PRIMARY ONLY
PAD_M6iu_BY_TEXT = M6j WITH TEXT PAD_TEXT M6_PIN_TEXT PRIMARY ONLY
PWR_M7iu_BY_TEXT = M7j WITH TEXT VDD_TEXT M7_PIN_TEXT PRIMARY ONLY
GND_M7iu_BY_TEXT = M7j WITH TEXT VSS_TEXT M7_PIN_TEXT PRIMARY ONLY
PAD_M7iu_BY_TEXT = M7j WITH TEXT PAD_TEXT M7_PIN_TEXT PRIMARY ONLY
PWR_M8iu_BY_TEXT = M8j WITH TEXT VDD_TEXT M8_PIN_TEXT PRIMARY ONLY
GND_M8iu_BY_TEXT = M8j WITH TEXT VSS_TEXT M8_PIN_TEXT PRIMARY ONLY
PAD_M8iu_BY_TEXT = M8j WITH TEXT PAD_TEXT M8_PIN_TEXT PRIMARY ONLY
PWR_M9iu_BY_TEXT = M9j WITH TEXT VDD_TEXT M9_PIN_TEXT PRIMARY ONLY
GND_M9iu_BY_TEXT = M9j WITH TEXT VSS_TEXT M9_PIN_TEXT PRIMARY ONLY
PAD_M9iu_BY_TEXT = M9j WITH TEXT PAD_TEXT M9_PIN_TEXT PRIMARY ONLY
PWR_M10iu_BY_TEXT = M10j WITH TEXT VDD_TEXT M10_PIN_TEXT PRIMARY ONLY
GND_M10iu_BY_TEXT = M10j WITH TEXT VSS_TEXT M10_PIN_TEXT PRIMARY ONLY
PAD_M10iu_BY_TEXT = M10j WITH TEXT PAD_TEXT M10_PIN_TEXT PRIMARY ONLY
PWR_APiu_BY_TEXT = APj WITH TEXT VDD_TEXT AP_PIN_TEXT PRIMARY ONLY
GND_APiu_BY_TEXT = APj WITH TEXT VSS_TEXT AP_PIN_TEXT PRIMARY ONLY
PAD_APiu_BY_TEXT = APj WITH TEXT PAD_TEXT AP_PIN_TEXT PRIMARY ONLY
#ENDIF
#ENDIF


MOS = DACT INTERACT GATE
G_DIODE   = MOS INTERACT ((GATE INTERACT PP) INTERACT NP)

// Power PAD
NSTPux = (NSTPi NOT INTERACT RNWEL) NOT VAR    
PSTPux = PSTPi NOT VAR

VDD_CB = NET AREA RATIO CBi NSTPux > 0
VSS_CB = NET AREA RATIO CBi PSTPux > 0
VDD_CB2F = NET AREA RATIO CB2Fi NSTPux > 0
VSS_CB2F = NET AREA RATIO CB2Fi PSTPux > 0
VDD_CB2W = NET AREA RATIO CB2Wi NSTPux > 0
VSS_CB2W = NET AREA RATIO CB2Wi PSTPux > 0
VDD_UBM = NET AREA RATIO UBMi NSTPux > 0
VSS_UBM = NET AREA RATIO UBMi PSTPux > 0
VDD_CB_BY_DUMMY = CBi NOT OUTSIDE VDDDMY
VSS_CB_BY_DUMMY = CBi NOT OUTSIDE VSSDMY
VDD_CB2F_BY_DUMMY = CB2Fi NOT OUTSIDE VDDDMY
VSS_CB2F_BY_DUMMY = CB2Fi NOT OUTSIDE VSSDMY
VDD_CB2W_BY_DUMMY = CB2Wi NOT OUTSIDE VDDDMY
VSS_CB2W_BY_DUMMY = CB2Wi NOT OUTSIDE VSSDMY
VDD_UBM_BY_DUMMY = UBMi NOT OUTSIDE VDDDMY
VSS_UBM_BY_DUMMY = UBMi NOT OUTSIDE VSSDMY

// Signal PAD
IO_CB  = (((CBiu NOT VDD_CB) NOT VSS_CB) NOT VDD_CB_BY_DUMMY) NOT VSS_CB_BY_DUMMY
IO_CB2F = (((CB2Fiu NOT VDD_CB2F) NOT VSS_CB2F) NOT VDD_CB2F_BY_DUMMY) NOT VSS_CB2F_BY_DUMMY
IO_CB2W = (((CB2Wiu NOT VDD_CB2W) NOT VSS_CB2W) NOT VDD_CB2W_BY_DUMMY) NOT VSS_CB2W_BY_DUMMY
IO_UBM = (((UBMiu NOT VDD_UBM) NOT VSS_UBM) NOT VDD_UBM_BY_DUMMY) NOT VSS_UBM_BY_DUMMY

PSD_PAD = NET AREA RATIO PSDiu CBiu CB2Fiu CB2Wiu UBMiu > 0 [!!AREA(CBiu)+!!AREA(CB2Fiu)+!!AREA(CB2Wiu)+!!AREA(UBMiu)]
NSD_PAD = NET AREA RATIO NSDiu CBiu CB2Fiu CB2Wiu UBMiu > 0 [!!AREA(CBiu)+!!AREA(CB2Fiu)+!!AREA(CB2Wiu)+!!AREA(UBMiu)]
PSD_IOPAD_stp = NET AREA RATIO PSDiu IO_CB IO_CB2F IO_CB2W IO_UBM > 0 [!!AREA(IO_CB)+!!AREA(IO_CB2W)+!!AREA(IO_CB2F)+!!AREA(IO_UBM)]
NSD_IOPAD_stp = NET AREA RATIO NSDiu IO_CB IO_CB2F IO_CB2W IO_UBM > 0 [!!AREA(IO_CB)+!!AREA(IO_CB2W)+!!AREA(IO_CB2F)+!!AREA(IO_UBM)]
#IFDEF  DEFINE_PAD_BY_TEXT
PSD_PAD_TEXT = NET AREA RATIO PSDiu OVER PAD_M10iu_BY_TEXT PAD_M9iu_BY_TEXT PAD_M8iu_BY_TEXT PAD_M7iu_BY_TEXT PAD_M6iu_BY_TEXT PAD_M5iu_BY_TEXT PAD_M4iu_BY_TEXT PAD_M3iu_BY_TEXT PAD_M2iu_BY_TEXT PAD_M1iu_BY_TEXT PAD_APiu_BY_TEXT > 0
NSD_PAD_TEXT = NET AREA RATIO NSDiu OVER PAD_M10iu_BY_TEXT PAD_M9iu_BY_TEXT PAD_M8iu_BY_TEXT PAD_M7iu_BY_TEXT PAD_M6iu_BY_TEXT PAD_M5iu_BY_TEXT PAD_M4iu_BY_TEXT PAD_M3iu_BY_TEXT PAD_M2iu_BY_TEXT PAD_M1iu_BY_TEXT PAD_APiu_BY_TEXT > 0
PSD_VDD_VSS_PAD_TEXT = NET AREA RATIO PSDiu OVER PWR_M10iu_BY_TEXT PWR_M9iu_BY_TEXT PWR_M8iu_BY_TEXT PWR_M7iu_BY_TEXT PWR_M6iu_BY_TEXT PWR_M5iu_BY_TEXT PWR_M4iu_BY_TEXT PWR_M3iu_BY_TEXT PWR_M2iu_BY_TEXT PWR_M1iu_BY_TEXT PWR_APiu_BY_TEXT GND_M10iu_BY_TEXT GND_M9iu_BY_TEXT GND_M8iu_BY_TEXT GND_M7iu_BY_TEXT GND_M6iu_BY_TEXT GND_M5iu_BY_TEXT GND_M4iu_BY_TEXT GND_M3iu_BY_TEXT GND_M2iu_BY_TEXT GND_M1iu_BY_TEXT GND_APiu_BY_TEXT > 0 
NSD_VDD_VSS_PAD_TEXT = NET AREA RATIO NSDiu OVER PWR_M10iu_BY_TEXT PWR_M9iu_BY_TEXT PWR_M8iu_BY_TEXT PWR_M7iu_BY_TEXT PWR_M6iu_BY_TEXT PWR_M5iu_BY_TEXT PWR_M4iu_BY_TEXT PWR_M3iu_BY_TEXT PWR_M2iu_BY_TEXT PWR_M1iu_BY_TEXT PWR_APiu_BY_TEXT GND_M10iu_BY_TEXT GND_M9iu_BY_TEXT GND_M8iu_BY_TEXT GND_M7iu_BY_TEXT GND_M6iu_BY_TEXT GND_M5iu_BY_TEXT GND_M4iu_BY_TEXT GND_M3iu_BY_TEXT GND_M2iu_BY_TEXT GND_M1iu_BY_TEXT GND_APiu_BY_TEXT > 0 
PSD_IOPAD = PSDiu INTERACT ((PSD_IOPAD_stp OR PSD_PAD_TEXT) NOT PSD_VDD_VSS_PAD_TEXT)
NSD_IOPAD = NSDiu INTERACT ((NSD_IOPAD_stp OR NSD_PAD_TEXT) NOT NSD_VDD_VSS_PAD_TEXT)
PMOS_filter = COPY EMPTYi
NMOS_filter = COPY EMPTYi
#ELSE
PSD_IOPAD = PSDiu INTERACT PSD_IOPAD_stp
NSD_IOPAD = NSDiu INTERACT NSD_IOPAD_stp
MOS_filter_DMY = CHIP INTERACT (VDDDMY OR VSSDMY)
PMOS_filter = (MOS INTERACT PSD_PAD == 1 BY NET) NOT MOS_filter_DMY
NMOS_filter = (MOS INTERACT NSD_PAD == 1 BY NET) NOT MOS_filter_DMY
#ENDIF
SD_IOPAD = PSD_IOPAD OR NSD_IOPAD
DUMMY_MOS = (MOS NOT INTERACT CO) NOT INTERACT (POLY INTERACT CO)
DUMMY_DIODE = (DACT NOT INTERACT POLY) NOT INTERACT CO
DACT_real = ((((DACT NOT INTERACT OD_RES) NOT INTERACT RNWEL) NOT DUMMY_MOS) NOT G_DIODE) NOT DUMMY_DIODE
PACT_real = PACT AND DACT_real
NACT_real = NACT AND DACT_real

// ESD device [covered by dummy layers]
POST_DRIVER_ACT1 = DACT_real AND SDI
// ESD device [connected to Signal PAD but not connected to one PAD only]
POST_DRIVER_ACT2 = ((DACT_real NOT PMOS_filter) NOT NMOS_filter) INTERACT SD_IOPAD

#IFDEF CHECK_LATCHUP_BY_PAD_CONNECTION
POST_DRIVER_ACT = POST_DRIVER_ACT1 OR POST_DRIVER_ACT2 
#ELSE
POST_DRIVER_ACT = COPY POST_DRIVER_ACT1
#ENDIF


// For LUP.1/LUP.2/LUP.4 - GuardRing
//====================================
NW_inside_guard_ring_pre1 = NWi NOT NSTPi
NW_inside_guard_ring_pre2 = NW_inside_guard_ring_pre1 NOT COIN OUTSIDE EDGE NSTPi
NW_inside_guard_ring = NW_inside_guard_ring_pre1 NOT WITH EDGE NW_inside_guard_ring_pre2
PW_inside_guard_ring_pre1 = PWELi NOT PSTPi
PW_inside_guard_ring_pre2 = PW_inside_guard_ring_pre1 NOT COIN OUTSIDE EDGE PSTPi
PW_inside_guard_ring = PW_inside_guard_ring_pre1 NOT WITH EDGE PW_inside_guard_ring_pre2
NTAP_guard_ring_hole = ((HOLES NSTPi INNER) INSIDE NWi) OR NW_inside_guard_ring
PTAP_guard_ring_hole = ((HOLES PSTPi INNER) INSIDE PWELi) OR PW_inside_guard_ring

// For LUP.1 - I/O PAD N/P ACTIVE
//=================================
POST_DRIVER_PACT = (POST_DRIVER_ACT INTERACT PSDiu) NOT INSIDE LUPWDMY
POST_DRIVER_NACT = (POST_DRIVER_ACT INTERACT NSDiu) NOT INSIDE LUPWDMY

// For LUP.3
//==================
POST_DRIVER_PMOS = POST_DRIVER_PACT INTERACT GATE 
POST_DRIVER_PMOS_NW = STAMP POST_DRIVER_PMOS BY NWEL
POST_DRIVER_PMOS_NW_HV  = POST_DRIVER_PMOS_NW INTERACT OD2
POST_DRIVER_PMOS_NW_5V = POST_DRIVER_PMOS_NW_HV INTERACT HVD_P
POST_DRIVER_PMOS_NW_33V = POST_DRIVER_PMOS_NW_HV INTERACT OD33
POST_DRIVER_PMOS_NW_25V = POST_DRIVER_PMOS_NW_HV INTERACT OD25
POST_DRIVER_PMOS_NW_18V = POST_DRIVER_PMOS_NW_HV INTERACT OD18
POST_DRIVER_PMOS_NW_LV  = POST_DRIVER_PMOS_NW NOT POST_DRIVER_PMOS_NW_HV
POST_DRIVER_NMOS = POST_DRIVER_NACT INTERACT GATE
POST_DRIVER_NMOS_RW = STAMP (POST_DRIVER_NMOS INSIDE DNW) BY DNW
POST_DRIVER_NMOS_RW_HV  = POST_DRIVER_NMOS_RW INTERACT OD2
POST_DRIVER_NMOS_RW_5V = POST_DRIVER_NMOS_RW_HV INTERACT HVD_N
POST_DRIVER_NMOS_RW_33V = POST_DRIVER_NMOS_RW_HV INTERACT OD33
POST_DRIVER_NMOS_RW_25V = POST_DRIVER_NMOS_RW_HV INTERACT OD25
POST_DRIVER_NMOS_RW_18V = POST_DRIVER_NMOS_RW_HV INTERACT OD18
POST_DRIVER_NMOS_RW_LV  = POST_DRIVER_NMOS_RW NOT POST_DRIVER_NMOS_RW_HV
POST_DRIVER_NMOS_PW = POST_DRIVER_NMOS NOT POST_DRIVER_NMOS_RW
POST_DRIVER_NMOS_PW_HV  = POST_DRIVER_NMOS_PW INTERACT OD2
POST_DRIVER_NMOS_PW_5V = POST_DRIVER_NMOS_PW_HV INTERACT HVD_N
POST_DRIVER_NMOS_PW_33V = POST_DRIVER_NMOS_PW_HV INTERACT OD33
POST_DRIVER_NMOS_PW_25V = POST_DRIVER_NMOS_PW_HV INTERACT OD25
POST_DRIVER_NMOS_PW_18V = POST_DRIVER_NMOS_PW_HV INTERACT OD18
POST_DRIVER_NMOS_PW_LV  = POST_DRIVER_NMOS_PW NOT POST_DRIVER_NMOS_PW_HV

// For LUP.2 - Peripheral N/P MOS
//=================================
BESIDE_POST_DRIVER = SIZE (POST_DRIVER_NMOS OR POST_DRIVER_PMOS) BY LUP_2
BESIDE_POST_DRIVER_NMOS = ((NACT_real INTERACT GATE) NOT OUTSIDE BESIDE_POST_DRIVER) NOT POST_DRIVER_NMOS
BESIDE_POST_DRIVER_PMOS = ((PACT_real INTERACT GATE) NOT OUTSIDE BESIDE_POST_DRIVER) NOT POST_DRIVER_PMOS

// For LUP.3/LUP.5 - Wide GuardRing
//====================================
PTAP_guard_ring_holex = PTAP_guard_ring_hole ENCLOSE (POST_DRIVER_NACT OR BESIDE_POST_DRIVER_NMOS)
NTAP_guard_ring_holex = NTAP_guard_ring_hole ENCLOSE (POST_DRIVER_PACT OR BESIDE_POST_DRIVER_PMOS)
PTAP_guard_ring_wide = (PSTPi TOUCH PTAP_guard_ring_holex) WITH WIDTH >= LUP_3_W
NTAP_guard_ring_wide = (NSTPi TOUCH NTAP_guard_ring_holex) WITH WIDTH >= LUP_3_W

PW_inside_guard_ring_wide_pre = PW_inside_guard_ring NOT COIN OUTSIDE EDGE PTAP_guard_ring_wide
PW_inside_guard_ring_wide = PW_inside_guard_ring NOT WITH EDGE PW_inside_guard_ring_wide_pre
NW_inside_guard_ring_wide_pre = NW_inside_guard_ring NOT COIN OUTSIDE EDGE NTAP_guard_ring_wide
NW_inside_guard_ring_wide = NW_inside_guard_ring NOT WITH EDGE NW_inside_guard_ring_wide_pre

PTAP_guard_ring_wide_hole = ((HOLES PTAP_guard_ring_wide INNER) INSIDE PWELi) OR PW_inside_guard_ring_wide
NTAP_guard_ring_wide_hole = ((HOLES NTAP_guard_ring_wide INNER) INSIDE NWi) OR NW_inside_guard_ring_wide

POST_DRIVER_PMOS_NW_5V_NG = POST_DRIVER_PMOS_NW_5V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NW_33V_NG = POST_DRIVER_PMOS_NW_33V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NW_25V_NG = POST_DRIVER_PMOS_NW_25V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NW_18V_NG = POST_DRIVER_PMOS_NW_18V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NW_LV_NG  = POST_DRIVER_PMOS_NW_LV  NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_RW_5V_NG = POST_DRIVER_NMOS_RW_5V NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_RW_33V_NG = POST_DRIVER_NMOS_RW_33V NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_RW_25V_NG = POST_DRIVER_NMOS_RW_25V NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_RW_18V_NG = POST_DRIVER_NMOS_RW_18V NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_RW_LV_NG  = POST_DRIVER_NMOS_RW_LV  NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_PW_5V_NG = POST_DRIVER_NMOS_PW_5V NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_PW_33V_NG = POST_DRIVER_NMOS_PW_33V NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_PW_25V_NG = POST_DRIVER_NMOS_PW_25V NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_PW_18V_NG = POST_DRIVER_NMOS_PW_18V NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_PW_LV_NG  = POST_DRIVER_NMOS_PW_LV  NOT INSIDE PTAP_guard_ring_wide_hole


POST_DRIVER_PMOS_NWi = STAMP POST_DRIVER_PMOS BY NWi
POST_DRIVER_PMOS_NWi_HV  = POST_DRIVER_PMOS_NWi INTERACT OD2
POST_DRIVER_PMOS_NWi_5V  = POST_DRIVER_PMOS_NWi_HV INTERACT HVD_P
POST_DRIVER_PMOS_NWi_33V = POST_DRIVER_PMOS_NWi_HV INTERACT OD33
POST_DRIVER_PMOS_NWi_25V = POST_DRIVER_PMOS_NWi_HV INTERACT OD25
POST_DRIVER_PMOS_NWi_18V = POST_DRIVER_PMOS_NWi_HV INTERACT OD18
POST_DRIVER_PMOS_NWi_LV  = POST_DRIVER_PMOS_NWi NOT POST_DRIVER_PMOS_NWi_HV
DNWc = STAMP DNW BY NWi
POST_DRIVER_NMOS_RWi = STAMP (POST_DRIVER_NMOS INSIDE DNW) BY DNWc
POST_DRIVER_NMOS_RWi_HV  = POST_DRIVER_NMOS_RWi INTERACT OD2
POST_DRIVER_NMOS_RWi_5V  = POST_DRIVER_NMOS_RWi_HV INTERACT HVD_N
POST_DRIVER_NMOS_RWi_33V = POST_DRIVER_NMOS_RWi_HV INTERACT OD33
POST_DRIVER_NMOS_RWi_25V = POST_DRIVER_NMOS_RWi_HV INTERACT OD25
POST_DRIVER_NMOS_RWi_18V = POST_DRIVER_NMOS_RWi_HV INTERACT OD18
POST_DRIVER_NMOS_RWi_LV  = POST_DRIVER_NMOS_RWi NOT POST_DRIVER_NMOS_RWi_HV

POST_DRIVER_PMOS_NWi_5V_NG  = POST_DRIVER_PMOS_NWi_5V  NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NWi_33V_NG = POST_DRIVER_PMOS_NWi_33V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NWi_25V_NG = POST_DRIVER_PMOS_NWi_25V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NWi_18V_NG = POST_DRIVER_PMOS_NWi_18V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NWi_LV_NG  = POST_DRIVER_PMOS_NWi_LV  NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_RWi_5V_NG  = POST_DRIVER_NMOS_RWi_5V  NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_RWi_33V_NG = POST_DRIVER_NMOS_RWi_33V NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_RWi_25V_NG = POST_DRIVER_NMOS_RWi_25V NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_RWi_18V_NG = POST_DRIVER_NMOS_RWi_18V NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_RWi_LV_NG  = POST_DRIVER_NMOS_RWi_LV  NOT INSIDE PTAP_guard_ring_wide_hole


// For LUP.5
//==================
BESIDE_POST_DRIVER_PMOS_NW = STAMP BESIDE_POST_DRIVER_PMOS BY NWEL
BESIDE_POST_DRIVER_NMOS_RW = STAMP (BESIDE_POST_DRIVER_NMOS INSIDE DNW) BY DNW
BESIDE_POST_DRIVER_NMOS_PW = BESIDE_POST_DRIVER_NMOS NOT BESIDE_POST_DRIVER_NMOS_RW

BESIDE_POST_DRIVER_PMOS_NW_NG = BESIDE_POST_DRIVER_PMOS_NW NOT INSIDE NTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_NMOS_RW_NG = BESIDE_POST_DRIVER_NMOS_RW NOT INSIDE PTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_NMOS_PW_NG = BESIDE_POST_DRIVER_NMOS_PW NOT INSIDE PTAP_guard_ring_wide_hole

BESIDE_POST_DRIVER_PMOS_NWi = STAMP BESIDE_POST_DRIVER_PMOS BY NWi
BESIDE_POST_DRIVER_NMOS_RWi = STAMP (BESIDE_POST_DRIVER_NMOS INSIDE DNW) BY DNWc

BESIDE_POST_DRIVER_PMOS_NWi_NG = BESIDE_POST_DRIVER_PMOS_NWi NOT INSIDE NTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_NMOS_RWi_NG = BESIDE_POST_DRIVER_NMOS_RWi NOT INSIDE PTAP_guard_ring_wide_hole

LUP.1 { @ Any N+Active or an N+Active cluster connected to an I/O pad must be surrounded by a P+ guard-ring.
        @ Any P+Active or a P+Active cluster connected to an I/O pad must be surrounded by a N+ guard-ring.
  POST_DRIVER_NACT NOT INSIDE PTAP_guard_ring_hole
  POST_DRIVER_PACT NOT INSIDE NTAP_guard_ring_hole
}

LUP.2 { @ Within ^LUP_2 um space from the MOS connected to an I/O pad, a P+ guard-ring is required to surround an NMOS or an NMOS cluster. And an N+ guard-ring is required to surround a PMOS or a PMOS cluster.
  X = EXT POST_DRIVER_PMOS_NW BESIDE_POST_DRIVER_NMOS_RW < LUP_2_S ABUT < 90 SINGULAR REGION CONNECTED
  Y = EXT POST_DRIVER_PMOS_NWi BESIDE_POST_DRIVER_NMOS_RWi < LUP_2_S ABUT < 90 SINGULAR REGION NOT CONNECTED
  BESIDE_POST_DRIVER_NMOS_waive = (BESIDE_POST_DRIVER_NMOS_RWi NOT INTERACT X) NOT INTERACT Y
  (BESIDE_POST_DRIVER_NMOS NOT BESIDE_POST_DRIVER_NMOS_waive) NOT INSIDE PTAP_guard_ring_hole
  BESIDE_POST_DRIVER_PMOS NOT INSIDE NTAP_guard_ring_hole
}

LUP.3.1.1 { @ For the 0.9V or 1.1V N/PMOS which connects to an IO pad, space between NMOS and PMOS >= ^LUP_3_1_1 um
  EXT POST_DRIVER_NMOS_PW_LV POST_DRIVER_PMOS_NW_LV < LUP_3_1_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_LV POST_DRIVER_PMOS_NW_LV < LUP_3_1_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV POST_DRIVER_PMOS_NWi_LV < LUP_3_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED  
}
LUP.3.1.2 { @ For the 0.9V or 1.1V N/PMOS which connects to an IO pad, space between NMOS and PMOS >= ^LUP_3_1_2 um. [if one of guard-ring < ^LUP_3_W um]
  EXT POST_DRIVER_NMOS_PW_LV_NG POST_DRIVER_PMOS_NW_LV < LUP_3_1_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_LV_NG POST_DRIVER_PMOS_NW_LV < LUP_3_1_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV_NG POST_DRIVER_PMOS_NWi_LV < LUP_3_1_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  
  EXT POST_DRIVER_NMOS_PW_LV POST_DRIVER_PMOS_NW_LV_NG < LUP_3_1_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_LV POST_DRIVER_PMOS_NW_LV_NG < LUP_3_1_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV POST_DRIVER_PMOS_NWi_LV_NG < LUP_3_1_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
}

LUP.3.2.1 { @ For the 1.8V N/PMOS which connects to an I/O pad, space between the 1.8V NMOS and the 1.8V/1.1V/0.9V PMOS, space between the 1.8V PMOS and the 1.8V/1.1V/0.9V NMOS >= ^LUP_3_2_1 um
  EXT POST_DRIVER_NMOS_PW_18V POST_DRIVER_PMOS_NW_18V < LUP_3_2_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_18V POST_DRIVER_PMOS_NW_LV  < LUP_3_2_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV  POST_DRIVER_PMOS_NW_18V < LUP_3_2_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_18V POST_DRIVER_PMOS_NW_18V < LUP_3_2_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_18V POST_DRIVER_PMOS_NW_LV  < LUP_3_2_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV  POST_DRIVER_PMOS_NW_18V < LUP_3_2_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_18V POST_DRIVER_PMOS_NWi_18V < LUP_3_2_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_18V POST_DRIVER_PMOS_NWi_LV  < LUP_3_2_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV  POST_DRIVER_PMOS_NWi_18V < LUP_3_2_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
LUP.3.2.2 { @ For the 1.8V N/PMOS which connects to an I/O pad, space between the 1.8V NMOS and the 1.8V/1.1V/0.9V PMOS, space between the 1.8V PMOS and the 1.8V/1.1V/0.9V NMOS >= ^LUP_3_2_2 um. [if one of guard-ring < ^LUP_3_W um]
  EXT POST_DRIVER_NMOS_PW_18V_NG POST_DRIVER_PMOS_NW_18V < LUP_3_2_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_18V_NG POST_DRIVER_PMOS_NW_LV  < LUP_3_2_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV_NG  POST_DRIVER_PMOS_NW_18V < LUP_3_2_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_18V_NG POST_DRIVER_PMOS_NW_18V < LUP_3_2_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_18V_NG POST_DRIVER_PMOS_NW_LV  < LUP_3_2_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV_NG  POST_DRIVER_PMOS_NW_18V < LUP_3_2_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_18V_NG POST_DRIVER_PMOS_NWi_18V < LUP_3_2_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_18V_NG POST_DRIVER_PMOS_NWi_LV  < LUP_3_2_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV_NG  POST_DRIVER_PMOS_NWi_18V < LUP_3_2_2 ABUT < 90 SINGULAR REGION NOT CONNECTED

  EXT POST_DRIVER_NMOS_PW_18V POST_DRIVER_PMOS_NW_18V_NG < LUP_3_2_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_18V POST_DRIVER_PMOS_NW_LV_NG  < LUP_3_2_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV  POST_DRIVER_PMOS_NW_18V_NG < LUP_3_2_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_18V POST_DRIVER_PMOS_NW_18V_NG < LUP_3_2_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_18V POST_DRIVER_PMOS_NW_LV_NG  < LUP_3_2_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV  POST_DRIVER_PMOS_NW_18V_NG < LUP_3_2_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_18V POST_DRIVER_PMOS_NWi_18V_NG < LUP_3_2_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_18V POST_DRIVER_PMOS_NWi_LV_NG  < LUP_3_2_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV  POST_DRIVER_PMOS_NWi_18V_NG < LUP_3_2_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
}

LUP.3.3.1 { @ For the 2.5V N/PMOS which connects to an I/O pad, space between the 2.5V NMOS and the 2.5V/1.1V/0.9V PMOS, space between the 2.5V PMOS and the 2.5V/1.1V/0.9V NMOS >= ^LUP_3_3_1 um
  EXT POST_DRIVER_NMOS_PW_25V POST_DRIVER_PMOS_NW_25V < LUP_3_3_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_25V POST_DRIVER_PMOS_NW_LV  < LUP_3_3_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV  POST_DRIVER_PMOS_NW_25V < LUP_3_3_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_25V POST_DRIVER_PMOS_NW_25V < LUP_3_3_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_25V POST_DRIVER_PMOS_NW_LV  < LUP_3_3_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV  POST_DRIVER_PMOS_NW_25V < LUP_3_3_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_25V POST_DRIVER_PMOS_NWi_25V < LUP_3_3_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_25V POST_DRIVER_PMOS_NWi_LV  < LUP_3_3_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV  POST_DRIVER_PMOS_NWi_25V < LUP_3_3_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
LUP.3.3.2 { @ For the 2.5V N/PMOS which connects to an I/O pad, space between the 2.5V NMOS and the 2.5V/1.1V/0.9V PMOS, space between the 2.5V PMOS and the 2.5V/1.1V/0.9V NMOS >= ^LUP_3_3_2 um. [if one of guard-ring < ^LUP_3_W um]
  EXT POST_DRIVER_NMOS_PW_25V_NG POST_DRIVER_PMOS_NW_25V < LUP_3_3_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_25V_NG POST_DRIVER_PMOS_NW_LV  < LUP_3_3_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV_NG  POST_DRIVER_PMOS_NW_25V < LUP_3_3_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_25V_NG POST_DRIVER_PMOS_NW_25V < LUP_3_3_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_25V_NG POST_DRIVER_PMOS_NW_LV  < LUP_3_3_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV_NG  POST_DRIVER_PMOS_NW_25V < LUP_3_3_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_25V_NG POST_DRIVER_PMOS_NWi_25V < LUP_3_3_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_25V_NG POST_DRIVER_PMOS_NWi_LV  < LUP_3_3_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV_NG  POST_DRIVER_PMOS_NWi_25V < LUP_3_3_2 ABUT < 90 SINGULAR REGION NOT CONNECTED

  EXT POST_DRIVER_NMOS_PW_25V POST_DRIVER_PMOS_NW_25V_NG < LUP_3_3_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_25V POST_DRIVER_PMOS_NW_LV_NG  < LUP_3_3_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV  POST_DRIVER_PMOS_NW_25V_NG < LUP_3_3_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_25V POST_DRIVER_PMOS_NW_25V_NG < LUP_3_3_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_25V POST_DRIVER_PMOS_NW_LV_NG  < LUP_3_3_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV  POST_DRIVER_PMOS_NW_25V_NG < LUP_3_3_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_25V POST_DRIVER_PMOS_NWi_25V_NG < LUP_3_3_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_25V POST_DRIVER_PMOS_NWi_LV_NG  < LUP_3_3_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV  POST_DRIVER_PMOS_NWi_25V_NG < LUP_3_3_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
}

LUP.3.4.1 { @ For the 3.3V N/PMOS which connects to an I/O pad, space between the 3.3V NMOS and the 2.5V/1.1V/0.9V PMOS, space between the 3.3V PMOS and the 2.5V/1.1V/0.9V NMOS >= ^LUP_3_4_1 um
  EXT POST_DRIVER_NMOS_PW_33V POST_DRIVER_PMOS_NW_33V < LUP_3_4_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_33V POST_DRIVER_PMOS_NW_LV  < LUP_3_4_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV  POST_DRIVER_PMOS_NW_33V < LUP_3_4_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_33V POST_DRIVER_PMOS_NW_33V < LUP_3_4_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_33V POST_DRIVER_PMOS_NW_LV  < LUP_3_4_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV  POST_DRIVER_PMOS_NW_33V < LUP_3_4_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_33V POST_DRIVER_PMOS_NWi_33V < LUP_3_4_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_33V POST_DRIVER_PMOS_NWi_LV  < LUP_3_4_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV  POST_DRIVER_PMOS_NWi_33V < LUP_3_4_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
LUP.3.4.2 { @ For the 3.3V N/PMOS which connects to an I/O pad, space between the 3.3V NMOS and the 2.5V/1.1V/0.9V PMOS, space between the 3.3V PMOS and the 2.5V/1.1V/0.9V NMOS >= ^LUP_3_4_2 um. [if one of guard-ring < ^LUP_3_W um]
  EXT POST_DRIVER_NMOS_PW_33V_NG POST_DRIVER_PMOS_NW_33V < LUP_3_4_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_33V_NG POST_DRIVER_PMOS_NW_LV  < LUP_3_4_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV_NG  POST_DRIVER_PMOS_NW_33V < LUP_3_4_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_33V_NG POST_DRIVER_PMOS_NW_33V < LUP_3_4_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_33V_NG POST_DRIVER_PMOS_NW_LV  < LUP_3_4_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV_NG  POST_DRIVER_PMOS_NW_33V < LUP_3_4_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_33V_NG POST_DRIVER_PMOS_NWi_33V < LUP_3_4_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_33V_NG POST_DRIVER_PMOS_NWi_LV  < LUP_3_4_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV_NG  POST_DRIVER_PMOS_NWi_33V < LUP_3_4_2 ABUT < 90 SINGULAR REGION NOT CONNECTED

  EXT POST_DRIVER_NMOS_PW_33V POST_DRIVER_PMOS_NW_33V_NG < LUP_3_4_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_33V POST_DRIVER_PMOS_NW_LV_NG  < LUP_3_4_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV  POST_DRIVER_PMOS_NW_33V_NG < LUP_3_4_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_33V POST_DRIVER_PMOS_NW_33V_NG < LUP_3_4_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_33V POST_DRIVER_PMOS_NW_LV_NG  < LUP_3_4_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV  POST_DRIVER_PMOS_NW_33V_NG < LUP_3_4_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_33V POST_DRIVER_PMOS_NWi_33V_NG < LUP_3_4_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_33V POST_DRIVER_PMOS_NWi_LV_NG  < LUP_3_4_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV  POST_DRIVER_PMOS_NWi_33V_NG < LUP_3_4_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
}

LUP.3.5.1 { @ For the 5V N/PMOS which connects to an I/O pad, space between the 5V NMOS and the 5V/1.1V/0.9V PMOS, space between the 5V PMOS and the 5V/1.1V/0.9V NMOS >= ^LUP_3_5_1 um
  EXT POST_DRIVER_NMOS_PW_5V POST_DRIVER_PMOS_NW_5V < LUP_3_5_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_5V POST_DRIVER_PMOS_NW_LV  < LUP_3_5_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV  POST_DRIVER_PMOS_NW_5V < LUP_3_5_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_5V POST_DRIVER_PMOS_NW_5V < LUP_3_5_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_5V POST_DRIVER_PMOS_NW_LV  < LUP_3_5_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV  POST_DRIVER_PMOS_NW_5V < LUP_3_5_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_5V POST_DRIVER_PMOS_NWi_5V < LUP_3_5_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_5V POST_DRIVER_PMOS_NWi_LV  < LUP_3_5_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV  POST_DRIVER_PMOS_NWi_5V < LUP_3_5_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
LUP.3.5.2 { @ For the 5V N/PMOS which connects to an I/O pad, space between the 5V NMOS and the 5V/1.1V/0.9V PMOS, space between the 5V PMOS and the 5V/1.1V/0.9V NMOS >= ^LUP_3_5_2 um. [if one of guard-ring < ^LUP_3_W um]
  EXT POST_DRIVER_NMOS_PW_5V_NG POST_DRIVER_PMOS_NW_5V < LUP_3_5_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_5V_NG POST_DRIVER_PMOS_NW_LV  < LUP_3_5_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV_NG  POST_DRIVER_PMOS_NW_5V < LUP_3_5_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_5V_NG POST_DRIVER_PMOS_NW_5V < LUP_3_5_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_5V_NG POST_DRIVER_PMOS_NW_LV  < LUP_3_5_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV_NG  POST_DRIVER_PMOS_NW_5V < LUP_3_5_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_5V_NG POST_DRIVER_PMOS_NWi_5V < LUP_3_5_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_5V_NG POST_DRIVER_PMOS_NWi_LV  < LUP_3_5_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV_NG  POST_DRIVER_PMOS_NWi_5V < LUP_3_5_2 ABUT < 90 SINGULAR REGION NOT CONNECTED

  EXT POST_DRIVER_NMOS_PW_5V POST_DRIVER_PMOS_NW_5V_NG < LUP_3_5_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_5V POST_DRIVER_PMOS_NW_LV_NG  < LUP_3_5_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV  POST_DRIVER_PMOS_NW_5V_NG < LUP_3_5_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_5V POST_DRIVER_PMOS_NW_5V_NG < LUP_3_5_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_5V POST_DRIVER_PMOS_NW_LV_NG  < LUP_3_5_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV  POST_DRIVER_PMOS_NW_5V_NG < LUP_3_5_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_5V POST_DRIVER_PMOS_NWi_5V_NG < LUP_3_5_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_5V POST_DRIVER_PMOS_NWi_LV_NG  < LUP_3_5_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV  POST_DRIVER_PMOS_NWi_5V_NG < LUP_3_5_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
}

LUP.4 { @ Within ^LUP_2 um space from the ACTIVE connecting to the IO pad, Minimum width for the N+ guard-ring, the P+ guard-ring, the N+ strap and the P+ strap >= ^LUP_4 um
  PTAP_guard_ring_wide2 = (PSTPi TOUCH PTAP_guard_ring_holex) WITH WIDTH >= LUP_4
  NTAP_guard_ring_wide2 = (NSTPi TOUCH NTAP_guard_ring_holex) WITH WIDTH >= LUP_4
  
  PW_inside_guard_ring_wide2_pre = PW_inside_guard_ring NOT COIN OUTSIDE EDGE PTAP_guard_ring_wide2
  PW_inside_guard_ring_wide2 = NW_inside_guard_ring NOT WITH EDGE PW_inside_guard_ring_wide2_pre
  NW_inside_guard_ring_wide2_pre = NW_inside_guard_ring NOT COIN OUTSIDE EDGE NTAP_guard_ring_wide2
  NW_inside_guard_ring_wide2 = NW_inside_guard_ring NOT WITH EDGE NW_inside_guard_ring_wide2_pre
  
  PTAP_guard_ring_wide_hole = ((HOLES PTAP_guard_ring_wide2 INNER) INSIDE PWELi) OR PW_inside_guard_ring_wide2
  NTAP_guard_ring_wide_hole = ((HOLES NTAP_guard_ring_wide2 INNER) INSIDE NWi) OR NW_inside_guard_ring_wide2
  PTAP_guard_ring_hole_check = PTAP_guard_ring_holex NOT INSIDE PTAP_guard_ring_wide_hole
  NTAP_guard_ring_hole_check = NTAP_guard_ring_holex NOT INSIDE NTAP_guard_ring_wide_hole
  PTAP_guard_ring_check = PSTPi COIN OUTSIDE EDGE PTAP_guard_ring_hole_check
  NTAP_guard_ring_check = NSTPi COIN OUTSIDE EDGE NTAP_guard_ring_hole_check
  INT PTAP_guard_ring_check PSTPi < LUP_4 ABUT < 90 REGION
  INT NTAP_guard_ring_check NSTPi < LUP_4 ABUT < 90 REGION
}

LUP.5.1.1 { @ Minimum space >= ^LUP_5_1_1 um
            @ 1. between 0.9V or 1.1V NMOS which connects to the IO pad and the the PMOS in the internal circuit
            @ 2. between 0.9V or 1.1V PMOS which connects to the IO pad and the the NMOS in the internal circuit
  EXT POST_DRIVER_PMOS_NW_LV BESIDE_POST_DRIVER_NMOS_PW < LUP_5_1_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_PMOS_NW_LV BESIDE_POST_DRIVER_NMOS_RW < LUP_5_1_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_PMOS_NWi_LV BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_PW_LV BESIDE_POST_DRIVER_PMOS_NW < LUP_5_1_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_LV BESIDE_POST_DRIVER_PMOS_NW < LUP_5_1_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV BESIDE_POST_DRIVER_PMOS_NWi < LUP_5_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
LUP.5.1.2 { @ Minimum space >= ^LUP_5_1_2 um [if one of guard-ring < ^LUP_3_W um]
            @ 1. between 0.9V or 1.1V NMOS which connects to the IO pad and the the PMOS in the internal circuit
            @ 2. between 0.9V or 1.1V PMOS which connects to the IO pad and the the NMOS in the internal circuit
  EXT POST_DRIVER_PMOS_NW_LV_NG BESIDE_POST_DRIVER_NMOS_PW < LUP_5_1_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_PMOS_NW_LV_NG BESIDE_POST_DRIVER_NMOS_RW < LUP_5_1_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_PMOS_NWi_LV_NG BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_1_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_PW_LV_NG BESIDE_POST_DRIVER_PMOS_NW < LUP_5_1_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_LV_NG BESIDE_POST_DRIVER_PMOS_NW < LUP_5_1_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV_NG BESIDE_POST_DRIVER_PMOS_NWi < LUP_5_1_2 ABUT < 90 SINGULAR REGION NOT CONNECTED

  EXT POST_DRIVER_PMOS_NW_LV BESIDE_POST_DRIVER_NMOS_PW_NG < LUP_5_1_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_PMOS_NW_LV BESIDE_POST_DRIVER_NMOS_RW_NG < LUP_5_1_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_PMOS_NWi_LV BESIDE_POST_DRIVER_NMOS_RWi_NG < LUP_5_1_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_PW_LV BESIDE_POST_DRIVER_PMOS_NW_NG < LUP_5_1_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_LV BESIDE_POST_DRIVER_PMOS_NW_NG < LUP_5_1_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV BESIDE_POST_DRIVER_PMOS_NWi_NG < LUP_5_1_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
}

LUP.5.2.1 { @ Minimum space >= ^LUP_5_2_1 um
            @ 1. between 1.8V NMOS which connects to the IO pad and the the PMOS in the internal circuit
            @ 2. between 1.8V PMOS which connects to the IO pad and the the NMOS in the internal circuit
  EXT POST_DRIVER_PMOS_NW_18V BESIDE_POST_DRIVER_NMOS_PW < LUP_5_2_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_PMOS_NW_18V BESIDE_POST_DRIVER_NMOS_RW < LUP_5_2_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_PMOS_NWi_18V BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_2_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_PW_18V BESIDE_POST_DRIVER_PMOS_NW < LUP_5_2_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_18V BESIDE_POST_DRIVER_PMOS_NW < LUP_5_2_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_18V BESIDE_POST_DRIVER_PMOS_NWi < LUP_5_2_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
LUP.5.2.2 { @ Minimum space >= ^LUP_5_2_2 um [if one of guard-ring < ^LUP_3_W um]
            @ 1. between 1.8V NMOS which connects to the IO pad and the the PMOS in the internal circuit 
            @ 2. between 1.8V PMOS which connects to the IO pad and the the NMOS in the internal circuit  
  EXT POST_DRIVER_PMOS_NW_18V_NG BESIDE_POST_DRIVER_NMOS_PW < LUP_5_2_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_PMOS_NW_18V_NG BESIDE_POST_DRIVER_NMOS_RW < LUP_5_2_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_PMOS_NWi_18V_NG BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_2_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_PW_18V_NG BESIDE_POST_DRIVER_PMOS_NW < LUP_5_2_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_18V_NG BESIDE_POST_DRIVER_PMOS_NW < LUP_5_2_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_18V_NG BESIDE_POST_DRIVER_PMOS_NWi < LUP_5_2_2 ABUT < 90 SINGULAR REGION NOT CONNECTED

  EXT POST_DRIVER_PMOS_NW_18V BESIDE_POST_DRIVER_NMOS_PW_NG < LUP_5_2_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_PMOS_NW_18V BESIDE_POST_DRIVER_NMOS_RW_NG < LUP_5_2_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_PMOS_NWi_18V BESIDE_POST_DRIVER_NMOS_RWi_NG < LUP_5_2_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_PW_18V BESIDE_POST_DRIVER_PMOS_NW_NG < LUP_5_2_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_18V BESIDE_POST_DRIVER_PMOS_NW_NG < LUP_5_2_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_18V BESIDE_POST_DRIVER_PMOS_NWi_NG < LUP_5_2_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
}

LUP.5.3.1 { @ Minimum space >= ^LUP_5_3_1 um
            @ 1. between 2.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit 
            @ 2. between 2.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit  
  EXT POST_DRIVER_PMOS_NW_25V BESIDE_POST_DRIVER_NMOS_PW < LUP_5_3_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_PMOS_NW_25V BESIDE_POST_DRIVER_NMOS_RW < LUP_5_3_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_PMOS_NWi_25V BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_3_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_PW_25V BESIDE_POST_DRIVER_PMOS_NW < LUP_5_3_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_25V BESIDE_POST_DRIVER_PMOS_NW < LUP_5_3_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_25V BESIDE_POST_DRIVER_PMOS_NWi < LUP_5_3_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
LUP.5.3.2 { @ Minimum space >= ^LUP_5_3_2 um [if one of guard-ring < ^LUP_3_W um]
            @ 1. between 2.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit 
            @ 2. between 2.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit  
  EXT POST_DRIVER_PMOS_NW_25V_NG BESIDE_POST_DRIVER_NMOS_PW < LUP_5_3_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_PMOS_NW_25V_NG BESIDE_POST_DRIVER_NMOS_RW < LUP_5_3_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_PMOS_NWi_25V_NG BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_3_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_PW_25V_NG BESIDE_POST_DRIVER_PMOS_NW < LUP_5_3_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_25V_NG BESIDE_POST_DRIVER_PMOS_NW < LUP_5_3_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_25V_NG BESIDE_POST_DRIVER_PMOS_NWi < LUP_5_3_2 ABUT < 90 SINGULAR REGION NOT CONNECTED

  EXT POST_DRIVER_PMOS_NW_25V BESIDE_POST_DRIVER_NMOS_PW_NG < LUP_5_3_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_PMOS_NW_25V BESIDE_POST_DRIVER_NMOS_RW_NG < LUP_5_3_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_PMOS_NWi_25V BESIDE_POST_DRIVER_NMOS_RWi_NG < LUP_5_3_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_PW_25V BESIDE_POST_DRIVER_PMOS_NW_NG < LUP_5_3_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_25V BESIDE_POST_DRIVER_PMOS_NW_NG < LUP_5_3_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_25V BESIDE_POST_DRIVER_PMOS_NWi_NG < LUP_5_3_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
LUP.5.4.1 { @ Minimum space >= ^LUP_5_4_1 um
            @ 1. between 3.3V NMOS which connects to the IO pad and the the PMOS in the internal circuit 
            @ 2. between 3.3V PMOS which connects to the IO pad and the the NMOS in the internal circuit  
  EXT POST_DRIVER_PMOS_NW_33V BESIDE_POST_DRIVER_NMOS_PW < LUP_5_4_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_PMOS_NW_33V BESIDE_POST_DRIVER_NMOS_RW < LUP_5_4_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_PMOS_NWi_33V BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_4_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_PW_33V BESIDE_POST_DRIVER_PMOS_NW < LUP_5_4_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_33V BESIDE_POST_DRIVER_PMOS_NW < LUP_5_4_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_33V BESIDE_POST_DRIVER_PMOS_NWi < LUP_5_4_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
LUP.5.4.2 { @ Minimum space >= ^LUP_5_4_2 um [if one of guard-ring < ^LUP_3_W um]
            @ 1. between 3.3V NMOS which connects to the IO pad and the the PMOS in the internal circuit 
            @ 2. between 3.3V PMOS which connects to the IO pad and the the NMOS in the internal circuit  
  EXT POST_DRIVER_PMOS_NW_33V_NG BESIDE_POST_DRIVER_NMOS_PW < LUP_5_4_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_PMOS_NW_33V_NG BESIDE_POST_DRIVER_NMOS_RW < LUP_5_4_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_PMOS_NWi_33V_NG BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_4_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_PW_33V_NG BESIDE_POST_DRIVER_PMOS_NW < LUP_5_4_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_33V_NG BESIDE_POST_DRIVER_PMOS_NW < LUP_5_4_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_33V_NG BESIDE_POST_DRIVER_PMOS_NWi < LUP_5_4_2 ABUT < 90 SINGULAR REGION NOT CONNECTED

  EXT POST_DRIVER_PMOS_NW_33V BESIDE_POST_DRIVER_NMOS_PW_NG < LUP_5_4_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_PMOS_NW_33V BESIDE_POST_DRIVER_NMOS_RW_NG < LUP_5_4_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_PMOS_NWi_33V BESIDE_POST_DRIVER_NMOS_RWi_NG < LUP_5_4_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_PW_33V BESIDE_POST_DRIVER_PMOS_NW_NG < LUP_5_4_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_33V BESIDE_POST_DRIVER_PMOS_NW_NG < LUP_5_4_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_33V BESIDE_POST_DRIVER_PMOS_NWi_NG < LUP_5_4_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
}

LUP.5.5.1 { @ Minimum space >= ^LUP_5_5_1 um
            @ 1. between 5V NMOS which connects to the IO pad and the the PMOS in the internal circuit 
            @ 2. between 5V PMOS which connects to the IO pad and the the NMOS in the internal circuit  
  EXT POST_DRIVER_PMOS_NW_5V BESIDE_POST_DRIVER_NMOS_PW < LUP_5_5_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_PMOS_NW_5V BESIDE_POST_DRIVER_NMOS_RW < LUP_5_5_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_PMOS_NWi_5V BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_5_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_PW_5V BESIDE_POST_DRIVER_PMOS_NW < LUP_5_5_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_5V BESIDE_POST_DRIVER_PMOS_NW < LUP_5_5_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_5V BESIDE_POST_DRIVER_PMOS_NWi < LUP_5_5_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
LUP.5.5.2 { @ Minimum space >= ^LUP_5_5_2 um [if one of guard-ring < ^LUP_3_W um]
            @ 1. between 5V NMOS which connects to the IO pad and the the PMOS in the internal circuit 
            @ 2. between 5V PMOS which connects to the IO pad and the the NMOS in the internal circuit  
  EXT POST_DRIVER_PMOS_NW_5V_NG BESIDE_POST_DRIVER_NMOS_PW < LUP_5_5_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_PMOS_NW_5V_NG BESIDE_POST_DRIVER_NMOS_RW < LUP_5_5_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_PMOS_NWi_5V_NG BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_5_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_PW_5V_NG BESIDE_POST_DRIVER_PMOS_NW < LUP_5_5_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_5V_NG BESIDE_POST_DRIVER_PMOS_NW < LUP_5_5_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_5V_NG BESIDE_POST_DRIVER_PMOS_NWi < LUP_5_5_2 ABUT < 90 SINGULAR REGION NOT CONNECTED

  EXT POST_DRIVER_PMOS_NW_5V BESIDE_POST_DRIVER_NMOS_PW_NG < LUP_5_5_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_PMOS_NW_5V BESIDE_POST_DRIVER_NMOS_RW_NG < LUP_5_5_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_PMOS_NWi_5V BESIDE_POST_DRIVER_NMOS_RWi_NG < LUP_5_5_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_PW_5V BESIDE_POST_DRIVER_PMOS_NW_NG < LUP_5_5_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_5V BESIDE_POST_DRIVER_PMOS_NW_NG < LUP_5_5_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_5V BESIDE_POST_DRIVER_PMOS_NWi_NG < LUP_5_5_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
}


CO_PACT = COi OR (PSDc NOT OUTSIDE COi)
NPUi = NSTPi INTERACT CO_PACT
NPUi_SRAM = NPUi INSIDE SRM 
NSTP_OS = SIZE NPUi BY LUP_6 INSIDE OF NWi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
NSTP_OS_SRAM = SIZE NPUi_SRAM BY LUP_6_SRAM INSIDE OF NWi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
PACT_CHECK = ((PACTi INTERACT COi) INTERACT POi) NOT POi
PACT_CHECK_NON_SRAM = PACT_CHECK NOT INSIDE SRM 
PACT_CHECK_SRAM =  PACT_CHECK INSIDE SRM

CO_NACT = COi OR (NSDc NOT OUTSIDE COi)
PPUi = PSTPi INTERACT CO_NACT
PPUi_SRAM = PPUi INSIDE SRM
PSTP_OS = SIZE PPUi BY LUP_6 INSIDE OF PWELi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
PSTP_OS_SRAM = SIZE PPUi_SRAM BY LUP_6_SRAM INSIDE OF PWELi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
NACT_CHECK = ((NACTi INTERACT COi) INTERACT POi) NOT POi
NACT_CHECK_NON_SRAM = NACT_CHECK NOT INSIDE SRM 
NACT_CHECK_SRAM =  NACT_CHECK INSIDE SRM

LUP.6 { @ Any point inside NMOS source/drain space to the nearest PW STRAP in the same PW <= ^LUP_6 um
        @ Any point inside PMOS source/drain space to the nearest NW STRAP in the same NW <= ^LUP_6 um
        @ In SRAM bit cell region, the rule is relaxed to ^LUP_6_SRAM um
  PACT_CHECK_NON_SRAM NOT NSTP_OS
  PACT_CHECK_SRAM NOT (NSTP_OS OR NSTP_OS_SRAM)
  NACT_CHECK_NON_SRAM NOT PSTP_OS
  NACT_CHECK_SRAM NOT (PSTP_OS OR PSTP_OS_SRAM)
}


#IFDEF GUIDELINE_ESD

// I/O ESD Guidance
//==================
PMOSi = (PACTi INTERACT POi) INTERACT COi //Interact CONTi to filter out filler cell.
NMOSi = (NACTi INTERACT POi) INTERACT COi
EPMOS = PMOSi AND SDI
ENMOS = NMOSi AND SDI
EMOS = EPMOS OR ENMOS
PASD = PACT NOT POLY
NASD = NACT NOT POLY
EPSD = SDI AND PASD
ENSD = SDI AND NASD
EGTE = SDI AND GATE
ECO  = (CO AND SDI) AND OD

// Define ESD Gate Type
//======================
EGTE_FULL_RPO = EGTE INSIDE RPO
EGTE_PART_RPO = EGTE CUT RPO  
EGTE_NO_RPO = EGTE NOT INTERACT RPO

REG_ENMOS = (ENMOS INTERACT EGTE_PART_RPO) NOT INTERACT EGTE_FULL_RPO
REG_EPMOS = (EPMOS INTERACT EGTE_PART_RPO) NOT INTERACT EGTE_FULL_RPO
TOL_ENMOS = (ENMOS INTERACT EGTE_PART_RPO) INTERACT EGTE_FULL_RPO
PCL_ENMOS = ENMOS NOT INTERACT RPO

REG_EGTE = EGTE AND (REG_ENMOS OR REG_EPMOS)
TOL_EGTE = EGTE AND (TOL_ENMOS OR REG_EPMOS)
PCL_EGTE = EGTE AND PCL_ENMOS

// For ESD.1g
//=============
NSDc_HVMOS = NSDc INTERACT HV_GATE
NSDc_LVMOS = NSDc INTERACT LV_GATE
PSDc_HVMOS = PSDc INTERACT HV_GATE
PSDc_LVMOS = PSDc INTERACT LV_GATE
NSDc_HVMOS_SDI = NSDc_HVMOS INTERACT SDI 
NSDc_LVMOS_SDI = NSDc_LVMOS INTERACT SDI 
PSDc_HVMOS_SDI = PSDc_HVMOS INTERACT SDI 
PSDc_LVMOS_SDI = PSDc_LVMOS INTERACT SDI 
HV_GATEc = STAMP HV_GATE BY ILP1i
LV_GATEc = STAMP LV_GATE BY ILP1i


// For ESD.6g
//=============
CONNECT ENSD NSDu
CONNECT EPSD PSDu
ENSDi = COPY ENSD
EPSDi = COPY EPSD
CONNECT ENSDi NSDc
CONNECT EPSDi PSDc

PSTP_real = PSTPi NOT DIODMY
NSTP_real = NSTPi NOT DIODMY
ENSD_SOURCE_pre = NET AREA RATIO ENSDi PSTP_real > 0 [!!AREA(ENSDi)*!!AREA(PSTP_real)]
EPSD_SOURCE_pre = NET AREA RATIO EPSDi NSTP_real > 0 [!!AREA(EPSDi)*!!AREA(NSTP_real)]
ENSD_SOURCE = ENSD_SOURCE_pre OR ((ENSD NOT PCL_ENMOS) OUTSIDE RPO)
EPSD_SOURCE = EPSD_SOURCE_pre OR (EPSD OUTSIDE RPO)
ENSD_DRAIN = ENSD NOT ENSD_SOURCE
EPSD_DRAIN = EPSD NOT EPSD_SOURCE
ENSD_DRAINx = ENSD_DRAIN INTERACT CO
ENMOSc = STAMP ENMOS BY ENSD_DRAINx
EPMOSc = STAMP EPMOS BY EPSD_DRAIN 

#IFDEF FULL_CHIP
ESD.WARN.1 { @ SDI is not in whole chip. If SDI does not exist, the ESD related DRC will not work well.
  CHIP NOT INTERACT SDI
}
#ENDIF

ESD.WARN.2 { @ SDI encloure of ACTIVE >= 0
  (DACT INTERACT SDI) NOT SDI
}

ESD.1g { @ Use thin oxide transistor for thin oxide power clamp and thin oxide I/O buffers; use thick oxide transistor for the thick oxide Power Clamp and thick oxide I/O buffers
  NET AREA RATIO NSDc_HVMOS_SDI NSDc_LVMOS PSDc_LVMOS LV_GATEc PSTPi > 0 
    [!!AREA(NSDc_HVMOS_SDI)*!AREA(PSTPi)*(!!AREA(NSDc_LVMOS)+!!AREA(PSDc_LVMOS)+!!AREA(LV_GATEc))] 
    RDB ESD.1g.hv_n.rep NSDc_HVMOS_SDI NSDc_LVMOS PSDc_LVMOS LV_GATEc
  NET AREA RATIO NSDc_LVMOS_SDI NSDc_HVMOS PSDc_HVMOS HV_GATEc PSTPi > 0 
    [!!AREA(NSDc_LVMOS_SDI)*!AREA(PSTPi)*(!!AREA(NSDc_HVMOS)+!!AREA(PSDc_HVMOS)+!!AREA(HV_GATEc))]
    RDB ESD.1g.lv_n.rep NSDc_LVMOS_SDI NSDc_HVMOS PSDc_HVMOS HV_GATEc 
  NET AREA RATIO PSDc_HVMOS_SDI NSDc_LVMOS PSDc_LVMOS LV_GATEc PSTPi > 0
    [!!AREA(PSDc_HVMOS_SDI)*!AREA(PSTPi)*(!!AREA(NSDc_LVMOS)+!!AREA(PSDc_LVMOS)+!!AREA(LV_GATEc))]
    RDB ESD.1g.hv_p.rep PSDc_HVMOS_SDI NSDc_LVMOS PSDc_LVMOS LV_GATEc
  NET AREA RATIO PSDc_LVMOS_SDI NSDc_HVMOS PSDc_HVMOS HV_GATEc PSTPi > 0 
    [!!AREA(PSDc_LVMOS_SDI)*!AREA(PSTPi)*(!!AREA(NSDc_HVMOS)+!!AREA(PSDc_HVMOS)+!!AREA(HV_GATEc))]
    RDB ESD.1g.lv_p.rep PSDc_LVMOS_SDI NSDc_HVMOS PSDc_HVMOS HV_GATEc
} 

ESD.3g { @ Unit finger width of NMOS and PMOS for I/O buffer and Power Clamp >= ^ESD_3g_MIN um <= ^ESD_3g_MAX um
  EGTE_W = EGTE INSIDE EDGE OD
  PATH LENGTH EGTE_W < ESD_3g_MIN
  PATH LENGTH EGTE_W > ESD_3g_MAX
}

ESD.4g { @ The OD area of the edge side of I/O buffer and Power Clamp should be Source or Bulk rather than Drain, to avoid an unwanted parasitic bipolar effect or an abnormal discharge path in ESD zapping.
  EDGE_NSD = NSDu INTERACT EGTE == 1
  NET AREA RATIO EDGE_NSD PSTPu > 0 [!!AREA(EDGE_NSD)*!AREA(PSTPu)]
  EDGE_PSD = PSDu INTERACT EGTE == 1
  NET AREA RATIO EDGE_PSD NSTPu > 0 [!!AREA(EDGE_PSD)*!AREA(NSTPu)]
}

ESD.5g { @ For same type OD of the I/O buffer and Power Clamp should be surrounded by a guard-ring. All other type ODs should be placed outside this guard-ring.
  EPMOS NOT INSIDE NTAP_guard_ring_hole
  ENMOS NOT INSIDE PTAP_guard_ring_hole
}

ESD.6g { @ Butted STRAP and the STRAP which are between two sources of the N/PMOS in the same I/O buffer and Power Clamp are strictly prohibited. 
  A = (EXT ENMOSc < ESD_6g ABUT < 90 OPPOSITE REGION CONNECTED) NOT INTERACT GATE
  A INTERACT PSTPi
  B = (EXT EPMOSc < ESD_6g ABUT < 90 OPPOSITE REGION CONNECTED) NOT INTERACT GATE
  B INTERACT NSTPi
}

NWELc = COPY NWEL
CONNECT NWELc
PWELc = COPY PWEL
CONNECT PWELc

ESD.7g { @ Except the ESD device, either one of the following two conditions must be followed.
@ 1. the space of two same type ODs >= ^ESD_7g um   2. two same type ODs should be separated by different type OD.    
@ The same type ODs are N+OD and N+OD in the same PW, or P+OD and P+OD in the same NW, which connect to two different Pad.
  PACT_CHECK = (PACT INTERACT PSD_IOPAD) NOT EPMOS 
  PACT_CHECK_CB = STAMP PACT_CHECK BY PSD_IOPAD
  P1 = EXT PACT_CHECK_CB < ESD_7g ABUT < 90 SINGULAR REGION NOT CONNECTED
  PACT_CHECK_NW = STAMP (PACT_CHECK INTERACT P1) BY NWELc
  P2 = EXT PACT_CHECK_NW < ESD_7g ABUT < 90 SINGULAR REGION CONNECTED
  ESD_P3 = P1 AND P2
  (ESD_P3 NOT NSTPi) INTERACT PACT_CHECK_CB > 1 BY NET
  
  NACT_CHECK = (NACT INTERACT NSD_IOPAD) NOT ENMOS 
  NACT_CHECK_CB = STAMP NACT_CHECK BY NSD_IOPAD
  N1 = EXT NACT_CHECK_CB < ESD_7g ABUT < 90 SINGULAR REGION NOT CONNECTED
  NACT_CHECK_PW = STAMP (NACT_CHECK INTERACT N1) BY PWELc
  N2 = EXT NACT_CHECK_PW < ESD_7g ABUT < 90 SINGULAR REGION CONNECTED
  ESD_N3 = N1 AND N2
  (ESD_N3 NOT PSTPi) INTERACT NACT_CHECK_CB > 1 BY NET
}

#IFDEF DEFINE_PAD_BY_TEXT
PAD_M1u_BY_TEXT = M1u WITH TEXT PAD_TEXT M1_PIN_TEXT PRIMARY ONLY
PAD_M2u_BY_TEXT = M2u WITH TEXT PAD_TEXT M2_PIN_TEXT PRIMARY ONLY
PAD_M3u_BY_TEXT = M3u WITH TEXT PAD_TEXT M3_PIN_TEXT PRIMARY ONLY
PAD_M4u_BY_TEXT = M4u WITH TEXT PAD_TEXT M4_PIN_TEXT PRIMARY ONLY
PAD_M5u_BY_TEXT = M5u WITH TEXT PAD_TEXT M5_PIN_TEXT PRIMARY ONLY
PAD_M6u_BY_TEXT = M6u WITH TEXT PAD_TEXT M6_PIN_TEXT PRIMARY ONLY
PAD_M7u_BY_TEXT = M7u WITH TEXT PAD_TEXT M7_PIN_TEXT PRIMARY ONLY
PAD_M8u_BY_TEXT = M8u WITH TEXT PAD_TEXT M8_PIN_TEXT PRIMARY ONLY
PAD_M9u_BY_TEXT = M9u WITH TEXT PAD_TEXT M9_PIN_TEXT PRIMARY ONLY
PAD_M10u_BY_TEXT = M10u WITH TEXT PAD_TEXT M10_PIN_TEXT PRIMARY ONLY
PAD_APu_BY_TEXT = APu WITH TEXT PAD_TEXT AP_PIN_TEXT PRIMARY ONLY
#ENDIF

ESD.12g { @ It is not allowed to use OD RPO resistor or NW resistor connected to PAD
  ODR_T = ((OD NOT POLY) INTERACT OD_RES_RPO) NOT OD_RES_RPO
  ODRuT = STAMP ODR_T BY COu
#IFDEF DEFINE_PAD_BY_TEXT
  NET AREA RATIO ODRuT OVER CBu CB2Fu CB2Wu UBMu PAD_M10u_BY_TEXT PAD_M9u_BY_TEXT PAD_M8u_BY_TEXT PAD_M7u_BY_TEXT PAD_M6u_BY_TEXT PAD_M5u_BY_TEXT PAD_M4u_BY_TEXT PAD_M3u_BY_TEXT PAD_M2u_BY_TEXT PAD_M1u_BY_TEXT PAD_APu_BY_TEXT > 0 
  NET AREA RATIO NWRuT OVER CBu CB2Fu CB2Wu UBMu PAD_M10u_BY_TEXT PAD_M9u_BY_TEXT PAD_M8u_BY_TEXT PAD_M7u_BY_TEXT PAD_M6u_BY_TEXT PAD_M5u_BY_TEXT PAD_M4u_BY_TEXT PAD_M3u_BY_TEXT PAD_M2u_BY_TEXT PAD_M1u_BY_TEXT PAD_APu_BY_TEXT > 0
#ELSE  
  NET AREA RATIO ODRuT OVER CBu CB2Fu CB2Wu UBMu > 0 
  NET AREA RATIO NWRuT OVER CBu CB2Fu CB2Wu UBMu > 0
#ENDIF    
}


// Regular I/O
//============

ESD_GATE_W = GATE_W INSIDE EDGE SDI
ESD_PMOS_GATE_W = ESD_GATE_W INSIDE EDGE PP
ESD_NMOS_GATE_W = ESD_GATE_W INSIDE EDGE NP
ESD_PMOS_GATE_W_EXP = EXPAND EDGE ESD_PMOS_GATE_W INSIDE BY GRID
ESD_NMOS_GATE_W_EXP = EXPAND EDGE ESD_NMOS_GATE_W INSIDE BY GRID
ESD_PMOS_GATE_W_EXPc = STAMP ESD_PMOS_GATE_W_EXP BY EPMOSc
ESD_NMOS_GATE_W_EXPc = STAMP ESD_NMOS_GATE_W_EXP BY ENMOSc

ESD.16g { @ Total finger width for NMOS in same connection of drain > ^ESD_16g um [check ESD.24g also]
  NET AREA RATIO ESD_NMOS_GATE_W_EXPc < ESD_16g
    [(AREA(ESD_NMOS_GATE_W_EXPc)/2)/GRID]
    RDB ESD.16g.NMOS.rep ESD_NMOS_GATE_W_EXPc
}
ESD.17g { @ Total finger width for PMOS in same connection of drain > ^ESD_17g um [check ESD.25g also]
  NET AREA RATIO ESD_PMOS_GATE_W_EXPc < ESD_17g
    [(AREA(ESD_PMOS_GATE_W_EXPc)/2)/GRID]
    RDB ESD.17g.PMOS.rep ESD_PMOS_GATE_W_EXPc
}
ESD.18g { @ Channel length for 3.3V NMOS/PMOS Regular I/O >= ^ESD_18g_33V um
  REG_EGTE_33V = REG_EGTE AND OD33
  INT REG_EGTE_33V < ESD_18g_33V ABUT < 90 SINGULAR REGION
}
ESD.18.1g { @ Channel length for 2.5V NMOS/PMOS Regular I/O >= ^ESD_18g_25V um
  REG_EGTE_25V = REG_EGTE AND OD25
  INT REG_EGTE_25V < ESD_18g_25V ABUT < 90 SINGULAR REGION
}
ESD.18.2g { @ Channel length for 1.8V NMOS/PMOS Regular I/O >= ^ESD_18g_18V um
  REG_EGTE_18V = REG_EGTE AND OD18
  INT REG_EGTE_18V < ESD_18g_18V ABUT < 90 SINGULAR REGION
}
ESD.18.3g { @ Channel length for 0.9V or 1.1V NMOS/PMOS Regular I/O >= ^ESD_18g_LV um
  REG_EGTE_LV  = REG_EGTE NOT OD2
  INT REG_EGTE_LV < ESD_18g_LV ABUT < 90 SINGULAR REGION
}
ESD.19g { @ The NMOS and PMOS should have an unsilicided area on the drain side. 
          @ That is, the RPO mask should block the drain side of the device.
          @ (except the contact region which should remain silicided).
  REG_EGTE NOT INTERACT RPO
}
ESD.20g { @ Overlap of RPO on the drain side to the poly gate for Regular I/O == ^ESD_20g um
  REG_EGTE OUTSIDE RPO
  REG_EGTE_W = REG_EGTE INSIDE EDGE OD
  X = REG_EGTE_W INSIDE EDGE RPO
  Y = EXPAND EDGE X INSIDE BY ESD_20g
  REG_EGTE WITH EDGE X > 1
  (REG_EGTE AND RPO) XOR Y
}
ESD.21g { @ Width of the RPO on drain side for NMOS Regular I/O >= ^ESD_21g um
  REG_ENSD = (ENSD INTERACT REG_EGTE) AND RPO
  INT REG_ENSD < ESD_21g ABUT < 90 SINGULAR REGION
}
ESD.22g { @ Width of the RPO on drain side for PMOS Regular I/O >= ^ESD_22g um
  REG_EPSD = (EPSD INTERACT REG_EGTE) AND RPO
  INT REG_EPSD < ESD_22g ABUT < 90 SINGULAR REGION
}
ESD.23g { @ Space of poly to CO on source side for Regular I/O >= ^ESD_23g um
  EXT ECO REG_EGTE < ESD_23g ABUT < 90 SINGULAR REGION
}


// HV Tolerant I/O
//================

TOL_ENOD = ENSD INTERACT TOL_EGTE
TOL_ENG  = (TOL_ENOD NOT INTERACT ECO) NOT INTERACT PSTP
TOL_ENSD = TOL_ENOD NOT TOL_ENG
TOL_ENS  = TOL_ENSD OUTSIDE RPO
TOL_END  = TOL_ENSD NOT OUTSIDE RPO

// ESD.24g is checked by ESD.16g
// ESD.25g is checked by ESD.17g
ESD.26g { @ Channel length for  5V NMOS/PMOS HV Tolerant I/O >= ^ESD_26g_5V um
  TOL_EGTE_5V = TOL_EGTE AND OD33
  INT TOL_EGTE_5V < ESD_26g_5V ABUT < 90 SINGULAR REGION
}
ESD.26.1g { @ Channel length for 3.3V NMOS/PMOS HV Tolerant I/O >= ^ESD_26g_33V um
  TOL_EGTE_33V = TOL_EGTE AND OD25
  INT TOL_EGTE_33V < ESD_26g_33V ABUT < 90 SINGULAR REGION
}
ESD.26.2g { @ Channel length for 2.5V NMOS/PMOS HV Tolerant I/O >= ^ESD_26g_25V um
  TOL_EGTE_25V = TOL_EGTE AND OD18
  INT TOL_EGTE_25V < ESD_26g_25V ABUT < 90 SINGULAR REGION
}
ESD.27g { @ The NMOS and PMOS should have an unsilicided area on the drain side. 
          @ That is, the RPO mask should block the drain side of the device.
          @ (except the contact region which should remain silicided).
  TOL_EGTE NOT INTERACT RPO
}
ESD.28g { @ Overlap of RPO on the drain side to the poly gate for NMOS HV Tolerant I/O == ^ESD_28g um
  TOL_ENGTE1 = TOL_EGTE INTERACT TOL_END
  TOL_ENGTE2 = TOL_EGTE INTERACT TOL_ENS
  TOL_ENGTE1 NOT RPO
  TOL_ENGTE2 OUTSIDE RPO
  TOL_ENG NOT INTERACT TOL_ENGTE2
  TOL_ENGTE2_W = TOL_ENGTE2 INSIDE EDGE OD
  X = TOL_ENGTE2_W INSIDE EDGE RPO
  Y = EXPAND EDGE X INSIDE BY ESD_28g
  (TOL_ENGTE2 AND RPO) XOR Y
}
ESD.29g { @ Overlap of RPO on the drain side to the poly gate for PMOS HV Tolerant I/O == ^ESD_29g um
  TOL_EPGTE = TOL_EGTE INTERACT EPSD
  TOL_EPGTE OUTSIDE RPO
  TOL_EPGTE_W = TOL_EPGTE INSIDE EDGE OD
  X = TOL_EPGTE_W INSIDE EDGE RPO
  Y = EXPAND EDGE X INSIDE BY ESD_29g
  TOL_EPGTE WITH EDGE X > 1
  (TOL_EPGTE AND RPO) XOR Y
}
ESD.30g { @ Width of the RPO on drain side for NMOS HV Tolerant I/O >= ^ESD_30g um
  TOL_ENSD = TOL_END AND RPO
  INT TOL_ENSD < ESD_30g ABUT < 90 SINGULAR REGION
}
ESD.31g { @ Width of the RPO on drain side for PMOS HV Tolerant I/O >= ^ESD_31g um
  TOL_EPSD = (EPSD INTERACT TOL_EGTE) AND RPO
  INT TOL_EPSD < ESD_31g ABUT < 90 SINGULAR REGION
}
ESD.32g { @ Space of poly to CO on source side for HV Tolerant I/O >= ^ESD_32g um
  EXT ECO TOL_EGTE < ESD_32g ABUT < 90 SINGULAR REGION
}
ESD.33g { @ Space of 1st poly gate(N2) to 2nd poly gate(N3) for NMOS HV Tolerant I/O == ^ESD_33g_MIN ~ ^ESD_33g um
  INT TOL_ENG < ESD_33g_MIN ABUT < 90 SINGULAR REGION
  TOL_ENG WITH WIDTH > ESD_33g
  (TOL_EGTE AND NP) NOT INTERACT TOL_ENG
}
ESD.34g { @ The NMOS HV Tolerant I/O should have ESDIMP
  TOL_ENMOS NOT INTERACT ESDIMP
}
// ESD.35g can not be checked by DRC


// Power Clamp
//============

PCL_GATE_W = ESD_GATE_W INSIDE EDGE PCL_ENMOS
PCL_HV_GATE_W = PCL_GATE_W INSIDE EDGE OD2
PCL_LV_GATE_W = PCL_GATE_W NOT INSIDE EDGE OD2
PCL_HV_GATE_W_EXP = EXPAND EDGE PCL_HV_GATE_W INSIDE BY GRID
PCL_LV_GATE_W_EXP = EXPAND EDGE PCL_LV_GATE_W INSIDE BY GRID
PCL_HV_GATE_W_EXPc = STAMP PCL_HV_GATE_W_EXP BY ENMOSc
PCL_LV_GATE_W_EXPc = STAMP PCL_LV_GATE_W_EXP BY ENMOSc

ESD.37g { @ Total finger width for 3.3V/2.5V/1.8V Power Clamp in same connection of drain > ^ESD_37g_HV um
  NET AREA RATIO PCL_HV_GATE_W_EXPc < ESD_37g_HV
    [(AREA(PCL_HV_GATE_W_EXPc)/2)/GRID]
    RDB ESD.37g.HV.rep PCL_HV_GATE_W_EXPc
}
ESD.37.1g { @ Total finger width for 1.1V/0.9V Power Clamp in same connection of drain > ^ESD_37g_LV um
  NET AREA RATIO PCL_LV_GATE_W_EXPc < ESD_37g_LV
    [(AREA(PCL_LV_GATE_W_EXPc)/2)/GRID]
    RDB ESD.37g.LV.rep PCL_LV_GATE_W_EXPc
}
ESD.38g { @ Channel length for 3.3V Power Clamp >= ^ESD_38g_33V um
  PCL_EGTE_33V = PCL_EGTE AND OD33
  INT PCL_EGTE_33V < ESD_38g_33V ABUT < 90 SINGULAR REGION
}
ESD.38.1g { @ Channel length for 2.5V Power Clamp >= ^ESD_38g_25V um
  PCL_EGTE_25V = PCL_EGTE AND OD25
  INT PCL_EGTE_25V < ESD_38g_25V ABUT < 90 SINGULAR REGION
}
ESD.38.2g { @ Channel length for 1.8V Power Clamp >= ^ESD_38g_18V um
  PCL_EGTE_18V = PCL_EGTE AND OD18
  INT PCL_EGTE_18V < ESD_38g_18V ABUT < 90 SINGULAR REGION
}  
ESD.38.3g { @ Channel length for 0.9V or 1.1V Power Clamp >= ^ESD_38g_LV um
  PCL_EGTE_LV  = PCL_EGTE NOT OD2
  INT PCL_EGTE_LV < ESD_38g_LV ABUT < 90 SINGULAR REGION
}
// ESD.43g can not be checked by DRC


NFD = ((NACT NOT INTERACT POLY) AND SDI) CUT RPO 
PFD = ((PACT NOT INTERACT POLY) AND SDI) CUT RPO 
NFDc = STAMP NFD BY NSDc
PFDc = STAMP PFD BY PSDc
NFD_Emitter = NET AREA RATIO NFDc PSTPi > 0
NFD_Collector = NFDc NOT NFD_Emitter 
PFD_Emitter = NET AREA RATIO PFDc NSTPi > 0
PFD_Collector = PFDc NOT PFD_Emitter

NFD_STI = EXT NFD_Collector NFD_Emitter == ESD_50g OPPOSITE REGION
PFD_STI = EXT PFD_Collector PFD_Emitter == ESD_50g OPPOSITE REGION

ESD.47g {@ The layer of OD2 is required for 5V protection (NFD and PFD)
    NFD NOT OD2
    PFD NOT OD2	
}
ESD.48g {@ Total width for NFD in same connection of collector >= 360 
    A =  NFD_Collector COIN OUTSIDE EDGE NFD_STI
    A1 = EXPAND EDGE A INSIDE BY GRID 
    Ac = STAMP A1 BY NFD_Collector
    NET AREA RATIO Ac < ESD_48g
    [(AREA(Ac)/2)/GRID]
}
ESD.49g {@ Total width for PFD in same connection of collector >= 360 
    A =  PFD_Collector COIN OUTSIDE EDGE PFD_STI
    A1 = EXPAND EDGE A INSIDE BY GRID 
    Ac = STAMP A1 BY PFD_Collector
    NET AREA RATIO Ac < ESD_49g
    [(AREA(Ac)/2)/GRID]
}
ESD.50g {@ STI spacing of the NFD and PFD = 0.35
   NFD_Collector NOT INTERACT NFD_STI == 2
   PFD_Collector NOT INTERACT PFD_STI == 2
}
ESD.51g	{@ Unit collector width of NFD and PFD = 15-60
   A =  NFD_Collector COIN OUTSIDE EDGE NFD_STI  
   LENGTH A < ESD_51g_MIN
   LENGTH A > ESD_51g_MAX
   B =  PFD_Collector COIN OUTSIDE EDGE PFD_STI  
   LENGTH B < ESD_51g_MIN
   LENGTH B > ESD_51g_MAX
}
ESD.52g	{@ Unit emitter width of NFD and PFD should be the same as unit collector width
   NOT RECTANGLE ( (NFD_STI OR NFD_Emitter) OR NFD_Collector)   
   NOT RECTANGLE ( (PFD_STI OR PFD_Emitter) OR PFD_Collector)  
}
ESD.53g {@ Unit emitter length of NFD and PFD >= 0.86
   INT NFD_Emitter < ESD_53g ABUT<90 SINGULAR REGION 
   INT PFD_Emitter < ESD_53g ABUT<90 SINGULAR REGION 
}
ESD.54g	{@ Width of the RPO on the collector side for NFD and PFD >= 1.95
   A =  NFD_Collector COIN OUTSIDE EDGE NFD_STI
   A1 = EXPAND EDGE A INSIDE BY ESD_54g
   A1 NOT RPO
   B =  PFD_Collector COIN OUTSIDE EDGE PFD_STI
   B1 = EXPAND EDGE B INSIDE BY ESD_54g
   B1 NOT RPO
}
ESD.55g	{@ Width of the RPO on the emitter side for NFD and PFD	= 0.1
   A =  NFD_Emitter COIN OUTSIDE EDGE NFD_STI
   A1 = EXPAND EDGE A INSIDE BY ESD_55g
   A1 XOR (RPO AND NFD_Emitter)
   B =  PFD_Emitter COIN OUTSIDE EDGE PFD_STI
   B1 = EXPAND EDGE B INSIDE BY ESD_55g
   B1 XOR (RPO AND PFD_Emitter)
}
ESD.56g {@ Space of RPO to CO on the collector and emitter side >= 0.22
   A = CO AND (NFD OR PFD)
   EXT A RPO < ESD_56g ABUT<90 SINGULAR REGION    
}
ESD.57g	{@ Total width of the RPO on the HVMOS protection. >= 2.4
   A = RPO INTERACT (NFD OR PFD)
   INT A < ESD_57g ABUT<90 SINGULAR REGION
}

#ENDIF



// SR_ESD CHECK
//--------------

SR_ESD.W.1 { @ width >= 0.18 
  INT SRESD < SRESD_W_1 ABUT < 90 SINGULAR REGION
} 

SRESD_GATE = GATE NOT OUTSIDE SRESD
SRESD_GATE_W = POi COIN INSIDE EDGE SRESD_GATE
SRESD_GATE_L = SRESD_GATE NOT TOUCH EDGE SRESD_GATE_W

SR_ESD.W.2 { @ Channel length in SR_ESD regions >= 0.1 
  LENGTH SRESD_GATE_L < SRESD_W_2
}
SR_ESD.W.3 { @ Channel width of core device in SR_ESD regions = 15 ~ 60 
  (LENGTH SRESD_GATE_W < SRESD_W_3a) NOT INSIDE EDGE OD2i
  (LENGTH SRESD_GATE_W > SRESD_W_3b) NOT INSIDE EDGE OD2i
}
SR_ESD.S.1 { @ Space >= 0.18 
  EXT SRESD < SRESD_S_1 ABUT < 90 SINGULAR REGION
}
SR_ESD.EX.1 { @ Extension on ACTIVE >= 0.02 
  ENC DACT SRESD < SRESD_EX_1 ABUT < 90 SINGULAR REGION
}
SR_ESD.L.1 { @ Maximum ACTIVE length of core device in SR_ESD regions <= 60 
  DACT_G = ((DACT NOT OD2i) ENCLOSE GATE) INSIDE SRESD // cut SR_ESD is checked by OD.L.4
  // rectangle active
  DACT_G_R = RECTANGLE DACT_G
  ENCLOSE RECTANGLE DACT_G_R GRID SRESD_L_1+GRID ORTHOGONAL ONLY
  // not rectangle active
  DACT_G_NR = AREA (DACT_G NOT DACT_G_R) > SRESD_L_1 * SRESD_W_3a // suspected active
  DACT_G_NR_EX = EXTENTS DACT_G_NR
  DACT_G_NR_EX_ERR = ENCLOSE RECTANGLE DACT_G_NR_EX GRID SRESD_L_1+GRID ORTHOGONAL ONLY
  DACT_G_NR_EX_ERR AND DACT_G_NR
}
SR_ESD.R.1 {@ SR_ESD can not cover core PMOS
  SRESD INTERACT (GATE_PP NOT OD2)
}


//SRAM CHECKS
//===========
SRAM.W.1 { @ SRM width.The SRM edge should be aligned to the boundary of the cell array, which may include storage, strapping, and dummy edge cells. >= 0.19 
  INT SRM < SRAM_W_1 ABUT < 90 SINGULAR REGION
}
SRAM.S.1 { @ SRM space >= 0.19 
  EXT SRM < SRAM_S_1 ABUT < 90 SINGULAR REGION
}
SRAM.S.2 { @ SRM space to {GATE not interact with SRM} >= 0.14 
  A = POi AND ODi
  B = A NOT INTERACT SRM    
  EXT B SRM < SRAM_S_2 ABUT < 90 SINGULAR REGION
}
SRAM.EN.1__SRAM.EN.2 { @ SRM enclosusre of GATE in S/D direction >= ^SRAM_EN_1 um, in PO end-cap direction >= ^SRAM_EN_2 um 
  A = GATEi INTERACT SRM
  X = A INSIDE EDGE ODi
  B = (EXPAND EDGE X OUTSIDE BY (SRAM_EN_1 - SRAM_EN_2)) OR A
  C = SIZE B BY SRAM_EN_2
  C NOT SRM
}

//SRAM.EN.1 is checked by SRAM.EN.1__SRAM.EN.2

//SRAM.EN.2 is checked by SRAM.EN.1__SRAM.EN.2

SRAM.EX.1 { @ SRM extension on NW (interact with OD). Extension = 0 is allowed. >= 0.19 
  (ENC NWi SRM < SRAM_EX_1 ABUT < 90 > 0 SINGULAR REGION) INTERACT ODi
}
SRAM.O.1 { @ SRM overlap of NW (interact with OD) (for VTC_N, VTC_P). Extension = 0 is allowed. >= 0.19 
  (INT (SRM AND NWi) < SRAM_O_1 ABUT < 90 OPPOSITE REGION) INTERACT ODi
}
SRAM.A.1 {@ SRM;0 (50;0) Area 11  
   AREA SRM < SRAM_A_1
}
SRAM.R.12 { @ SRAMDMY (186;5)/(186;4) overlap of SRAMDMY (186;0) is not allowed.   
  SRAMDMY_PERI AND SRAMDMY
}
SRAM.R.13 { @ SRM must fully cover GATE.   
  GATEi CUT SRM
}

//SRAM.R.14 is checked by related rules

SRAM.R.15 { @ CO;11 (30;11) is a must for CO mask tape-out in SRAM. 1. If CO;11 exists, it must cover CO;0  2. CO;11 must be 0.06um x 0.06um 3. CO;11 must be exactly the same as CO;0. 4. CO;11 must be fully covered by SRM(50;0) and SRAMDMY(186;0) 5. Square CO;0 in SRAM must cover CO;11
// CO;11 (30;11) is a must for CO mask tape-out in SRAM
   (((SRAMDMY AND SRM) NOT RAM1TDMY) INTERACT COi) NOT INTERACT COPUSH
// 1.If CO;11 exists, it must cover CO;0 
  COPUSH NOT COi 	
// 2.CO;11 must be 0.06um x 0.06um  
  NOT RECTANGLE COPUSH == CO_W_1 BY == CO_W_1 ORTHOGONAL ONLY
// 3.CO;11 must be exactly the same as CO;0.
  CO_COPUSH = COi INTERACT COPUSH
  CO_COPUSH XOR COPUSH
// 4.CO;11 must be fully covered by SRM(50;0) and SRAMDMY(186;0)
  COPUSH NOT SRM
  COPUSH NOT SRAMDMY
// 5. Square CO must be covered by CO;11
  CO_SRAM = COi INSIDE SRM
  SQUARE_CO = RECTANGLE CO_SRAM == CO_W_1 BY == CO_W_1 ORTHOGONAL ONLY
  SQUARE_CO NOT COPUSH
}

SRAM.R.17 { @ SRAMDMY (186;0) and SRM (50;0) must fully cover OD, CO, VIA1.   
   ODi CUT SRAMDMY
   COi CUT SRAMDMY 
   VIA1i CUT SRAMDMY
   ODi CUT SRM
   COi CUT SRM
   VIA1i CUT SRM
}
SRAM.R.19 { @ SRAM dummy layers can exist only in SRM (50;0) region. And in logic region, no SRAM dummy layer can be used. SRAM dummy layers are listed below : DMMYOD1~16, DUMMYPO1~7, SRM;1~2, NPreDOSRM, SRAMDMY;0~1, CO;11, CO2, DPSRM, PRSRM, SRM_LOP;12~14, LV_LOP, HCDP_LOP, 8TTP_LOP and 10TTP_LOP.   
  A = ((((((((((((((DUMMYOD1 OR DUMMYOD2) OR DUMMYOD3) OR DUMMYOD4) OR DUMMYOD5) OR DUMMYOD6) OR DUMMYOD7) OR DUMMYOD8) OR DUMMYOD9) OR DUMMYOD10) OR DUMMYOD11) OR DUMMYOD12) OR DUMMYOD13) OR DUMMYOD14) OR DUMMYOD15) OR DUMMYOD16
  A NOT SRM
  B = (((((DUMMYPO1 OR DUMMYPO2) OR DUMMYPO3) OR DUMMYPO4) OR DUMMYPO5) OR DUMMYPO6) OR DUMMYPO7
  B NOT SRM
  C = (((((((((((((SRMN OR SRMP) OR NPreDOSRM) OR SRAMDMY_PAS) OR COPUSH) OR CO2) OR DPSRM) OR PRSRM) OR SRMLOP12) OR SRMLOP13) OR SRMLOP14) OR LVLOP) OR HCDPLOP) OR TPLOP_8T) OR TPLOP_10T
  C NOT SRM
} 
SRAM.R.20 { @ Inside of SRAM array, SRM(50;0), SRAMDMY(186;0) can not have any holes in them.   
  HOLES SRM INNER
  HOLES SRAMDMY INNER
}
SRAM.R.21 { @ SRM(50;0) and SRAMDMY(186;0) must be drawn identically (Except RAM1TDMY (160;0) region)   
  SRM XOR (SRAMDMY NOT RAM1TDMY)
}


  
SRAM_R22_24L = ((((((SRMLOP12 OR SRMLOP13) OR SRMLOP14) OR LVLOP) OR HCDPLOP) OR TPLOP_8T) OR TPLOP_10T) OR DPSRM

SRAM.R.22.DPSRM { @ (80;x) must overlap (80;11). x=0, 12~18.   
  DPSRM OUTSIDE PRSRM

}
SRAM.R.22.SRMLOP12 { @ (80;x) must overlap (80;11). x=0, 12~18.   
  SRMLOP12 OUTSIDE PRSRM

}
SRAM.R.22.SRMLOP13 { @ (80;x) must overlap (80;11). x=0, 12~18.   
  SRMLOP13 OUTSIDE PRSRM

}
SRAM.R.22.SRMLOP14 { @ (80;x) must overlap (80;11). x=0, 12~18.   
  SRMLOP14 OUTSIDE PRSRM

}
SRAM.R.22.LVLOP { @ (80;x) must overlap (80;11). x=0, 12~18.   
  LVLOP OUTSIDE PRSRM

}
SRAM.R.22.HCDPLOP { @ (80;x) must overlap (80;11). x=0, 12~18.   
  HCDPLOP OUTSIDE PRSRM

}
SRAM.R.22.TPLOP_8T { @ (80;x) must overlap (80;11). x=0, 12~18.   
  TPLOP_8T OUTSIDE PRSRM

}
SRAM.R.22.TPLOP_10T { @ (80;x) must overlap (80;11). x=0, 12~18.   
  TPLOP_10T OUTSIDE PRSRM

}

//SRAM.R.22 is checked by SRAM.R.22.DPSRM, SRAM.R.22.SRMLOP12, SRAM.R.22.SRMLOP13, SRAM.R.22.SRMLOP14, SRAM.R.22.LVLOP, SRAM.R.22.HCDPLOP, SRAM.R.22.TPLOP_8T, SRAM.R.22.TPLOP_10T 

SRAM.R.23 { @ if (80;11) interacts (80;x). It must be fully covered by (80;x). x=0, 12~18.   
  PRSRM_Check = PRSRM INTERACT SRAM_R22_24L
  PRSRM_Check NOT SRAM_R22_24L  
}

SRAM.R.24.DPSRM { @ (80;x) interact (50;0) must be identical to (50;0), except (80;15) and (80;17), x=0, 12~18.   
  DPSRM_C = DPSRM INTERACT SRM
  SRM_C = SRM INTERACT DPSRM
  DPSRM_C XOR SRM_C
}

SRAM.R.24.SRMLOP12 { @ (80;x) interact (50;0) must be identical to (50;0), except (80;15) and (80;17), x=0, 12~18.   
  SRMLOP12_C = SRMLOP12 INTERACT SRM
  SRM_C = SRM INTERACT SRMLOP12
  SRMLOP12_C XOR SRM_C
}

SRAM.R.24.SRMLOP13 { @ (80;x) interact (50;0) must be identical to (50;0), except (80;15) and (80;17), x=0, 12~18.   
  SRMLOP13_C = SRMLOP13 INTERACT SRM
  SRM_C = SRM INTERACT SRMLOP13
  SRMLOP13_C XOR SRM_C
}

SRAM.R.24.SRMLOP14 { @ (80;x) interact (50;0) must be identical to (50;0), except (80;15) and (80;17), x=0, 12~18.   
  SRMLOP14_C = SRMLOP14 INTERACT SRM
  SRM_C = SRM INTERACT SRMLOP14
  SRMLOP14_C XOR SRM_C
}


SRAM.R.24.HCDPLOP { @ (80;x) interact (50;0) must be identical to (50;0), except (80;15) and (80;17), x=0, 12~18.   
  HCDPLOP_C = HCDPLOP INTERACT SRM
  SRM_C = SRM INTERACT HCDPLOP
  HCDPLOP_C XOR SRM_C
}


SRAM.R.24.TPLOP_10T { @ (80;x) interact (50;0) must be identical to (50;0), except (80;15) and (80;17), x=0, 12~18.   
  TPLOP_10T_C = TPLOP_10T INTERACT SRM
  SRM_C = SRM INTERACT TPLOP_10T
  TPLOP_10T_C XOR SRM_C
}


//SRAM.R.24 is checked by SRAM.R.24.DPSRM, SRAM.R.22.SRMLOP12, SRAM.R.22.SRMLOP13, SRAM.R.22.SRMLOP14, SRAM.R.22.HCDPLOP, SRAM.R.22.TPLOP_10T

SRAM.R.25.DPSRM { @ (80;x) can't interact each other, x=0, 12~18. Only (80;15) interacting with(80;17) is allowed.   

  DPSRM INTERACT SRMLOP12

  DPSRM INTERACT SRMLOP13

  DPSRM INTERACT SRMLOP14

  DPSRM INTERACT LVLOP

  DPSRM INTERACT HCDPLOP

  DPSRM INTERACT TPLOP_8T

  DPSRM INTERACT TPLOP_10T

}
SRAM.R.25.SRMLOP12 { @ (80;x) can't interact each other, x=0, 12~18. Only (80;15) interacting with(80;17) is allowed.   

  SRMLOP12 INTERACT SRMLOP13

  SRMLOP12 INTERACT SRMLOP14

  SRMLOP12 INTERACT LVLOP

  SRMLOP12 INTERACT HCDPLOP

  SRMLOP12 INTERACT TPLOP_8T

  SRMLOP12 INTERACT TPLOP_10T

}
SRAM.R.25.SRMLOP13 { @ (80;x) can't interact each other, x=0, 12~18. Only (80;15) interacting with(80;17) is allowed.   

  SRMLOP13 INTERACT SRMLOP14

  SRMLOP13 INTERACT LVLOP

  SRMLOP13 INTERACT HCDPLOP

  SRMLOP13 INTERACT TPLOP_8T

  SRMLOP13 INTERACT TPLOP_10T

}
SRAM.R.25.SRMLOP14 { @ (80;x) can't interact each other, x=0, 12~18. Only (80;15) interacting with(80;17) is allowed.   

  SRMLOP14 INTERACT LVLOP

  SRMLOP14 INTERACT HCDPLOP

  SRMLOP14 INTERACT TPLOP_8T

  SRMLOP14 INTERACT TPLOP_10T

}
SRAM.R.25.LVLOP { @ (80;x) can't interact each other, x=0, 12~18. Only (80;15) interacting with(80;17) is allowed.   

  LVLOP INTERACT HCDPLOP


  LVLOP INTERACT TPLOP_10T

}
SRAM.R.25.HCDPLOP { @ (80;x) can't interact each other, x=0, 12~18. Only (80;15) interacting with(80;17) is allowed.   

  HCDPLOP INTERACT TPLOP_8T

  HCDPLOP INTERACT TPLOP_10T

}
SRAM.R.25.TPLOP_8T { @ (80;x) can't interact each other, x=0, 12~18. Only (80;15) interacting with(80;17) is allowed.   

  TPLOP_8T INTERACT TPLOP_10T

}

//SRAM.R.25 is checked by SRAM.R.25.DPSRM, SRAM.R.25.SRMLOP12, SRAM.R.25.SRMLOP13, SRAM.R.25.SRMLOP14, SRAM.R.25.LVLOP, SRAM.R.25.HCDPLOP, SRAM.R.25.TPLOP_8T

SRAM.R.26 {@ SRM;0 (50;0) must cover ((NP AND gate) OR (PP AND gate))
   SRM NOT INTERACT ((NPi OR PPi) AND GATEi)
}

#IFDEF GS
SRAM.R.27 {@ For GS, SRM;0(50;0) must include both SRM;1(50;1) and SRM;2(50;2). 
  SRM NOT INTERACT SRMN
  SRM NOT INTERACT SRMP
}
#ELSE
SRAM.R.28 {@ For LP/LPG, {SRM;0(50;0) AND SRM_HD(80;14)} must include both SRM;1(50;1) and SRM;2(50;2).   
  (SRM AND SRMLOP14) NOT INTERACT SRMN
  (SRM AND SRMLOP14) NOT INTERACT SRMP
}
SRAM.R.29 {@ For LP/LPG, {SRM;0(50;0) AND DPSRM(80;0)} must include both SRM;1(50;1) and SRM;2(50;2).   
  (SRM AND DPSRM) NOT INTERACT SRMN
  (SRM AND DPSRM) NOT INTERACT SRMP
}
#ENDIF

SRAM.R.31 { @ When M1 or M2 width > ^SRAM_R_31_W um, more than one VIA1 is required.
            @ 2 vias spacing should be <= ^SRAM_R_31_S1 um or 4 vias spacing should be <= ^SRAM_R_31_S2 um
   VIA1_EXDi = VIA1i NOT VIA_EXD
   M1Wide_R31_VIA1 = (M1i NOT OUTSIDE SRAMDMY) WITH WIDTH > SRAM_R_31_W      // 0.3
   M2Wide_R31_VIA1 = (M2i NOT OUTSIDE SRAMDMY) WITH WIDTH > SRAM_R_31_W      // 0.3
   M2OvpM1_W = ((M1Wide_R31_VIA1 AND M2i) OR (M2Wide_R31_VIA1 AND M1i)) NOT OUTSIDE SRAMDMY
   Checked_VIA1_W = VIA1_EXDi NOT OUTSIDE M2OvpM1_W
   M1_effect = M1i INTERACT M2OvpM1_W
   M2_effect = M2i INTERACT M2OvpM1_W
   effect_M2OvpM1_ = M1_effect AND M2_effect
   effect_M2OvpM1 = effect_M2OvpM1_ INTERACT M2OvpM1_W
   effect_VIA = VIA1_EXDi INTERACT effect_M2OvpM1

   V1Merged_A = SIZE effect_VIA BY SRAM_R_31_S1/2 INSIDE OF effect_M2OvpM1 STEP M1_S_1*0.7
   V1Merged_B = SIZE V1Merged_A BY (SRAM_R_31_S2 - SRAM_R_31_S1)/2 INSIDE OF effect_M2OvpM1 STEP M1_S_1*0.7
   V1Merged_A2R = V1Merged_A INTERACT effect_VIA < 2
   V1Merged_A2 = V1Merged_A OUTSIDE V1Merged_A2R
   V1Merged_B4R = V1Merged_B INTERACT effect_VIA < 4
   V1Merged_B4 = V1Merged_B OUTSIDE V1Merged_B4R

   GMergeW = V1Merged_A2 OR V1Merged_B4
   GVIA_W = Checked_VIA1_W INTERACT GMergeW
   GOOD_AREA_W = M2OvpM1_W INTERACT GVIA_W
   (Checked_VIA1_W OUTSIDE GOOD_AREA_W) NOT OUTSIDE SRAMDMY
}

SRAM.R.32.M1 { @ At least two VIAx must be used for a connection that is <= ^SRAM_R_32_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^SRAM_R_32_W um (L) and width > ^SRAM_R_32_W um (W). (It is allowed to use one VIAx for a connection that is > ^SRAM_R_32_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^SRAM_R_32_W um (L) and width > ^SRAM_R_32_W um (W).)   
  M1Wide_R32_VIA1 = (M1i NOT OUTSIDE SRAMDMY) WITH WIDTH > SRAM_R_32_W      // 0.3
  Branch1 = ((SIZE M1Wide_R32_VIA1 BY SRAM_R_32_D + GRID) NOT M1Wide_R32_VIA1) AND M1i
  Branch1HasVia = (Branch1 INTERACT M1Wide_R32_VIA1) INTERACT VIA1i
  Branch1Edge = M1Wide_R32_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY SRAM_R_32_D INSIDE OF Branch1HasVia STEP M1_S_1*0.5
  GoodBranch = (Branch AND M2i) INTERACT VIA1i > 1
  BranchSingleVia = (VIA1i NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M1i) INTERACT BranchSingleVia) INTERACT VIA1i == 1
  ((BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD) NOT OUTSIDE SRAMDMY
}

SRAM.R.32.M2 { @ At least two VIAx must be used for a connection that is <= ^SRAM_R_32_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^SRAM_R_32_W um (L) and width > ^SRAM_R_32_W um (W). (It is allowed to use one VIAx for a connection that is > ^SRAM_R_32_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^SRAM_R_32_W um (L) and width > ^SRAM_R_32_W um (W)).   
  M2Wide_R32_VIA1 = (M2i NOT OUTSIDE SRAMDMY) WITH WIDTH > SRAM_R_32_W      // 0.3
  Branch1 = ((SIZE M2Wide_R32_VIA1 BY SRAM_R_32_D + GRID) NOT M2Wide_R32_VIA1) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Wide_R32_VIA1) INTERACT VIA1i
  Branch1Edge = M2Wide_R32_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY SRAM_R_32_D INSIDE OF Branch1HasVia STEP M2_S_1*0.5
  GoodBranch = (Branch AND M1i) INTERACT VIA1i > 1
  BranchSingleVia = (VIA1i NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M1i INTERACT BranchSingleVia) AND M2i) INTERACT BranchSingleVia) INTERACT VIA1i == 1
  ((BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD) NOT OUTSIDE SRAMDMY
}

//SRAM.R.32 is checked by SRAM.R.32.M1, SRAM.R.32.M2

SRAM.R.33.DPSRM {@ (80;0) must fully cover (30;11), (50;0), (50;21),(82;Y); (83;Z), (186;0), (186;1), and (100;0). Y=1,2,9,10,11,12,16. Z=1,2,3,4,5,7
  DPSRM NOT ENCLOSE COPUSH       // sram 0.589 cell must have 30;11
  DPSRM NOT ENCLOSE SRM          // sram 0.589 cell must have 50;0
  DPSRM NOT ENCLOSE NPreDOSRM    // sram 0.589 cell must have 50;21
  DPSRM NOT ENCLOSE DUMMYOD1     // sram 0.589 cell must have 82;1
  DPSRM NOT ENCLOSE DUMMYOD2     // sram 0.589 cell must have 82;2
  DPSRM NOT ENCLOSE DUMMYOD9     // sram 0.589 cell must have 82;9
  DPSRM NOT ENCLOSE DUMMYOD10    // sram 0.589 cell must have 82;10
  DPSRM NOT ENCLOSE DUMMYOD11    // sram 0.589 cell must have 82;11
  DPSRM NOT ENCLOSE DUMMYOD12    // sram 0.589 cell must have 82;12
  DPSRM NOT ENCLOSE DUMMYOD16    // sram 0.589 cell must have 82;16
  DPSRM NOT ENCLOSE DUMMYPO1     // sram 0.589 cell must have 83;1
  DPSRM NOT ENCLOSE DUMMYPO2     // sram 0.589 cell must have 83;2
  DPSRM NOT ENCLOSE DUMMYPO3     // sram 0.589 cell must have 83;3
  DPSRM NOT ENCLOSE DUMMYPO4     // sram 0.589 cell must have 83;4
  DPSRM NOT ENCLOSE DUMMYPO5     // sram 0.589 cell must have 83;5
  DPSRM NOT ENCLOSE DUMMYPO7     // sram 0.589 cell must have 83;7
  DPSRM NOT ENCLOSE SRAMDMY      // sram 0.589 cell must have 186;0
  DPSRM NOT ENCLOSE SRAMDMY_PAS  // sram 0.589 cell must have 186;1
  DPSRM NOT ENCLOSE CO2          // sram 0.589 cell must have 100;0
}
SRAM.R.33.SRMLOP14 {@ (80;14) must fully cover (30;11), (50;0), (50;21),(82;Y); (83;Z), (186;0), (186;1), and (100;0). Y=1,2,9,10,11,12,16. Z=1,2,3,4,5,7
  SRMLOP14 NOT ENCLOSE COPUSH       // sram 0.299 cell must have 30;11
  SRMLOP14 NOT ENCLOSE SRM          // sram 0.299 cell must have 50;0
  SRMLOP14 NOT ENCLOSE NPreDOSRM    // sram 0.299 cell must have 50;21
  SRMLOP14 NOT ENCLOSE DUMMYOD1     // sram 0.299 cell must have 82;1
  SRMLOP14 NOT ENCLOSE DUMMYOD2     // sram 0.299 cell must have 82;2
  SRMLOP14 NOT ENCLOSE DUMMYOD9     // sram 0.299 cell must have 82;9
  SRMLOP14 NOT ENCLOSE DUMMYOD10    // sram 0.299 cell must have 82;10
  SRMLOP14 NOT ENCLOSE DUMMYOD11    // sram 0.299 cell must have 82;11
  SRMLOP14 NOT ENCLOSE DUMMYOD12    // sram 0.299 cell must have 82;12
  SRMLOP14 NOT ENCLOSE DUMMYOD16    // sram 0.299 cell must have 82;16
  SRMLOP14 NOT ENCLOSE DUMMYPO1     // sram 0.299 cell must have 83;1
  SRMLOP14 NOT ENCLOSE DUMMYPO2     // sram 0.299 cell must have 83;2
  SRMLOP14 NOT ENCLOSE DUMMYPO3     // sram 0.299 cell must have 83;3
  SRMLOP14 NOT ENCLOSE DUMMYPO4     // sram 0.299 cell must have 83;4
  SRMLOP14 NOT ENCLOSE DUMMYPO5     // sram 0.299 cell must have 83;5
  SRMLOP14 NOT ENCLOSE DUMMYPO7     // sram 0.299 cell must have 83;7
  SRMLOP14 NOT ENCLOSE SRAMDMY      // sram 0.299 cell must have 186;0
  SRMLOP14 NOT ENCLOSE SRAMDMY_PAS  // sram 0.299 cell must have 186;1
  SRMLOP14 NOT ENCLOSE CO2          // sram 0.299 cell must have 100;0
}
SRAM.R.33.HCDPLOP { @ (80;16) must fully cover (30;11), (50;0), (50;21),(82;Y); (83;Z), (186;0), (186;1), and (100;0). Y=1,2,9,10,11,12,16. Z=1,2,3,4,5,7
  HCDPLOP NOT ENCLOSE COPUSH       // sram DP_0.741 cell must have 30;11
  HCDPLOP NOT ENCLOSE SRM          // sram DP_0.741 cell must have 50;0
  HCDPLOP NOT ENCLOSE NPreDOSRM    // sram DP_0.741 cell must have 50;21
  HCDPLOP NOT ENCLOSE DUMMYOD1     // sram DP_0.741 cell must have 82;1
  HCDPLOP NOT ENCLOSE DUMMYOD2     // sram DP_0.741 cell must have 82;2
  HCDPLOP NOT ENCLOSE DUMMYOD9     // sram DP_0.741 cell must have 82;9
  HCDPLOP NOT ENCLOSE DUMMYOD10    // sram DP_0.741 cell must have 82;10
  HCDPLOP NOT ENCLOSE DUMMYOD11    // sram DP_0.741 cell must have 82;11
  HCDPLOP NOT ENCLOSE DUMMYOD12    // sram DP_0.741 cell must have 82;12
  HCDPLOP NOT ENCLOSE DUMMYOD16    // sram DP_0.741 cell must have 82;16
  HCDPLOP NOT ENCLOSE DUMMYPO1     // sram DP_0.741 cell must have 83;1
  HCDPLOP NOT ENCLOSE DUMMYPO2     // sram DP_0.741 cell must have 83;2
  HCDPLOP NOT ENCLOSE DUMMYPO3     // sram DP_0.741 cell must have 83;3
  HCDPLOP NOT ENCLOSE DUMMYPO4     // sram DP_0.741 cell must have 83;4
  HCDPLOP NOT ENCLOSE DUMMYPO5     // sram DP_0.741 cell must have 83;5
  HCDPLOP NOT ENCLOSE DUMMYPO7     // sram DP_0.741 cell must have 83;7
  HCDPLOP NOT ENCLOSE SRAMDMY      // sram DP_0.741 cell must have 186;0
  HCDPLOP NOT ENCLOSE SRAMDMY_PAS  // sram DP_0.741 cell must have 186;1
  HCDPLOP NOT ENCLOSE CO2          // sram DP_0.741 cell must have 100;0
}

//SRAM.R.33 is checked by SRAM.R.33.DPSRM, SRAM.R.33.SRMLOP14, SRAM.R.33.HCDPLOP 

SRAM.R.34.DPSRM {@ (80;0) must not have (50;5), (50;7), (82;15), (83;6), (186;4), (186;5)
  DPSRM AND SRMRP                // sram 0.589 cell must not have 50;5
  DPSRM AND SRM_HS               // sram 0.589 cell must not have 50;7
  DPSRM AND DUMMYOD15            // sram 0.589 cell must not have 82;15
  DPSRM AND DUMMYPO6             // sram 0.589 cell must not have 83;6
  DPSRM AND SRAMDMY_PERI_LP         // sram 0.589 cell must not have 186;4
  DPSRM AND SRAMDMY_PERI_G       // sram 0.589 cell must not have 186;5
}
SRAM.R.34.SRMLOP13 {@ (80;13) must not have (50;5), (50;7), (82;15), (83;6), (186;4), (186;5)

  SRMLOP13 AND SRMRP                // sram 0.374 cell must not have 50;5
  SRMLOP13 AND SRM_HS               // sram 0.374 cell must not have 50;7
  SRMLOP13 AND DUMMYOD15            // sram 0.374 cell must not have 82;15
  SRMLOP13 AND DUMMYPO6             // sram 0.374 cell must not have 83;6
  SRMLOP13 AND SRAMDMY_PERI_LP         // sram 0.374 cell must not have 186;4
  SRMLOP13 AND SRAMDMY_PERI_G       // sram 0.374 cell must not have 186;5
}
SRAM.R.34.SRMLOP14 {@ (80;14) must not have (50;5), (50;7), (82;15), (83;6), (186;4), (186;5)
  SRMLOP14 AND SRMRP                // sram 0.299 cell must not have 50;5
  SRMLOP14 AND SRM_HS               // sram 0.299 cell must not have 50;7
  SRMLOP14 AND DUMMYOD15            // sram 0.299 cell must not have 82;15
  SRMLOP14 AND DUMMYPO6             // sram 0.299 cell must not have 83;6
  SRMLOP14 AND SRAMDMY_PERI_LP         // sram 0.299 cell must not have 186;4
  SRMLOP14 AND SRAMDMY_PERI_G       // sram 0.299 cell must not have 186;5
}
SRAM.R.34.HCDPLOP {@ (80;16) must not have (50;5), (50;7), (82;15), (83;6), (186;4), (186;5)
  HCDPLOP AND SRMRP                // sram DP_0.741 cell must not have 50;5
  HCDPLOP AND SRM_HS               // sram DP_0.741 cell must not have 50;7
  HCDPLOP AND DUMMYOD15            // sram DP_0.741 cell must not have 82;15
  HCDPLOP AND DUMMYPO6             // sram DP_0.741 cell must not have 83;6
  HCDPLOP AND SRAMDMY_PERI_LP      // sram DP_0.741 cell must not have 186;4
  HCDPLOP AND SRAMDMY_PERI_G       // sram DP_0.741 cell must not have 186;5
}

//SRAM.R.34 is checked by SRAM.R.34.DPSRM, SRAM.R.34.SRMLOP13, SRAM.R.34.SRMLOP14, SRAM.R.34.HCDPLOP 

SRAM.R.35.DPSRM {@ (80;0) must fully cover (82;Y).  Y=3,4,5,6,7,8
  DPSRM NOT ENCLOSE DUMMYOD3     // sram 0.589 cell must have 82;3
  DPSRM NOT ENCLOSE DUMMYOD4     // sram 0.589 cell must have 82;4
  DPSRM NOT ENCLOSE DUMMYOD5     // sram 0.589 cell must have 82;5
  DPSRM NOT ENCLOSE DUMMYOD6     // sram 0.589 cell must have 82;6
  DPSRM NOT ENCLOSE DUMMYOD7     // sram 0.589 cell must have 82;7
  DPSRM NOT ENCLOSE DUMMYOD8     // sram 0.589 cell must have 82;8
}
SRAM.R.35.SRMLOP13 {@ (80;13) must fully cover (82;Y).  Y=3,4,5,6,7,8
  SRMLOP13 NOT ENCLOSE DUMMYOD3     // sram 0.374 cell must have 82;3
  SRMLOP13 NOT ENCLOSE DUMMYOD4     // sram 0.374 cell must have 82;4
  SRMLOP13 NOT ENCLOSE DUMMYOD5     // sram 0.374 cell must have 82;5
  SRMLOP13 NOT ENCLOSE DUMMYOD6     // sram 0.374 cell must have 82;6
  SRMLOP13 NOT ENCLOSE DUMMYOD7     // sram 0.374 cell must have 82;7
  SRMLOP13 NOT ENCLOSE DUMMYOD8     // sram 0.374 cell must have 82;8
}
SRAM.R.35.SRMLOP14 {@ (80;14) must fully cover (82;Y).  Y=3,4,5,6,7,8
  SRMLOP14 NOT ENCLOSE DUMMYOD3     // sram 0.299 cell must have 82;3
  SRMLOP14 NOT ENCLOSE DUMMYOD4     // sram 0.299 cell must have 82;4
  SRMLOP14 NOT ENCLOSE DUMMYOD5     // sram 0.299 cell must have 82;5
  SRMLOP14 NOT ENCLOSE DUMMYOD6     // sram 0.299 cell must have 82;6
  SRMLOP14 NOT ENCLOSE DUMMYOD7     // sram 0.299 cell must have 82;7
  SRMLOP14 NOT ENCLOSE DUMMYOD8     // sram 0.299 cell must have 82;8
}

//SRAM.R.35 is checked by SRAM.R.35.DPSRM, SRAM.R.35.SRMLOP13, SRAM.R.35.SRMLOP14 

SRAM.R.36 {@ (80;16) must not have (82;Y). Y=3,4,5,6,7,8
  HCDPLOP AND DUMMYOD3     // sram DP_0.741 cell must not have 82;3
  HCDPLOP AND DUMMYOD4     // sram DP_0.741 cell must not have 82;4
  HCDPLOP AND DUMMYOD5     // sram DP_0.741 cell must not have 82;5
  HCDPLOP AND DUMMYOD6     // sram DP_0.741 cell must not have 82;6
  HCDPLOP AND DUMMYOD7     // sram DP_0.741 cell must not have 82;7
  HCDPLOP AND DUMMYOD8     // sram DP_0.741 cell must not have 82;8
}

SRAM.R.37 { @ (50;6) can not be used in (50;0) region
  ROM AND SRM
}

SRAM.R.38.DPSRM {@ (80;0) must fully cover (82;13) and (82;14)
  DPSRM NOT ENCLOSE DUMMYOD13    // sram 0.589 cell must have 82;13
  DPSRM NOT ENCLOSE DUMMYOD14    // sram 0.589 cell must have 82;14
}
SRAM.R.38.SRMLOP {@ (80;14) must fully cover (82;13) and (82;14)
  SRMLOP14 NOT ENCLOSE DUMMYOD13    // sram 0.299 cell must have 82;13
  SRMLOP14 NOT ENCLOSE DUMMYOD14    // sram 0.299 cell must have 82;14
}
SRAM.R.38.HCDPLOP {@ (80;16) must fully cover (82;13) and (82;14)
  HCDPLOP NOT ENCLOSE DUMMYOD13    // sram DP_0.741 cell must have 82;13
  HCDPLOP NOT ENCLOSE DUMMYOD14    // sram DP_0.741 cell must have 82;14
}

//SRAM.R.38 is checked by SRAM.R.38.DPSRM, SRAM.R.38.SRMLOP, SRAM.R.38.HCDPLOP

SRAM.R.39 {@ (80;13) must not have (82;13) and (82;14)
  SRMLOP13 AND DUMMYOD13    // sram 0.374 cell must have 82;13
  SRMLOP13 AND DUMMYOD14    // sram 0.374 cell must have 82;14
}

SRAM.R.40 {@ (80;13) must fully cover (30;11), (50;0), (50;21),(82;Y); (83;Z), (186;0), (186;1), and (100;0). Y=1,2,9,10,11,12,16. Z=3,4,5,7
  SRMLOP13 NOT ENCLOSE COPUSH       // sram 0.374 cell must have 30;11
  SRMLOP13 NOT ENCLOSE SRM          // sram 0.374 cell must have 50;0
  SRMLOP13 NOT ENCLOSE NPreDOSRM    // sram 0.374 cell must have 50;21
  SRMLOP13 NOT ENCLOSE DUMMYOD1     // sram 0.374 cell must have 82;1
  SRMLOP13 NOT ENCLOSE DUMMYOD2     // sram 0.374 cell must have 82;2
  SRMLOP13 NOT ENCLOSE DUMMYOD9     // sram 0.374 cell must have 82;9
  SRMLOP13 NOT ENCLOSE DUMMYOD10    // sram 0.374 cell must have 82;10
  SRMLOP13 NOT ENCLOSE DUMMYOD11    // sram 0.374 cell must have 82;11
  SRMLOP13 NOT ENCLOSE DUMMYOD12    // sram 0.374 cell must have 82;12
  SRMLOP13 NOT ENCLOSE DUMMYOD16    // sram 0.374 cell must have 82;16
  SRMLOP13 NOT ENCLOSE DUMMYPO3     // sram 0.374 cell must have 83;3
  SRMLOP13 NOT ENCLOSE DUMMYPO4     // sram 0.374 cell must have 83;4
  SRMLOP13 NOT ENCLOSE DUMMYPO5     // sram 0.374 cell must have 83;5
  SRMLOP13 NOT ENCLOSE DUMMYPO7     // sram 0.374 cell must have 83;7
  SRMLOP13 NOT ENCLOSE SRAMDMY      // sram 0.374 cell must have 186;0
  SRMLOP13 NOT ENCLOSE SRAMDMY_PAS  // sram 0.374 cell must have 186;1
  SRMLOP13 NOT ENCLOSE CO2          // sram 0.374 cell must have 100;0
}

SRAM.R.41{@ NMOS gate in SRM (50;0) must be fully covered by (50;21) (Except RODMY(49;0) region)
  (((GATEi AND SRM) AND NPi ) NOT NPreDOSRM) NOT RODMY 
}



//NPre CHECKS
//============

NPre.W.1 { @ Width >= ^NPre_W_1 
  INT NPreDOSRM < NPre_W_1 ABUT < 90 SINGULAR REGION
}
NPre.S.1 { @ Space >= ^NPre_S_1 
  EXT NPreDOSRM < NPre_S_1 ABUT < 90 SINGULAR REGION
}
NPre.S.2 { @ Space to P+ACTIVE (non-butted) >= ^NPre_S_2 
  EXT NPreDOSRM PACT < NPre_S_2 ABUT < 90 > 0 SINGULAR REGION
}

//NPre.S.3 is checked by NPre.S.2, NPre.S.4

NPre.S.4 { @ Space to PW STRAP (non-butted) >= ^NPre_S_4
  EXT NPreDOSRM PSTP < NPre_S_4 ABUT < 90 > 0 SINGULAR REGION
}
NPre.S.5 { @ {NPre edge on OD} space to PMOS GATE >= ^NPre_S_5 
  A = NPreDOSRM INSIDE EDGE OD
  EXT GATEP_W A < NPre_S_5 ABUT < 90 OPPOSITE REGION
}
NPre.S.7 { @ Space to P-type unsilicided OD/PO resistor >= ^NPre_S_7
  EXT NPreDOSRM ODPO_RES_RPO_PP  < NPre_S_7 ABUT < 90 SINGULAR REGION
}
NPre.EX.4 { @ {NPre edge on OD} extension on NMOS GATE in SRM (50;0), except RODMY (49;0) >= ^NPre_EX_4 
   A = NPreDOSRM INSIDE EDGE OD
   B = ((GATEi AND SRM) AND NPi ) NOT RODMY
   ENC B A < NPre_EX_4 ABUT < 90 OPPOSITE REGION
}
NPre.O.1 { @ Overlap of OD >= ^NPre_O_1 
  INT OD NPreDOSRM < NPre_O_1  ABUT < 90 > 0 SINGULAR REGION
}
NPre.A.1 { @ Area >= ^NPre_A_1 
  AREA NPreDOSRM < NPre_A_1
}
NPre.A.2 { @ Enclosed area >= ^NPre_A_2
  A = HOLES NPreDOSRM INNER
  B = A NOT NPreDOSRM
  AREA B < NPre_A_2
}
NPre.R.2 { @ Overlap of PP is not allowed
   NPreDOSRM AND PP
}
NPre.L.1 { @ 45-degree edge length >= ^NPre_L_1
   NPre_45ANGLE = NPreDOSRM ANGLE == 45
   LENGTH NPre_45ANGLE < NPre_L_1
}


// WLD CHECKS
//============

OD_PERI = ODi AND SRAMDMY_PERI
CO_PERI = COi NOT OUTSIDE SRAMDMY_PERI

WLD.R.2 { @ {CO AND SRAMDMY (186;4/5)} space to PO. >= 0.035 
  EXT CO_PERI POi < WLD_R_2 ABUT < 90 SINGULAR REGION
}

COOD_PERI = CO_PERI NOT OUTSIDE OD_PERI
CONNECT COOD_PERI OD_PERI
WLD.R.3 { @ CO space on the same OD [inside SRAMDMY (186;4 & 186;5)] >= 0.1 
  EXT COOD_PERI < WLD_R_3 ABUT < 90 CONNECTED SINGULAR REGION 
}

WLD.R.6 { @ SRAMDMY (186;4/5) edge cut CO is not allowed.   
  CO_PERI CUT SRAMDMY_PERI_LP
  CO_PERI CUT SRAMDMY_PERI_G
}

WLD.R.7 { @ SRAMDMY (186;0) SIZING 100 um must cover SRAMDMY (186;5) or (186;4)   
  S = SIZE SRAMDMY BY WLD_R_7
  SRAMDMY_PERI_LP NOT S
  SRAMDMY_PERI_G NOT S
}

WLDR8_GATE = GATEi NOT OUTSIDE SRAMDMY_PERI
WLDR8_GATE_W = POi COIN INSIDE EDGE WLDR8_GATE
WLDR8_GATE_W_V = EXPAND EDGE (ANGLE WLDR8_GATE_W == 90) INSIDE BY GRID
WLDR8_GATE_W_H = EXPAND EDGE (ANGLE WLDR8_GATE_W == 0) INSIDE BY GRID
WLDR8_V = CHIP INTERACT WLDR8_GATE_W_V
WLDR8_H = CHIP INTERACT WLDR8_GATE_W_H

WLDR8_V_BAD = WLDR8_V INTERACT POR7_GATE_W_H
WLDR8_H_BAD = WLDR8_H INTERACT POR7_GATE_W_V


WLD.R.8_V { @ Gate direction on the WL driver must be same as gate on the SRAM (Unique direction)
  WLDR8_GATE_W_V AND WLDR8_V_BAD
}

WLD.R.8_H { @ Gate direction on the WL driver must be same as gate on the SRAM (Unique direction)
  WLDR8_GATE_W_H AND WLDR8_H_BAD
}

//WLD.R.8 is checked by WLD.R.8_V, WLD.R.8_H

WLD.R.9 { @ At least 2 COs are required at both source and drain side on WL driver(186;4/5) region
  SD_C = (NSDi OR PSDi) AND SRAMDMY_PERI
  SD_C NOT INTERACT COi >= WLD_R_9    
}



#IFDEF eDRAM
// CO2 CHECKS
//------------
CO2.W.1 { @ Width (maximum = minimum) = 0.06 
  NOT RECTANGLE CO2 == CO2_W_1 BY == CO2_W_1 ORTHOGONAL ONLY
}

CO2.R.1 { @ CO2 layout must exist in SRAM bit cell for eDRAM process
  (SRM INTERACT (CHIP INTERACT RAM1TDMY)) NOT INTERACT CO2
}

CO2.R.2 { @ CO2 should be fully covered by M1 and BTC ((30;0 NOT 30;11) AND 50;0) 
@ The following conditions can be waived.
@ a. Butted contact (BTC) without interact M1
@ b. The area of CO2 not covered by M1 is smaller than or equal to 0.015*0.005 um2
   BTC = (COi NOT COPUSH) AND SRM
   Check_CO2 = CO2 INTERACT (BTC INTERACT M1)    
   AREA (Check_CO2 NOT M1i) > CO2_R_2
   CO2 NOT BTC
}
#ENDIF


// ROM CHECKS
//===========
ROM_GATE_W = GATE_W NOT OUTSIDE EDGE ROM

ROM.W.1 { @ Channel width = 0.12~0.35 
  LENGTH ROM_GATE_W < ROM_W_1A
  LENGTH ROM_GATE_W > ROM_W_1B
}
ROM.W.2 { @ Channel length = 0.045, 0.05 
  INT ROM_GATE_W < ROM_W_2A ABUT < 90 REGION
  ROM_GATE = GATE WITH EDGE ROM_GATE_W
  ROM_GATE WITH WIDTH > ROM_W_2B
}




// Analog Checks
//==============

BJT.R.1 { @ RPO needs to cover 0.3um on the Emitter OD edge for both OD and STI sides, i.e. RPO= ((Emitter OD SIZING 0.3 um) NOT (Emitter OD SIZING -0.3 um)) = 0.6 
     X = ( SIZE EMOD BY BJT_R_1_G1 ) NOT ( SIZE EMOD BY -BJT_R_1_G1 )
     Y = RPO INTERACT EMOD
     X XOR Y
}

BJT.R.8 { @ BJTDMY enclosure of Emitter OD >= 0.13 
   A = COPY BJTDMY 
   ENC EMOD A < BJT_R_8 ABUT<90 SINGULAR REGION 
   EMOD NOT A 
}  


NWRODR1m_NWCellIn = INSIDE CELL NWi CellsForRRuleAnalog  
NWRODR1m_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleAnalog 
NWRODR1m_NWCell = NWRODR1m_NWCellIn AND NWRODR1m_NWCellOut
NWRODR1m_NWMarker = NWi AND RRuleAnalog
NWRODR1m_NW = ((( NWRODR1m_NWCell OR NWRODR1m_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleAnalog

NWRODR1m_NWRES = ( NWRODR1m_NW AND NWRES ) AND NWDMY

NWRODR1m_NWRES_L = NWRODR1m_NWRES NOT INSIDE EDGE NWEL
NWRODR1m_NWRES_W = NWRODR1m_NWRES INSIDE EDGE NWEL
NWRODR1m_NWRES_L_ex = EXPAND EDGE NWRODR1m_NWRES_L BY 0.005
NWRODR1m_NWRES_W_ex = EXPAND EDGE NWRODR1m_NWRES_W BY 0.005
CONNECT NWRODR1m_NWRES_L_ex NWRODR1m_NWRES_W_ex

NWROD.R.1m { @ Width >= ^NWROD_R_1_W_M um, length >= ^NWROD_R_1_L_M, and square number(L/W) >= ^NWROD_R_1_S_M um for NW resistor with OD
  INT NWRODR1m_NWRES < NWROD_R_1_W_M ABUT < 90 SINGULAR REGION
  RES_L = NWRODR1m_NWRES COIN INSIDE EDGE NWRODR1m_NW
  X = PATH LENGTH RES_L < NWROD_R_1_L_M
  CHECK_RES = NWRODR1m_NWRES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE NWDMY
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY ( 10 - GRID*2 ) INSIDE OF NWRODR1m_NWRES STEP NW_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
  NET AREA RATIO NWRODR1m_NWRES_L_ex NWRODR1m_NWRES_W_ex < NWROD_R_1_S_M
}


NWRSTIR1m_NWCellIn = INSIDE CELL NWi CellsForRRuleAnalog  
NWRSTIR1m_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleAnalog 
NWRSTIR1m_NWCell = NWRSTIR1m_NWCellIn AND NWRSTIR1m_NWCellOut
NWRSTIR1m_NWMarker = NWi AND RRuleAnalog
NWRSTIR1m_NW = ((( NWRSTIR1m_NWCell OR NWRSTIR1m_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleAnalog

NWRSTIR1m_NWRES = ( NWRSTIR1m_NW AND NWRES_STI ) AND NWDMY

NWRSTIR1m_NWRES_L = NWRSTIR1m_NWRES NOT INSIDE EDGE NWEL
NWRSTIR1m_NWRES_W = NWRSTIR1m_NWRES INSIDE EDGE NWEL
NWRSTIR1m_NWRES_L_ex = EXPAND EDGE NWRSTIR1m_NWRES_L BY 0.005
NWRSTIR1m_NWRES_W_ex = EXPAND EDGE NWRSTIR1m_NWRES_W BY 0.005
CONNECT NWRSTIR1m_NWRES_L_ex NWRSTIR1m_NWRES_W_ex

NWRSTI.R.1m { @ Width >= ^NWRSTI_R_1_W_M um, length >= ^NWRSTI_R_1_L_M um, and square number(L/W) >= ^NWRSTI_R_1_S_M um for NW resistor under STI
  INT NWRSTIR1m_NWRES < NWRSTI_R_1_W_M ABUT < 90 SINGULAR REGION
  RES_L = NWRSTIR1m_NWRES COIN INSIDE EDGE NWRSTIR1m_NW
  X = PATH LENGTH RES_L < NWRSTI_R_1_L_M
  CHECK_RES = NWRSTIR1m_NWRES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE NWDMY
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY ( 10 - GRID*2 ) INSIDE OF NWRSTIR1m_NWRES STEP NW_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
  NET AREA RATIO NWRSTIR1m_NWRES_L_ex NWRSTIR1m_NWRES_W_ex < NWRSTI_R_1_S_M
}

#ENDIF 

#IFDEF BACK_END

// IND CHECKS
//==========
IND.W.1 { @ M1, DM1, DM1_O width in (INDDMY SIZING 16 um) >= 0.28 
  A = M1x NOT OUTSIDE IND_REGION
  (INT A < IND_W_1 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION
}
IND.W.2.M2 { @ Mx, DMx, DMx_O width in (INDDMY SIZING 16 um) >= 0.28 
  A = M2x NOT OUTSIDE IND_REGION
  (INT A < IND_W_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION
}
IND.W.2.M3 { @ Mx, DMx, DMx_O width in (INDDMY SIZING 16 um) >= 0.28 
  A = M3x NOT OUTSIDE IND_REGION
  (INT A < IND_W_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION
}
IND.W.2.M4 { @ Mx, DMx, DMx_O width in (INDDMY SIZING 16 um) >= 0.28 
  A = M4x NOT OUTSIDE IND_REGION
  (INT A < IND_W_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION
}
IND.W.2.M5 { @ Mx, DMx, DMx_O width in (INDDMY SIZING 16 um) >= 0.28 
  A = M5x NOT OUTSIDE IND_REGION
  (INT A < IND_W_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION
}
IND.W.2.M6 { @ Mx, DMx, DMx_O width in (INDDMY SIZING 16 um) >= 0.28 
  A = M6x NOT OUTSIDE IND_REGION
  (INT A < IND_W_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION
}
IND.W.2.M7 { @ Mx, DMx, DMx_O width in (INDDMY SIZING 16 um) >= 0.28 
  A = M7x NOT OUTSIDE IND_REGION
  (INT A < IND_W_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION
}
IND.W.2.M8 { @ Mx, DMx, DMx_O width in (INDDMY SIZING 16 um) >= 0.28 
  A = M8x NOT OUTSIDE IND_REGION
  (INT A < IND_W_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION
}
IND.W.4.M9 { @ Mz, DMz width in (INDDMY SIZING 16 um) >= 0.40 
  A = M9x NOT OUTSIDE IND_REGION  
  (INT A < IND_W_4 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION
}
IND.W.4.M10 { @ Mz, DMz width in (INDDMY SIZING 16 um) >= 0.40 
  A = M10x NOT OUTSIDE IND_REGION  
  (INT A < IND_W_4 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION
}

IND.W.7.M1 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O maximum width in (INDDMY SIZING 16 um) <= 4.5 
  A = M1x NOT OUTSIDE IND_REGION
  (A WITH WIDTH > IND_W_7) NOT OUTSIDE IND_REGION
}
IND.W.7.M2 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O maximum width in (INDDMY SIZING 16 um) <= 4.5 
  A = M2x NOT OUTSIDE IND_REGION
  (A WITH WIDTH > IND_W_7) NOT OUTSIDE IND_REGION
}
IND.W.7.M3 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O maximum width in (INDDMY SIZING 16 um) <= 4.5 
  A = M3x NOT OUTSIDE IND_REGION
  (A WITH WIDTH > IND_W_7) NOT OUTSIDE IND_REGION
}
IND.W.7.M4 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O maximum width in (INDDMY SIZING 16 um) <= 4.5 
  A = M4x NOT OUTSIDE IND_REGION
  (A WITH WIDTH > IND_W_7) NOT OUTSIDE IND_REGION
}
IND.W.7.M5 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O maximum width in (INDDMY SIZING 16 um) <= 4.5 
  A = M5x NOT OUTSIDE IND_REGION
  (A WITH WIDTH > IND_W_7) NOT OUTSIDE IND_REGION
}
IND.W.7.M6 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O maximum width in (INDDMY SIZING 16 um) <= 4.5 
  A = M6x NOT OUTSIDE IND_REGION
  (A WITH WIDTH > IND_W_7) NOT OUTSIDE IND_REGION
}
IND.W.7.M7 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O maximum width in (INDDMY SIZING 16 um) <= 4.5 
  A = M7x NOT OUTSIDE IND_REGION
  (A WITH WIDTH > IND_W_7) NOT OUTSIDE IND_REGION
}
IND.W.7.M8 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O maximum width in (INDDMY SIZING 16 um) <= 4.5 
  A = M8x NOT OUTSIDE IND_REGION
  (A WITH WIDTH > IND_W_7) NOT OUTSIDE IND_REGION
}
IND.W.9.M9 { @ Mz, DMz/Mr, DMr/Mu, DMu maximum width inside (INDDMY SIZING 22 um) (for inductor application only) <= 30.00 
  A = M9x NOT OUTSIDE IND_EXD
  (A WITH WIDTH > IND_W_9) NOT OUTSIDE IND_EXD
}
IND.W.9.M10 { @ Mz, DMz/Mr, DMr/Mu, DMu maximum width inside (INDDMY SIZING 22 um) (for inductor application only) <= 30.00 
  A = M10x NOT OUTSIDE IND_EXD
  (A WITH WIDTH > IND_W_9) NOT OUTSIDE IND_EXD
}

IND.W.10 { @ Maximum dimension (either width or length) of an INDDMY region <= 600.00 
  ENCLOSE RECTANGLE INDDMY GRID IND_W_10+GRID ORTHOGONAL ONLY
}

IND.S.1 { @ M1, DM1, DM1_O space in (INDDMY SIZING 16 um) >= 0.28 
  A = M1x AND IND_EXD  
  (EXT A < IND_S_1 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION  
}
IND.S.2.M2 { @ Mx, DMx, DMx_O space in (INDDMY SIZING 16 um) >= 0.28 
  A =  M2x AND IND_EXD  
  (EXT A < IND_S_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION  
}
IND.S.2.M3 { @ Mx, DMx, DMx_O space in (INDDMY SIZING 16 um) >= 0.28 
  A =  M3x AND IND_EXD  
  (EXT A < IND_S_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION  
}
IND.S.2.M4 { @ Mx, DMx, DMx_O space in (INDDMY SIZING 16 um) >= 0.28 
  A =  M4x AND IND_EXD  
  (EXT A < IND_S_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION  
}
IND.S.2.M5 { @ Mx, DMx, DMx_O space in (INDDMY SIZING 16 um) >= 0.28 
  A =  M5x AND IND_EXD  
  (EXT A < IND_S_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION  
}
IND.S.2.M6 { @ Mx, DMx, DMx_O space in (INDDMY SIZING 16 um) >= 0.28 
  A =  M6x AND IND_EXD  
  (EXT A < IND_S_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION  
}
IND.S.2.M7 { @ Mx, DMx, DMx_O space in (INDDMY SIZING 16 um) >= 0.28 
  A =  M7x AND IND_EXD  
  (EXT A < IND_S_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION  
}
IND.S.2.M8 { @ Mx, DMx, DMx_O space in (INDDMY SIZING 16 um) >= 0.28 
  A =  M8x AND IND_EXD  
  (EXT A < IND_S_2 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION  
}
IND.S.4.M9 { @ Mz, DMz space in (INDDMY SIZING 16 um) >= 0.40 
  A =  M9x AND IND_EXD  
  (EXT A < IND_S_4 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION  
}
IND.S.4.M10 { @ Mz, DMz space in (INDDMY SIZING 16 um) >= 0.40 
  A =  M10x AND IND_EXD  
  (EXT A < IND_S_4 ABUT < 90 SINGULAR REGION) NOT OUTSIDE IND_REGION  
}

IND.S.7.M1 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O/My, DMy/Mz, DMz space in (INDDMY SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 0.5 
  A = (M1x WITH WIDTH > IND_S_7_W) AND IND_EXD
  X = EXT A M1x < IND_S_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1x
  (ENCLOSE RECTANGLE Y 0.001 IND_S_7_L+0.001) NOT OUTSIDE IND_REGION
}
IND.S.7.M2 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O/My, DMy/Mz, DMz space in (INDDMY SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 0.5 
  A = (M2x WITH WIDTH > IND_S_7_W) AND IND_EXD
  X = EXT A M2x < IND_S_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2x
  (ENCLOSE RECTANGLE Y 0.001 IND_S_7_L+0.001) NOT OUTSIDE IND_REGION
}
IND.S.7.M3 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O/My, DMy/Mz, DMz space in (INDDMY SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 0.5 
  A = (M3x WITH WIDTH > IND_S_7_W) AND IND_EXD
  X = EXT A M3x < IND_S_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3x
  (ENCLOSE RECTANGLE Y 0.001 IND_S_7_L+0.001) NOT OUTSIDE IND_REGION
}
IND.S.7.M4 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O/My, DMy/Mz, DMz space in (INDDMY SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 0.5 
  A = (M4x WITH WIDTH > IND_S_7_W) AND IND_EXD
  X = EXT A M4x < IND_S_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4x
  (ENCLOSE RECTANGLE Y 0.001 IND_S_7_L+0.001) NOT OUTSIDE IND_REGION
}
IND.S.7.M5 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O/My, DMy/Mz, DMz space in (INDDMY SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 0.5 
  A = (M5x WITH WIDTH > IND_S_7_W) AND IND_EXD
  X = EXT A M5x < IND_S_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5x
  (ENCLOSE RECTANGLE Y 0.001 IND_S_7_L+0.001) NOT OUTSIDE IND_REGION
}
IND.S.7.M6 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O/My, DMy/Mz, DMz space in (INDDMY SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 0.5 
  A = (M6x WITH WIDTH > IND_S_7_W) AND IND_EXD
  X = EXT A M6x < IND_S_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M6x
  (ENCLOSE RECTANGLE Y 0.001 IND_S_7_L+0.001) NOT OUTSIDE IND_REGION
}
IND.S.7.M7 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O/My, DMy/Mz, DMz space in (INDDMY SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 0.5 
  A = (M7x WITH WIDTH > IND_S_7_W) AND IND_EXD
  X = EXT A M7x < IND_S_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M7x
  (ENCLOSE RECTANGLE Y 0.001 IND_S_7_L+0.001) NOT OUTSIDE IND_REGION
}
IND.S.7.M8 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O/My, DMy/Mz, DMz space in (INDDMY SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 0.5 
  A = (M8x WITH WIDTH > IND_S_7_W) AND IND_EXD
  X = EXT A M8x < IND_S_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M8x
  (ENCLOSE RECTANGLE Y 0.001 IND_S_7_L+0.001) NOT OUTSIDE IND_REGION
}
IND.S.7.M9 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O/My, DMy/Mz, DMz space in (INDDMY SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 0.5 
  A = (M9x WITH WIDTH > IND_S_7_W) AND IND_EXD
  X = EXT A M9x < IND_S_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M9x
  (ENCLOSE RECTANGLE Y 0.001 IND_S_7_L+0.001) NOT OUTSIDE IND_REGION
}
IND.S.7.M10 { @ M1, DM1, DM1_O/Mx, DMx, DMx_O/My, DMy/Mz, DMz space in (INDDMY SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 0.5 
  A = (M10x WITH WIDTH > IND_S_7_W) AND IND_EXD
  X = EXT A M10x < IND_S_7 OPPOSITE REGION MEASURE ALL
  Y = X NOT M10x
  (ENCLOSE RECTANGLE Y 0.001 IND_S_7_L+0.001) NOT OUTSIDE IND_REGION
}
IND.S.9.M9 { @ My, DMy/Mz, DMz/Mr, DMr space in (INDDMY SIZING 16 um) [at least one metal line width > 4.5 um (W3) and the parallel metal run length > 4.5 um (L3)] >= 1.5 
  A = (M9x WITH WIDTH > IND_S_9_W) AND IND_EXD 
  X = EXT A M9x < IND_S_9 OPPOSITE REGION MEASURE ALL
  Y = X NOT M9x
  (ENCLOSE RECTANGLE Y 0.001 IND_S_9_L+0.001) NOT OUTSIDE IND_REGION
}
IND.S.9.M10 { @ My, DMy/Mz, DMz/Mr, DMr space in (INDDMY SIZING 16 um) [at least one metal line width > 4.5 um (W3) and the parallel metal run length > 4.5 um (L3)] >= 1.5 
  A = (M10x WITH WIDTH > IND_S_9_W) AND IND_EXD 
  X = EXT A M10x < IND_S_9 OPPOSITE REGION MEASURE ALL
  Y = X NOT M10x
  (ENCLOSE RECTANGLE Y 0.001 IND_S_9_L+0.001) NOT OUTSIDE IND_REGION
}
#IFNDEF IND_INTER_MET_VIA
IND.R.1 { @ In the region of (INDDMY SIZING 16 um), inter-via Vx, Vy and top via Vy (2XTM) are all not allowed. (Except TLDMY region and Vx in {LOWMEDN NOT (LOWMEDN SIZING -4 um)})   
  ((VIA1 AND IND_REGION) NOT TLDMY) NOT P_RING_REGION 
  ((VIA2 AND IND_REGION) NOT TLDMY) NOT P_RING_REGION 
  ((VIA3 AND IND_REGION) NOT TLDMY) NOT P_RING_REGION 
  ((VIA4 AND IND_REGION) NOT TLDMY) NOT P_RING_REGION 
  ((VIA5 AND IND_REGION) NOT TLDMY) NOT P_RING_REGION 
  ((VIA6 AND IND_REGION) NOT TLDMY) NOT P_RING_REGION 
  ((VIA7 AND IND_REGION) NOT TLDMY) NOT P_RING_REGION 
}
#ENDIF

IND.R.2.VIA8 { @ At least 4 VIAz with space <= 1.7 um are required to connect [two Mz layers], [Mz to inter-My] or [Mz to Mx] in (INDDMY SIZING 16 um). <= 1.70 
  M9OvpM8 = (M9 AND M8) AND IND_REGION 
  Check_VIA8 = VIA8_EXD NOT OUTSIDE M9OvpM8
  VIA8Merge = SIZE Check_VIA8 BY (IND_R_2/2) INSIDE OF M9OvpM8 STEP M8_S_1*0.7
  VIA8Merge2 = VIA8Merge ENCLOSE Check_VIA8 >= 4
  Good_VIA8 = Check_VIA8 AND VIA8Merge2
  GM9OvpM8 = M9OvpM8 INTERACT Good_VIA8
  Check_VIA8 OUTSIDE GM9OvpM8
}
IND.R.2.VIA9 { @ At least 4 VIAz with space <= 1.7 um are required to connect [two Mz layers], [Mz to inter-My] or [Mz to Mx] in (INDDMY SIZING 16 um). <= 1.70 
  M10OvpM9 = (M10 AND M9) AND IND_REGION 
  Check_VIA9 = VIA9_EXD NOT OUTSIDE M10OvpM9
  VIA9Merge = SIZE Check_VIA9 BY (IND_R_2/2) INSIDE OF M10OvpM9 STEP M9_S_1*0.7
  VIA9Merge2 = VIA9Merge ENCLOSE Check_VIA9 >= 4
  Good_VIA9 = Check_VIA9 AND VIA9Merge2
  GM10OvpM9 = M10OvpM9 INTERACT Good_VIA9
  Check_VIA9 OUTSIDE GM10OvpM9
}



#IFNDEF IND_INTER_MET_VIA
IND.R.5 { @ In the INDDMY identified region a, except the Mx or My layer (one layer only) directly below [Mz, Mr or Mu], any other inter-metal layer (Mx/My) is not allowed. (E.g. for a 1P6M process with 0.9 um of M6 (Mz), then Mx of M5 is allowed, but other lower Mx metal layers are not allowed for the INDDMY identified inductor.) (Except TLDMY region and Mx in {(LOWMEDN NOT (LOWMEDN SIZING -5 um)) interact VIAx bar})   
  ((M2 AND INDDMY) NOT TLDMY) NOT ((M2 AND P_RING_REGION2) INTERACT P_RING_VIA1)

  ((M3 AND INDDMY) NOT TLDMY) NOT ((M3 AND P_RING_REGION2) INTERACT P_RING_VIA2)

  ((M4 AND INDDMY) NOT TLDMY) NOT ((M4 AND P_RING_REGION2) INTERACT P_RING_VIA3)

  ((M5 AND INDDMY) NOT TLDMY) NOT ((M5 AND P_RING_REGION2) INTERACT P_RING_VIA4)

  ((M6 AND INDDMY) NOT TLDMY) NOT ((M6 AND P_RING_REGION2) INTERACT P_RING_VIA5)

  ((M7 AND INDDMY) NOT TLDMY) NOT ((M7 AND P_RING_REGION2) INTERACT P_RING_VIA6)

}
#ENDIF
// IND.R.6 can not be checked by DRC
// IND.R.7 can not be checked by DRC
// IND.R.8 is checked by RV.R.1
// IND.R.9 can not be checked by DRC

#IFDEF FULL_CHIP
IND.DN.1 { @ Maximum density of {INDDMY OR TLDMY} in whole chip 5%  
  X = INDDMY OR TLDMY  
  DENSITY X CHIP > IND_DN_1 INSIDE OF LAYER CHIPx PRINT IND.DN.1.density
    [ AREA(X)/AREA(CHIP) ]
}    
#ENDIF

IND.DN.2.M1 { @ Maximum M1/Mx/Inter-My density within (INDDMY SIZING 16 um) in window 125 um x 125 um, stepping 62.5 um 85%   
  DENSITY M1x > IND_DN_2 INSIDE OF LAYER IND_REGION WINDOW IND_DN_2_W STEP IND_DN_2_S BACKUP PRINT IND.DN.2.M1.density 
}
IND.DN.2.M2 { @ Maximum M1/Mx/Inter-My density within (INDDMY SIZING 16 um) in window 125 um x 125 um, stepping 62.5 um 85%   
  DENSITY M2x > IND_DN_2 INSIDE OF LAYER IND_REGION WINDOW IND_DN_2_W STEP IND_DN_2_S BACKUP PRINT IND.DN.2.M2.density 
}
IND.DN.2.M3 { @ Maximum M1/Mx/Inter-My density within (INDDMY SIZING 16 um) in window 125 um x 125 um, stepping 62.5 um 85%   
  DENSITY M3x > IND_DN_2 INSIDE OF LAYER IND_REGION WINDOW IND_DN_2_W STEP IND_DN_2_S BACKUP PRINT IND.DN.2.M3.density 
}
IND.DN.2.M4 { @ Maximum M1/Mx/Inter-My density within (INDDMY SIZING 16 um) in window 125 um x 125 um, stepping 62.5 um 85%   
  DENSITY M4x > IND_DN_2 INSIDE OF LAYER IND_REGION WINDOW IND_DN_2_W STEP IND_DN_2_S BACKUP PRINT IND.DN.2.M4.density 
}
IND.DN.2.M5 { @ Maximum M1/Mx/Inter-My density within (INDDMY SIZING 16 um) in window 125 um x 125 um, stepping 62.5 um 85%   
  DENSITY M5x > IND_DN_2 INSIDE OF LAYER IND_REGION WINDOW IND_DN_2_W STEP IND_DN_2_S BACKUP PRINT IND.DN.2.M5.density 
}
IND.DN.2.M6 { @ Maximum M1/Mx/Inter-My density within (INDDMY SIZING 16 um) in window 125 um x 125 um, stepping 62.5 um 85%   
  DENSITY M6x > IND_DN_2 INSIDE OF LAYER IND_REGION WINDOW IND_DN_2_W STEP IND_DN_2_S BACKUP PRINT IND.DN.2.M6.density 
}
IND.DN.2.M7 { @ Maximum M1/Mx/Inter-My density within (INDDMY SIZING 16 um) in window 125 um x 125 um, stepping 62.5 um 85%   
  DENSITY M7x > IND_DN_2 INSIDE OF LAYER IND_REGION WINDOW IND_DN_2_W STEP IND_DN_2_S BACKUP PRINT IND.DN.2.M7.density 
}
IND.DN.2.M8 { @ Maximum M1/Mx/Inter-My density within (INDDMY SIZING 16 um) in window 125 um x 125 um, stepping 62.5 um 85%   
  DENSITY M8x > IND_DN_2 INSIDE OF LAYER IND_REGION WINDOW IND_DN_2_W STEP IND_DN_2_S BACKUP PRINT IND.DN.2.M8.density 
}

CHIP_IND = CHIP INTERACT INDDMY
#IFDEF FULL_CHIP
IND.DN.3.M1 { @ M1/Mx/My/Mz/Mr metal density over the whole chip (include INDDMY) 20%  
  DENSITY M1x CHIP < IND_DN_3 INSIDE OF LAYER CHIP_IND PRINT IND.DN.3.M1.density [ AREA(M1x)/AREA(CHIP) ]
}

IND.DN.3.M2 { @ M1/Mx/My/Mz/Mr metal density over the whole chip (include INDDMY) 20%  
  DENSITY M2x CHIP < IND_DN_3 INSIDE OF LAYER CHIP_IND PRINT IND.DN.3.M2.density [ AREA(M2x)/AREA(CHIP) ]
}

IND.DN.3.M3 { @ M1/Mx/My/Mz/Mr metal density over the whole chip (include INDDMY) 20%  
  DENSITY M3x CHIP < IND_DN_3 INSIDE OF LAYER CHIP_IND PRINT IND.DN.3.M3.density [ AREA(M3x)/AREA(CHIP) ]
}

IND.DN.3.M4 { @ M1/Mx/My/Mz/Mr metal density over the whole chip (include INDDMY) 20%  
  DENSITY M4x CHIP < IND_DN_3 INSIDE OF LAYER CHIP_IND PRINT IND.DN.3.M4.density [ AREA(M4x)/AREA(CHIP) ]
}

IND.DN.3.M5 { @ M1/Mx/My/Mz/Mr metal density over the whole chip (include INDDMY) 20%  
  DENSITY M5x CHIP < IND_DN_3 INSIDE OF LAYER CHIP_IND PRINT IND.DN.3.M5.density [ AREA(M5x)/AREA(CHIP) ]
}

IND.DN.3.M6 { @ M1/Mx/My/Mz/Mr metal density over the whole chip (include INDDMY) 20%  
  DENSITY M6x CHIP < IND_DN_3 INSIDE OF LAYER CHIP_IND PRINT IND.DN.3.M6.density [ AREA(M6x)/AREA(CHIP) ]
}

IND.DN.3.M7 { @ M1/Mx/My/Mz/Mr metal density over the whole chip (include INDDMY) 20%  
  DENSITY M7x CHIP < IND_DN_3 INSIDE OF LAYER CHIP_IND PRINT IND.DN.3.M7.density [ AREA(M7x)/AREA(CHIP) ]
}

IND.DN.3.M8 { @ M1/Mx/My/Mz/Mr metal density over the whole chip (include INDDMY) 20%  
  DENSITY M8x CHIP < IND_DN_3 INSIDE OF LAYER CHIP_IND PRINT IND.DN.3.M8.density [ AREA(M8x)/AREA(CHIP) ]
}

IND.DN.3.M9 { @ M1/Mx/My/Mz/Mr metal density over the whole chip (include INDDMY) 20%  
  DENSITY M9x CHIP < IND_DN_3 INSIDE OF LAYER CHIP_IND PRINT IND.DN.3.M9.density [ AREA(M9x)/AREA(CHIP) ]
}

IND.DN.3.M10 { @ M1/Mx/My/Mz/Mr metal density over the whole chip (include INDDMY) 20%  
  DENSITY M10x CHIP < IND_DN_3 INSIDE OF LAYER CHIP_IND PRINT IND.DN.3.M10.density [ AREA(M10x)/AREA(CHIP) ]
}

#ENDIF
// IND.DN.4 is checked by Mz.DN.1, Mr.DN.1, and Mu.DN.2
// IND.DN.4.1 is checked by Mz.DN.1.1, Mr.DN.1.1, and Mu.DN.2.1
// IND.DN.5 can not be checked by DRC, since it has different value from Logic rule (40%)
// IND.R.10 is checked by related rules
// IND.R.14 is checked by related rules

#IFDEF FULL_CHIP
IND.DN.7 { @ Maximum density of INDDMY in window 1600 um x 1600 um stepping 800 um <= 14 %
   DENSITY INDDMY CHIP > IND_DN_7 WINDOW IND_DN_7_W STEP IND_DN_7_S BACKUP INSIDE OF LAYER CHIPx [AREA(INDDMY)/AREA(CHIP)] PRINT IND.DN.7.density
}
#ENDIF


#IFDEF IND_INTER_MET_VIA

INT_VIA1pre = (SIZE (VIA1 AND INDDMY) BY IND_DN_6R) AND INDDMY
INT_VIA1 = COPY INT_VIA1pre

INT_VIA2pre = (SIZE (VIA2 AND INDDMY) BY IND_DN_6R) AND INDDMY
INT_VIA2 = INT_VIA2pre OR INT_VIA1

INT_VIA3pre = (SIZE (VIA3 AND INDDMY) BY IND_DN_6R) AND INDDMY
INT_VIA3 = INT_VIA3pre OR INT_VIA2

INT_VIA4pre = (SIZE (VIA4 AND INDDMY) BY IND_DN_6R) AND INDDMY
INT_VIA4 = INT_VIA4pre OR INT_VIA3

INT_VIA5pre = (SIZE (VIA5 AND INDDMY) BY IND_DN_6R) AND INDDMY
INT_VIA5 = INT_VIA5pre OR INT_VIA4

INT_VIA6pre = (SIZE (VIA6 AND INDDMY) BY IND_DN_6R) AND INDDMY
INT_VIA6 = INT_VIA6pre OR INT_VIA5

INT_VIA7pre = (SIZE (VIA7 AND INDDMY) BY IND_DN_6R) AND INDDMY
INT_VIA7 = INT_VIA7pre OR INT_VIA6



INT_DEN_CHK = COPY INT_VIA7
INT_DEN_CHKx = COPY INT_DEN_CHK

IND.DN.6.M1 { @ For the region of (INDDMY SIZING 16 um) with VIAx and inter-VIAy adopted, minimum metal density over any 125 um x 125 um area for all lower metal layers that below VIAx and inter-VIAy in the region of {[(((Inter-VIA AND INDDMY) SIZING 4 um) SIZING -4 um) SIZING 4 um] AND INDDMY}. The added metal for meeting this density rule can be either datatype 0 or 1 for Mx layer(s), or either 20 or 21 for My layer(s). E.g. If Vx3 and Vx4 are the adopted inter via within (INDDMY SIZING 16 um) region, then the metal density within the check region for the M4, M3, M2 and M1 must be followed.  15%  
  DENSITY M1x INT_DEN_CHK < IND_DN_6 WINDOW IND_DN_6W STEP IND_DN_6W/2 BACKUP INSIDE OF LAYER INT_DEN_CHKx BY POLYGON PRINT IND.DN.6.density_M1.rep 
	[ AREA(M1x)/AREA(INT_DEN_CHK) ]
}
IND.DN.6.M2 { @ For the region of (INDDMY SIZING 16 um) with VIAx and inter-VIAy adopted, minimum metal density over any 125 um x 125 um area for all lower metal layers that below VIAx and inter-VIAy in the region of {[(((Inter-VIA AND INDDMY) SIZING 4 um) SIZING -4 um) SIZING 4 um] AND INDDMY}. The added metal for meeting this density rule can be either datatype 0 or 1 for Mx layer(s), or either 20 or 21 for My layer(s). E.g. If Vx3 and Vx4 are the adopted inter via within (INDDMY SIZING 16 um) region, then the metal density within the check region for the M4, M3, M2 and M1 must be followed.  15%  
  DENSITY M2x INT_DEN_CHK < IND_DN_6 WINDOW IND_DN_6W STEP IND_DN_6W/2 BACKUP INSIDE OF LAYER INT_DEN_CHKx BY POLYGON PRINT IND.DN.6.density_M2.rep 
	[ AREA(M2x)/AREA(INT_DEN_CHK) ]
}
IND.DN.6.M3 { @ For the region of (INDDMY SIZING 16 um) with VIAx and inter-VIAy adopted, minimum metal density over any 125 um x 125 um area for all lower metal layers that below VIAx and inter-VIAy in the region of {[(((Inter-VIA AND INDDMY) SIZING 4 um) SIZING -4 um) SIZING 4 um] AND INDDMY}. The added metal for meeting this density rule can be either datatype 0 or 1 for Mx layer(s), or either 20 or 21 for My layer(s). E.g. If Vx3 and Vx4 are the adopted inter via within (INDDMY SIZING 16 um) region, then the metal density within the check region for the M4, M3, M2 and M1 must be followed.  15%  
  DENSITY M3x INT_DEN_CHK < IND_DN_6 WINDOW IND_DN_6W STEP IND_DN_6W/2 BACKUP INSIDE OF LAYER INT_DEN_CHKx BY POLYGON PRINT IND.DN.6.density_M3.rep 
	[ AREA(M3x)/AREA(INT_DEN_CHK) ]
}
IND.DN.6.M4 { @ For the region of (INDDMY SIZING 16 um) with VIAx and inter-VIAy adopted, minimum metal density over any 125 um x 125 um area for all lower metal layers that below VIAx and inter-VIAy in the region of {[(((Inter-VIA AND INDDMY) SIZING 4 um) SIZING -4 um) SIZING 4 um] AND INDDMY}. The added metal for meeting this density rule can be either datatype 0 or 1 for Mx layer(s), or either 20 or 21 for My layer(s). E.g. If Vx3 and Vx4 are the adopted inter via within (INDDMY SIZING 16 um) region, then the metal density within the check region for the M4, M3, M2 and M1 must be followed.  15%  
  DENSITY M4x INT_DEN_CHK < IND_DN_6 WINDOW IND_DN_6W STEP IND_DN_6W/2 BACKUP INSIDE OF LAYER INT_DEN_CHKx BY POLYGON PRINT IND.DN.6.density_M4.rep 
	[ AREA(M4x)/AREA(INT_DEN_CHK) ]
}
IND.DN.6.M5 { @ For the region of (INDDMY SIZING 16 um) with VIAx and inter-VIAy adopted, minimum metal density over any 125 um x 125 um area for all lower metal layers that below VIAx and inter-VIAy in the region of {[(((Inter-VIA AND INDDMY) SIZING 4 um) SIZING -4 um) SIZING 4 um] AND INDDMY}. The added metal for meeting this density rule can be either datatype 0 or 1 for Mx layer(s), or either 20 or 21 for My layer(s). E.g. If Vx3 and Vx4 are the adopted inter via within (INDDMY SIZING 16 um) region, then the metal density within the check region for the M4, M3, M2 and M1 must be followed.  15%  
  DENSITY M5x INT_DEN_CHK < IND_DN_6 WINDOW IND_DN_6W STEP IND_DN_6W/2 BACKUP INSIDE OF LAYER INT_DEN_CHKx BY POLYGON PRINT IND.DN.6.density_M5.rep 
	[ AREA(M5x)/AREA(INT_DEN_CHK) ]
}
IND.DN.6.M6 { @ For the region of (INDDMY SIZING 16 um) with VIAx and inter-VIAy adopted, minimum metal density over any 125 um x 125 um area for all lower metal layers that below VIAx and inter-VIAy in the region of {[(((Inter-VIA AND INDDMY) SIZING 4 um) SIZING -4 um) SIZING 4 um] AND INDDMY}. The added metal for meeting this density rule can be either datatype 0 or 1 for Mx layer(s), or either 20 or 21 for My layer(s). E.g. If Vx3 and Vx4 are the adopted inter via within (INDDMY SIZING 16 um) region, then the metal density within the check region for the M4, M3, M2 and M1 must be followed.  15%  
  DENSITY M6x INT_DEN_CHK < IND_DN_6 WINDOW IND_DN_6W STEP IND_DN_6W/2 BACKUP INSIDE OF LAYER INT_DEN_CHKx BY POLYGON PRINT IND.DN.6.density_M6.rep 
	[ AREA(M6x)/AREA(INT_DEN_CHK) ]
}
IND.DN.6.M7 { @ For the region of (INDDMY SIZING 16 um) with VIAx and inter-VIAy adopted, minimum metal density over any 125 um x 125 um area for all lower metal layers that below VIAx and inter-VIAy in the region of {[(((Inter-VIA AND INDDMY) SIZING 4 um) SIZING -4 um) SIZING 4 um] AND INDDMY}. The added metal for meeting this density rule can be either datatype 0 or 1 for Mx layer(s), or either 20 or 21 for My layer(s). E.g. If Vx3 and Vx4 are the adopted inter via within (INDDMY SIZING 16 um) region, then the metal density within the check region for the M4, M3, M2 and M1 must be followed.  15%  
  DENSITY M7x INT_DEN_CHK < IND_DN_6 WINDOW IND_DN_6W STEP IND_DN_6W/2 BACKUP INSIDE OF LAYER INT_DEN_CHKx BY POLYGON PRINT IND.DN.6.density_M7.rep 
	[ AREA(M7x)/AREA(INT_DEN_CHK) ]
}

IND.R.11.VIA1 { @ At least 100 VIAx with space <= 0.14 um are required to connect [two Mx layers] or [Mx to M1] in (INDDMY SIZING 16 um) <= 0.14 
  M2OvpM1 = (M2 AND M1) AND IND_REGION 
  Check_VIA1 = VIA1_EXD NOT OUTSIDE M2OvpM1
  VIA1Merge = SIZE Check_VIA1 BY (IND_R_11/2) INSIDE OF M2OvpM1 STEP M1_S_1*0.7
  VIA1Merge2 = VIA1Merge ENCLOSE Check_VIA1 >= IND_R_11C
  Good_VIA1 = Check_VIA1 AND VIA1Merge2
  GM2OvpM1 = M2OvpM1 INTERACT Good_VIA1
  Check_VIA1 OUTSIDE GM2OvpM1
}
IND.R.11.VIA2 { @ At least 100 VIAx with space <= 0.14 um are required to connect [two Mx layers] or [Mx to M1] in (INDDMY SIZING 16 um) <= 0.14 
  M3OvpM2 = (M3 AND M2) AND IND_REGION 
  Check_VIA2 = VIA2_EXD NOT OUTSIDE M3OvpM2
  VIA2Merge = SIZE Check_VIA2 BY (IND_R_11/2) INSIDE OF M3OvpM2 STEP M2_S_1*0.7
  VIA2Merge2 = VIA2Merge ENCLOSE Check_VIA2 >= IND_R_11C
  Good_VIA2 = Check_VIA2 AND VIA2Merge2
  GM3OvpM2 = M3OvpM2 INTERACT Good_VIA2
  Check_VIA2 OUTSIDE GM3OvpM2
}
IND.R.11.VIA3 { @ At least 100 VIAx with space <= 0.14 um are required to connect [two Mx layers] or [Mx to M1] in (INDDMY SIZING 16 um) <= 0.14 
  M4OvpM3 = (M4 AND M3) AND IND_REGION 
  Check_VIA3 = VIA3_EXD NOT OUTSIDE M4OvpM3
  VIA3Merge = SIZE Check_VIA3 BY (IND_R_11/2) INSIDE OF M4OvpM3 STEP M3_S_1*0.7
  VIA3Merge2 = VIA3Merge ENCLOSE Check_VIA3 >= IND_R_11C
  Good_VIA3 = Check_VIA3 AND VIA3Merge2
  GM4OvpM3 = M4OvpM3 INTERACT Good_VIA3
  Check_VIA3 OUTSIDE GM4OvpM3
}
IND.R.11.VIA4 { @ At least 100 VIAx with space <= 0.14 um are required to connect [two Mx layers] or [Mx to M1] in (INDDMY SIZING 16 um) <= 0.14 
  M5OvpM4 = (M5 AND M4) AND IND_REGION 
  Check_VIA4 = VIA4_EXD NOT OUTSIDE M5OvpM4
  VIA4Merge = SIZE Check_VIA4 BY (IND_R_11/2) INSIDE OF M5OvpM4 STEP M4_S_1*0.7
  VIA4Merge2 = VIA4Merge ENCLOSE Check_VIA4 >= IND_R_11C
  Good_VIA4 = Check_VIA4 AND VIA4Merge2
  GM5OvpM4 = M5OvpM4 INTERACT Good_VIA4
  Check_VIA4 OUTSIDE GM5OvpM4
}
IND.R.11.VIA5 { @ At least 100 VIAx with space <= 0.14 um are required to connect [two Mx layers] or [Mx to M1] in (INDDMY SIZING 16 um) <= 0.14 
  M6OvpM5 = (M6 AND M5) AND IND_REGION 
  Check_VIA5 = VIA5_EXD NOT OUTSIDE M6OvpM5
  VIA5Merge = SIZE Check_VIA5 BY (IND_R_11/2) INSIDE OF M6OvpM5 STEP M5_S_1*0.7
  VIA5Merge2 = VIA5Merge ENCLOSE Check_VIA5 >= IND_R_11C
  Good_VIA5 = Check_VIA5 AND VIA5Merge2
  GM6OvpM5 = M6OvpM5 INTERACT Good_VIA5
  Check_VIA5 OUTSIDE GM6OvpM5
}
IND.R.11.VIA6 { @ At least 100 VIAx with space <= 0.14 um are required to connect [two Mx layers] or [Mx to M1] in (INDDMY SIZING 16 um) <= 0.14 
  M7OvpM6 = (M7 AND M6) AND IND_REGION 
  Check_VIA6 = VIA6_EXD NOT OUTSIDE M7OvpM6
  VIA6Merge = SIZE Check_VIA6 BY (IND_R_11/2) INSIDE OF M7OvpM6 STEP M6_S_1*0.7
  VIA6Merge2 = VIA6Merge ENCLOSE Check_VIA6 >= IND_R_11C
  Good_VIA6 = Check_VIA6 AND VIA6Merge2
  GM7OvpM6 = M7OvpM6 INTERACT Good_VIA6
  Check_VIA6 OUTSIDE GM7OvpM6
}
IND.R.11.VIA7 { @ At least 100 VIAx with space <= 0.14 um are required to connect [two Mx layers] or [Mx to M1] in (INDDMY SIZING 16 um) <= 0.14 
  M8OvpM7 = (M8 AND M7) AND IND_REGION 
  Check_VIA7 = VIA7_EXD NOT OUTSIDE M8OvpM7
  VIA7Merge = SIZE Check_VIA7 BY (IND_R_11/2) INSIDE OF M8OvpM7 STEP M7_S_1*0.7
  VIA7Merge2 = VIA7Merge ENCLOSE Check_VIA7 >= IND_R_11C
  Good_VIA7 = Check_VIA7 AND VIA7Merge2
  GM8OvpM7 = M8OvpM7 INTERACT Good_VIA7
  Check_VIA7 OUTSIDE GM8OvpM7
}

#ENDIF


#ENDIF
#ENDIF


#IFDEF DFM       // start DFM check


#IFDEF Systematic
#DEFINE SP
#DEFINE SD
#DEFINE FSP
#ELSE
#IFDEF Parametric
#DEFINE SP
#DEFINE FSP
#ELSE
#IFDEF Defect
#DEFINE SD
#ELSE
#IFDEF First_priority
#DEFINE FSP
#ENDIF
#ENDIF
#ENDIF
#ENDIF


#IFDEF Required

#IFDEF _POEX2_
POEX2_ODCellIn = INSIDE CELL ODi CellsForRRuleRequired  
POEX2_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRequired 
POEX2_ODCell = POEX2_ODCellIn AND POEX2_ODCellOut
POEX2_ODMarker = ODi AND RRuleRequired
POEX2_OD = ((( POEX2_ODCell OR POEX2_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRequired

RR:AR:POEX2 { @ Recommended OD extension on PO >= ^PO_EX_2_R um
  (ENC POLY POEX2_OD < PO_EX_2_R ABUT < 90 SINGULAR OPPOSITE REGION) NOT INSIDE (LOGO OR TCDDMY)
}
#ENDIF

#IFDEF _POS5_
POS5_POCellIn = INSIDE CELL POi CellsForRRuleRequired  
POS5_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRequired 
POS5_POCell = POS5_POCellIn AND POS5_POCellOut
POS5_POMarker = POi AND RRuleRequired
POS5_PO = ((( POS5_POCell OR POS5_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRequired

POS5_GateW = GATE_W COIN INSIDE EDGE POS5_PO
POS5_GateWExp = EXPAND EDGE POS5_GateW INSIDE BY GRID EXTEND BY OD_S_1
POS5_GateWExe = POS5_PO COIN INSIDE EDGE POS5_GateWExp
RR:AR:POS5 { @ Recommended PO space to L-shape OD when PO and OD are in the same MOS >= ^PO_S_5_R um
  EXT POS5_GateWExe ODi < PO_S_5_R ABUT < 90 OPPOSITE REGION
}
#ENDIF // _POS5_

#IFDEF _POS6_
POS6_ODCellIn = INSIDE CELL ODi CellsForRRuleRequired  
POS6_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRequired 
POS6_ODCell = POS6_ODCellIn AND POS6_ODCellOut
POS6_ODMarker = ODi AND RRuleRequired
POS6_OD = ((( POS6_ODCell OR POS6_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRequired

POS6_OD_CHK = POS6_OD NOT TCDDMY
POS6_GateL = GATE_L COIN INSIDE EDGE POS6_OD_CHK
POS6_GateLExp = EXPAND EDGE POS6_GateL INSIDE BY GRID EXTEND BY PO_S_1
POS6_GateLExe = (POS6_OD_CHK COIN INSIDE EDGE POS6_GateLExp) TOUCH INSIDE EDGE POS6_GateL
RR:AR:POS6 { @ Recommended L-shape PO Space to OD when PO and OD are in the same MOS >= ^PO_S_6_R um
  EXT POS6_GateLExe POi < PO_S_6_R ABUT < 90 OPPOSITE REGION
}
#ENDIF // _POS6_

#ENDIF // Required

#IFDEF Recommended

#IFDEF Systematic


#IFDEF _ODS6_
ODS6_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
ODS6_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
ODS6_ODCell = ODS6_ODCellIn AND ODS6_ODCellOut
ODS6_ODMarker = ODi AND RRuleRecommended
ODS6_OD = ((( ODS6_ODCell OR ODS6_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

ODS6Area = AREA ( ODi NOT INTERACT SEALRING_EXCLUDE ) > BIG_AREA
RR:RE:S:ODS6 { @ Space to large OD [OD area > ^BIG_AREA] >= ^OD_S_6_R um
  (EXT ODS6Area SRDOD < OD_S_6_R ABUT < 90 SINGULAR REGION) INTERACT ODS6_OD
  (EXT ODS6Area ODi < OD_S_6_R SPACE ABUT < 90 SINGULAR REGION) INTERACT ODS6_OD
}
#ENDIF


#IFDEF _SRDODS3_
SRDODS3_SRDODCellIn = INSIDE CELL SRDOD CellsForRRuleRecommended  
SRDODS3_SRDODCellOut = NOT INSIDE CELL SRDOD ExclCellsForRRuleRecommended 
SRDODS3_SRDODCell = SRDODS3_SRDODCellIn AND SRDODS3_SRDODCellOut
SRDODS3_SRDODMarker = SRDOD AND RRuleRecommended
SRDODS3_SRDOD = ((( SRDODS3_SRDODCell OR SRDODS3_SRDODMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:S:SRDODS3 { @ Recommended space to DPO, SR_DPO >= 0.05 
  EXT SRDODS3_SRDOD DPO < SRDOD_S_3_R ABUT < 90 SINGULAR REGION INSIDE ALSO
  EXT SRDODS3_SRDOD SRDPO < SRDOD_S_3_R ABUT < 90 SINGULAR REGION INSIDE ALSO
}
#ENDIF


#IFDEF _SRDPOL1_
SRDPOL1_SRDPOCellIn = INSIDE CELL SRDPO CellsForRRuleRecommended  
SRDPOL1_SRDPOCellOut = NOT INSIDE CELL SRDPO ExclCellsForRRuleRecommended 
SRDPOL1_SRDPOCell = SRDPOL1_SRDPOCellIn AND SRDPOL1_SRDPOCellOut
SRDPOL1_SRDPOMarker = SRDPO AND RRuleRecommended
SRDPOL1_SRDPO = ((( SRDPOL1_SRDPOCell OR SRDPOL1_SRDPOMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:L:SRDPOL1 { @ Recommended length of SR_DPO ^SRDPO_L_1_R um
  NOT ENCLOSE RECTANGLE SRDPOL1_SRDPO SRDPO_L_1_R GRID ORTHOGONAL ONLY
}
#ENDIF

#IFDEF _SRDPOL3_
SRDPOL3_SRDPOCellIn = INSIDE CELL SRDPO CellsForRRuleRecommended  
SRDPOL3_SRDPOCellOut = NOT INSIDE CELL SRDPO ExclCellsForRRuleRecommended 
SRDPOL3_SRDPOCell = SRDPOL3_SRDPOCellIn AND SRDPOL3_SRDPOCellOut
SRDPOL3_SRDPOMarker = SRDPO AND RRuleRecommended
SRDPOL3_SRDPO = ((( SRDPOL3_SRDPOCell OR SRDPOL3_SRDPOMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:L:SRDPOL3 { @ Recommended maximum Length <= 10 
  ENCLOSE RECTANGLE SRDPOL3_SRDPO SRDPO_L_3_R+GRID GRID ORTHOGONAL ONLY
}
#ENDIF
#IFDEF _DNWEN1_
DNWEN1_DNWCellIn = INSIDE CELL DNWi CellsForRRuleRecommended  
DNWEN1_DNWCellOut = NOT INSIDE CELL DNWi ExclCellsForRRuleRecommended 
DNWEN1_DNWCell = DNWEN1_DNWCellIn AND DNWEN1_DNWCellOut
DNWEN1_DNWMarker = DNWi AND RRuleRecommended
DNWEN1_DNW = ((( DNWEN1_DNWCell OR DNWEN1_DNWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:S:DNWEN1 { @ Enclosure by NW >= ^DNW_EN_1_R um for better noise isolation. 
  ENC DNWEN1_DNW NWEL < DNW_EN_1_R ABUT < 90 SINGULAR REGION 
  DNWEN1_DNW OUTSIDE EDGE NWEL
}
#ENDIF 

#IFDEF _ESDIMPEN1_
ESDIMPEN1_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
ESDIMPEN1_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
ESDIMPEN1_ODCell = ESDIMPEN1_ODCellIn AND ESDIMPEN1_ODCellOut
ESDIMPEN1_ODMarker = ODi AND RRuleRecommended
ESDIMPEN1_OD = ((( ESDIMPEN1_ODCell OR ESDIMPEN1_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:S:ESDIMPEN1 { @ Recommended (OD NOT PO) enclosure of ESDIMP == ^ESDIMP_EN_1R um
  OD_NPO = ESDIMPEN1_OD NOT POLY
  OD_NPO_ESD = SIZE (OD_NPO INTERACT ESDIMP) BY -ESDIMP_EN_1R
  ESDIMP_OD = ESDIMP INTERACT OD_NPO
  XOR OD_NPO_ESD ESDIMP_OD
}
#ENDIF

#IFDEF _M1S7_
M1S7_M1CellIn = INSIDE CELL M1i CellsForRRuleRecommended  
M1S7_M1CellOut = NOT INSIDE CELL M1i ExclCellsForRRuleRecommended 
M1S7_M1Cell = M1S7_M1CellIn AND M1S7_M1CellOut
M1S7_M1Marker = M1i AND RRuleRecommended
M1S7_M1 = ((M1S7_M1Cell OR M1S7_M1Marker) NOT Block ) NOT excludeRRuleRecommended

M1S7_DM1CellIn = INSIDE CELL DUM1 CellsForRRuleRecommended  
M1S7_DM1CellOut = NOT INSIDE CELL DUM1 ExclCellsForRRuleRecommended 
M1S7_DM1Cell = M1S7_DM1CellIn AND M1S7_DM1CellOut
M1S7_DM1Marker = DUM1 AND RRuleRecommended
M1S7_DM1 = ((M1S7_DM1Cell OR M1S7_DM1Marker) NOT Block ) NOT excludeRRuleRecommended

M1S7_M1x = M1S7_M1 OR M1S7_DM1
M1S7_NOT_M1x = CHIP NOT M1x
M1S7_BIGAREA = AREA M1S7_NOT_M1x > BIG_AREA
M1S7_ERROR = (EXT M1S7_BIGAREA M1S7_NOT_M1x < M1_S_7_R SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M1S7_M1x 

RR:RE:S:M1S7 { @ Space between two non-M1 regions >= ^M1_S_7_R um [ one of the non-M1 area > ^BIG_AREA ]
  COPY M1S7_ERROR
}
#ENDIF
#IFDEF _M1DN6_
M1DN6_M1CellIn = INSIDE CELL M1i CellsForRRuleRecommended  
M1DN6_M1CellOut = NOT INSIDE CELL M1i ExclCellsForRRuleRecommended 
M1DN6_M1Cell = M1DN6_M1CellIn AND M1DN6_M1CellOut
M1DN6_M1Marker = M1i AND RRuleRecommended
M1DN6_M1 = ((M1DN6_M1Cell OR M1DN6_M1Marker) NOT Block ) NOT excludeRRuleRecommended

M1DN6_DM1CellIn = INSIDE CELL DUM1 CellsForRRuleRecommended  
M1DN6_DM1CellOut = NOT INSIDE CELL DUM1 ExclCellsForRRuleRecommended 
M1DN6_DM1Cell = M1DN6_DM1CellIn AND M1DN6_DM1CellOut
M1DN6_DM1Marker = DUM1 AND RRuleRecommended
M1DN6_DM1 = ((M1DN6_DM1Cell OR M1DN6_DM1Marker) NOT Block ) NOT excludeRRuleRecommended


M1DN6_M1x = M1DN6_M1 OR M1DN6_DM1
M1DN6_M1_CHECK = M1DN6_M1x NOT NEW_DEN_EXC
M1DN6_CHIP_CHECK = (CHIP NOT NEW_DEN_EXC) NOT excludeRRuleRecommended

#IFDEF FULL_CHIP
M1DN6_CHIP_M1 = COPY CHIP
#ELSE
M1DN6_CHIP_M1 = CHIP INTERACT M1DN6_M1x
#ENDIF

RR:RE:S:M1DN6 { @ Recommend metal Desnsity >= ^M1_DN_6_R for IP level. All condition-A, condition-B and condition-C must be followed.
@ (1) Condition-A: For IP level, recommend metal density [window ^M1_DN_6_W_A_R um x ^M1_DN_6_W_A_R um, stepping ^M1_DN_6_S_A_R um] >= ^M1_DN_6_R
@ (2) Condition-B: For IP level, recommend maximum area of merged low density windows [window ^M1_DN_6_W_BC_R um x ^M1_DN_6_W_BC_R um, stepping ^M1_DN_6_S_BC_R um < ^M1_DN_6_R] <= ^M1_DN_6_A_B_R um2, except merged low density windows width <= ^M1_DN_6_U_R um
@ (3) Condition-C: For IP level, recommend maximum area of merged low density windows [window ^M1_DN_6_W_BC_R um x ^M1_DN_6_W_BC_R um, stepping ^M1_DN_6_S_BC_R um < ^M1_DN_6_R] <= ^M1_DN_6_A_C_R um2
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M1_DN_6_E_A_R um for condition-A and >= ^M1_DN_6_E_BC_R um for both condition-B/condition-C 
  // Condition-A
  M1DN6_ERR_WIN_A = DENSITY M1DN6_M1_CHECK M1DN6_CHIP_CHECK < M1_DN_6_R WINDOW M1_DN_6_W_A_R STEP M1_DN_6_S_A_R INSIDE OF LAYER M1DN6_CHIP_M1 BACKUP
	[ AREA(M1DN6_M1_CHECK)/AREA(M1DN6_CHIP_CHECK) ]
  M1DN6_F_A = WITH WIDTH (M1DN6_ERR_WIN_A NOT NEW_DEN_EXC) >= M1_DN_6_E_A_R
  DENSITY M1DN6_F_A M1DN6_M1_CHECK M1DN6_CHIP_CHECK < M1_DN_6_R WINDOW M1_DN_6_W_A_R STEP M1_DN_6_S_A_R INSIDE OF LAYER M1DN6_CHIP_M1 BACKUP PRINT M1DN6R_A.density
         [ !AREA(M1DN6_F_A)+AREA(M1DN6_M1_CHECK)/AREA(M1DN6_CHIP_CHECK) ]
  // Condition-B	 
  M1DN6_ERR_WIN_B = DENSITY M1DN6_M1_CHECK M1DN6_CHIP_CHECK < M1_DN_6_R WINDOW M1_DN_6_W_BC_R STEP M1_DN_6_S_BC_R INSIDE OF LAYER M1DN6_CHIP_M1 BACKUP 
	[ AREA(M1DN6_M1_CHECK)/AREA(M1DN6_CHIP_CHECK) ]
  M1DN6_F_B = WITH WIDTH (M1DN6_ERR_WIN_B NOT NEW_DEN_EXC) >= M1_DN_6_E_BC_R
  M1DN6_A = DENSITY M1DN6_F_B M1DN6_M1_CHECK M1DN6_CHIP_CHECK < M1_DN_6_R WINDOW M1_DN_6_W_BC_R STEP M1_DN_6_S_BC_R INSIDE OF LAYER M1DN6_CHIP_M1 BACKUP PRINT M1DN6R_BC.density
         [ !AREA(M1DN6_F_B)+AREA(M1DN6_M1_CHECK)/AREA(M1DN6_CHIP_CHECK) ]
  M1DN6_B = AREA M1DN6_A > M1_DN_6_A_B_R
  M1DN6_C = SIZE M1DN6_B BY M1_DN_6_U_R/2 UNDEROVER
  M1DN6_B INTERACT M1DN6_C
  // Condition-C
  AREA M1DN6_B > M1_DN_6_A_C_R
}
#ENDIF

#IFDEF _M2S7_
M2S7_M2CellIn = INSIDE CELL M2i CellsForRRuleRecommended  
M2S7_M2CellOut = NOT INSIDE CELL M2i ExclCellsForRRuleRecommended 
M2S7_M2Cell = M2S7_M2CellIn AND M2S7_M2CellOut
M2S7_M2Marker = M2i AND RRuleRecommended
M2S7_M2 = ((M2S7_M2Cell OR M2S7_M2Marker) NOT Block ) NOT excludeRRuleRecommended

M2S7_DM2CellIn = INSIDE CELL DUM2 CellsForRRuleRecommended  
M2S7_DM2CellOut = NOT INSIDE CELL DUM2 ExclCellsForRRuleRecommended 
M2S7_DM2Cell = M2S7_DM2CellIn AND M2S7_DM2CellOut
M2S7_DM2Marker = DUM2 AND RRuleRecommended
M2S7_DM2 = ((M2S7_DM2Cell OR M2S7_DM2Marker) NOT Block ) NOT excludeRRuleRecommended

M2S7_M2x = M2S7_M2 OR M2S7_DM2
M2S7_NOT_M2x = CHIP NOT M2x
M2S7_BIGAREA = AREA M2S7_NOT_M2x > BIG_AREA
M2S7_ERROR = (EXT M2S7_BIGAREA M2S7_NOT_M2x < M2_S_7_R SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M2S7_M2x 

RR:RE:S:M2S7 { @ Space between two non-M2 regions >= ^M2_S_7_R um [ one of the non-M2 area > ^BIG_AREA ]
  COPY M2S7_ERROR 
}
#ENDIF 
#IFDEF _M2DN6_
M2DN6_M2CellIn = INSIDE CELL M2i CellsForRRuleRecommended  
M2DN6_M2CellOut = NOT INSIDE CELL M2i ExclCellsForRRuleRecommended 
M2DN6_M2Cell = M2DN6_M2CellIn AND M2DN6_M2CellOut
M2DN6_M2Marker = M2i AND RRuleRecommended
M2DN6_M2 = ((M2DN6_M2Cell OR M2DN6_M2Marker) NOT Block ) NOT excludeRRuleRecommended

M2DN6_DM2CellIn = INSIDE CELL DUM2 CellsForRRuleRecommended  
M2DN6_DM2CellOut = NOT INSIDE CELL DUM2 ExclCellsForRRuleRecommended 
M2DN6_DM2Cell = M2DN6_DM2CellIn AND M2DN6_DM2CellOut
M2DN6_DM2Marker = DUM2 AND RRuleRecommended
M2DN6_DM2 = ((M2DN6_DM2Cell OR M2DN6_DM2Marker) NOT Block ) NOT excludeRRuleRecommended


M2DN6_M2x = M2DN6_M2 OR M2DN6_DM2
M2DN6_M2_CHECK = M2DN6_M2x NOT NEW_DEN_EXC
M2DN6_CHIP_CHECK = (CHIP NOT NEW_DEN_EXC) NOT excludeRRuleRecommended

#IFDEF FULL_CHIP
M2DN6_CHIP_M2 = COPY CHIP
#ELSE
M2DN6_CHIP_M2 = CHIP INTERACT M2DN6_M2x
#ENDIF

RR:RE:S:M2DN6 { @ Recommend metal Desnsity >= ^M2_DN_6_R for IP level. All condition-A, condition-B and condition-C must be followed.
@ (1) Condition-A: For IP level, recommend metal density [window ^M2_DN_6_W_A_R um x ^M2_DN_6_W_A_R um, stepping ^M2_DN_6_S_A_R um] >= ^M2_DN_6_R
@ (2) Condition-B: For IP level, recommend maximum area of merged low density windows [window ^M2_DN_6_W_BC_R um x ^M2_DN_6_W_BC_R um, stepping ^M2_DN_6_S_BC_R um < ^M2_DN_6_R] <= ^M2_DN_6_A_B_R um2, except merged low density windows width <= ^M2_DN_6_U_R um
@ (3) Condition-C: For IP level, recommend maximum area of merged low density windows [window ^M2_DN_6_W_BC_R um x ^M2_DN_6_W_BC_R um, stepping ^M2_DN_6_S_BC_R um < ^M2_DN_6_R] <= ^M2_DN_6_A_C_R um2
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M2_DN_6_E_A_R um for condition-A and >= ^M2_DN_6_E_BC_R um for both condition-B/condition-C 
  // Condition-A
  M2DN6_ERR_WIN_A = DENSITY M2DN6_M2_CHECK M2DN6_CHIP_CHECK < M2_DN_6_R WINDOW M2_DN_6_W_A_R STEP M2_DN_6_S_A_R INSIDE OF LAYER M2DN6_CHIP_M2 BACKUP
	[ AREA(M2DN6_M2_CHECK)/AREA(M2DN6_CHIP_CHECK) ]
  M2DN6_F_A = WITH WIDTH (M2DN6_ERR_WIN_A NOT NEW_DEN_EXC) >= M2_DN_6_E_A_R
  DENSITY M2DN6_F_A M2DN6_M2_CHECK M2DN6_CHIP_CHECK < M2_DN_6_R WINDOW M2_DN_6_W_A_R STEP M2_DN_6_S_A_R INSIDE OF LAYER M2DN6_CHIP_M2 BACKUP PRINT M2DN6R_A.density
         [ !AREA(M2DN6_F_A)+AREA(M2DN6_M2_CHECK)/AREA(M2DN6_CHIP_CHECK) ]
  // Condition-B	 
  M2DN6_ERR_WIN_B = DENSITY M2DN6_M2_CHECK M2DN6_CHIP_CHECK < M2_DN_6_R WINDOW M2_DN_6_W_BC_R STEP M2_DN_6_S_BC_R INSIDE OF LAYER M2DN6_CHIP_M2 BACKUP 
	[ AREA(M2DN6_M2_CHECK)/AREA(M2DN6_CHIP_CHECK) ]
  M2DN6_F_B = WITH WIDTH (M2DN6_ERR_WIN_B NOT NEW_DEN_EXC) >= M2_DN_6_E_BC_R
  M2DN6_A = DENSITY M2DN6_F_B M2DN6_M2_CHECK M2DN6_CHIP_CHECK < M2_DN_6_R WINDOW M2_DN_6_W_BC_R STEP M2_DN_6_S_BC_R INSIDE OF LAYER M2DN6_CHIP_M2 BACKUP PRINT M2DN6R_BC.density
         [ !AREA(M2DN6_F_B)+AREA(M2DN6_M2_CHECK)/AREA(M2DN6_CHIP_CHECK) ]
  M2DN6_B = AREA M2DN6_A > M2_DN_6_A_B_R
  M2DN6_C = SIZE M2DN6_B BY M2_DN_6_U_R/2 UNDEROVER
  M2DN6_B INTERACT M2DN6_C
  // Condition-C
  AREA M2DN6_B > M2_DN_6_A_C_R
}
#ENDIF

#IFDEF _M3S7_
M3S7_M3CellIn = INSIDE CELL M3i CellsForRRuleRecommended  
M3S7_M3CellOut = NOT INSIDE CELL M3i ExclCellsForRRuleRecommended 
M3S7_M3Cell = M3S7_M3CellIn AND M3S7_M3CellOut
M3S7_M3Marker = M3i AND RRuleRecommended
M3S7_M3 = ((M3S7_M3Cell OR M3S7_M3Marker) NOT Block ) NOT excludeRRuleRecommended

M3S7_DM3CellIn = INSIDE CELL DUM3 CellsForRRuleRecommended  
M3S7_DM3CellOut = NOT INSIDE CELL DUM3 ExclCellsForRRuleRecommended 
M3S7_DM3Cell = M3S7_DM3CellIn AND M3S7_DM3CellOut
M3S7_DM3Marker = DUM3 AND RRuleRecommended
M3S7_DM3 = ((M3S7_DM3Cell OR M3S7_DM3Marker) NOT Block ) NOT excludeRRuleRecommended

M3S7_M3x = M3S7_M3 OR M3S7_DM3
M3S7_NOT_M3x = CHIP NOT M3x
M3S7_BIGAREA = AREA M3S7_NOT_M3x > BIG_AREA
M3S7_ERROR = (EXT M3S7_BIGAREA M3S7_NOT_M3x < M3_S_7_R SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M3S7_M3x 

RR:RE:S:M3S7 { @ Space between two non-M3 regions >= ^M3_S_7_R um [ one of the non-M3 area > ^BIG_AREA ]
  COPY M3S7_ERROR 
}
#ENDIF 
#IFDEF _M3DN6_
M3DN6_M3CellIn = INSIDE CELL M3i CellsForRRuleRecommended  
M3DN6_M3CellOut = NOT INSIDE CELL M3i ExclCellsForRRuleRecommended 
M3DN6_M3Cell = M3DN6_M3CellIn AND M3DN6_M3CellOut
M3DN6_M3Marker = M3i AND RRuleRecommended
M3DN6_M3 = ((M3DN6_M3Cell OR M3DN6_M3Marker) NOT Block ) NOT excludeRRuleRecommended

M3DN6_DM3CellIn = INSIDE CELL DUM3 CellsForRRuleRecommended  
M3DN6_DM3CellOut = NOT INSIDE CELL DUM3 ExclCellsForRRuleRecommended 
M3DN6_DM3Cell = M3DN6_DM3CellIn AND M3DN6_DM3CellOut
M3DN6_DM3Marker = DUM3 AND RRuleRecommended
M3DN6_DM3 = ((M3DN6_DM3Cell OR M3DN6_DM3Marker) NOT Block ) NOT excludeRRuleRecommended


M3DN6_M3x = M3DN6_M3 OR M3DN6_DM3
M3DN6_M3_CHECK = M3DN6_M3x NOT NEW_DEN_EXC
M3DN6_CHIP_CHECK = (CHIP NOT NEW_DEN_EXC) NOT excludeRRuleRecommended

#IFDEF FULL_CHIP
M3DN6_CHIP_M3 = COPY CHIP
#ELSE
M3DN6_CHIP_M3 = CHIP INTERACT M3DN6_M3x
#ENDIF

RR:RE:S:M3DN6 { @ Recommend metal Desnsity >= ^M3_DN_6_R for IP level. All condition-A, condition-B and condition-C must be followed.
@ (1) Condition-A: For IP level, recommend metal density [window ^M3_DN_6_W_A_R um x ^M3_DN_6_W_A_R um, stepping ^M3_DN_6_S_A_R um] >= ^M3_DN_6_R
@ (2) Condition-B: For IP level, recommend maximum area of merged low density windows [window ^M3_DN_6_W_BC_R um x ^M3_DN_6_W_BC_R um, stepping ^M3_DN_6_S_BC_R um < ^M3_DN_6_R] <= ^M3_DN_6_A_B_R um2, except merged low density windows width <= ^M3_DN_6_U_R um
@ (3) Condition-C: For IP level, recommend maximum area of merged low density windows [window ^M3_DN_6_W_BC_R um x ^M3_DN_6_W_BC_R um, stepping ^M3_DN_6_S_BC_R um < ^M3_DN_6_R] <= ^M3_DN_6_A_C_R um2
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M3_DN_6_E_A_R um for condition-A and >= ^M3_DN_6_E_BC_R um for both condition-B/condition-C 
  // Condition-A
  M3DN6_ERR_WIN_A = DENSITY M3DN6_M3_CHECK M3DN6_CHIP_CHECK < M3_DN_6_R WINDOW M3_DN_6_W_A_R STEP M3_DN_6_S_A_R INSIDE OF LAYER M3DN6_CHIP_M3 BACKUP
	[ AREA(M3DN6_M3_CHECK)/AREA(M3DN6_CHIP_CHECK) ]
  M3DN6_F_A = WITH WIDTH (M3DN6_ERR_WIN_A NOT NEW_DEN_EXC) >= M3_DN_6_E_A_R
  DENSITY M3DN6_F_A M3DN6_M3_CHECK M3DN6_CHIP_CHECK < M3_DN_6_R WINDOW M3_DN_6_W_A_R STEP M3_DN_6_S_A_R INSIDE OF LAYER M3DN6_CHIP_M3 BACKUP PRINT M3DN6R_A.density
         [ !AREA(M3DN6_F_A)+AREA(M3DN6_M3_CHECK)/AREA(M3DN6_CHIP_CHECK) ]
  // Condition-B	 
  M3DN6_ERR_WIN_B = DENSITY M3DN6_M3_CHECK M3DN6_CHIP_CHECK < M3_DN_6_R WINDOW M3_DN_6_W_BC_R STEP M3_DN_6_S_BC_R INSIDE OF LAYER M3DN6_CHIP_M3 BACKUP 
	[ AREA(M3DN6_M3_CHECK)/AREA(M3DN6_CHIP_CHECK) ]
  M3DN6_F_B = WITH WIDTH (M3DN6_ERR_WIN_B NOT NEW_DEN_EXC) >= M3_DN_6_E_BC_R
  M3DN6_A = DENSITY M3DN6_F_B M3DN6_M3_CHECK M3DN6_CHIP_CHECK < M3_DN_6_R WINDOW M3_DN_6_W_BC_R STEP M3_DN_6_S_BC_R INSIDE OF LAYER M3DN6_CHIP_M3 BACKUP PRINT M3DN6R_BC.density
         [ !AREA(M3DN6_F_B)+AREA(M3DN6_M3_CHECK)/AREA(M3DN6_CHIP_CHECK) ]
  M3DN6_B = AREA M3DN6_A > M3_DN_6_A_B_R
  M3DN6_C = SIZE M3DN6_B BY M3_DN_6_U_R/2 UNDEROVER
  M3DN6_B INTERACT M3DN6_C
  // Condition-C
  AREA M3DN6_B > M3_DN_6_A_C_R
}
#ENDIF
#IFDEF _MxDN7_M1_M2_M3_
MxDN7_M1_M2_M3_M1CellIn = INSIDE CELL M1i CellsForRRuleRecommended  
MxDN7_M1_M2_M3_M1CellOut = NOT INSIDE CELL M1i ExclCellsForRRuleRecommended 
MxDN7_M1_M2_M3_M1Cell = MxDN7_M1_M2_M3_M1CellIn AND MxDN7_M1_M2_M3_M1CellOut
MxDN7_M1_M2_M3_M1Marker = M1i AND RRuleRecommended
MxDN7_M1_M2_M3_M1 = ((MxDN7_M1_M2_M3_M1Cell OR MxDN7_M1_M2_M3_M1Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M1_M2_M3_DM1CellIn = INSIDE CELL DUM1 CellsForRRuleRecommended  
MxDN7_M1_M2_M3_DM1CellOut = NOT INSIDE CELL DUM1 ExclCellsForRRuleRecommended 
MxDN7_M1_M2_M3_DM1Cell = MxDN7_M1_M2_M3_DM1CellIn AND MxDN7_M1_M2_M3_DM1CellOut
MxDN7_M1_M2_M3_DM1Marker = DUM1 AND RRuleRecommended
MxDN7_M1_M2_M3_DM1 = ((MxDN7_M1_M2_M3_DM1Cell OR MxDN7_M1_M2_M3_DM1Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M1_M2_M3_M2CellIn = INSIDE CELL M2i CellsForRRuleRecommended  
MxDN7_M1_M2_M3_M2CellOut = NOT INSIDE CELL M2i ExclCellsForRRuleRecommended 
MxDN7_M1_M2_M3_M2Cell = MxDN7_M1_M2_M3_M2CellIn AND MxDN7_M1_M2_M3_M2CellOut
MxDN7_M1_M2_M3_M2Marker = M2i AND RRuleRecommended
MxDN7_M1_M2_M3_M2 = ((MxDN7_M1_M2_M3_M2Cell OR MxDN7_M1_M2_M3_M2Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M1_M2_M3_DM2CellIn = INSIDE CELL DUM2 CellsForRRuleRecommended  
MxDN7_M1_M2_M3_DM2CellOut = NOT INSIDE CELL DUM2 ExclCellsForRRuleRecommended 
MxDN7_M1_M2_M3_DM2Cell = MxDN7_M1_M2_M3_DM2CellIn AND MxDN7_M1_M2_M3_DM2CellOut
MxDN7_M1_M2_M3_DM2Marker = DUM2 AND RRuleRecommended
MxDN7_M1_M2_M3_DM2 = ((MxDN7_M1_M2_M3_DM2Cell OR MxDN7_M1_M2_M3_DM2Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M1_M2_M3_M3CellIn = INSIDE CELL M3i CellsForRRuleRecommended  
MxDN7_M1_M2_M3_M3CellOut = NOT INSIDE CELL M3i ExclCellsForRRuleRecommended 
MxDN7_M1_M2_M3_M3Cell = MxDN7_M1_M2_M3_M3CellIn AND MxDN7_M1_M2_M3_M3CellOut
MxDN7_M1_M2_M3_M3Marker = M3i AND RRuleRecommended
MxDN7_M1_M2_M3_M3 = ((MxDN7_M1_M2_M3_M3Cell OR MxDN7_M1_M2_M3_M3Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M1_M2_M3_DM3CellIn = INSIDE CELL DUM3 CellsForRRuleRecommended  
MxDN7_M1_M2_M3_DM3CellOut = NOT INSIDE CELL DUM3 ExclCellsForRRuleRecommended 
MxDN7_M1_M2_M3_DM3Cell = MxDN7_M1_M2_M3_DM3CellIn AND MxDN7_M1_M2_M3_DM3CellOut
MxDN7_M1_M2_M3_DM3Marker = DUM3 AND RRuleRecommended
MxDN7_M1_M2_M3_DM3 = ((MxDN7_M1_M2_M3_DM3Cell OR MxDN7_M1_M2_M3_DM3Marker) NOT Block ) NOT excludeRRuleRecommended


MxDN7_M1_M2_M3_M1x = MxDN7_M1_M2_M3_M1 OR MxDN7_M1_M2_M3_DM1
MxDN7_M1_M2_M3_M2x = MxDN7_M1_M2_M3_M2 OR MxDN7_M1_M2_M3_DM2
MxDN7_M1_M2_M3_M3x = MxDN7_M1_M2_M3_M3 OR MxDN7_M1_M2_M3_DM3

MxDN7_M1_M2_M3_M1_CHECK = MxDN7_M1_M2_M3_M1x NOT NEW_DEN_EXC
MxDN7_M1_M2_M3_M2_CHECK = MxDN7_M1_M2_M3_M2x NOT NEW_DEN_EXC
MxDN7_M1_M2_M3_M3_CHECK = MxDN7_M1_M2_M3_M3x NOT NEW_DEN_EXC
MxDN7_M1_M2_M3_CHIP_CHECK = (CHIP NOT NEW_DEN_EXC) NOT excludeRRuleRecommended

#IFDEF FULL_CHIP
MxDN7_M1_M2_M3_CHIP_M3 = COPY CHIP
#ELSE
MxDN7_M1_M2_M3_CHIP_M3 = CHIP INTERACT MxDN7_M1_M2_M3_M3x
#ENDIF

RR:RE:S:MxDN7_M1_M2_M3 { @ It is not recommended to have local density < ^M1_DN_7_R of all 3 consecutive metal layer(M1, M2, M3) over any ^M1_DN_7_W_R um x ^M1_DN_7_W_R um window (stepping ^M1_DN_7_S_R um) for IP level, i.e. it is allowed for either one of M1, M2, or M3 to have a local density >= ^M1_DN_7_R.
@ 1. The metal layers include M1/Mx and dummy metals 
@ 2. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 3. This rule is applied while the width of (checking window NOT above excluding region) >= ^M1_DN_7_E_R um 
   MxDN7_M1_M2_M3_ERR_WIN = DENSITY MxDN7_M1_M2_M3_M1_CHECK MxDN7_M1_M2_M3_M2_CHECK MxDN7_M1_M2_M3_M3_CHECK MxDN7_M1_M2_M3_CHIP_CHECK >0 WINDOW M1_DN_7_W_R STEP M1_DN_7_S_R BACKUP INSIDE OF LAYER MxDN7_M1_M2_M3_CHIP_M3
   [ !~(M1_DN_7_R-AREA(MxDN7_M1_M2_M3_M1_CHECK)/AREA(MxDN7_M1_M2_M3_CHIP_CHECK))*!~(M1_DN_7_R-AREA(MxDN7_M1_M2_M3_M2_CHECK)/AREA(MxDN7_M1_M2_M3_CHIP_CHECK))*!~(M1_DN_7_R-AREA(MxDN7_M1_M2_M3_M3_CHECK)/AREA(MxDN7_M1_M2_M3_CHIP_CHECK)) ]
   MxDN7_M1_M2_M3_F = WITH WIDTH (MxDN7_M1_M2_M3_ERR_WIN NOT NEW_DEN_EXC) >= M1_DN_7_E_R
   DENSITY MxDN7_M1_M2_M3_F MxDN7_M1_M2_M3_M1_CHECK MxDN7_M1_M2_M3_M2_CHECK MxDN7_M1_M2_M3_M3_CHECK MxDN7_M1_M2_M3_CHIP_CHECK >0 WINDOW M1_DN_7_W_R STEP M1_DN_7_S_R BACKUP INSIDE OF LAYER MxDN7_M1_M2_M3_CHIP_M3
   [ !!AREA(MxDN7_M1_M2_M3_F)*!~(M1_DN_7_R-AREA(MxDN7_M1_M2_M3_M1_CHECK)/AREA(MxDN7_M1_M2_M3_CHIP_CHECK))*!~(M1_DN_7_R-AREA(MxDN7_M1_M2_M3_M2_CHECK)/AREA(MxDN7_M1_M2_M3_CHIP_CHECK))*!~(M1_DN_7_R-AREA(MxDN7_M1_M2_M3_M3_CHECK)/AREA(MxDN7_M1_M2_M3_CHIP_CHECK)) ]
   RDB MxDN7R_M1_M2_M3.density
}
#ENDIF

#IFDEF _M4S7_
M4S7_M4CellIn = INSIDE CELL M4i CellsForRRuleRecommended  
M4S7_M4CellOut = NOT INSIDE CELL M4i ExclCellsForRRuleRecommended 
M4S7_M4Cell = M4S7_M4CellIn AND M4S7_M4CellOut
M4S7_M4Marker = M4i AND RRuleRecommended
M4S7_M4 = ((M4S7_M4Cell OR M4S7_M4Marker) NOT Block ) NOT excludeRRuleRecommended

M4S7_DM4CellIn = INSIDE CELL DUM4 CellsForRRuleRecommended  
M4S7_DM4CellOut = NOT INSIDE CELL DUM4 ExclCellsForRRuleRecommended 
M4S7_DM4Cell = M4S7_DM4CellIn AND M4S7_DM4CellOut
M4S7_DM4Marker = DUM4 AND RRuleRecommended
M4S7_DM4 = ((M4S7_DM4Cell OR M4S7_DM4Marker) NOT Block ) NOT excludeRRuleRecommended

M4S7_M4x = M4S7_M4 OR M4S7_DM4
M4S7_NOT_M4x = CHIP NOT M4x
M4S7_BIGAREA = AREA M4S7_NOT_M4x > BIG_AREA
M4S7_ERROR = (EXT M4S7_BIGAREA M4S7_NOT_M4x < M4_S_7_R SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M4S7_M4x 

RR:RE:S:M4S7 { @ Space between two non-M4 regions >= ^M4_S_7_R um [ one of the non-M4 area > ^BIG_AREA ]
  COPY M4S7_ERROR 
}
#ENDIF 
#IFDEF _M4DN6_
M4DN6_M4CellIn = INSIDE CELL M4i CellsForRRuleRecommended  
M4DN6_M4CellOut = NOT INSIDE CELL M4i ExclCellsForRRuleRecommended 
M4DN6_M4Cell = M4DN6_M4CellIn AND M4DN6_M4CellOut
M4DN6_M4Marker = M4i AND RRuleRecommended
M4DN6_M4 = ((M4DN6_M4Cell OR M4DN6_M4Marker) NOT Block ) NOT excludeRRuleRecommended

M4DN6_DM4CellIn = INSIDE CELL DUM4 CellsForRRuleRecommended  
M4DN6_DM4CellOut = NOT INSIDE CELL DUM4 ExclCellsForRRuleRecommended 
M4DN6_DM4Cell = M4DN6_DM4CellIn AND M4DN6_DM4CellOut
M4DN6_DM4Marker = DUM4 AND RRuleRecommended
M4DN6_DM4 = ((M4DN6_DM4Cell OR M4DN6_DM4Marker) NOT Block ) NOT excludeRRuleRecommended


M4DN6_M4x = M4DN6_M4 OR M4DN6_DM4
M4DN6_M4_CHECK = M4DN6_M4x NOT NEW_DEN_EXC
M4DN6_CHIP_CHECK = (CHIP NOT NEW_DEN_EXC) NOT excludeRRuleRecommended

#IFDEF FULL_CHIP
M4DN6_CHIP_M4 = COPY CHIP
#ELSE
M4DN6_CHIP_M4 = CHIP INTERACT M4DN6_M4x
#ENDIF

RR:RE:S:M4DN6 { @ Recommend metal Desnsity >= ^M4_DN_6_R for IP level. All condition-A, condition-B and condition-C must be followed.
@ (1) Condition-A: For IP level, recommend metal density [window ^M4_DN_6_W_A_R um x ^M4_DN_6_W_A_R um, stepping ^M4_DN_6_S_A_R um] >= ^M4_DN_6_R
@ (2) Condition-B: For IP level, recommend maximum area of merged low density windows [window ^M4_DN_6_W_BC_R um x ^M4_DN_6_W_BC_R um, stepping ^M4_DN_6_S_BC_R um < ^M4_DN_6_R] <= ^M4_DN_6_A_B_R um2, except merged low density windows width <= ^M4_DN_6_U_R um
@ (3) Condition-C: For IP level, recommend maximum area of merged low density windows [window ^M4_DN_6_W_BC_R um x ^M4_DN_6_W_BC_R um, stepping ^M4_DN_6_S_BC_R um < ^M4_DN_6_R] <= ^M4_DN_6_A_C_R um2
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M4_DN_6_E_A_R um for condition-A and >= ^M4_DN_6_E_BC_R um for both condition-B/condition-C 
  // Condition-A
  M4DN6_ERR_WIN_A = DENSITY M4DN6_M4_CHECK M4DN6_CHIP_CHECK < M4_DN_6_R WINDOW M4_DN_6_W_A_R STEP M4_DN_6_S_A_R INSIDE OF LAYER M4DN6_CHIP_M4 BACKUP
	[ AREA(M4DN6_M4_CHECK)/AREA(M4DN6_CHIP_CHECK) ]
  M4DN6_F_A = WITH WIDTH (M4DN6_ERR_WIN_A NOT NEW_DEN_EXC) >= M4_DN_6_E_A_R
  DENSITY M4DN6_F_A M4DN6_M4_CHECK M4DN6_CHIP_CHECK < M4_DN_6_R WINDOW M4_DN_6_W_A_R STEP M4_DN_6_S_A_R INSIDE OF LAYER M4DN6_CHIP_M4 BACKUP PRINT M4DN6R_A.density
         [ !AREA(M4DN6_F_A)+AREA(M4DN6_M4_CHECK)/AREA(M4DN6_CHIP_CHECK) ]
  // Condition-B	 
  M4DN6_ERR_WIN_B = DENSITY M4DN6_M4_CHECK M4DN6_CHIP_CHECK < M4_DN_6_R WINDOW M4_DN_6_W_BC_R STEP M4_DN_6_S_BC_R INSIDE OF LAYER M4DN6_CHIP_M4 BACKUP 
	[ AREA(M4DN6_M4_CHECK)/AREA(M4DN6_CHIP_CHECK) ]
  M4DN6_F_B = WITH WIDTH (M4DN6_ERR_WIN_B NOT NEW_DEN_EXC) >= M4_DN_6_E_BC_R
  M4DN6_A = DENSITY M4DN6_F_B M4DN6_M4_CHECK M4DN6_CHIP_CHECK < M4_DN_6_R WINDOW M4_DN_6_W_BC_R STEP M4_DN_6_S_BC_R INSIDE OF LAYER M4DN6_CHIP_M4 BACKUP PRINT M4DN6R_BC.density
         [ !AREA(M4DN6_F_B)+AREA(M4DN6_M4_CHECK)/AREA(M4DN6_CHIP_CHECK) ]
  M4DN6_B = AREA M4DN6_A > M4_DN_6_A_B_R
  M4DN6_C = SIZE M4DN6_B BY M4_DN_6_U_R/2 UNDEROVER
  M4DN6_B INTERACT M4DN6_C
  // Condition-C
  AREA M4DN6_B > M4_DN_6_A_C_R
}
#ENDIF
#IFDEF _MxDN7_M2_M3_M4_
MxDN7_M2_M3_M4_M2CellIn = INSIDE CELL M2i CellsForRRuleRecommended  
MxDN7_M2_M3_M4_M2CellOut = NOT INSIDE CELL M2i ExclCellsForRRuleRecommended 
MxDN7_M2_M3_M4_M2Cell = MxDN7_M2_M3_M4_M2CellIn AND MxDN7_M2_M3_M4_M2CellOut
MxDN7_M2_M3_M4_M2Marker = M2i AND RRuleRecommended
MxDN7_M2_M3_M4_M2 = ((MxDN7_M2_M3_M4_M2Cell OR MxDN7_M2_M3_M4_M2Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M2_M3_M4_DM2CellIn = INSIDE CELL DUM2 CellsForRRuleRecommended  
MxDN7_M2_M3_M4_DM2CellOut = NOT INSIDE CELL DUM2 ExclCellsForRRuleRecommended 
MxDN7_M2_M3_M4_DM2Cell = MxDN7_M2_M3_M4_DM2CellIn AND MxDN7_M2_M3_M4_DM2CellOut
MxDN7_M2_M3_M4_DM2Marker = DUM2 AND RRuleRecommended
MxDN7_M2_M3_M4_DM2 = ((MxDN7_M2_M3_M4_DM2Cell OR MxDN7_M2_M3_M4_DM2Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M2_M3_M4_M3CellIn = INSIDE CELL M3i CellsForRRuleRecommended  
MxDN7_M2_M3_M4_M3CellOut = NOT INSIDE CELL M3i ExclCellsForRRuleRecommended 
MxDN7_M2_M3_M4_M3Cell = MxDN7_M2_M3_M4_M3CellIn AND MxDN7_M2_M3_M4_M3CellOut
MxDN7_M2_M3_M4_M3Marker = M3i AND RRuleRecommended
MxDN7_M2_M3_M4_M3 = ((MxDN7_M2_M3_M4_M3Cell OR MxDN7_M2_M3_M4_M3Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M2_M3_M4_DM3CellIn = INSIDE CELL DUM3 CellsForRRuleRecommended  
MxDN7_M2_M3_M4_DM3CellOut = NOT INSIDE CELL DUM3 ExclCellsForRRuleRecommended 
MxDN7_M2_M3_M4_DM3Cell = MxDN7_M2_M3_M4_DM3CellIn AND MxDN7_M2_M3_M4_DM3CellOut
MxDN7_M2_M3_M4_DM3Marker = DUM3 AND RRuleRecommended
MxDN7_M2_M3_M4_DM3 = ((MxDN7_M2_M3_M4_DM3Cell OR MxDN7_M2_M3_M4_DM3Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M2_M3_M4_M4CellIn = INSIDE CELL M4i CellsForRRuleRecommended  
MxDN7_M2_M3_M4_M4CellOut = NOT INSIDE CELL M4i ExclCellsForRRuleRecommended 
MxDN7_M2_M3_M4_M4Cell = MxDN7_M2_M3_M4_M4CellIn AND MxDN7_M2_M3_M4_M4CellOut
MxDN7_M2_M3_M4_M4Marker = M4i AND RRuleRecommended
MxDN7_M2_M3_M4_M4 = ((MxDN7_M2_M3_M4_M4Cell OR MxDN7_M2_M3_M4_M4Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M2_M3_M4_DM4CellIn = INSIDE CELL DUM4 CellsForRRuleRecommended  
MxDN7_M2_M3_M4_DM4CellOut = NOT INSIDE CELL DUM4 ExclCellsForRRuleRecommended 
MxDN7_M2_M3_M4_DM4Cell = MxDN7_M2_M3_M4_DM4CellIn AND MxDN7_M2_M3_M4_DM4CellOut
MxDN7_M2_M3_M4_DM4Marker = DUM4 AND RRuleRecommended
MxDN7_M2_M3_M4_DM4 = ((MxDN7_M2_M3_M4_DM4Cell OR MxDN7_M2_M3_M4_DM4Marker) NOT Block ) NOT excludeRRuleRecommended


MxDN7_M2_M3_M4_M2x = MxDN7_M2_M3_M4_M2 OR MxDN7_M2_M3_M4_DM2
MxDN7_M2_M3_M4_M3x = MxDN7_M2_M3_M4_M3 OR MxDN7_M2_M3_M4_DM3
MxDN7_M2_M3_M4_M4x = MxDN7_M2_M3_M4_M4 OR MxDN7_M2_M3_M4_DM4

MxDN7_M2_M3_M4_M2_CHECK = MxDN7_M2_M3_M4_M2x NOT NEW_DEN_EXC
MxDN7_M2_M3_M4_M3_CHECK = MxDN7_M2_M3_M4_M3x NOT NEW_DEN_EXC
MxDN7_M2_M3_M4_M4_CHECK = MxDN7_M2_M3_M4_M4x NOT NEW_DEN_EXC
MxDN7_M2_M3_M4_CHIP_CHECK = (CHIP NOT NEW_DEN_EXC) NOT excludeRRuleRecommended

#IFDEF FULL_CHIP
MxDN7_M2_M3_M4_CHIP_M4 = COPY CHIP
#ELSE
MxDN7_M2_M3_M4_CHIP_M4 = CHIP INTERACT MxDN7_M2_M3_M4_M4x
#ENDIF

RR:RE:S:MxDN7_M2_M3_M4 { @ It is not recommended to have local density < ^M2_DN_7_R of all 3 consecutive metal layer(M2, M3, M4) over any ^M2_DN_7_W_R um x ^M2_DN_7_W_R um window (stepping ^M2_DN_7_S_R um) for IP level, i.e. it is allowed for either one of M2, M3, or M4 to have a local density >= ^M2_DN_7_R.
@ 1. The metal layers include M1/Mx and dummy metals 
@ 2. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 3. This rule is applied while the width of (checking window NOT above excluding region) >= ^M2_DN_7_E_R um 
   MxDN7_M2_M3_M4_ERR_WIN = DENSITY MxDN7_M2_M3_M4_M2_CHECK MxDN7_M2_M3_M4_M3_CHECK MxDN7_M2_M3_M4_M4_CHECK MxDN7_M2_M3_M4_CHIP_CHECK >0 WINDOW M2_DN_7_W_R STEP M2_DN_7_S_R BACKUP INSIDE OF LAYER MxDN7_M2_M3_M4_CHIP_M4
   [ !~(M2_DN_7_R-AREA(MxDN7_M2_M3_M4_M2_CHECK)/AREA(MxDN7_M2_M3_M4_CHIP_CHECK))*!~(M2_DN_7_R-AREA(MxDN7_M2_M3_M4_M3_CHECK)/AREA(MxDN7_M2_M3_M4_CHIP_CHECK))*!~(M2_DN_7_R-AREA(MxDN7_M2_M3_M4_M4_CHECK)/AREA(MxDN7_M2_M3_M4_CHIP_CHECK)) ]
   MxDN7_M2_M3_M4_F = WITH WIDTH (MxDN7_M2_M3_M4_ERR_WIN NOT NEW_DEN_EXC) >= M2_DN_7_E_R
   DENSITY MxDN7_M2_M3_M4_F MxDN7_M2_M3_M4_M2_CHECK MxDN7_M2_M3_M4_M3_CHECK MxDN7_M2_M3_M4_M4_CHECK MxDN7_M2_M3_M4_CHIP_CHECK >0 WINDOW M2_DN_7_W_R STEP M2_DN_7_S_R BACKUP INSIDE OF LAYER MxDN7_M2_M3_M4_CHIP_M4
   [ !!AREA(MxDN7_M2_M3_M4_F)*!~(M2_DN_7_R-AREA(MxDN7_M2_M3_M4_M2_CHECK)/AREA(MxDN7_M2_M3_M4_CHIP_CHECK))*!~(M2_DN_7_R-AREA(MxDN7_M2_M3_M4_M3_CHECK)/AREA(MxDN7_M2_M3_M4_CHIP_CHECK))*!~(M2_DN_7_R-AREA(MxDN7_M2_M3_M4_M4_CHECK)/AREA(MxDN7_M2_M3_M4_CHIP_CHECK)) ]
   RDB MxDN7R_M2_M3_M4.density
}
#ENDIF

#IFDEF _M5S7_
M5S7_M5CellIn = INSIDE CELL M5i CellsForRRuleRecommended  
M5S7_M5CellOut = NOT INSIDE CELL M5i ExclCellsForRRuleRecommended 
M5S7_M5Cell = M5S7_M5CellIn AND M5S7_M5CellOut
M5S7_M5Marker = M5i AND RRuleRecommended
M5S7_M5 = ((M5S7_M5Cell OR M5S7_M5Marker) NOT Block ) NOT excludeRRuleRecommended

M5S7_DM5CellIn = INSIDE CELL DUM5 CellsForRRuleRecommended  
M5S7_DM5CellOut = NOT INSIDE CELL DUM5 ExclCellsForRRuleRecommended 
M5S7_DM5Cell = M5S7_DM5CellIn AND M5S7_DM5CellOut
M5S7_DM5Marker = DUM5 AND RRuleRecommended
M5S7_DM5 = ((M5S7_DM5Cell OR M5S7_DM5Marker) NOT Block ) NOT excludeRRuleRecommended

M5S7_M5x = M5S7_M5 OR M5S7_DM5
M5S7_NOT_M5x = CHIP NOT M5x
M5S7_BIGAREA = AREA M5S7_NOT_M5x > BIG_AREA
M5S7_ERROR = (EXT M5S7_BIGAREA M5S7_NOT_M5x < M5_S_7_R SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M5S7_M5x 

RR:RE:S:M5S7 { @ Space between two non-M5 regions >= ^M5_S_7_R um [ one of the non-M5 area > ^BIG_AREA ]
  COPY M5S7_ERROR 
}
#ENDIF 
#IFDEF _M5DN6_
M5DN6_M5CellIn = INSIDE CELL M5i CellsForRRuleRecommended  
M5DN6_M5CellOut = NOT INSIDE CELL M5i ExclCellsForRRuleRecommended 
M5DN6_M5Cell = M5DN6_M5CellIn AND M5DN6_M5CellOut
M5DN6_M5Marker = M5i AND RRuleRecommended
M5DN6_M5 = ((M5DN6_M5Cell OR M5DN6_M5Marker) NOT Block ) NOT excludeRRuleRecommended

M5DN6_DM5CellIn = INSIDE CELL DUM5 CellsForRRuleRecommended  
M5DN6_DM5CellOut = NOT INSIDE CELL DUM5 ExclCellsForRRuleRecommended 
M5DN6_DM5Cell = M5DN6_DM5CellIn AND M5DN6_DM5CellOut
M5DN6_DM5Marker = DUM5 AND RRuleRecommended
M5DN6_DM5 = ((M5DN6_DM5Cell OR M5DN6_DM5Marker) NOT Block ) NOT excludeRRuleRecommended


M5DN6_M5x = M5DN6_M5 OR M5DN6_DM5
M5DN6_M5_CHECK = M5DN6_M5x NOT NEW_DEN_EXC
M5DN6_CHIP_CHECK = (CHIP NOT NEW_DEN_EXC) NOT excludeRRuleRecommended

#IFDEF FULL_CHIP
M5DN6_CHIP_M5 = COPY CHIP
#ELSE
M5DN6_CHIP_M5 = CHIP INTERACT M5DN6_M5x
#ENDIF

RR:RE:S:M5DN6 { @ Recommend metal Desnsity >= ^M5_DN_6_R for IP level. All condition-A, condition-B and condition-C must be followed.
@ (1) Condition-A: For IP level, recommend metal density [window ^M5_DN_6_W_A_R um x ^M5_DN_6_W_A_R um, stepping ^M5_DN_6_S_A_R um] >= ^M5_DN_6_R
@ (2) Condition-B: For IP level, recommend maximum area of merged low density windows [window ^M5_DN_6_W_BC_R um x ^M5_DN_6_W_BC_R um, stepping ^M5_DN_6_S_BC_R um < ^M5_DN_6_R] <= ^M5_DN_6_A_B_R um2, except merged low density windows width <= ^M5_DN_6_U_R um
@ (3) Condition-C: For IP level, recommend maximum area of merged low density windows [window ^M5_DN_6_W_BC_R um x ^M5_DN_6_W_BC_R um, stepping ^M5_DN_6_S_BC_R um < ^M5_DN_6_R] <= ^M5_DN_6_A_C_R um2
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M5_DN_6_E_A_R um for condition-A and >= ^M5_DN_6_E_BC_R um for both condition-B/condition-C 
  // Condition-A
  M5DN6_ERR_WIN_A = DENSITY M5DN6_M5_CHECK M5DN6_CHIP_CHECK < M5_DN_6_R WINDOW M5_DN_6_W_A_R STEP M5_DN_6_S_A_R INSIDE OF LAYER M5DN6_CHIP_M5 BACKUP
	[ AREA(M5DN6_M5_CHECK)/AREA(M5DN6_CHIP_CHECK) ]
  M5DN6_F_A = WITH WIDTH (M5DN6_ERR_WIN_A NOT NEW_DEN_EXC) >= M5_DN_6_E_A_R
  DENSITY M5DN6_F_A M5DN6_M5_CHECK M5DN6_CHIP_CHECK < M5_DN_6_R WINDOW M5_DN_6_W_A_R STEP M5_DN_6_S_A_R INSIDE OF LAYER M5DN6_CHIP_M5 BACKUP PRINT M5DN6R_A.density
         [ !AREA(M5DN6_F_A)+AREA(M5DN6_M5_CHECK)/AREA(M5DN6_CHIP_CHECK) ]
  // Condition-B	 
  M5DN6_ERR_WIN_B = DENSITY M5DN6_M5_CHECK M5DN6_CHIP_CHECK < M5_DN_6_R WINDOW M5_DN_6_W_BC_R STEP M5_DN_6_S_BC_R INSIDE OF LAYER M5DN6_CHIP_M5 BACKUP 
	[ AREA(M5DN6_M5_CHECK)/AREA(M5DN6_CHIP_CHECK) ]
  M5DN6_F_B = WITH WIDTH (M5DN6_ERR_WIN_B NOT NEW_DEN_EXC) >= M5_DN_6_E_BC_R
  M5DN6_A = DENSITY M5DN6_F_B M5DN6_M5_CHECK M5DN6_CHIP_CHECK < M5_DN_6_R WINDOW M5_DN_6_W_BC_R STEP M5_DN_6_S_BC_R INSIDE OF LAYER M5DN6_CHIP_M5 BACKUP PRINT M5DN6R_BC.density
         [ !AREA(M5DN6_F_B)+AREA(M5DN6_M5_CHECK)/AREA(M5DN6_CHIP_CHECK) ]
  M5DN6_B = AREA M5DN6_A > M5_DN_6_A_B_R
  M5DN6_C = SIZE M5DN6_B BY M5_DN_6_U_R/2 UNDEROVER
  M5DN6_B INTERACT M5DN6_C
  // Condition-C
  AREA M5DN6_B > M5_DN_6_A_C_R
}
#ENDIF
#IFDEF _MxDN7_M3_M4_M5_
MxDN7_M3_M4_M5_M3CellIn = INSIDE CELL M3i CellsForRRuleRecommended  
MxDN7_M3_M4_M5_M3CellOut = NOT INSIDE CELL M3i ExclCellsForRRuleRecommended 
MxDN7_M3_M4_M5_M3Cell = MxDN7_M3_M4_M5_M3CellIn AND MxDN7_M3_M4_M5_M3CellOut
MxDN7_M3_M4_M5_M3Marker = M3i AND RRuleRecommended
MxDN7_M3_M4_M5_M3 = ((MxDN7_M3_M4_M5_M3Cell OR MxDN7_M3_M4_M5_M3Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M3_M4_M5_DM3CellIn = INSIDE CELL DUM3 CellsForRRuleRecommended  
MxDN7_M3_M4_M5_DM3CellOut = NOT INSIDE CELL DUM3 ExclCellsForRRuleRecommended 
MxDN7_M3_M4_M5_DM3Cell = MxDN7_M3_M4_M5_DM3CellIn AND MxDN7_M3_M4_M5_DM3CellOut
MxDN7_M3_M4_M5_DM3Marker = DUM3 AND RRuleRecommended
MxDN7_M3_M4_M5_DM3 = ((MxDN7_M3_M4_M5_DM3Cell OR MxDN7_M3_M4_M5_DM3Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M3_M4_M5_M4CellIn = INSIDE CELL M4i CellsForRRuleRecommended  
MxDN7_M3_M4_M5_M4CellOut = NOT INSIDE CELL M4i ExclCellsForRRuleRecommended 
MxDN7_M3_M4_M5_M4Cell = MxDN7_M3_M4_M5_M4CellIn AND MxDN7_M3_M4_M5_M4CellOut
MxDN7_M3_M4_M5_M4Marker = M4i AND RRuleRecommended
MxDN7_M3_M4_M5_M4 = ((MxDN7_M3_M4_M5_M4Cell OR MxDN7_M3_M4_M5_M4Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M3_M4_M5_DM4CellIn = INSIDE CELL DUM4 CellsForRRuleRecommended  
MxDN7_M3_M4_M5_DM4CellOut = NOT INSIDE CELL DUM4 ExclCellsForRRuleRecommended 
MxDN7_M3_M4_M5_DM4Cell = MxDN7_M3_M4_M5_DM4CellIn AND MxDN7_M3_M4_M5_DM4CellOut
MxDN7_M3_M4_M5_DM4Marker = DUM4 AND RRuleRecommended
MxDN7_M3_M4_M5_DM4 = ((MxDN7_M3_M4_M5_DM4Cell OR MxDN7_M3_M4_M5_DM4Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M3_M4_M5_M5CellIn = INSIDE CELL M5i CellsForRRuleRecommended  
MxDN7_M3_M4_M5_M5CellOut = NOT INSIDE CELL M5i ExclCellsForRRuleRecommended 
MxDN7_M3_M4_M5_M5Cell = MxDN7_M3_M4_M5_M5CellIn AND MxDN7_M3_M4_M5_M5CellOut
MxDN7_M3_M4_M5_M5Marker = M5i AND RRuleRecommended
MxDN7_M3_M4_M5_M5 = ((MxDN7_M3_M4_M5_M5Cell OR MxDN7_M3_M4_M5_M5Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M3_M4_M5_DM5CellIn = INSIDE CELL DUM5 CellsForRRuleRecommended  
MxDN7_M3_M4_M5_DM5CellOut = NOT INSIDE CELL DUM5 ExclCellsForRRuleRecommended 
MxDN7_M3_M4_M5_DM5Cell = MxDN7_M3_M4_M5_DM5CellIn AND MxDN7_M3_M4_M5_DM5CellOut
MxDN7_M3_M4_M5_DM5Marker = DUM5 AND RRuleRecommended
MxDN7_M3_M4_M5_DM5 = ((MxDN7_M3_M4_M5_DM5Cell OR MxDN7_M3_M4_M5_DM5Marker) NOT Block ) NOT excludeRRuleRecommended


MxDN7_M3_M4_M5_M3x = MxDN7_M3_M4_M5_M3 OR MxDN7_M3_M4_M5_DM3
MxDN7_M3_M4_M5_M4x = MxDN7_M3_M4_M5_M4 OR MxDN7_M3_M4_M5_DM4
MxDN7_M3_M4_M5_M5x = MxDN7_M3_M4_M5_M5 OR MxDN7_M3_M4_M5_DM5

MxDN7_M3_M4_M5_M3_CHECK = MxDN7_M3_M4_M5_M3x NOT NEW_DEN_EXC
MxDN7_M3_M4_M5_M4_CHECK = MxDN7_M3_M4_M5_M4x NOT NEW_DEN_EXC
MxDN7_M3_M4_M5_M5_CHECK = MxDN7_M3_M4_M5_M5x NOT NEW_DEN_EXC
MxDN7_M3_M4_M5_CHIP_CHECK = (CHIP NOT NEW_DEN_EXC) NOT excludeRRuleRecommended

#IFDEF FULL_CHIP
MxDN7_M3_M4_M5_CHIP_M5 = COPY CHIP
#ELSE
MxDN7_M3_M4_M5_CHIP_M5 = CHIP INTERACT MxDN7_M3_M4_M5_M5x
#ENDIF

RR:RE:S:MxDN7_M3_M4_M5 { @ It is not recommended to have local density < ^M3_DN_7_R of all 3 consecutive metal layer(M3, M4, M5) over any ^M3_DN_7_W_R um x ^M3_DN_7_W_R um window (stepping ^M3_DN_7_S_R um) for IP level, i.e. it is allowed for either one of M3, M4, or M5 to have a local density >= ^M3_DN_7_R.
@ 1. The metal layers include M1/Mx and dummy metals 
@ 2. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 3. This rule is applied while the width of (checking window NOT above excluding region) >= ^M3_DN_7_E_R um 
   MxDN7_M3_M4_M5_ERR_WIN = DENSITY MxDN7_M3_M4_M5_M3_CHECK MxDN7_M3_M4_M5_M4_CHECK MxDN7_M3_M4_M5_M5_CHECK MxDN7_M3_M4_M5_CHIP_CHECK >0 WINDOW M3_DN_7_W_R STEP M3_DN_7_S_R BACKUP INSIDE OF LAYER MxDN7_M3_M4_M5_CHIP_M5
   [ !~(M3_DN_7_R-AREA(MxDN7_M3_M4_M5_M3_CHECK)/AREA(MxDN7_M3_M4_M5_CHIP_CHECK))*!~(M3_DN_7_R-AREA(MxDN7_M3_M4_M5_M4_CHECK)/AREA(MxDN7_M3_M4_M5_CHIP_CHECK))*!~(M3_DN_7_R-AREA(MxDN7_M3_M4_M5_M5_CHECK)/AREA(MxDN7_M3_M4_M5_CHIP_CHECK)) ]
   MxDN7_M3_M4_M5_F = WITH WIDTH (MxDN7_M3_M4_M5_ERR_WIN NOT NEW_DEN_EXC) >= M3_DN_7_E_R
   DENSITY MxDN7_M3_M4_M5_F MxDN7_M3_M4_M5_M3_CHECK MxDN7_M3_M4_M5_M4_CHECK MxDN7_M3_M4_M5_M5_CHECK MxDN7_M3_M4_M5_CHIP_CHECK >0 WINDOW M3_DN_7_W_R STEP M3_DN_7_S_R BACKUP INSIDE OF LAYER MxDN7_M3_M4_M5_CHIP_M5
   [ !!AREA(MxDN7_M3_M4_M5_F)*!~(M3_DN_7_R-AREA(MxDN7_M3_M4_M5_M3_CHECK)/AREA(MxDN7_M3_M4_M5_CHIP_CHECK))*!~(M3_DN_7_R-AREA(MxDN7_M3_M4_M5_M4_CHECK)/AREA(MxDN7_M3_M4_M5_CHIP_CHECK))*!~(M3_DN_7_R-AREA(MxDN7_M3_M4_M5_M5_CHECK)/AREA(MxDN7_M3_M4_M5_CHIP_CHECK)) ]
   RDB MxDN7R_M3_M4_M5.density
}
#ENDIF

#IFDEF _M6S7_
M6S7_M6CellIn = INSIDE CELL M6i CellsForRRuleRecommended  
M6S7_M6CellOut = NOT INSIDE CELL M6i ExclCellsForRRuleRecommended 
M6S7_M6Cell = M6S7_M6CellIn AND M6S7_M6CellOut
M6S7_M6Marker = M6i AND RRuleRecommended
M6S7_M6 = ((M6S7_M6Cell OR M6S7_M6Marker) NOT Block ) NOT excludeRRuleRecommended

M6S7_DM6CellIn = INSIDE CELL DUM6 CellsForRRuleRecommended  
M6S7_DM6CellOut = NOT INSIDE CELL DUM6 ExclCellsForRRuleRecommended 
M6S7_DM6Cell = M6S7_DM6CellIn AND M6S7_DM6CellOut
M6S7_DM6Marker = DUM6 AND RRuleRecommended
M6S7_DM6 = ((M6S7_DM6Cell OR M6S7_DM6Marker) NOT Block ) NOT excludeRRuleRecommended

M6S7_M6x = M6S7_M6 OR M6S7_DM6
M6S7_NOT_M6x = CHIP NOT M6x
M6S7_BIGAREA = AREA M6S7_NOT_M6x > BIG_AREA
M6S7_ERROR = (EXT M6S7_BIGAREA M6S7_NOT_M6x < M6_S_7_R SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M6S7_M6x 

RR:RE:S:M6S7 { @ Space between two non-M6 regions >= ^M6_S_7_R um [ one of the non-M6 area > ^BIG_AREA ]
  COPY M6S7_ERROR 
}
#ENDIF 
#IFDEF _M6DN6_
M6DN6_M6CellIn = INSIDE CELL M6i CellsForRRuleRecommended  
M6DN6_M6CellOut = NOT INSIDE CELL M6i ExclCellsForRRuleRecommended 
M6DN6_M6Cell = M6DN6_M6CellIn AND M6DN6_M6CellOut
M6DN6_M6Marker = M6i AND RRuleRecommended
M6DN6_M6 = ((M6DN6_M6Cell OR M6DN6_M6Marker) NOT Block ) NOT excludeRRuleRecommended

M6DN6_DM6CellIn = INSIDE CELL DUM6 CellsForRRuleRecommended  
M6DN6_DM6CellOut = NOT INSIDE CELL DUM6 ExclCellsForRRuleRecommended 
M6DN6_DM6Cell = M6DN6_DM6CellIn AND M6DN6_DM6CellOut
M6DN6_DM6Marker = DUM6 AND RRuleRecommended
M6DN6_DM6 = ((M6DN6_DM6Cell OR M6DN6_DM6Marker) NOT Block ) NOT excludeRRuleRecommended


M6DN6_M6x = M6DN6_M6 OR M6DN6_DM6
M6DN6_M6_CHECK = M6DN6_M6x NOT NEW_DEN_EXC
M6DN6_CHIP_CHECK = (CHIP NOT NEW_DEN_EXC) NOT excludeRRuleRecommended

#IFDEF FULL_CHIP
M6DN6_CHIP_M6 = COPY CHIP
#ELSE
M6DN6_CHIP_M6 = CHIP INTERACT M6DN6_M6x
#ENDIF

RR:RE:S:M6DN6 { @ Recommend metal Desnsity >= ^M6_DN_6_R for IP level. All condition-A, condition-B and condition-C must be followed.
@ (1) Condition-A: For IP level, recommend metal density [window ^M6_DN_6_W_A_R um x ^M6_DN_6_W_A_R um, stepping ^M6_DN_6_S_A_R um] >= ^M6_DN_6_R
@ (2) Condition-B: For IP level, recommend maximum area of merged low density windows [window ^M6_DN_6_W_BC_R um x ^M6_DN_6_W_BC_R um, stepping ^M6_DN_6_S_BC_R um < ^M6_DN_6_R] <= ^M6_DN_6_A_B_R um2, except merged low density windows width <= ^M6_DN_6_U_R um
@ (3) Condition-C: For IP level, recommend maximum area of merged low density windows [window ^M6_DN_6_W_BC_R um x ^M6_DN_6_W_BC_R um, stepping ^M6_DN_6_S_BC_R um < ^M6_DN_6_R] <= ^M6_DN_6_A_C_R um2
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M6_DN_6_E_A_R um for condition-A and >= ^M6_DN_6_E_BC_R um for both condition-B/condition-C 
  // Condition-A
  M6DN6_ERR_WIN_A = DENSITY M6DN6_M6_CHECK M6DN6_CHIP_CHECK < M6_DN_6_R WINDOW M6_DN_6_W_A_R STEP M6_DN_6_S_A_R INSIDE OF LAYER M6DN6_CHIP_M6 BACKUP
	[ AREA(M6DN6_M6_CHECK)/AREA(M6DN6_CHIP_CHECK) ]
  M6DN6_F_A = WITH WIDTH (M6DN6_ERR_WIN_A NOT NEW_DEN_EXC) >= M6_DN_6_E_A_R
  DENSITY M6DN6_F_A M6DN6_M6_CHECK M6DN6_CHIP_CHECK < M6_DN_6_R WINDOW M6_DN_6_W_A_R STEP M6_DN_6_S_A_R INSIDE OF LAYER M6DN6_CHIP_M6 BACKUP PRINT M6DN6R_A.density
         [ !AREA(M6DN6_F_A)+AREA(M6DN6_M6_CHECK)/AREA(M6DN6_CHIP_CHECK) ]
  // Condition-B	 
  M6DN6_ERR_WIN_B = DENSITY M6DN6_M6_CHECK M6DN6_CHIP_CHECK < M6_DN_6_R WINDOW M6_DN_6_W_BC_R STEP M6_DN_6_S_BC_R INSIDE OF LAYER M6DN6_CHIP_M6 BACKUP 
	[ AREA(M6DN6_M6_CHECK)/AREA(M6DN6_CHIP_CHECK) ]
  M6DN6_F_B = WITH WIDTH (M6DN6_ERR_WIN_B NOT NEW_DEN_EXC) >= M6_DN_6_E_BC_R
  M6DN6_A = DENSITY M6DN6_F_B M6DN6_M6_CHECK M6DN6_CHIP_CHECK < M6_DN_6_R WINDOW M6_DN_6_W_BC_R STEP M6_DN_6_S_BC_R INSIDE OF LAYER M6DN6_CHIP_M6 BACKUP PRINT M6DN6R_BC.density
         [ !AREA(M6DN6_F_B)+AREA(M6DN6_M6_CHECK)/AREA(M6DN6_CHIP_CHECK) ]
  M6DN6_B = AREA M6DN6_A > M6_DN_6_A_B_R
  M6DN6_C = SIZE M6DN6_B BY M6_DN_6_U_R/2 UNDEROVER
  M6DN6_B INTERACT M6DN6_C
  // Condition-C
  AREA M6DN6_B > M6_DN_6_A_C_R
}
#ENDIF
#IFDEF _MxDN7_M4_M5_M6_
MxDN7_M4_M5_M6_M4CellIn = INSIDE CELL M4i CellsForRRuleRecommended  
MxDN7_M4_M5_M6_M4CellOut = NOT INSIDE CELL M4i ExclCellsForRRuleRecommended 
MxDN7_M4_M5_M6_M4Cell = MxDN7_M4_M5_M6_M4CellIn AND MxDN7_M4_M5_M6_M4CellOut
MxDN7_M4_M5_M6_M4Marker = M4i AND RRuleRecommended
MxDN7_M4_M5_M6_M4 = ((MxDN7_M4_M5_M6_M4Cell OR MxDN7_M4_M5_M6_M4Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M4_M5_M6_DM4CellIn = INSIDE CELL DUM4 CellsForRRuleRecommended  
MxDN7_M4_M5_M6_DM4CellOut = NOT INSIDE CELL DUM4 ExclCellsForRRuleRecommended 
MxDN7_M4_M5_M6_DM4Cell = MxDN7_M4_M5_M6_DM4CellIn AND MxDN7_M4_M5_M6_DM4CellOut
MxDN7_M4_M5_M6_DM4Marker = DUM4 AND RRuleRecommended
MxDN7_M4_M5_M6_DM4 = ((MxDN7_M4_M5_M6_DM4Cell OR MxDN7_M4_M5_M6_DM4Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M4_M5_M6_M5CellIn = INSIDE CELL M5i CellsForRRuleRecommended  
MxDN7_M4_M5_M6_M5CellOut = NOT INSIDE CELL M5i ExclCellsForRRuleRecommended 
MxDN7_M4_M5_M6_M5Cell = MxDN7_M4_M5_M6_M5CellIn AND MxDN7_M4_M5_M6_M5CellOut
MxDN7_M4_M5_M6_M5Marker = M5i AND RRuleRecommended
MxDN7_M4_M5_M6_M5 = ((MxDN7_M4_M5_M6_M5Cell OR MxDN7_M4_M5_M6_M5Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M4_M5_M6_DM5CellIn = INSIDE CELL DUM5 CellsForRRuleRecommended  
MxDN7_M4_M5_M6_DM5CellOut = NOT INSIDE CELL DUM5 ExclCellsForRRuleRecommended 
MxDN7_M4_M5_M6_DM5Cell = MxDN7_M4_M5_M6_DM5CellIn AND MxDN7_M4_M5_M6_DM5CellOut
MxDN7_M4_M5_M6_DM5Marker = DUM5 AND RRuleRecommended
MxDN7_M4_M5_M6_DM5 = ((MxDN7_M4_M5_M6_DM5Cell OR MxDN7_M4_M5_M6_DM5Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M4_M5_M6_M6CellIn = INSIDE CELL M6i CellsForRRuleRecommended  
MxDN7_M4_M5_M6_M6CellOut = NOT INSIDE CELL M6i ExclCellsForRRuleRecommended 
MxDN7_M4_M5_M6_M6Cell = MxDN7_M4_M5_M6_M6CellIn AND MxDN7_M4_M5_M6_M6CellOut
MxDN7_M4_M5_M6_M6Marker = M6i AND RRuleRecommended
MxDN7_M4_M5_M6_M6 = ((MxDN7_M4_M5_M6_M6Cell OR MxDN7_M4_M5_M6_M6Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M4_M5_M6_DM6CellIn = INSIDE CELL DUM6 CellsForRRuleRecommended  
MxDN7_M4_M5_M6_DM6CellOut = NOT INSIDE CELL DUM6 ExclCellsForRRuleRecommended 
MxDN7_M4_M5_M6_DM6Cell = MxDN7_M4_M5_M6_DM6CellIn AND MxDN7_M4_M5_M6_DM6CellOut
MxDN7_M4_M5_M6_DM6Marker = DUM6 AND RRuleRecommended
MxDN7_M4_M5_M6_DM6 = ((MxDN7_M4_M5_M6_DM6Cell OR MxDN7_M4_M5_M6_DM6Marker) NOT Block ) NOT excludeRRuleRecommended


MxDN7_M4_M5_M6_M4x = MxDN7_M4_M5_M6_M4 OR MxDN7_M4_M5_M6_DM4
MxDN7_M4_M5_M6_M5x = MxDN7_M4_M5_M6_M5 OR MxDN7_M4_M5_M6_DM5
MxDN7_M4_M5_M6_M6x = MxDN7_M4_M5_M6_M6 OR MxDN7_M4_M5_M6_DM6

MxDN7_M4_M5_M6_M4_CHECK = MxDN7_M4_M5_M6_M4x NOT NEW_DEN_EXC
MxDN7_M4_M5_M6_M5_CHECK = MxDN7_M4_M5_M6_M5x NOT NEW_DEN_EXC
MxDN7_M4_M5_M6_M6_CHECK = MxDN7_M4_M5_M6_M6x NOT NEW_DEN_EXC
MxDN7_M4_M5_M6_CHIP_CHECK = (CHIP NOT NEW_DEN_EXC) NOT excludeRRuleRecommended

#IFDEF FULL_CHIP
MxDN7_M4_M5_M6_CHIP_M6 = COPY CHIP
#ELSE
MxDN7_M4_M5_M6_CHIP_M6 = CHIP INTERACT MxDN7_M4_M5_M6_M6x
#ENDIF

RR:RE:S:MxDN7_M4_M5_M6 { @ It is not recommended to have local density < ^M4_DN_7_R of all 3 consecutive metal layer(M4, M5, M6) over any ^M4_DN_7_W_R um x ^M4_DN_7_W_R um window (stepping ^M4_DN_7_S_R um) for IP level, i.e. it is allowed for either one of M4, M5, or M6 to have a local density >= ^M4_DN_7_R.
@ 1. The metal layers include M1/Mx and dummy metals 
@ 2. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 3. This rule is applied while the width of (checking window NOT above excluding region) >= ^M4_DN_7_E_R um 
   MxDN7_M4_M5_M6_ERR_WIN = DENSITY MxDN7_M4_M5_M6_M4_CHECK MxDN7_M4_M5_M6_M5_CHECK MxDN7_M4_M5_M6_M6_CHECK MxDN7_M4_M5_M6_CHIP_CHECK >0 WINDOW M4_DN_7_W_R STEP M4_DN_7_S_R BACKUP INSIDE OF LAYER MxDN7_M4_M5_M6_CHIP_M6
   [ !~(M4_DN_7_R-AREA(MxDN7_M4_M5_M6_M4_CHECK)/AREA(MxDN7_M4_M5_M6_CHIP_CHECK))*!~(M4_DN_7_R-AREA(MxDN7_M4_M5_M6_M5_CHECK)/AREA(MxDN7_M4_M5_M6_CHIP_CHECK))*!~(M4_DN_7_R-AREA(MxDN7_M4_M5_M6_M6_CHECK)/AREA(MxDN7_M4_M5_M6_CHIP_CHECK)) ]
   MxDN7_M4_M5_M6_F = WITH WIDTH (MxDN7_M4_M5_M6_ERR_WIN NOT NEW_DEN_EXC) >= M4_DN_7_E_R
   DENSITY MxDN7_M4_M5_M6_F MxDN7_M4_M5_M6_M4_CHECK MxDN7_M4_M5_M6_M5_CHECK MxDN7_M4_M5_M6_M6_CHECK MxDN7_M4_M5_M6_CHIP_CHECK >0 WINDOW M4_DN_7_W_R STEP M4_DN_7_S_R BACKUP INSIDE OF LAYER MxDN7_M4_M5_M6_CHIP_M6
   [ !!AREA(MxDN7_M4_M5_M6_F)*!~(M4_DN_7_R-AREA(MxDN7_M4_M5_M6_M4_CHECK)/AREA(MxDN7_M4_M5_M6_CHIP_CHECK))*!~(M4_DN_7_R-AREA(MxDN7_M4_M5_M6_M5_CHECK)/AREA(MxDN7_M4_M5_M6_CHIP_CHECK))*!~(M4_DN_7_R-AREA(MxDN7_M4_M5_M6_M6_CHECK)/AREA(MxDN7_M4_M5_M6_CHIP_CHECK)) ]
   RDB MxDN7R_M4_M5_M6.density
}
#ENDIF

#IFDEF _M7S7_
M7S7_M7CellIn = INSIDE CELL M7i CellsForRRuleRecommended  
M7S7_M7CellOut = NOT INSIDE CELL M7i ExclCellsForRRuleRecommended 
M7S7_M7Cell = M7S7_M7CellIn AND M7S7_M7CellOut
M7S7_M7Marker = M7i AND RRuleRecommended
M7S7_M7 = ((M7S7_M7Cell OR M7S7_M7Marker) NOT Block ) NOT excludeRRuleRecommended

M7S7_DM7CellIn = INSIDE CELL DUM7 CellsForRRuleRecommended  
M7S7_DM7CellOut = NOT INSIDE CELL DUM7 ExclCellsForRRuleRecommended 
M7S7_DM7Cell = M7S7_DM7CellIn AND M7S7_DM7CellOut
M7S7_DM7Marker = DUM7 AND RRuleRecommended
M7S7_DM7 = ((M7S7_DM7Cell OR M7S7_DM7Marker) NOT Block ) NOT excludeRRuleRecommended

M7S7_M7x = M7S7_M7 OR M7S7_DM7
M7S7_NOT_M7x = CHIP NOT M7x
M7S7_BIGAREA = AREA M7S7_NOT_M7x > BIG_AREA
M7S7_ERROR = (EXT M7S7_BIGAREA M7S7_NOT_M7x < M7_S_7_R SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M7S7_M7x 

RR:RE:S:M7S7 { @ Space between two non-M7 regions >= ^M7_S_7_R um [ one of the non-M7 area > ^BIG_AREA ]
  COPY M7S7_ERROR 
}
#ENDIF 
#IFDEF _M7DN6_
M7DN6_M7CellIn = INSIDE CELL M7i CellsForRRuleRecommended  
M7DN6_M7CellOut = NOT INSIDE CELL M7i ExclCellsForRRuleRecommended 
M7DN6_M7Cell = M7DN6_M7CellIn AND M7DN6_M7CellOut
M7DN6_M7Marker = M7i AND RRuleRecommended
M7DN6_M7 = ((M7DN6_M7Cell OR M7DN6_M7Marker) NOT Block ) NOT excludeRRuleRecommended

M7DN6_DM7CellIn = INSIDE CELL DUM7 CellsForRRuleRecommended  
M7DN6_DM7CellOut = NOT INSIDE CELL DUM7 ExclCellsForRRuleRecommended 
M7DN6_DM7Cell = M7DN6_DM7CellIn AND M7DN6_DM7CellOut
M7DN6_DM7Marker = DUM7 AND RRuleRecommended
M7DN6_DM7 = ((M7DN6_DM7Cell OR M7DN6_DM7Marker) NOT Block ) NOT excludeRRuleRecommended


M7DN6_M7x = M7DN6_M7 OR M7DN6_DM7
M7DN6_M7_CHECK = M7DN6_M7x NOT NEW_DEN_EXC
M7DN6_CHIP_CHECK = (CHIP NOT NEW_DEN_EXC) NOT excludeRRuleRecommended

#IFDEF FULL_CHIP
M7DN6_CHIP_M7 = COPY CHIP
#ELSE
M7DN6_CHIP_M7 = CHIP INTERACT M7DN6_M7x
#ENDIF

RR:RE:S:M7DN6 { @ Recommend metal Desnsity >= ^M7_DN_6_R for IP level. All condition-A, condition-B and condition-C must be followed.
@ (1) Condition-A: For IP level, recommend metal density [window ^M7_DN_6_W_A_R um x ^M7_DN_6_W_A_R um, stepping ^M7_DN_6_S_A_R um] >= ^M7_DN_6_R
@ (2) Condition-B: For IP level, recommend maximum area of merged low density windows [window ^M7_DN_6_W_BC_R um x ^M7_DN_6_W_BC_R um, stepping ^M7_DN_6_S_BC_R um < ^M7_DN_6_R] <= ^M7_DN_6_A_B_R um2, except merged low density windows width <= ^M7_DN_6_U_R um
@ (3) Condition-C: For IP level, recommend maximum area of merged low density windows [window ^M7_DN_6_W_BC_R um x ^M7_DN_6_W_BC_R um, stepping ^M7_DN_6_S_BC_R um < ^M7_DN_6_R] <= ^M7_DN_6_A_C_R um2
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M7_DN_6_E_A_R um for condition-A and >= ^M7_DN_6_E_BC_R um for both condition-B/condition-C 
  // Condition-A
  M7DN6_ERR_WIN_A = DENSITY M7DN6_M7_CHECK M7DN6_CHIP_CHECK < M7_DN_6_R WINDOW M7_DN_6_W_A_R STEP M7_DN_6_S_A_R INSIDE OF LAYER M7DN6_CHIP_M7 BACKUP
	[ AREA(M7DN6_M7_CHECK)/AREA(M7DN6_CHIP_CHECK) ]
  M7DN6_F_A = WITH WIDTH (M7DN6_ERR_WIN_A NOT NEW_DEN_EXC) >= M7_DN_6_E_A_R
  DENSITY M7DN6_F_A M7DN6_M7_CHECK M7DN6_CHIP_CHECK < M7_DN_6_R WINDOW M7_DN_6_W_A_R STEP M7_DN_6_S_A_R INSIDE OF LAYER M7DN6_CHIP_M7 BACKUP PRINT M7DN6R_A.density
         [ !AREA(M7DN6_F_A)+AREA(M7DN6_M7_CHECK)/AREA(M7DN6_CHIP_CHECK) ]
  // Condition-B	 
  M7DN6_ERR_WIN_B = DENSITY M7DN6_M7_CHECK M7DN6_CHIP_CHECK < M7_DN_6_R WINDOW M7_DN_6_W_BC_R STEP M7_DN_6_S_BC_R INSIDE OF LAYER M7DN6_CHIP_M7 BACKUP 
	[ AREA(M7DN6_M7_CHECK)/AREA(M7DN6_CHIP_CHECK) ]
  M7DN6_F_B = WITH WIDTH (M7DN6_ERR_WIN_B NOT NEW_DEN_EXC) >= M7_DN_6_E_BC_R
  M7DN6_A = DENSITY M7DN6_F_B M7DN6_M7_CHECK M7DN6_CHIP_CHECK < M7_DN_6_R WINDOW M7_DN_6_W_BC_R STEP M7_DN_6_S_BC_R INSIDE OF LAYER M7DN6_CHIP_M7 BACKUP PRINT M7DN6R_BC.density
         [ !AREA(M7DN6_F_B)+AREA(M7DN6_M7_CHECK)/AREA(M7DN6_CHIP_CHECK) ]
  M7DN6_B = AREA M7DN6_A > M7_DN_6_A_B_R
  M7DN6_C = SIZE M7DN6_B BY M7_DN_6_U_R/2 UNDEROVER
  M7DN6_B INTERACT M7DN6_C
  // Condition-C
  AREA M7DN6_B > M7_DN_6_A_C_R
}
#ENDIF
#IFDEF _MxDN7_M5_M6_M7_
MxDN7_M5_M6_M7_M5CellIn = INSIDE CELL M5i CellsForRRuleRecommended  
MxDN7_M5_M6_M7_M5CellOut = NOT INSIDE CELL M5i ExclCellsForRRuleRecommended 
MxDN7_M5_M6_M7_M5Cell = MxDN7_M5_M6_M7_M5CellIn AND MxDN7_M5_M6_M7_M5CellOut
MxDN7_M5_M6_M7_M5Marker = M5i AND RRuleRecommended
MxDN7_M5_M6_M7_M5 = ((MxDN7_M5_M6_M7_M5Cell OR MxDN7_M5_M6_M7_M5Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M5_M6_M7_DM5CellIn = INSIDE CELL DUM5 CellsForRRuleRecommended  
MxDN7_M5_M6_M7_DM5CellOut = NOT INSIDE CELL DUM5 ExclCellsForRRuleRecommended 
MxDN7_M5_M6_M7_DM5Cell = MxDN7_M5_M6_M7_DM5CellIn AND MxDN7_M5_M6_M7_DM5CellOut
MxDN7_M5_M6_M7_DM5Marker = DUM5 AND RRuleRecommended
MxDN7_M5_M6_M7_DM5 = ((MxDN7_M5_M6_M7_DM5Cell OR MxDN7_M5_M6_M7_DM5Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M5_M6_M7_M6CellIn = INSIDE CELL M6i CellsForRRuleRecommended  
MxDN7_M5_M6_M7_M6CellOut = NOT INSIDE CELL M6i ExclCellsForRRuleRecommended 
MxDN7_M5_M6_M7_M6Cell = MxDN7_M5_M6_M7_M6CellIn AND MxDN7_M5_M6_M7_M6CellOut
MxDN7_M5_M6_M7_M6Marker = M6i AND RRuleRecommended
MxDN7_M5_M6_M7_M6 = ((MxDN7_M5_M6_M7_M6Cell OR MxDN7_M5_M6_M7_M6Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M5_M6_M7_DM6CellIn = INSIDE CELL DUM6 CellsForRRuleRecommended  
MxDN7_M5_M6_M7_DM6CellOut = NOT INSIDE CELL DUM6 ExclCellsForRRuleRecommended 
MxDN7_M5_M6_M7_DM6Cell = MxDN7_M5_M6_M7_DM6CellIn AND MxDN7_M5_M6_M7_DM6CellOut
MxDN7_M5_M6_M7_DM6Marker = DUM6 AND RRuleRecommended
MxDN7_M5_M6_M7_DM6 = ((MxDN7_M5_M6_M7_DM6Cell OR MxDN7_M5_M6_M7_DM6Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M5_M6_M7_M7CellIn = INSIDE CELL M7i CellsForRRuleRecommended  
MxDN7_M5_M6_M7_M7CellOut = NOT INSIDE CELL M7i ExclCellsForRRuleRecommended 
MxDN7_M5_M6_M7_M7Cell = MxDN7_M5_M6_M7_M7CellIn AND MxDN7_M5_M6_M7_M7CellOut
MxDN7_M5_M6_M7_M7Marker = M7i AND RRuleRecommended
MxDN7_M5_M6_M7_M7 = ((MxDN7_M5_M6_M7_M7Cell OR MxDN7_M5_M6_M7_M7Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M5_M6_M7_DM7CellIn = INSIDE CELL DUM7 CellsForRRuleRecommended  
MxDN7_M5_M6_M7_DM7CellOut = NOT INSIDE CELL DUM7 ExclCellsForRRuleRecommended 
MxDN7_M5_M6_M7_DM7Cell = MxDN7_M5_M6_M7_DM7CellIn AND MxDN7_M5_M6_M7_DM7CellOut
MxDN7_M5_M6_M7_DM7Marker = DUM7 AND RRuleRecommended
MxDN7_M5_M6_M7_DM7 = ((MxDN7_M5_M6_M7_DM7Cell OR MxDN7_M5_M6_M7_DM7Marker) NOT Block ) NOT excludeRRuleRecommended


MxDN7_M5_M6_M7_M5x = MxDN7_M5_M6_M7_M5 OR MxDN7_M5_M6_M7_DM5
MxDN7_M5_M6_M7_M6x = MxDN7_M5_M6_M7_M6 OR MxDN7_M5_M6_M7_DM6
MxDN7_M5_M6_M7_M7x = MxDN7_M5_M6_M7_M7 OR MxDN7_M5_M6_M7_DM7

MxDN7_M5_M6_M7_M5_CHECK = MxDN7_M5_M6_M7_M5x NOT NEW_DEN_EXC
MxDN7_M5_M6_M7_M6_CHECK = MxDN7_M5_M6_M7_M6x NOT NEW_DEN_EXC
MxDN7_M5_M6_M7_M7_CHECK = MxDN7_M5_M6_M7_M7x NOT NEW_DEN_EXC
MxDN7_M5_M6_M7_CHIP_CHECK = (CHIP NOT NEW_DEN_EXC) NOT excludeRRuleRecommended

#IFDEF FULL_CHIP
MxDN7_M5_M6_M7_CHIP_M7 = COPY CHIP
#ELSE
MxDN7_M5_M6_M7_CHIP_M7 = CHIP INTERACT MxDN7_M5_M6_M7_M7x
#ENDIF

RR:RE:S:MxDN7_M5_M6_M7 { @ It is not recommended to have local density < ^M5_DN_7_R of all 3 consecutive metal layer(M5, M6, M7) over any ^M5_DN_7_W_R um x ^M5_DN_7_W_R um window (stepping ^M5_DN_7_S_R um) for IP level, i.e. it is allowed for either one of M5, M6, or M7 to have a local density >= ^M5_DN_7_R.
@ 1. The metal layers include M1/Mx and dummy metals 
@ 2. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 3. This rule is applied while the width of (checking window NOT above excluding region) >= ^M5_DN_7_E_R um 
   MxDN7_M5_M6_M7_ERR_WIN = DENSITY MxDN7_M5_M6_M7_M5_CHECK MxDN7_M5_M6_M7_M6_CHECK MxDN7_M5_M6_M7_M7_CHECK MxDN7_M5_M6_M7_CHIP_CHECK >0 WINDOW M5_DN_7_W_R STEP M5_DN_7_S_R BACKUP INSIDE OF LAYER MxDN7_M5_M6_M7_CHIP_M7
   [ !~(M5_DN_7_R-AREA(MxDN7_M5_M6_M7_M5_CHECK)/AREA(MxDN7_M5_M6_M7_CHIP_CHECK))*!~(M5_DN_7_R-AREA(MxDN7_M5_M6_M7_M6_CHECK)/AREA(MxDN7_M5_M6_M7_CHIP_CHECK))*!~(M5_DN_7_R-AREA(MxDN7_M5_M6_M7_M7_CHECK)/AREA(MxDN7_M5_M6_M7_CHIP_CHECK)) ]
   MxDN7_M5_M6_M7_F = WITH WIDTH (MxDN7_M5_M6_M7_ERR_WIN NOT NEW_DEN_EXC) >= M5_DN_7_E_R
   DENSITY MxDN7_M5_M6_M7_F MxDN7_M5_M6_M7_M5_CHECK MxDN7_M5_M6_M7_M6_CHECK MxDN7_M5_M6_M7_M7_CHECK MxDN7_M5_M6_M7_CHIP_CHECK >0 WINDOW M5_DN_7_W_R STEP M5_DN_7_S_R BACKUP INSIDE OF LAYER MxDN7_M5_M6_M7_CHIP_M7
   [ !!AREA(MxDN7_M5_M6_M7_F)*!~(M5_DN_7_R-AREA(MxDN7_M5_M6_M7_M5_CHECK)/AREA(MxDN7_M5_M6_M7_CHIP_CHECK))*!~(M5_DN_7_R-AREA(MxDN7_M5_M6_M7_M6_CHECK)/AREA(MxDN7_M5_M6_M7_CHIP_CHECK))*!~(M5_DN_7_R-AREA(MxDN7_M5_M6_M7_M7_CHECK)/AREA(MxDN7_M5_M6_M7_CHIP_CHECK)) ]
   RDB MxDN7R_M5_M6_M7.density
}
#ENDIF

#IFDEF _M8S7_
M8S7_M8CellIn = INSIDE CELL M8i CellsForRRuleRecommended  
M8S7_M8CellOut = NOT INSIDE CELL M8i ExclCellsForRRuleRecommended 
M8S7_M8Cell = M8S7_M8CellIn AND M8S7_M8CellOut
M8S7_M8Marker = M8i AND RRuleRecommended
M8S7_M8 = ((M8S7_M8Cell OR M8S7_M8Marker) NOT Block ) NOT excludeRRuleRecommended

M8S7_DM8CellIn = INSIDE CELL DUM8 CellsForRRuleRecommended  
M8S7_DM8CellOut = NOT INSIDE CELL DUM8 ExclCellsForRRuleRecommended 
M8S7_DM8Cell = M8S7_DM8CellIn AND M8S7_DM8CellOut
M8S7_DM8Marker = DUM8 AND RRuleRecommended
M8S7_DM8 = ((M8S7_DM8Cell OR M8S7_DM8Marker) NOT Block ) NOT excludeRRuleRecommended

M8S7_M8x = M8S7_M8 OR M8S7_DM8
M8S7_NOT_M8x = CHIP NOT M8x
M8S7_BIGAREA = AREA M8S7_NOT_M8x > BIG_AREA
M8S7_ERROR = (EXT M8S7_BIGAREA M8S7_NOT_M8x < M8_S_7_R SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M8S7_M8x 

RR:RE:S:M8S7 { @ Space between two non-M8 regions >= ^M8_S_7_R um [ one of the non-M8 area > ^BIG_AREA ]
  COPY M8S7_ERROR 
}
#ENDIF 
#IFDEF _M8DN6_
M8DN6_M8CellIn = INSIDE CELL M8i CellsForRRuleRecommended  
M8DN6_M8CellOut = NOT INSIDE CELL M8i ExclCellsForRRuleRecommended 
M8DN6_M8Cell = M8DN6_M8CellIn AND M8DN6_M8CellOut
M8DN6_M8Marker = M8i AND RRuleRecommended
M8DN6_M8 = ((M8DN6_M8Cell OR M8DN6_M8Marker) NOT Block ) NOT excludeRRuleRecommended

M8DN6_DM8CellIn = INSIDE CELL DUM8 CellsForRRuleRecommended  
M8DN6_DM8CellOut = NOT INSIDE CELL DUM8 ExclCellsForRRuleRecommended 
M8DN6_DM8Cell = M8DN6_DM8CellIn AND M8DN6_DM8CellOut
M8DN6_DM8Marker = DUM8 AND RRuleRecommended
M8DN6_DM8 = ((M8DN6_DM8Cell OR M8DN6_DM8Marker) NOT Block ) NOT excludeRRuleRecommended


M8DN6_M8x = M8DN6_M8 OR M8DN6_DM8
M8DN6_M8_CHECK = M8DN6_M8x NOT NEW_DEN_EXC
M8DN6_CHIP_CHECK = (CHIP NOT NEW_DEN_EXC) NOT excludeRRuleRecommended

#IFDEF FULL_CHIP
M8DN6_CHIP_M8 = COPY CHIP
#ELSE
M8DN6_CHIP_M8 = CHIP INTERACT M8DN6_M8x
#ENDIF

RR:RE:S:M8DN6 { @ Recommend metal Desnsity >= ^M8_DN_6_R for IP level. All condition-A, condition-B and condition-C must be followed.
@ (1) Condition-A: For IP level, recommend metal density [window ^M8_DN_6_W_A_R um x ^M8_DN_6_W_A_R um, stepping ^M8_DN_6_S_A_R um] >= ^M8_DN_6_R
@ (2) Condition-B: For IP level, recommend maximum area of merged low density windows [window ^M8_DN_6_W_BC_R um x ^M8_DN_6_W_BC_R um, stepping ^M8_DN_6_S_BC_R um < ^M8_DN_6_R] <= ^M8_DN_6_A_B_R um2, except merged low density windows width <= ^M8_DN_6_U_R um
@ (3) Condition-C: For IP level, recommend maximum area of merged low density windows [window ^M8_DN_6_W_BC_R um x ^M8_DN_6_W_BC_R um, stepping ^M8_DN_6_S_BC_R um < ^M8_DN_6_R] <= ^M8_DN_6_A_C_R um2
@ 1. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 2. This rule is applied while the width of (checking window NOT above excluding region) >= ^M8_DN_6_E_A_R um for condition-A and >= ^M8_DN_6_E_BC_R um for both condition-B/condition-C 
  // Condition-A
  M8DN6_ERR_WIN_A = DENSITY M8DN6_M8_CHECK M8DN6_CHIP_CHECK < M8_DN_6_R WINDOW M8_DN_6_W_A_R STEP M8_DN_6_S_A_R INSIDE OF LAYER M8DN6_CHIP_M8 BACKUP
	[ AREA(M8DN6_M8_CHECK)/AREA(M8DN6_CHIP_CHECK) ]
  M8DN6_F_A = WITH WIDTH (M8DN6_ERR_WIN_A NOT NEW_DEN_EXC) >= M8_DN_6_E_A_R
  DENSITY M8DN6_F_A M8DN6_M8_CHECK M8DN6_CHIP_CHECK < M8_DN_6_R WINDOW M8_DN_6_W_A_R STEP M8_DN_6_S_A_R INSIDE OF LAYER M8DN6_CHIP_M8 BACKUP PRINT M8DN6R_A.density
         [ !AREA(M8DN6_F_A)+AREA(M8DN6_M8_CHECK)/AREA(M8DN6_CHIP_CHECK) ]
  // Condition-B	 
  M8DN6_ERR_WIN_B = DENSITY M8DN6_M8_CHECK M8DN6_CHIP_CHECK < M8_DN_6_R WINDOW M8_DN_6_W_BC_R STEP M8_DN_6_S_BC_R INSIDE OF LAYER M8DN6_CHIP_M8 BACKUP 
	[ AREA(M8DN6_M8_CHECK)/AREA(M8DN6_CHIP_CHECK) ]
  M8DN6_F_B = WITH WIDTH (M8DN6_ERR_WIN_B NOT NEW_DEN_EXC) >= M8_DN_6_E_BC_R
  M8DN6_A = DENSITY M8DN6_F_B M8DN6_M8_CHECK M8DN6_CHIP_CHECK < M8_DN_6_R WINDOW M8_DN_6_W_BC_R STEP M8_DN_6_S_BC_R INSIDE OF LAYER M8DN6_CHIP_M8 BACKUP PRINT M8DN6R_BC.density
         [ !AREA(M8DN6_F_B)+AREA(M8DN6_M8_CHECK)/AREA(M8DN6_CHIP_CHECK) ]
  M8DN6_B = AREA M8DN6_A > M8_DN_6_A_B_R
  M8DN6_C = SIZE M8DN6_B BY M8_DN_6_U_R/2 UNDEROVER
  M8DN6_B INTERACT M8DN6_C
  // Condition-C
  AREA M8DN6_B > M8_DN_6_A_C_R
}
#ENDIF
#IFDEF _MxDN7_M6_M7_M8_
MxDN7_M6_M7_M8_M6CellIn = INSIDE CELL M6i CellsForRRuleRecommended  
MxDN7_M6_M7_M8_M6CellOut = NOT INSIDE CELL M6i ExclCellsForRRuleRecommended 
MxDN7_M6_M7_M8_M6Cell = MxDN7_M6_M7_M8_M6CellIn AND MxDN7_M6_M7_M8_M6CellOut
MxDN7_M6_M7_M8_M6Marker = M6i AND RRuleRecommended
MxDN7_M6_M7_M8_M6 = ((MxDN7_M6_M7_M8_M6Cell OR MxDN7_M6_M7_M8_M6Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M6_M7_M8_DM6CellIn = INSIDE CELL DUM6 CellsForRRuleRecommended  
MxDN7_M6_M7_M8_DM6CellOut = NOT INSIDE CELL DUM6 ExclCellsForRRuleRecommended 
MxDN7_M6_M7_M8_DM6Cell = MxDN7_M6_M7_M8_DM6CellIn AND MxDN7_M6_M7_M8_DM6CellOut
MxDN7_M6_M7_M8_DM6Marker = DUM6 AND RRuleRecommended
MxDN7_M6_M7_M8_DM6 = ((MxDN7_M6_M7_M8_DM6Cell OR MxDN7_M6_M7_M8_DM6Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M6_M7_M8_M7CellIn = INSIDE CELL M7i CellsForRRuleRecommended  
MxDN7_M6_M7_M8_M7CellOut = NOT INSIDE CELL M7i ExclCellsForRRuleRecommended 
MxDN7_M6_M7_M8_M7Cell = MxDN7_M6_M7_M8_M7CellIn AND MxDN7_M6_M7_M8_M7CellOut
MxDN7_M6_M7_M8_M7Marker = M7i AND RRuleRecommended
MxDN7_M6_M7_M8_M7 = ((MxDN7_M6_M7_M8_M7Cell OR MxDN7_M6_M7_M8_M7Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M6_M7_M8_DM7CellIn = INSIDE CELL DUM7 CellsForRRuleRecommended  
MxDN7_M6_M7_M8_DM7CellOut = NOT INSIDE CELL DUM7 ExclCellsForRRuleRecommended 
MxDN7_M6_M7_M8_DM7Cell = MxDN7_M6_M7_M8_DM7CellIn AND MxDN7_M6_M7_M8_DM7CellOut
MxDN7_M6_M7_M8_DM7Marker = DUM7 AND RRuleRecommended
MxDN7_M6_M7_M8_DM7 = ((MxDN7_M6_M7_M8_DM7Cell OR MxDN7_M6_M7_M8_DM7Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M6_M7_M8_M8CellIn = INSIDE CELL M8i CellsForRRuleRecommended  
MxDN7_M6_M7_M8_M8CellOut = NOT INSIDE CELL M8i ExclCellsForRRuleRecommended 
MxDN7_M6_M7_M8_M8Cell = MxDN7_M6_M7_M8_M8CellIn AND MxDN7_M6_M7_M8_M8CellOut
MxDN7_M6_M7_M8_M8Marker = M8i AND RRuleRecommended
MxDN7_M6_M7_M8_M8 = ((MxDN7_M6_M7_M8_M8Cell OR MxDN7_M6_M7_M8_M8Marker) NOT Block ) NOT excludeRRuleRecommended

MxDN7_M6_M7_M8_DM8CellIn = INSIDE CELL DUM8 CellsForRRuleRecommended  
MxDN7_M6_M7_M8_DM8CellOut = NOT INSIDE CELL DUM8 ExclCellsForRRuleRecommended 
MxDN7_M6_M7_M8_DM8Cell = MxDN7_M6_M7_M8_DM8CellIn AND MxDN7_M6_M7_M8_DM8CellOut
MxDN7_M6_M7_M8_DM8Marker = DUM8 AND RRuleRecommended
MxDN7_M6_M7_M8_DM8 = ((MxDN7_M6_M7_M8_DM8Cell OR MxDN7_M6_M7_M8_DM8Marker) NOT Block ) NOT excludeRRuleRecommended


MxDN7_M6_M7_M8_M6x = MxDN7_M6_M7_M8_M6 OR MxDN7_M6_M7_M8_DM6
MxDN7_M6_M7_M8_M7x = MxDN7_M6_M7_M8_M7 OR MxDN7_M6_M7_M8_DM7
MxDN7_M6_M7_M8_M8x = MxDN7_M6_M7_M8_M8 OR MxDN7_M6_M7_M8_DM8

MxDN7_M6_M7_M8_M6_CHECK = MxDN7_M6_M7_M8_M6x NOT NEW_DEN_EXC
MxDN7_M6_M7_M8_M7_CHECK = MxDN7_M6_M7_M8_M7x NOT NEW_DEN_EXC
MxDN7_M6_M7_M8_M8_CHECK = MxDN7_M6_M7_M8_M8x NOT NEW_DEN_EXC
MxDN7_M6_M7_M8_CHIP_CHECK = (CHIP NOT NEW_DEN_EXC) NOT excludeRRuleRecommended

#IFDEF FULL_CHIP
MxDN7_M6_M7_M8_CHIP_M8 = COPY CHIP
#ELSE
MxDN7_M6_M7_M8_CHIP_M8 = CHIP INTERACT MxDN7_M6_M7_M8_M8x
#ENDIF

RR:RE:S:MxDN7_M6_M7_M8 { @ It is not recommended to have local density < ^M6_DN_7_R of all 3 consecutive metal layer(M6, M7, M8) over any ^M6_DN_7_W_R um x ^M6_DN_7_W_R um window (stepping ^M6_DN_7_S_R um) for IP level, i.e. it is allowed for either one of M6, M7, or M8 to have a local density >= ^M6_DN_7_R.
@ 1. The metal layers include M1/Mx and dummy metals 
@ 2. The following special regions are excluded while the density checking
@    Chip corner triangle empty areas if sealring is added by tsmc. 
@    LOWMEDN
@ 3. This rule is applied while the width of (checking window NOT above excluding region) >= ^M6_DN_7_E_R um 
   MxDN7_M6_M7_M8_ERR_WIN = DENSITY MxDN7_M6_M7_M8_M6_CHECK MxDN7_M6_M7_M8_M7_CHECK MxDN7_M6_M7_M8_M8_CHECK MxDN7_M6_M7_M8_CHIP_CHECK >0 WINDOW M6_DN_7_W_R STEP M6_DN_7_S_R BACKUP INSIDE OF LAYER MxDN7_M6_M7_M8_CHIP_M8
   [ !~(M6_DN_7_R-AREA(MxDN7_M6_M7_M8_M6_CHECK)/AREA(MxDN7_M6_M7_M8_CHIP_CHECK))*!~(M6_DN_7_R-AREA(MxDN7_M6_M7_M8_M7_CHECK)/AREA(MxDN7_M6_M7_M8_CHIP_CHECK))*!~(M6_DN_7_R-AREA(MxDN7_M6_M7_M8_M8_CHECK)/AREA(MxDN7_M6_M7_M8_CHIP_CHECK)) ]
   MxDN7_M6_M7_M8_F = WITH WIDTH (MxDN7_M6_M7_M8_ERR_WIN NOT NEW_DEN_EXC) >= M6_DN_7_E_R
   DENSITY MxDN7_M6_M7_M8_F MxDN7_M6_M7_M8_M6_CHECK MxDN7_M6_M7_M8_M7_CHECK MxDN7_M6_M7_M8_M8_CHECK MxDN7_M6_M7_M8_CHIP_CHECK >0 WINDOW M6_DN_7_W_R STEP M6_DN_7_S_R BACKUP INSIDE OF LAYER MxDN7_M6_M7_M8_CHIP_M8
   [ !!AREA(MxDN7_M6_M7_M8_F)*!~(M6_DN_7_R-AREA(MxDN7_M6_M7_M8_M6_CHECK)/AREA(MxDN7_M6_M7_M8_CHIP_CHECK))*!~(M6_DN_7_R-AREA(MxDN7_M6_M7_M8_M7_CHECK)/AREA(MxDN7_M6_M7_M8_CHIP_CHECK))*!~(M6_DN_7_R-AREA(MxDN7_M6_M7_M8_M8_CHECK)/AREA(MxDN7_M6_M7_M8_CHIP_CHECK)) ]
   RDB MxDN7R_M6_M7_M8.density
}
#ENDIF

#IFDEF _M9W3_
#IFDEF MIXED_SCHEME
M9W3_M9_OLDCellIn = INSIDE CELL M9_OLD CellsForRRuleRecommended  
M9W3_M9_OLDCellOut = NOT INSIDE CELL M9_OLD ExclCellsForRRuleRecommended 
M9W3_M9_OLDCell = M9W3_M9_OLDCellIn AND M9W3_M9_OLDCellOut
M9W3_M9_OLDMarker = M9_OLD AND RRuleRecommended
M9W3_M9_OLD = ((M9W3_M9_OLDCell OR M9W3_M9_OLDMarker) NOT Block ) NOT excludeRRuleRecommended

M9W3_M9_NEWCellIn = INSIDE CELL M9_NEW CellsForRRuleRecommended  
M9W3_M9_NEWCellOut = NOT INSIDE CELL M9_NEW ExclCellsForRRuleRecommended 
M9W3_M9_NEWCell = M9W3_M9_NEWCellIn AND M9W3_M9_NEWCellOut
M9W3_M9_NEWMarker = M9_NEW AND RRuleRecommended
M9W3_M9_NEW = ((M9W3_M9_NEWCell OR M9W3_M9_NEWMarker) NOT Block ) NOT excludeRRuleRecommended

M9W3_M9 = M9W3_M9_OLD OR M9W3_M9_NEW
#ELSE
M9W3_M9CellIn = INSIDE CELL M9_NEW CellsForRRuleRecommended  
M9W3_M9CellOut = NOT INSIDE CELL M9_NEW ExclCellsForRRuleRecommended 
M9W3_M9Cell = M9W3_M9CellIn AND M9W3_M9CellOut
M9W3_M9Marker = M9_NEW AND RRuleRecommended
M9W3_M9 = ((M9W3_M9Cell OR M9W3_M9Marker) NOT Block ) NOT excludeRRuleRecommended

#ENDIF
M9W3_EXT = CHIP NOT ( SIZE M8x BY (M9_W_3_S_R/2 - 0.001) OVERUNDER )
M9W3_BIG = SIZE( SIZE M9W3_EXT BY (M9_W_3_S_R/2 - 0.001) UNDEROVER ) BY M9_W_3_G_R
M9W3_CHECK = M9W3_M9 INSIDE EDGE M9W3_BIG
RR:RE:S:M9W3 { @ Recommended M9 width on (M8 OR DM8 with space>= ^M9_W_3_S_R x ^M9_W_3_S_R sizing ^M9_W_3_G_R) >= ^M9_W_3_R
  INT M9W3_CHECK < M9_W_3_R ABUT < 89.5 REGION 
}
#ENDIF

#IFDEF _M10W3_
#IFDEF MIXED_SCHEME
M10W3_M10_OLDCellIn = INSIDE CELL M10_OLD CellsForRRuleRecommended  
M10W3_M10_OLDCellOut = NOT INSIDE CELL M10_OLD ExclCellsForRRuleRecommended 
M10W3_M10_OLDCell = M10W3_M10_OLDCellIn AND M10W3_M10_OLDCellOut
M10W3_M10_OLDMarker = M10_OLD AND RRuleRecommended
M10W3_M10_OLD = ((M10W3_M10_OLDCell OR M10W3_M10_OLDMarker) NOT Block ) NOT excludeRRuleRecommended

M10W3_M10_NEWCellIn = INSIDE CELL M10_NEW CellsForRRuleRecommended  
M10W3_M10_NEWCellOut = NOT INSIDE CELL M10_NEW ExclCellsForRRuleRecommended 
M10W3_M10_NEWCell = M10W3_M10_NEWCellIn AND M10W3_M10_NEWCellOut
M10W3_M10_NEWMarker = M10_NEW AND RRuleRecommended
M10W3_M10_NEW = ((M10W3_M10_NEWCell OR M10W3_M10_NEWMarker) NOT Block ) NOT excludeRRuleRecommended

M10W3_M10 = M10W3_M10_OLD OR M10W3_M10_NEW
#ELSE
M10W3_M10CellIn = INSIDE CELL M10_NEW CellsForRRuleRecommended  
M10W3_M10CellOut = NOT INSIDE CELL M10_NEW ExclCellsForRRuleRecommended 
M10W3_M10Cell = M10W3_M10CellIn AND M10W3_M10CellOut
M10W3_M10Marker = M10_NEW AND RRuleRecommended
M10W3_M10 = ((M10W3_M10Cell OR M10W3_M10Marker) NOT Block ) NOT excludeRRuleRecommended

#ENDIF
M10W3_EXT = CHIP NOT ( SIZE M9x BY (M10_W_3_S_R/2 - 0.001) OVERUNDER )
M10W3_BIG = SIZE( SIZE M10W3_EXT BY (M10_W_3_S_R/2 - 0.001) UNDEROVER ) BY M10_W_3_G_R
M10W3_CHECK = M10W3_M10 INSIDE EDGE M10W3_BIG
RR:RE:S:M10W3 { @ Recommended M10 width on (M9 OR DM9 with space>= ^M10_W_3_S_R x ^M10_W_3_S_R sizing ^M10_W_3_G_R) >= ^M10_W_3_R
  INT M10W3_CHECK < M10_W_3_R ABUT < 89.5 REGION 
}
#ENDIF

#IFDEF _VIAxR8_

SINGLE_VIA1 = (VIA1 INTERACT ( (M1i AND M2i) INTERACT VIA1 == 1 )) NOT P_RING_VIA1
SINGLE_VIA2 = (VIA2 INTERACT ( (M2i AND M3i) INTERACT VIA2 == 1 )) NOT P_RING_VIA2
SINGLE_VIA3 = (VIA3 INTERACT ( (M3i AND M4i) INTERACT VIA3 == 1 )) NOT P_RING_VIA3
SINGLE_VIA4 = (VIA4 INTERACT ( (M4i AND M5i) INTERACT VIA4 == 1 )) NOT P_RING_VIA4
SINGLE_VIA5 = (VIA5 INTERACT ( (M5i AND M6i) INTERACT VIA5 == 1 )) NOT P_RING_VIA5
SINGLE_VIA6 = (VIA6 INTERACT ( (M6i AND M7i) INTERACT VIA6 == 1 )) NOT P_RING_VIA6
SINGLE_VIA7 = (VIA7 INTERACT ( (M7i AND M8i) INTERACT VIA7 == 1 )) NOT P_RING_VIA7

VIAxR8_V4CellIn = INSIDE CELL VIA4i CellsForRRuleRecommended  
VIAxR8_V4CellOut = NOT INSIDE CELL VIA4i ExclCellsForRRuleRecommended 
VIAxR8_V4Cell = VIAxR8_V4CellIn AND VIAxR8_V4CellOut
VIAxR8_V4Marker = VIA4i AND RRuleRecommended
VIAxR8_V4 = ((VIAxR8_V4Cell OR VIAxR8_V4Marker) NOT Block ) NOT excludeRRuleRecommended

VIAxR8_STACK_V3V5 = ((SINGLE_VIA3 AND SINGLE_VIA4) AND SINGLE_VIA5) AND VIAxR8_V4

RR:RE:S:VIAxR8_V1V5 { @ Max. 4 stacked Vias are allowed when only one via for each VIA layer.(VIA1~VIA5 is not allowed)
  ((VIAxR8_STACK_V3V5 AND SINGLE_VIA1) AND SINGLE_VIA2) NOT SEALRING_EXCLUDE
}
RR:RE:S:VIAxR8_V2V6 { @ Max. 4 stacked Vias are allowed when only one via for each VIA layer.(VIA2~VIA6 is not allowed)
  ((VIAxR8_STACK_V3V5 AND SINGLE_VIA2) AND SINGLE_VIA6) NOT SEALRING_EXCLUDE
} 
RR:RE:S:VIAxR8_V3V7 { @ Max. 4 stacked Vias are allowed when only one via for each VIA layer.(VIA3~VIA7 is not allowed)
  ((VIAxR8_STACK_V3V5 AND SINGLE_VIA6) AND SINGLE_VIA7) NOT SEALRING_EXCLUDE
} 

#ENDIF

#ENDIF //End of Systematic   

#IFDEF Defect

#IFDEF _ODS1_
ODS1_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
ODS1_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
ODS1_ODCell = ODS1_ODCellIn AND ODS1_ODCellOut
ODS1_ODMarker = ODi AND RRuleRecommended
ODS1_OD = ((( ODS1_ODCell OR ODS1_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:D:ODS1 { @ OD space >= ^OD_S_1_R um
  A = ODS1_OD NOT TCDDMY     
  EXT A < OD_S_1_R ABUT < 90 REGION SINGULAR 
}
#ENDIF

#IFDEF _POS1_
POS1_POCellIn = INSIDE CELL POi CellsForRRuleRecommended  
POS1_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRecommended 
POS1_POCell = POS1_POCellIn AND POS1_POCellOut
POS1_POMarker = POi AND RRuleRecommended
POS1_PO = ((( POS1_POCell OR POS1_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

POS1_PO_CHK = POS1_PO NOT TCDDMY
POS1Err = EXT [POS1_PO_CHK] < PO_S_1_R ABUT < 90
POS1ErrLong = POS1Err NOT TOUCH EDGE GATE  // exclude gate space checking
RR:RE:D:POS1 { @ PO interconnect space >= ^PO_S_1_R um, to reduce short possibility
  EXT POS1ErrLong < PO_S_1_R ABUT < 90 REGION
}
#ENDIF

#IFDEF _M1S1_
M1S1_M1CellIn = INSIDE CELL M1i CellsForRRuleRecommended  
M1S1_M1CellOut = NOT INSIDE CELL M1i ExclCellsForRRuleRecommended 
M1S1_M1Cell = M1S1_M1CellIn AND M1S1_M1CellOut
M1S1_M1Marker = M1i AND RRuleRecommended
M1S1_M1 = ((( M1S1_M1Cell OR M1S1_M1Marker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:D:M1S1 { @ M1 space >= ^M1_S_1_R um
  EXT M1S1_M1 < M1_S_1_R ABUT < 90 SINGULAR REGION 
}
#ENDIF

#IFDEF _M2S1_
M2S1_M2CellIn = INSIDE CELL M2i CellsForRRuleRecommended  
M2S1_M2CellOut = NOT INSIDE CELL M2i ExclCellsForRRuleRecommended 
M2S1_M2Cell = M2S1_M2CellIn AND M2S1_M2CellOut
M2S1_M2Marker = M2i AND RRuleRecommended
M2S1_M2 = ((M2S1_M2Cell OR M2S1_M2Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:D:M2S1 { @ M2 space >= ^M2_S_1_R um
  EXT M2S1_M2 < M2_S_1_R ABUT < 90 SINGULAR REGION 
}
#ENDIF

#IFDEF _M3S1_
M3S1_M3CellIn = INSIDE CELL M3i CellsForRRuleRecommended  
M3S1_M3CellOut = NOT INSIDE CELL M3i ExclCellsForRRuleRecommended 
M3S1_M3Cell = M3S1_M3CellIn AND M3S1_M3CellOut
M3S1_M3Marker = M3i AND RRuleRecommended
M3S1_M3 = ((M3S1_M3Cell OR M3S1_M3Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:D:M3S1 { @ M3 space >= ^M3_S_1_R um
  EXT M3S1_M3 < M3_S_1_R ABUT < 90 SINGULAR REGION 
}
#ENDIF

#IFDEF _M4S1_
M4S1_M4CellIn = INSIDE CELL M4i CellsForRRuleRecommended  
M4S1_M4CellOut = NOT INSIDE CELL M4i ExclCellsForRRuleRecommended 
M4S1_M4Cell = M4S1_M4CellIn AND M4S1_M4CellOut
M4S1_M4Marker = M4i AND RRuleRecommended
M4S1_M4 = ((M4S1_M4Cell OR M4S1_M4Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:D:M4S1 { @ M4 space >= ^M4_S_1_R um
  EXT M4S1_M4 < M4_S_1_R ABUT < 90 SINGULAR REGION 
}
#ENDIF

#IFDEF _M5S1_
M5S1_M5CellIn = INSIDE CELL M5i CellsForRRuleRecommended  
M5S1_M5CellOut = NOT INSIDE CELL M5i ExclCellsForRRuleRecommended 
M5S1_M5Cell = M5S1_M5CellIn AND M5S1_M5CellOut
M5S1_M5Marker = M5i AND RRuleRecommended
M5S1_M5 = ((M5S1_M5Cell OR M5S1_M5Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:D:M5S1 { @ M5 space >= ^M5_S_1_R um
  EXT M5S1_M5 < M5_S_1_R ABUT < 90 SINGULAR REGION 
}
#ENDIF

#IFDEF _M6S1_
M6S1_M6CellIn = INSIDE CELL M6i CellsForRRuleRecommended  
M6S1_M6CellOut = NOT INSIDE CELL M6i ExclCellsForRRuleRecommended 
M6S1_M6Cell = M6S1_M6CellIn AND M6S1_M6CellOut
M6S1_M6Marker = M6i AND RRuleRecommended
M6S1_M6 = ((M6S1_M6Cell OR M6S1_M6Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:D:M6S1 { @ M6 space >= ^M6_S_1_R um
  EXT M6S1_M6 < M6_S_1_R ABUT < 90 SINGULAR REGION 
}
#ENDIF

#IFDEF _M7S1_
M7S1_M7CellIn = INSIDE CELL M7i CellsForRRuleRecommended  
M7S1_M7CellOut = NOT INSIDE CELL M7i ExclCellsForRRuleRecommended 
M7S1_M7Cell = M7S1_M7CellIn AND M7S1_M7CellOut
M7S1_M7Marker = M7i AND RRuleRecommended
M7S1_M7 = ((M7S1_M7Cell OR M7S1_M7Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:D:M7S1 { @ M7 space >= ^M7_S_1_R um
  EXT M7S1_M7 < M7_S_1_R ABUT < 90 SINGULAR REGION 
}
#ENDIF

#IFDEF _M8S1_
M8S1_M8CellIn = INSIDE CELL M8i CellsForRRuleRecommended  
M8S1_M8CellOut = NOT INSIDE CELL M8i ExclCellsForRRuleRecommended 
M8S1_M8Cell = M8S1_M8CellIn AND M8S1_M8CellOut
M8S1_M8Marker = M8i AND RRuleRecommended
M8S1_M8 = ((M8S1_M8Cell OR M8S1_M8Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:D:M8S1 { @ M8 space >= ^M8_S_1_R um
  EXT M8S1_M8 < M8_S_1_R ABUT < 90 SINGULAR REGION 
}
#ENDIF


#ENDIF // End of Defect

#IFDEF Parametric

#IFDEF _ODW1_
ODW1_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
ODW1_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
ODW1_ODCell = ODW1_ODCellIn AND ODW1_ODCellOut
ODW1_ODMarker = ODi AND RRuleRecommended
ODW1_OD = ((( ODW1_ODCell OR ODW1_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:P:ODW1 { @ Recommended interconnect OD width >= ^OD_W_1_R um 
  A = (ODW1_OD NOT POi) NOT TCDDMY
  (INT A < OD_W_1_R ABUT < 90 SINGULAR REGION) NOT MOMDMY
}
#ENDIF

#IFDEF _NWRODS3_
NWRODS3_NWCellIn = INSIDE CELL NWi CellsForRRuleRecommended  
NWRODS3_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleRecommended 
NWRODS3_NWCell = NWRODS3_NWCellIn AND NWRODS3_NWCellOut
NWRODS3_NWMarker = NWi AND RRuleRecommended
NWRODS3_NW = ((( NWRODS3_NWCell OR NWRODS3_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:P:NWRODS3 { @ RPO space to CO in NWEL resistor within OD for SPICE simulation accuracy == ^NWROD_S_3_R um
  A = RPO INSIDE EDGE ( NWRES AND NWRODS3_NW ) 
  B = EXPAND EDGE A OUTSIDE BY NWROD_S_3_R
  B AND COWR 
  B NOT INTERACT COWR
}
#ENDIF

#IFDEF _NWRSTIEN2_
NWRSTIEN2_NWCellIn = INSIDE CELL NWi CellsForRRuleRecommended  
NWRSTIEN2_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleRecommended 
NWRSTIEN2_NWCell = NWRSTIEN2_NWCellIn AND NWRSTIEN2_NWCellOut
NWRSTIEN2_NWMarker = NWi AND RRuleRecommended
NWRSTIEN2_NW = ((( NWRSTIEN2_NWCell OR NWRSTIEN2_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:P:NWRSTIEN2 { @ OD enclosure of CO in NWEL resistor under STI for SPICE simulation accuracy == ^NWRSTI_EN_2_R um
  A = OD INSIDE EDGE ( NWRES_STI AND NWRSTIEN2_NW ) 
  B = EXPAND EDGE A INSIDE BY NWRSTI_EN_2_R
  B NOT INTERACT COWR_STI
}
#ENDIF


#IFDEF _POS4_1_
POS4_1_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
POS4_1_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
POS4_1_ODCell = POS4_1_ODCellIn AND POS4_1_ODCellOut
POS4_1_ODMarker = ODi AND RRuleRecommended
POS4_1_OD = ((( POS4_1_ODCell OR POS4_1_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

POS4_1_GATE  = POLY AND POS4_1_OD
RR:RE:P:POS4_1 { @ Recommended gate space when the area enclosed by L-shape OD and L-shape PO < ^PO_S_4_1_A_R for PO/OD rounding effect >= ^PO_S_4_1_R
  ((EXT POS4_1_GATE < PO_S_4_1_R ABUT < 90 REGION CORNER TO CORNER) INTERACT ODi == 1) INTERACT POi == 1
}
#ENDIF
#IFDEF _SRDPOS1_
SRDPOS1_SRDPOCellIn = INSIDE CELL SRDPO CellsForRRuleRecommended  
SRDPOS1_SRDPOCellOut = NOT INSIDE CELL SRDPO ExclCellsForRRuleRecommended 
SRDPOS1_SRDPOCell = SRDPOS1_SRDPOCellIn AND SRDPOS1_SRDPOCellOut
SRDPOS1_SRDPOMarker = SRDPO AND RRuleRecommended
SRDPOS1_SRDPO = ((( SRDPOS1_SRDPOCell OR SRDPOS1_SRDPOMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

SRDPOS1_POCellIn = INSIDE CELL POi CellsForRRuleRecommended  
SRDPOS1_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRecommended 
SRDPOS1_POCell = SRDPOS1_POCellIn AND SRDPOS1_POCellOut
SRDPOS1_POMarker = POi AND RRuleRecommended
SRDPOS1_PO = ((( SRDPOS1_POCell OR SRDPOS1_POMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:S:SRDPOS1 { @ Recommended space to {PO OR SR_DPO} (SR_DPO overlap with PO is not allowed) >= 0.12 
  SRDPOS1_POdx = SRDPOS1_PO OR SRDPOS1_SRDPO
  EXT SRDPOS1_SRDPO SRDPOS1_POdx < SRDPO_S_1_R ABUT < 90 SINGULAR REGION 
}
#ENDIF

#ENDIF  //End of Parametric

#IFDEF SP

#IFDEF _POEX1_
POEX1_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
POEX1_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
POEX1_ODCell = POEX1_ODCellIn AND POEX1_ODCellOut
POEX1_ODMarker = ODi AND RRuleRecommended
POEX1_OD = ((( POEX1_ODCell OR POEX1_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:SP:POEX1 { @ Recommended PO extension on OD (end-cap) >= ^PO_EX_1_R um
  (ENC POEX1_OD POLY < PO_EX_1_R ABUT < 90 OPPOSITE SINGULAR REGION) NOT INSIDE (LOGO OR TCDDMY)
}
#ENDIF

#IFNDEF GS
#IFDEF _POS2_
POS2_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
POS2_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
POS2_ODCell = POS2_ODCellIn AND POS2_ODCellOut
POS2_ODMarker = ODi AND RRuleRecommended
POS2_OD = ((( POS2_ODCell OR POS2_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

POS2_GATE_W = POLY INSIDE EDGE POS2_OD
POS2_GATE  = POLY AND POS2_OD
RR:RE:SP:POS2 { @ Recommended gate space in the same OD >= ^PO_S_2_R um
  EXT POS2_GATE_W < PO_S_2_R ABUT < 90 REGION 
  (EXT POS2_GATE < PO_S_2_R ABUT < 90 REGION CORNER TO CORNER) INTERACT ODi == 1
}
#ENDIF
#ENDIF

#IFDEF _COEN1_
COEN1_COCellIn = INSIDE CELL COi CellsForRRuleRecommended  
COEN1_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleRecommended 
COEN1_COCell = COEN1_COCellIn AND COEN1_COCellOut
COEN1_COMarker = COi AND RRuleRecommended
COEN1_CO = ((( COEN1_COCell OR COEN1_COMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:SP:COEN1 { @ Recommended enclosure by OD >= ^CO_EN_1_R um
  ENC COEN1_CO OD < CO_EN_1_R ABUT < 90 REGION
}
#ENDIF

#IFDEF _COEN11_
COEN11_COCellIn = INSIDE CELL COi CellsForRRuleRecommended  
COEN11_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleRecommended 
COEN11_COCell = COEN11_COCellIn AND COEN11_COCellOut
COEN11_COMarker = COi AND RRuleRecommended
COEN11_CO = ((( COEN11_COCell OR COEN11_COMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:SP:COEN11 { @ Recommended enclosure by OD [at least two opposite sides] >= ^CO_EN_1_1_R um
  X = RECTANGLE ENCLOSURE COEN11_CO OD ABUT < 90 SINGULAR GOOD CO_EN_1 CO_EN_1_1_R OPPOSITE CO_EN_1 CO_EN_1_1_R OPPOSITE
  Y = ENC [X] OD < CO_EN_1_1_R ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < CO_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
#ENDIF

#IFDEF _COEN3_
COEN3_COCellIn = INSIDE CELL COi CellsForRRuleRecommended  
COEN3_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleRecommended 
COEN3_COCell = COEN3_COCellIn AND COEN3_COCellOut
COEN3_COMarker = COi AND RRuleRecommended
COEN3_CO = ((( COEN3_COCell OR COEN3_COMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:SP:COEN3 { @ Recommended enclosure by PO [at least two opposite sides] >= ^CO_EN_3_R um
  X = RECTANGLE ENCLOSURE COEN3_CO POLY ABUT < 90 SINGULAR GOOD CO_EN_2 CO_EN_3_R OPPOSITE CO_EN_2 CO_EN_3_R OPPOSITE
  Y = ENC [X] POLY < CO_EN_3_R ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < CO_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
#ENDIF

#ENDIF  //End of SP

#IFDEF SD

#IFDEF _COS3_
COS3_COCellIn = INSIDE CELL COi CellsForRRuleRecommended  
COS3_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleRecommended 
COS3_COCell = COS3_COCellIn AND COS3_COCellOut
COS3_COMarker = COi AND RRuleRecommended
COS3_CO = ((( COS3_COCell OR COS3_COMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:SD:COS3 { @ Recommended space to gate to reduce the short possibility caused by particle >= ^CO_S_3_R
  EXT (COS3_CO AND ODi) GATE < CO_S_3_R ABUT < 90 SINGULAR REGION
}
#ENDIF

#ENDIF  //End of SD

#IFDEF FSP

#IFDEF _M1EN1_M1EN2_
M1EN1_M1EN2_COCellIn = INSIDE CELL COi CellsForRRuleRecommended  
M1EN1_M1EN2_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleRecommended 
M1EN1_M1EN2_COCell = M1EN1_M1EN2_COCellIn AND M1EN1_M1EN2_COCellOut
M1EN1_M1EN2_COMarker = COi AND RRuleRecommended
M1EN1_M1EN2_CO = ((( M1EN1_M1EN2_COCell OR M1EN1_M1EN2_COMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:FP:M1EN1_M1EN2 { @ Enclosure of CO at least two opposite sides ^M1_EN_2_R um/Enclosure of CO ^M1_EN_1_R um 
  A = RECTANGLE ENCLOSURE M1EN1_M1EN2_CO M1s ABUT > 0 < 90 GOOD 0 M1_EN_2_R OPPOSITE 0 M1_EN_2_R OPPOSITE
  (ENC A M1s < M1_EN_1_R ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
#ENDIF


#IFDEF _VIA1EN1_VIA1EN2_
VIA1EN1_VIA1EN2_VIA1CellIn = INSIDE CELL VIA1i CellsForRRuleRecommended  
VIA1EN1_VIA1EN2_VIA1CellOut = NOT INSIDE CELL VIA1i ExclCellsForRRuleRecommended 
VIA1EN1_VIA1EN2_VIA1Cell = VIA1EN1_VIA1EN2_VIA1CellIn AND VIA1EN1_VIA1EN2_VIA1CellOut
VIA1EN1_VIA1EN2_VIA1Marker = VIA1i AND RRuleRecommended
VIA1EN1_VIA1EN2_VIA1 = ((( VIA1EN1_VIA1EN2_VIA1Cell OR VIA1EN1_VIA1EN2_VIA1Marker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:FP:VIA1EN1_VIA1EN2 { @ Enclosure of VIA1 at least two opposite sides ^VIA1_EN_2_R um/Enclosure of VIA1 ^VIA1_EN_1_R um 
  A = RECTANGLE ENCLOSURE VIA1EN1_VIA1EN2_VIA1 M1 ABUT < 90 SINGULAR GOOD 0 VIA1_EN_2_R OPPOSITE 0 VIA1_EN_2_R OPPOSITE
  ENC A M1 < VIA1_EN_1_R ABUT < 90 SINGULAR REGION
}
#ENDIF

#IFDEF _M2EN1_M2EN2_
M2EN1_M2EN2_VIA1CellIn = INSIDE CELL VIA1i CellsForRRuleRecommended  
M2EN1_M2EN2_VIA1CellOut = NOT INSIDE CELL VIA1i ExclCellsForRRuleRecommended 
M2EN1_M2EN2_VIA1Cell = M2EN1_M2EN2_VIA1CellIn AND M2EN1_M2EN2_VIA1CellOut
M2EN1_M2EN2_VIA1Marker = VIA1i AND RRuleRecommended
M2EN1_M2EN2_VIA1 = ((( M2EN1_M2EN2_VIA1Cell OR M2EN1_M2EN2_VIA1Marker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:FP:M2EN1_M2EN2 { @ Enclosure of VIA1 at least two opposite sides ^M2_EN_2_R um/Enclosure of VIA1 ^M2_EN_1_R um 
  A = RECTANGLE ENCLOSURE M2EN1_M2EN2_VIA1 M2 ABUT < 90 SINGULAR GOOD 0 M2_EN_2_R OPPOSITE 0 M2_EN_2_R OPPOSITE
  ENC A M2 < M2_EN_1_R ABUT < 90 SINGULAR REGION
}
#ENDIF


#IFDEF _VIA2EN1_VIA2EN2_
VIA2EN1_VIA2EN2_VIA2CellIn = INSIDE CELL VIA2i CellsForRRuleRecommended  
VIA2EN1_VIA2EN2_VIA2CellOut = NOT INSIDE CELL VIA2i ExclCellsForRRuleRecommended 
VIA2EN1_VIA2EN2_VIA2Cell = VIA2EN1_VIA2EN2_VIA2CellIn AND VIA2EN1_VIA2EN2_VIA2CellOut
VIA2EN1_VIA2EN2_VIA2Marker = VIA2i AND RRuleRecommended
VIA2EN1_VIA2EN2_VIA2 = ((( VIA2EN1_VIA2EN2_VIA2Cell OR VIA2EN1_VIA2EN2_VIA2Marker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:FP:VIA2EN1_VIA2EN2 { @ Enclosure of VIA2 at least two opposite sides ^VIA2_EN_2_R um/Enclosure of VIA2 ^VIA2_EN_1_R um 
  A = RECTANGLE ENCLOSURE VIA2EN1_VIA2EN2_VIA2 M2 ABUT < 90 SINGULAR GOOD 0 VIA2_EN_2_R OPPOSITE 0 VIA2_EN_2_R OPPOSITE
  ENC A M2 < VIA2_EN_1_R ABUT < 90 SINGULAR REGION
}
#ENDIF

#IFDEF _M3EN1_M3EN2_
M3EN1_M3EN2_VIA2CellIn = INSIDE CELL VIA2i CellsForRRuleRecommended  
M3EN1_M3EN2_VIA2CellOut = NOT INSIDE CELL VIA2i ExclCellsForRRuleRecommended 
M3EN1_M3EN2_VIA2Cell = M3EN1_M3EN2_VIA2CellIn AND M3EN1_M3EN2_VIA2CellOut
M3EN1_M3EN2_VIA2Marker = VIA2i AND RRuleRecommended
M3EN1_M3EN2_VIA2 = ((( M3EN1_M3EN2_VIA2Cell OR M3EN1_M3EN2_VIA2Marker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:FP:M3EN1_M3EN2 { @ Enclosure of VIA2 at least two opposite sides ^M3_EN_2_R um/Enclosure of VIA2 ^M3_EN_1_R um 
  A = RECTANGLE ENCLOSURE M3EN1_M3EN2_VIA2 M3 ABUT < 90 SINGULAR GOOD 0 M3_EN_2_R OPPOSITE 0 M3_EN_2_R OPPOSITE
  ENC A M3 < M3_EN_1_R ABUT < 90 SINGULAR REGION
}
#ENDIF


#IFDEF _VIA3EN1_VIA3EN2_
VIA3EN1_VIA3EN2_VIA3CellIn = INSIDE CELL VIA3i CellsForRRuleRecommended  
VIA3EN1_VIA3EN2_VIA3CellOut = NOT INSIDE CELL VIA3i ExclCellsForRRuleRecommended 
VIA3EN1_VIA3EN2_VIA3Cell = VIA3EN1_VIA3EN2_VIA3CellIn AND VIA3EN1_VIA3EN2_VIA3CellOut
VIA3EN1_VIA3EN2_VIA3Marker = VIA3i AND RRuleRecommended
VIA3EN1_VIA3EN2_VIA3 = ((VIA3EN1_VIA3EN2_VIA3Cell OR VIA3EN1_VIA3EN2_VIA3Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:FP:VIA3EN1_VIA3EN2 { @ Enclosure of VIA3 at least two opposite sides ^VIA3_EN_2_R um/Enclosure of VIA3 ^VIA3_EN_1_R um 
  A = RECTANGLE ENCLOSURE VIA3EN1_VIA3EN2_VIA3 M3 ABUT < 90 SINGULAR GOOD 0 VIA3_EN_2_R OPPOSITE 0 VIA3_EN_2_R OPPOSITE
  ENC A M3 < VIA3_EN_1_R ABUT < 90 SINGULAR REGION
}
#ENDIF

#IFDEF _M4EN1_M4EN2_
M4EN1_M4EN2_VIA3CellIn = INSIDE CELL VIA3i CellsForRRuleRecommended  
M4EN1_M4EN2_VIA3CellOut = NOT INSIDE CELL VIA3i ExclCellsForRRuleRecommended 
M4EN1_M4EN2_VIA3Cell = M4EN1_M4EN2_VIA3CellIn AND M4EN1_M4EN2_VIA3CellOut
M4EN1_M4EN2_VIA3Marker = VIA3i AND RRuleRecommended
M4EN1_M4EN2_VIA3 = ((M4EN1_M4EN2_VIA3Cell OR M4EN1_M4EN2_VIA3Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:FP:M4EN1_M4EN2 { @ Enclosure of VIA3 at least two opposite sides ^M4_EN_2_R um/Enclosure of VIA3 ^M4_EN_1_R um 
  A = RECTANGLE ENCLOSURE M4EN1_M4EN2_VIA3 M4 ABUT < 90 SINGULAR GOOD 0 M4_EN_2_R OPPOSITE 0 M4_EN_2_R OPPOSITE
  ENC A M4 < M4_EN_1_R ABUT < 90 SINGULAR REGION
}
#ENDIF


#IFDEF _VIA4EN1_VIA4EN2_
VIA4EN1_VIA4EN2_VIA4CellIn = INSIDE CELL VIA4i CellsForRRuleRecommended  
VIA4EN1_VIA4EN2_VIA4CellOut = NOT INSIDE CELL VIA4i ExclCellsForRRuleRecommended 
VIA4EN1_VIA4EN2_VIA4Cell = VIA4EN1_VIA4EN2_VIA4CellIn AND VIA4EN1_VIA4EN2_VIA4CellOut
VIA4EN1_VIA4EN2_VIA4Marker = VIA4i AND RRuleRecommended
VIA4EN1_VIA4EN2_VIA4 = ((VIA4EN1_VIA4EN2_VIA4Cell OR VIA4EN1_VIA4EN2_VIA4Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:FP:VIA4EN1_VIA4EN2 { @ Enclosure of VIA4 at least two opposite sides ^VIA4_EN_2_R um/Enclosure of VIA4 ^VIA4_EN_1_R um 
  A = RECTANGLE ENCLOSURE VIA4EN1_VIA4EN2_VIA4 M4 ABUT < 90 SINGULAR GOOD 0 VIA4_EN_2_R OPPOSITE 0 VIA4_EN_2_R OPPOSITE
  ENC A M4 < VIA4_EN_1_R ABUT < 90 SINGULAR REGION
}
#ENDIF

#IFDEF _M5EN1_M5EN2_
M5EN1_M5EN2_VIA4CellIn = INSIDE CELL VIA4i CellsForRRuleRecommended  
M5EN1_M5EN2_VIA4CellOut = NOT INSIDE CELL VIA4i ExclCellsForRRuleRecommended 
M5EN1_M5EN2_VIA4Cell = M5EN1_M5EN2_VIA4CellIn AND M5EN1_M5EN2_VIA4CellOut
M5EN1_M5EN2_VIA4Marker = VIA4i AND RRuleRecommended
M5EN1_M5EN2_VIA4 = ((M5EN1_M5EN2_VIA4Cell OR M5EN1_M5EN2_VIA4Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:FP:M5EN1_M5EN2 { @ Enclosure of VIA4 at least two opposite sides ^M5_EN_2_R um/Enclosure of VIA4 ^M5_EN_1_R um 
  A = RECTANGLE ENCLOSURE M5EN1_M5EN2_VIA4 M5 ABUT < 90 SINGULAR GOOD 0 M5_EN_2_R OPPOSITE 0 M5_EN_2_R OPPOSITE
  ENC A M5 < M5_EN_1_R ABUT < 90 SINGULAR REGION
}
#ENDIF


#IFDEF _VIA5EN1_VIA5EN2_
VIA5EN1_VIA5EN2_VIA5CellIn = INSIDE CELL VIA5i CellsForRRuleRecommended  
VIA5EN1_VIA5EN2_VIA5CellOut = NOT INSIDE CELL VIA5i ExclCellsForRRuleRecommended 
VIA5EN1_VIA5EN2_VIA5Cell = VIA5EN1_VIA5EN2_VIA5CellIn AND VIA5EN1_VIA5EN2_VIA5CellOut
VIA5EN1_VIA5EN2_VIA5Marker = VIA5i AND RRuleRecommended
VIA5EN1_VIA5EN2_VIA5 = ((VIA5EN1_VIA5EN2_VIA5Cell OR VIA5EN1_VIA5EN2_VIA5Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:FP:VIA5EN1_VIA5EN2 { @ Enclosure of VIA5 at least two opposite sides ^VIA5_EN_2_R um/Enclosure of VIA5 ^VIA5_EN_1_R um 
  A = RECTANGLE ENCLOSURE VIA5EN1_VIA5EN2_VIA5 M5 ABUT < 90 SINGULAR GOOD 0 VIA5_EN_2_R OPPOSITE 0 VIA5_EN_2_R OPPOSITE
  ENC A M5 < VIA5_EN_1_R ABUT < 90 SINGULAR REGION
}
#ENDIF

#IFDEF _M6EN1_M6EN2_
M6EN1_M6EN2_VIA5CellIn = INSIDE CELL VIA5i CellsForRRuleRecommended  
M6EN1_M6EN2_VIA5CellOut = NOT INSIDE CELL VIA5i ExclCellsForRRuleRecommended 
M6EN1_M6EN2_VIA5Cell = M6EN1_M6EN2_VIA5CellIn AND M6EN1_M6EN2_VIA5CellOut
M6EN1_M6EN2_VIA5Marker = VIA5i AND RRuleRecommended
M6EN1_M6EN2_VIA5 = ((M6EN1_M6EN2_VIA5Cell OR M6EN1_M6EN2_VIA5Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:FP:M6EN1_M6EN2 { @ Enclosure of VIA5 at least two opposite sides ^M6_EN_2_R um/Enclosure of VIA5 ^M6_EN_1_R um 
  A = RECTANGLE ENCLOSURE M6EN1_M6EN2_VIA5 M6 ABUT < 90 SINGULAR GOOD 0 M6_EN_2_R OPPOSITE 0 M6_EN_2_R OPPOSITE
  ENC A M6 < M6_EN_1_R ABUT < 90 SINGULAR REGION
}
#ENDIF


#IFDEF _VIA6EN1_VIA6EN2_
VIA6EN1_VIA6EN2_VIA6CellIn = INSIDE CELL VIA6i CellsForRRuleRecommended  
VIA6EN1_VIA6EN2_VIA6CellOut = NOT INSIDE CELL VIA6i ExclCellsForRRuleRecommended 
VIA6EN1_VIA6EN2_VIA6Cell = VIA6EN1_VIA6EN2_VIA6CellIn AND VIA6EN1_VIA6EN2_VIA6CellOut
VIA6EN1_VIA6EN2_VIA6Marker = VIA6i AND RRuleRecommended
VIA6EN1_VIA6EN2_VIA6 = ((VIA6EN1_VIA6EN2_VIA6Cell OR VIA6EN1_VIA6EN2_VIA6Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:FP:VIA6EN1_VIA6EN2 { @ Enclosure of VIA6 at least two opposite sides ^VIA6_EN_2_R um/Enclosure of VIA6 ^VIA6_EN_1_R um 
  A = RECTANGLE ENCLOSURE VIA6EN1_VIA6EN2_VIA6 M6 ABUT < 90 SINGULAR GOOD 0 VIA6_EN_2_R OPPOSITE 0 VIA6_EN_2_R OPPOSITE
  ENC A M6 < VIA6_EN_1_R ABUT < 90 SINGULAR REGION
}
#ENDIF

#IFDEF _M7EN1_M7EN2_
M7EN1_M7EN2_VIA6CellIn = INSIDE CELL VIA6i CellsForRRuleRecommended  
M7EN1_M7EN2_VIA6CellOut = NOT INSIDE CELL VIA6i ExclCellsForRRuleRecommended 
M7EN1_M7EN2_VIA6Cell = M7EN1_M7EN2_VIA6CellIn AND M7EN1_M7EN2_VIA6CellOut
M7EN1_M7EN2_VIA6Marker = VIA6i AND RRuleRecommended
M7EN1_M7EN2_VIA6 = ((M7EN1_M7EN2_VIA6Cell OR M7EN1_M7EN2_VIA6Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:FP:M7EN1_M7EN2 { @ Enclosure of VIA6 at least two opposite sides ^M7_EN_2_R um/Enclosure of VIA6 ^M7_EN_1_R um 
  A = RECTANGLE ENCLOSURE M7EN1_M7EN2_VIA6 M7 ABUT < 90 SINGULAR GOOD 0 M7_EN_2_R OPPOSITE 0 M7_EN_2_R OPPOSITE
  ENC A M7 < M7_EN_1_R ABUT < 90 SINGULAR REGION
}
#ENDIF


#IFDEF _VIA7EN1_VIA7EN2_
VIA7EN1_VIA7EN2_VIA7CellIn = INSIDE CELL VIA7i CellsForRRuleRecommended  
VIA7EN1_VIA7EN2_VIA7CellOut = NOT INSIDE CELL VIA7i ExclCellsForRRuleRecommended 
VIA7EN1_VIA7EN2_VIA7Cell = VIA7EN1_VIA7EN2_VIA7CellIn AND VIA7EN1_VIA7EN2_VIA7CellOut
VIA7EN1_VIA7EN2_VIA7Marker = VIA7i AND RRuleRecommended
VIA7EN1_VIA7EN2_VIA7 = ((VIA7EN1_VIA7EN2_VIA7Cell OR VIA7EN1_VIA7EN2_VIA7Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:FP:VIA7EN1_VIA7EN2 { @ Enclosure of VIA7 at least two opposite sides ^VIA7_EN_2_R um/Enclosure of VIA7 ^VIA7_EN_1_R um 
  A = RECTANGLE ENCLOSURE VIA7EN1_VIA7EN2_VIA7 M7 ABUT < 90 SINGULAR GOOD 0 VIA7_EN_2_R OPPOSITE 0 VIA7_EN_2_R OPPOSITE
  ENC A M7 < VIA7_EN_1_R ABUT < 90 SINGULAR REGION
}
#ENDIF

#IFDEF _M8EN1_M8EN2_
M8EN1_M8EN2_VIA7CellIn = INSIDE CELL VIA7i CellsForRRuleRecommended  
M8EN1_M8EN2_VIA7CellOut = NOT INSIDE CELL VIA7i ExclCellsForRRuleRecommended 
M8EN1_M8EN2_VIA7Cell = M8EN1_M8EN2_VIA7CellIn AND M8EN1_M8EN2_VIA7CellOut
M8EN1_M8EN2_VIA7Marker = VIA7i AND RRuleRecommended
M8EN1_M8EN2_VIA7 = ((M8EN1_M8EN2_VIA7Cell OR M8EN1_M8EN2_VIA7Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:FP:M8EN1_M8EN2 { @ Enclosure of VIA7 at least two opposite sides ^M8_EN_2_R um/Enclosure of VIA7 ^M8_EN_1_R um 
  A = RECTANGLE ENCLOSURE M8EN1_M8EN2_VIA7 M8 ABUT < 90 SINGULAR GOOD 0 M8_EN_2_R OPPOSITE 0 M8_EN_2_R OPPOSITE
  ENC A M8 < M8_EN_1_R ABUT < 90 SINGULAR REGION
}
#ENDIF

#ENDIF // End of FSP


#IFDEF FULL_CHIP
#IFDEF _DTCDDN1_
RR:RE:DTCDDN1 { @ Density of Dummy TCD (2mmx2mm is one unit) >= 70 %
  ALL_WIN = DENSITY CHIP == DTCD_DN_1_WR*DTCD_DN_1_WR WINDOW DTCD_DN_1_WR STEP DTCD_DN_1_WR INSIDE OF LAYER CHIPx [AREA(CHIP)]
  BAD_WIN = DENSITY TCDDMY == 0 WINDOW DTCD_DN_1_WR STEP DTCD_DN_1_WR INSIDE OF LAYER ALL_WIN PRINT DTCD.DN.1.NO_TCDDMY
  GOOD_WIN = ALL_WIN NOT BAD_WIN
  ERR = DENSITY GOOD_WIN INSIDE OF LAYER ALL_WIN < DTCD_DN_1_R PRINT DTCD.DN.1.density
  ERR AND BAD_WIN
}
#ENDIF
#ENDIF




#ENDIF // End of Recommended

#IFDEF Analog

#IFDEF _POS14m_
POS14m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
POS14m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
POS14m_POCell = POS14m_POCellIn AND POS14m_POCellOut
POS14m_POMarker = POi AND RRuleAnalog
POS14m_PO = ((( POS14m_POCell OR POS14m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POS14m_GATE = ( GATE_NP AND POS14m_PO ) NOT OD2 
POS14m_NW = OD2 OR (NWEL OR NTN)
RR:AN:POS14m { @ Gate space to ( OD2 OR (NW OR NT_N) ) in Core NMOS >= ^PO_S_14_MR um
  EXT POS14m_GATE POS14m_NW < PO_S_14_MR ABUT < 90 SINGULAR REGION 
}
#ENDIF 

#IFDEF _POEN1m_
POEN1m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
POEN1m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
POEN1m_POCell = POEN1m_POCellIn AND POEN1m_POCellOut
POEN1m_POMarker = POi AND RRuleAnalog
POEN1m_PO = ((( POEN1m_POCell OR POEN1m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POEN1m_GATE = ( GATE_PP AND POEN1m_PO ) NOT OD2
#IFDEF GS
POEN1m_NW = (NWEL NOT OD2) NOT NTN 
RR:AN:POEN1m { @ Gate enclosure by ( (NW NOT OD2) NOT NT_N) in Core PMOS >= ^PO_EN_1_MR um
  ENC POEN1m_GATE POEN1m_NW < PO_EN_1_MR ABUT < 90 SINGULAR REGION 
}
#ELSE
POEN1m_NW = NWEL NOT NTN 
RR:AN:POEN1m { @ Gate enclosure by (NW NOT NT_N) in Core PMOS >= ^PO_EN_1_MR um
  ENC POEN1m_GATE POEN1m_NW < PO_EN_1_MR ABUT < 90 SINGULAR REGION 
}
#ENDIF
#ENDIF 

#IFDEF _POEN2m_
POEN2m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
POEN2m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
POEN2m_POCell = POEN2m_POCellIn AND POEN2m_POCellOut
POEN2m_POMarker = POi AND RRuleAnalog
POEN2m_PO = ((( POEN2m_POCell OR POEN2m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POEN2m_GATE = ( GATE_NP AND POEN2m_PO ) AND OD2
POEN2m_NW = OD2 NOT ( NWEL OR NTN) 
RR:AN:POEN2m { @ Gate enclosure by ( OD2 NOT (NW OR NT_N) ) in IO NMOS >= ^PO_EN_2_MR um
  ENC POEN2m_GATE POEN2m_NW < PO_EN_2_MR ABUT < 90 SINGULAR REGION
}
#ENDIF 

#IFDEF _POEN3m_
POEN3m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
POEN3m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
POEN3m_POCell = POEN3m_POCellIn AND POEN3m_POCellOut
POEN3m_POMarker = POi AND RRuleAnalog
POEN3m_PO = ((( POEN3m_POCell OR POEN3m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POEN3m_GATE = ( GATE_PP AND POEN3m_PO ) AND OD2
#IFDEF GS
POEN3m_NW = (NWEL AND OD2) NOT NTN  
RR:AN:POEN3m { @ Gate enclosure by (( NW AND OD2) NOT NT_N) in IO PMOS >= ^PO_EN_3_MR um
  ENC POEN3m_GATE POEN3m_NW < PO_EN_3_MR ABUT < 90 SINGULAR REGION 
}
#ELSE
POEN3m_NW = NWEL NOT NTN 
RR:AN:POEN3m { @ Gate enclosure by (NW NOT NT_N) in IO PMOS >= ^PO_EN_3_MR um
  ENC POEN3m_GATE POEN3m_NW < PO_EN_3_MR ABUT < 90 SINGULAR REGION 
}
#ENDIF
#ENDIF 

#IFDEF _POS5m_
POS5m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
POS5m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
POS5m_POCell = POS5m_POCellIn AND POS5m_POCellOut
POS5m_POMarker = POi AND RRuleAnalog
POS5m_PO = ((( POS5m_POCell OR POS5m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POS5m_GateW = GATE_W COIN INSIDE EDGE POS5m_PO
POS5m_GateWExp = EXPAND EDGE POS5m_GateW INSIDE BY GRID EXTEND BY OD_S_1
POS5m_GateWExe = POS5m_PO COIN INSIDE EDGE POS5m_GateWExp
RR:AN:POS5m { @ Recommended PO space to L-shape OD when PO and OD are in the same MOS >= ^PO_S_5_MR um
  EXT POS5m_GateWExe ODi < PO_S_5_MR ABUT < 90 OPPOSITE REGION
}
#ENDIF 

#IFDEF _POS6m_
POS6m_ODCellIn = INSIDE CELL ODi CellsForRRuleAnalog  
POS6m_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleAnalog 
POS6m_ODCell = POS6m_ODCellIn AND POS6m_ODCellOut
POS6m_ODMarker = ODi AND RRuleAnalog
POS6m_OD = ((( POS6m_ODCell OR POS6m_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POS6m_GateL = GATE_L COIN INSIDE EDGE POS6m_OD
POS6m_GateLExp = EXPAND EDGE POS6m_GateL INSIDE BY GRID EXTEND BY PO_S_1
POS6m_GateLExe = (POS6m_OD COIN INSIDE EDGE POS6m_GateLExp) TOUCH INSIDE EDGE POS6m_GateL
RR:AN:POS6m { @ Recommended L-shape PO space to OD when PO and OD are in the same MOS >= 0.1  
  EXT POS6m_GateLExe POi < PO_S_6_MR ABUT < 90 OPPOSITE REGION
}
#ENDIF 

#IFDEF _POS61m_
POS61m_ODCellIn = INSIDE CELL ODi CellsForRRuleAnalog  
POS61m_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleAnalog 
POS61m_ODCell = POS61m_ODCellIn AND POS61m_ODCellOut
POS61m_ODMarker = ODi AND RRuleAnalog
POS61m_OD = ((( POS61m_ODCell OR POS61m_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

RR:AN:POS61m { @ Recommended L-shape PO space to OD when PO and OD are in the same MOS [channel width < 0.3 um and L-sharp PO length > 0.1 um (L)] >= 0.18 
  POS61m_Gate = (GATE AND POS61m_OD) WITH EDGE (LENGTH GATE_W < PO_S_6_1_W_MR)
  POS61m_GateL = GATE_L COIN INSIDE EDGE POS61m_Gate
  POS61m_GateL1 =  EXPAND EDGE POS61m_GateL INSIDE BY GRID EXTEND BY PO_S_6_1_L_MR+GRID
  POS61m_GateL2 =  EXPAND EDGE POS61m_GateL INSIDE BY GRID EXTEND BY PO_S_6_1_L_MR
  L_GATE_L = POS61m_GateL1 NOT POS61m_GateL2
  L_GATE_L1E = (POS61m_GateL1 TOUCH EDGE GATE_L) TOUCH EDGE OD
  L_GATE_LE = L_GATE_L COIN EDGE L_GATE_L1E
  B = EXT L_GATE_LE [FPO1] <= PO_S_6_1_MR ABUT < 90 OPPOSITE
  EXT B OD < PO_S_6_1_MR ABUT < 90 OPPOSITE REGION
  U_PO = CONVEX EDGE POLY ANGLE1 == 270 ANGLE2 == 270 WITH LENGTH > PO_S_6_1_L_MR <= PO_S_6_1_L_MR*2
  X = EXT U_PO POS61m_OD < PO_S_6_1_MR OPPOSITE REGION
  ((SIZE X BY 0.001) INTERACT GATE == 2) INTERACT POS61m_Gate
}
#ENDIF 

#IFDEF _POEX1m_
POEX1m_ODCellIn = INSIDE CELL ODi CellsForRRuleAnalog  
POEX1m_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleAnalog 
POEX1m_ODCell = POEX1m_ODCellIn AND POEX1m_ODCellOut
POEX1m_ODMarker = ODi AND RRuleAnalog
POEX1m_OD = ((( POEX1m_ODCell OR POEX1m_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

RR:AN:POEX1m { @ Recommended PO extension on OD (end-cap) >= ^PO_EX_1_MR um
  (ENC POEX1m_OD POLY < PO_EX_1_MR ABUT > 0 < 90 OPPOSITE SINGULAR REGION) NOT INSIDE LOGO
}
#ENDIF
#IFDEF _BJTR2_
BJT.R.2R { @ OD( Emitter size ) is ^BJT_R_2_S_R x ^BJT_R_2_S_R, ^BJT_R_2_M_R x ^BJT_R_2_M_R, ^BJT_R_2_B_R x ^BJT_R_2_B_R 
  X = NOT RECTANGLE EMOD == BJT_R_2_S_R BY == BJT_R_2_S_R
  Y = NOT RECTANGLE X == BJT_R_2_M_R BY == BJT_R_2_M_R
  (NOT RECTANGLE Y == BJT_R_2_B_R BY == BJT_R_2_B_R) NOT INSIDE excludeRRuleAnalog
}
#ENDIF


#IFDEF _BJTR7_
BJT.R.7R { @ BJTDMY overlap of NT_N, PO, VTH_N, VTH_P, VTL_N, VTL_P, VAR and SRM is not recommended
  (BJTDMY AND NTN ) NOT INSIDE excludeRRuleAnalog
  (BJTDMY AND POLY) NOT INSIDE excludeRRuleAnalog
  (BJTDMY AND VTHN) NOT INSIDE excludeRRuleAnalog
  (BJTDMY AND VTHP) NOT INSIDE excludeRRuleAnalog
  (BJTDMY AND VTLN) NOT INSIDE excludeRRuleAnalog
  (BJTDMY AND VTLP) NOT INSIDE excludeRRuleAnalog
  (BJTDMY AND VAR ) NOT INSIDE excludeRRuleAnalog
  (BJTDMY AND SRM ) NOT INSIDE excludeRRuleAnalog
}
#ENDIF

#IFDEF _ANR17_
ANR17mg_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
ANR17mg_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
ANR17mg_POCell = ANR17mg_POCellIn AND ANR17mg_POCellOut
ANR17mg_POMarker = POi AND RRuleAnalog
ANR17mg_PO = ((( ANR17mg_POCell OR ANR17mg_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

ANR17mg_PORES = ANR17mg_PO AND PO_RES_RPO
RR:AN:ANR17mg { @ Place unsilicide PO resistor on NW for better noise immunity; A P+ PO resistor is recommended
  ANR17mg_PORES NOT NWEL
  ANR17mg_PORES NOT PP
}
#ENDIF

#IFDEF _ANR20_
ANR20mg_VARCellIn = INSIDE CELL VARi CellsForRRuleAnalog  
ANR20mg_VARCellOut = NOT INSIDE CELL VARi ExclCellsForRRuleAnalog 
ANR20mg_VARCell = ANR20mg_VARCellIn AND ANR20mg_VARCellOut
ANR20mg_VARMarker = VARi AND RRuleAnalog
ANR20mg_VAR = ((ANR20mg_VARCell OR ANR20mg_VARMarker) NOT Block ) NOT excludeRRuleAnalog

ANR20mg_VAROD = ANR20mg_VAR AND OD
RR:AN:ANR20mg { @ Use OD2 MOS varactor is recommended.
  ANR20mg_VAROD NOT OD2
}
#ENDIF

#ENDIF // Analog

#IFDEF Guideline

#IFDEF _NWR1_
NWR1_NWCellIn = INSIDE CELL NWi CellsForRRuleGuideline  
NWR1_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleGuideline 
NWR1_NWCell = NWR1_NWCellIn AND NWR1_NWCellOut
NWR1_NWMarker = NWi AND RRuleGuideline
NWR1_NW = ((( NWR1_NWCell OR NWR1_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:NWR1 { @ Recommended not to use floating well
   (((NWi OUTSIDE (NPODi INTERACT COi)) NOT (LOGO OR TCDDMY)) NOT INSIDE SRAM_EXCLUDE) INTERACT NWR1_NW
}
#ENDIF

#IFDEF _DNWR6_
DNWR6_DNWCellIn = INSIDE CELL DNWi CellsForRRuleGuideline  
DNWR6_DNWCellOut = NOT INSIDE CELL DNWi ExclCellsForRRuleGuideline 
DNWR6_DNWCell = DNWR6_DNWCellIn AND DNWR6_DNWCellOut
DNWR6_DNWMarker = DNWi AND RRuleGuideline
DNWR6_DNW = ((( DNWR6_DNWCell OR DNWR6_DNWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:DNWR6 { @ Recommended not to use floating RW
  ((RWi OUTSIDE (PPODi INTERACT COi)) NOT INSIDE SRAM_EXCLUDE) INTERACT DNWR6_DNW  
}
#ENDIF

#IFDEF _NWRODR3_NWRSTIR3_
NWRODR3_NWDMYCellIn = INSIDE CELL NWDMY CellsForRRuleGuideline  
NWRODR3_NWDMYCellOut = NOT INSIDE CELL NWDMY ExclCellsForRRuleGuideline 
NWRODR3_NWDMYCell = NWRODR3_NWDMYCellIn AND NWRODR3_NWDMYCellOut
NWRODR3_NWDMYMarker = NWDMY AND RRuleGuideline
NWRODR3_NWDMY = ((( NWRODR3_NWDMYCell OR NWRODR3_NWDMYMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:NWRODR3_NWRSTIR3 { @ Recommended to use rectangle shape resistor
  NWRES_BODY = RNWEL AND (NWDMY INTERACT NWRODR3_NWDMY)     
  NOT RECTANGLE NWRES_BODY ORTHOGONAL ONLY 
}
#ENDIF

#IFDEF _RESR15_
RESR15_RHCellIn = INSIDE CELL RH CellsForRRuleGuideline  
RESR15_RHCellOut = NOT INSIDE CELL RH ExclCellsForRRuleGuideline 
RESR15_RHCell = RESR15_RHCellIn AND RESR15_RHCellOut
RESR15_RHMarker = RH AND RRuleGuideline
RESR15_RH = ((( RESR15_RHCell OR RESR15_RHMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline


RR:GL:RESR15 { @ Recommended to use rectangle shape resistor for SPICE simulation accuracy
  (NOT RECTANGLE OD_RES_RPO) INTERACT RESR15_RH
  (NOT RECTANGLE PO_RES_RPO) INTERACT RESR15_RH
}
#ENDIF

#IFDEF _COS6_
COS6_ODCellIn = INSIDE CELL ODi CellsForRRuleGuideline  
COS6_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleGuideline 
COS6_ODCell = COS6_ODCellIn AND COS6_ODCellOut
COS6_ODMarker = ODi AND RRuleGuideline
COS6_OD = ((( COS6_ODCell OR COS6_ODMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:COS6 { @ Recommended to put contacts at both source side and butted well pickup.
  BUTT_SOUR = SD INTERACT (BUTT_PSTP OR BUTT_NSTP)
  (BUTT_PSTP INTERACT COS6_OD ) NOT INTERACT COi
  (BUTT_NSTP INTERACT COS6_OD ) NOT INTERACT COi
  (BUTT_SOUR INTERACT COS6_OD ) NOT INTERACT COi
}
#ENDIF

#IFDEF _COR5_
COR5_COCellIn = INSIDE CELL COi CellsForRRuleGuideline  
COR5_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleGuideline 
COR5_COCell = COR5_COCellIn AND COR5_COCellOut
COR5_COMarker = COi AND RRuleGuideline
COR5_CO = ((( COR5_COCell OR COR5_COMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:COR5 { @ Recommended to use redundant CO to avoid high Rc whenever layout allows.
  ((FPO1 AND M1) INTERACT COR5_CO == 1) AND COR5_CO
  ((SD AND M1) INTERACT COR5_CO == 1) AND COR5_CO
  ((DSTP AND M1) INTERACT COR5_CO == 1) AND COR5_CO
}
#ENDIF

#IFDEF _VIA1R9_
VIA1R9_VIA1CellIn = INSIDE CELL VIA1i CellsForRRuleGuideline  
VIA1R9_VIA1CellOut = NOT INSIDE CELL VIA1i ExclCellsForRRuleGuideline 
VIA1R9_VIA1Cell = VIA1R9_VIA1CellIn AND VIA1R9_VIA1CellOut
VIA1R9_VIA1Marker = VIA1i AND RRuleGuideline
VIA1R9_VIA1 = ((( VIA1R9_VIA1Cell OR VIA1R9_VIA1Marker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleGuideline

RR:GL:VIA1R9{@ Recommended to use redundant VIAs to avoid high Rc whenever layout allows.
  (((M1 AND M2) INTERACT VIA1R9_VIA1 == 1) AND VIA1R9_VIA1) NOT P_RING_VIA1
}
#ENDIF
#IFDEF _VIA2R9_
VIA2R9_VIA2CellIn = INSIDE CELL VIA2i CellsForRRuleGuideline  
VIA2R9_VIA2CellOut = NOT INSIDE CELL VIA2i ExclCellsForRRuleGuideline 
VIA2R9_VIA2Cell = VIA2R9_VIA2CellIn AND VIA2R9_VIA2CellOut
VIA2R9_VIA2Marker = VIA2i AND RRuleGuideline
VIA2R9_VIA2 = ((( VIA2R9_VIA2Cell OR VIA2R9_VIA2Marker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleGuideline

RR:GL:VIA2R9{@ Recommended to use redundant VIAs to avoid high Rc whenever layout allows.
  (((M2 AND M3) INTERACT VIA2R9_VIA2 == 1) AND VIA2R9_VIA2) NOT P_RING_VIA2
}
#ENDIF
#IFDEF _VIA3R9_
VIA3R9_VIA3CellIn = INSIDE CELL VIA3i CellsForRRuleGuideline  
VIA3R9_VIA3CellOut = NOT INSIDE CELL VIA3i ExclCellsForRRuleGuideline 
VIA3R9_VIA3Cell = VIA3R9_VIA3CellIn AND VIA3R9_VIA3CellOut
VIA3R9_VIA3Marker = VIA3i AND RRuleGuideline
VIA3R9_VIA3 = ((VIA3R9_VIA3Cell OR VIA3R9_VIA3Marker) NOT Block ) NOT excludeRRuleGuideline

RR:GL:VIA3R9{@ Recommended to use redundant VIAs to avoid high Rc whenever layout allows.
  (((M3 AND M4) INTERACT VIA3R9_VIA3 == 1) AND VIA3R9_VIA3) NOT P_RING_VIA3
}
#ENDIF
#IFDEF _VIA4R9_
VIA4R9_VIA4CellIn = INSIDE CELL VIA4i CellsForRRuleGuideline  
VIA4R9_VIA4CellOut = NOT INSIDE CELL VIA4i ExclCellsForRRuleGuideline 
VIA4R9_VIA4Cell = VIA4R9_VIA4CellIn AND VIA4R9_VIA4CellOut
VIA4R9_VIA4Marker = VIA4i AND RRuleGuideline
VIA4R9_VIA4 = ((VIA4R9_VIA4Cell OR VIA4R9_VIA4Marker) NOT Block ) NOT excludeRRuleGuideline

RR:GL:VIA4R9{@ Recommended to use redundant VIAs to avoid high Rc whenever layout allows.
  (((M4 AND M5) INTERACT VIA4R9_VIA4 == 1) AND VIA4R9_VIA4) NOT P_RING_VIA4
}
#ENDIF
#IFDEF _VIA5R9_
VIA5R9_VIA5CellIn = INSIDE CELL VIA5i CellsForRRuleGuideline  
VIA5R9_VIA5CellOut = NOT INSIDE CELL VIA5i ExclCellsForRRuleGuideline 
VIA5R9_VIA5Cell = VIA5R9_VIA5CellIn AND VIA5R9_VIA5CellOut
VIA5R9_VIA5Marker = VIA5i AND RRuleGuideline
VIA5R9_VIA5 = ((VIA5R9_VIA5Cell OR VIA5R9_VIA5Marker) NOT Block ) NOT excludeRRuleGuideline

RR:GL:VIA5R9{@ Recommended to use redundant VIAs to avoid high Rc whenever layout allows.
  (((M5 AND M6) INTERACT VIA5R9_VIA5 == 1) AND VIA5R9_VIA5) NOT P_RING_VIA5
}
#ENDIF
#IFDEF _VIA6R9_
VIA6R9_VIA6CellIn = INSIDE CELL VIA6i CellsForRRuleGuideline  
VIA6R9_VIA6CellOut = NOT INSIDE CELL VIA6i ExclCellsForRRuleGuideline 
VIA6R9_VIA6Cell = VIA6R9_VIA6CellIn AND VIA6R9_VIA6CellOut
VIA6R9_VIA6Marker = VIA6i AND RRuleGuideline
VIA6R9_VIA6 = ((VIA6R9_VIA6Cell OR VIA6R9_VIA6Marker) NOT Block ) NOT excludeRRuleGuideline

RR:GL:VIA6R9{@ Recommended to use redundant VIAs to avoid high Rc whenever layout allows.
  (((M6 AND M7) INTERACT VIA6R9_VIA6 == 1) AND VIA6R9_VIA6) NOT P_RING_VIA6
}
#ENDIF
#IFDEF _VIA7R9_
VIA7R9_VIA7CellIn = INSIDE CELL VIA7i CellsForRRuleGuideline  
VIA7R9_VIA7CellOut = NOT INSIDE CELL VIA7i ExclCellsForRRuleGuideline 
VIA7R9_VIA7Cell = VIA7R9_VIA7CellIn AND VIA7R9_VIA7CellOut
VIA7R9_VIA7Marker = VIA7i AND RRuleGuideline
VIA7R9_VIA7 = ((VIA7R9_VIA7Cell OR VIA7R9_VIA7Marker) NOT Block ) NOT excludeRRuleGuideline

RR:GL:VIA7R9{@ Recommended to use redundant VIAs to avoid high Rc whenever layout allows.
  (((M7 AND M8) INTERACT VIA7R9_VIA7 == 1) AND VIA7R9_VIA7) NOT P_RING_VIA7
}
#ENDIF
#IFDEF _VIA8R5_
#IFDEF MIXED_SCHEME
VIA8R5_VIA8_OLDCellIn = INSIDE CELL VIA8_OLD CellsForRRuleGuideline  
VIA8R5_VIA8_OLDCellOut = NOT INSIDE CELL VIA8_OLD ExclCellsForRRuleGuideline 
VIA8R5_VIA8_OLDCell = VIA8R5_VIA8_OLDCellIn AND VIA8R5_VIA8_OLDCellOut
VIA8R5_VIA8_OLDMarker = VIA8_OLD AND RRuleGuideline
VIA8R5_VIA8_OLD = ((VIA8R5_VIA8_OLDCell OR VIA8R5_VIA8_OLDMarker) NOT Block ) NOT excludeRRuleGuideline

VIA8R5_VIA8_NEWCellIn = INSIDE CELL VIA8_NEW CellsForRRuleGuideline  
VIA8R5_VIA8_NEWCellOut = NOT INSIDE CELL VIA8_NEW ExclCellsForRRuleGuideline 
VIA8R5_VIA8_NEWCell = VIA8R5_VIA8_NEWCellIn AND VIA8R5_VIA8_NEWCellOut
VIA8R5_VIA8_NEWMarker = VIA8_NEW AND RRuleGuideline
VIA8R5_VIA8_NEW = ((VIA8R5_VIA8_NEWCell OR VIA8R5_VIA8_NEWMarker) NOT Block ) NOT excludeRRuleGuideline

VIA8R5_VIA8 = VIA8R5_VIA8_OLD OR VIA8R5_VIA8_NEW
#ELSE
VIA8R5_VIA8CellIn = INSIDE CELL VIA8_NEW CellsForRRuleGuideline  
VIA8R5_VIA8CellOut = NOT INSIDE CELL VIA8_NEW ExclCellsForRRuleGuideline 
VIA8R5_VIA8Cell = VIA8R5_VIA8CellIn AND VIA8R5_VIA8CellOut
VIA8R5_VIA8Marker = VIA8_NEW AND RRuleGuideline
VIA8R5_VIA8 = ((VIA8R5_VIA8Cell OR VIA8R5_VIA8Marker) NOT Block ) NOT excludeRRuleGuideline

#ENDIF
RR:GL:VIA8R5{@ Recommended to use redundant VIAs to avoid high Rc whenever layout allows.
  ((M8 AND M9) INTERACT VIA8R5_VIA8 == 1) AND VIA8R5_VIA8
}
#ENDIF
#IFDEF _VIA9R5_
#IFDEF MIXED_SCHEME
VIA9R5_VIA9_OLDCellIn = INSIDE CELL VIA9_OLD CellsForRRuleGuideline  
VIA9R5_VIA9_OLDCellOut = NOT INSIDE CELL VIA9_OLD ExclCellsForRRuleGuideline 
VIA9R5_VIA9_OLDCell = VIA9R5_VIA9_OLDCellIn AND VIA9R5_VIA9_OLDCellOut
VIA9R5_VIA9_OLDMarker = VIA9_OLD AND RRuleGuideline
VIA9R5_VIA9_OLD = ((VIA9R5_VIA9_OLDCell OR VIA9R5_VIA9_OLDMarker) NOT Block ) NOT excludeRRuleGuideline

VIA9R5_VIA9_NEWCellIn = INSIDE CELL VIA9_NEW CellsForRRuleGuideline  
VIA9R5_VIA9_NEWCellOut = NOT INSIDE CELL VIA9_NEW ExclCellsForRRuleGuideline 
VIA9R5_VIA9_NEWCell = VIA9R5_VIA9_NEWCellIn AND VIA9R5_VIA9_NEWCellOut
VIA9R5_VIA9_NEWMarker = VIA9_NEW AND RRuleGuideline
VIA9R5_VIA9_NEW = ((VIA9R5_VIA9_NEWCell OR VIA9R5_VIA9_NEWMarker) NOT Block ) NOT excludeRRuleGuideline

VIA9R5_VIA9 = VIA9R5_VIA9_OLD OR VIA9R5_VIA9_NEW
#ELSE
VIA9R5_VIA9CellIn = INSIDE CELL VIA9_NEW CellsForRRuleGuideline  
VIA9R5_VIA9CellOut = NOT INSIDE CELL VIA9_NEW ExclCellsForRRuleGuideline 
VIA9R5_VIA9Cell = VIA9R5_VIA9CellIn AND VIA9R5_VIA9CellOut
VIA9R5_VIA9Marker = VIA9_NEW AND RRuleGuideline
VIA9R5_VIA9 = ((VIA9R5_VIA9Cell OR VIA9R5_VIA9Marker) NOT Block ) NOT excludeRRuleGuideline

#ENDIF
RR:GL:VIA9R5{@ Recommended to use redundant VIAs to avoid high Rc whenever layout allows.
  ((M9 AND M10) INTERACT VIA9R5_VIA9 == 1) AND VIA9R5_VIA9
}
#ENDIF

#ENDIF //Guideline


#IFDEF Recommended

#IFDEF SP
#IFDEF _POS17_
POS17_POCellIn = INSIDE CELL POi CellsForRRuleRecommended  
POS17_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRecommended 
POS17_POCell = POS17_POCellIn AND POS17_POCellOut
POS17_POMarker = POi AND RRuleRecommended
POS17_PO = ((( POS17_POCell OR POS17_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:POS17 {@ Recommended Gate edge [channel length = 0.04um, channel width <=0.2um] spaceto {(PO OR SR_DPO) OR DPO } [width >= 0.12um][projection in S/D direction], and Gate edge parallel length (individual projection) in the same gate >= 0.1um, for poly gate CDU control >= 0.16 
   GATE_CHK = ((GATE AND POS17_PO) WITH EDGE (LENGTH GATE_L == PO_S_17_R_GL)) WITH EDGE (LENGTH GATE_W <= PO_S_17_R_GW )
   GATE_W_CHK = GATE_W COIN INSIDE EDGE GATE_CHK  
   POLY_CHECK = WITH WIDTH ALL_POLY >= PO_S_17_R_W   
   X = EXT [GATE_W_CHK] POLY_CHECK < PO_S_17_R OPPOSITE
   LENGTH X >= PO_S_17_R_L
}
#ENDIF
#ENDIF

#IFDEF GS
#IFDEF Parametric
#IFDEF _POS18_
POS18_POCellIn = INSIDE CELL POi CellsForRRuleRecommended  
POS18_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRecommended 
POS18_POCell = POS18_POCellIn AND POS18_POCellOut
POS18_POMarker = POi AND RRuleRecommended
POS18_PO = ((( POS18_POCell OR POS18_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:POS18 {@ Recommend to add 2nd poly away from 1st poly [for channel length < 0.08um] (DRC only check 1st poly space to gate <= 0.2 and width < 0.08) 0.14~0.2  
   GATE_CHK = ((GATE NOT TCDDMY) AND POS18_PO) WITH EDGE (LENGTH GATE_L < PO_S_18_R_GL)
   GATE_W_CHK = GATE_W COIN INSIDE EDGE GATE_CHK  
   X = EXT GATE_W_CHK [ALL_POLY] <= PO_S_18_R_S OPPOSITE
   Y = INT X [ALL_POLY] < PO_S_18_R_W OPPOSITE 
   EXT [Y] ALL_POLY < PO_S_18_R_1 OPPOSITE 
   A = EXT [Y] ALL_POLY <= PO_S_18_R_2 OPPOSITE
   Y NOT COIN INSIDE EDGE A
}
#ENDIF
#ENDIF
#ENDIF

#IFDEF Defect
#IFDEF _M1EN5_
M1EN5_COCellIn = INSIDE CELL COi CellsForRRuleRecommended  
M1EN5_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleRecommended 
M1EN5_COCell = M1EN5_COCellIn AND M1EN5_COCellOut
M1EN5_COMarker = COi AND RRuleRecommended
M1EN5_CO = ((( M1EN5_COCell OR M1EN5_COMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:M1EN5 { @ Enclosure of CO [metal width >= 0.11, space < 0.08] >= 0.015 (This check does not include two or more COs in the metal intersection)
   X = M1s WITH WIDTH >= M1_EN_5_R_W
   sus_co = M1EN5_CO NOT OUTSIDE X
   sus_M1 = M1i INTERACT sus_co
   sus_M1_OD = (sus_M1 AND (OD NOT POLY)) ENCLOSE COi == 1
   sus_M1_PO = (sus_M1 AND POLY) ENCLOSE COi == 1
   check_co = sus_co AND (sus_M1_OD OR sus_M1_PO)
   G1 = EXT [X] M1s < M1_EN_5_R_S OPPOSITE MEASURE ALL
   G2 = (EXT X M1s < M1_EN_5_R_S OPPOSITE REGION MEASURE ALL) NOT M1s
   check_edge = EXT G1 [G2] < M1_EN_5_R OPPOSITE ABUT < 90
   EXT check_co check_edge < M1_EN_5_R ABUT < 90 REGION OPPOSITE
}
#ENDIF
#ENDIF

#IFDEF SD
M1A1_M1CellIn = INSIDE CELL M1i_R CellsForRRuleRecommended  
M1A1_M1CellOut = NOT INSIDE CELL M1i_R ExclCellsForRRuleRecommended 
M1A1_M1Cell = M1A1_M1CellIn AND M1A1_M1CellOut
M1A1_M1Marker = M1i_R AND RRuleRecommended
M1A1_M1 = ((M1A1_M1Cell OR M1A1_M1Marker) NOT Block ) NOT excludeRRuleRecommended

#IFDEF _M1A1_
RR:RE:M1A1 { @ Recommended area >= 0.0351  
   AREA M1A1_M1 < M1_A_1_R
}
#ENDIF
M2A1_M2CellIn = INSIDE CELL M2i_R CellsForRRuleRecommended  
M2A1_M2CellOut = NOT INSIDE CELL M2i_R ExclCellsForRRuleRecommended 
M2A1_M2Cell = M2A1_M2CellIn AND M2A1_M2CellOut
M2A1_M2Marker = M2i_R AND RRuleRecommended
M2A1_M2 = ((M2A1_M2Cell OR M2A1_M2Marker) NOT Block ) NOT excludeRRuleRecommended

#IFDEF _M2A1_
RR:RE:M2A1 { @ Recommended area >= 0.0351  
   AREA M2A1_M2 < M2_A_1_R
}
#ENDIF
M3A1_M3CellIn = INSIDE CELL M3i_R CellsForRRuleRecommended  
M3A1_M3CellOut = NOT INSIDE CELL M3i_R ExclCellsForRRuleRecommended 
M3A1_M3Cell = M3A1_M3CellIn AND M3A1_M3CellOut
M3A1_M3Marker = M3i_R AND RRuleRecommended
M3A1_M3 = ((M3A1_M3Cell OR M3A1_M3Marker) NOT Block ) NOT excludeRRuleRecommended

#IFDEF _M3A1_
RR:RE:M3A1 { @ Recommended area >= 0.0351  
   AREA M3A1_M3 < M3_A_1_R
}
#ENDIF
M4A1_M4CellIn = INSIDE CELL M4i_R CellsForRRuleRecommended  
M4A1_M4CellOut = NOT INSIDE CELL M4i_R ExclCellsForRRuleRecommended 
M4A1_M4Cell = M4A1_M4CellIn AND M4A1_M4CellOut
M4A1_M4Marker = M4i_R AND RRuleRecommended
M4A1_M4 = ((M4A1_M4Cell OR M4A1_M4Marker) NOT Block ) NOT excludeRRuleRecommended

#IFDEF _M4A1_
RR:RE:M4A1 { @ Recommended area >= 0.0351  
   AREA M4A1_M4 < M4_A_1_R
}
#ENDIF
M5A1_M5CellIn = INSIDE CELL M5i_R CellsForRRuleRecommended  
M5A1_M5CellOut = NOT INSIDE CELL M5i_R ExclCellsForRRuleRecommended 
M5A1_M5Cell = M5A1_M5CellIn AND M5A1_M5CellOut
M5A1_M5Marker = M5i_R AND RRuleRecommended
M5A1_M5 = ((M5A1_M5Cell OR M5A1_M5Marker) NOT Block ) NOT excludeRRuleRecommended

#IFDEF _M5A1_
RR:RE:M5A1 { @ Recommended area >= 0.0351  
   AREA M5A1_M5 < M5_A_1_R
}
#ENDIF
M6A1_M6CellIn = INSIDE CELL M6i_R CellsForRRuleRecommended  
M6A1_M6CellOut = NOT INSIDE CELL M6i_R ExclCellsForRRuleRecommended 
M6A1_M6Cell = M6A1_M6CellIn AND M6A1_M6CellOut
M6A1_M6Marker = M6i_R AND RRuleRecommended
M6A1_M6 = ((M6A1_M6Cell OR M6A1_M6Marker) NOT Block ) NOT excludeRRuleRecommended

#IFDEF _M6A1_
RR:RE:M6A1 { @ Recommended area >= 0.0351  
   AREA M6A1_M6 < M6_A_1_R
}
#ENDIF
M7A1_M7CellIn = INSIDE CELL M7i_R CellsForRRuleRecommended  
M7A1_M7CellOut = NOT INSIDE CELL M7i_R ExclCellsForRRuleRecommended 
M7A1_M7Cell = M7A1_M7CellIn AND M7A1_M7CellOut
M7A1_M7Marker = M7i_R AND RRuleRecommended
M7A1_M7 = ((M7A1_M7Cell OR M7A1_M7Marker) NOT Block ) NOT excludeRRuleRecommended

#IFDEF _M7A1_
RR:RE:M7A1 { @ Recommended area >= 0.0351  
   AREA M7A1_M7 < M7_A_1_R
}
#ENDIF
M8A1_M8CellIn = INSIDE CELL M8i_R CellsForRRuleRecommended  
M8A1_M8CellOut = NOT INSIDE CELL M8i_R ExclCellsForRRuleRecommended 
M8A1_M8Cell = M8A1_M8CellIn AND M8A1_M8CellOut
M8A1_M8Marker = M8i_R AND RRuleRecommended
M8A1_M8 = ((M8A1_M8Cell OR M8A1_M8Marker) NOT Block ) NOT excludeRRuleRecommended

#IFDEF _M8A1_
RR:RE:M8A1 { @ Recommended area >= 0.0351  
   AREA M8A1_M8 < M8_A_1_R
}
#ENDIF
#ENDIF

#ENDIF
#ENDIF


#IFDEF DFM
#IFDEF Recommended
#IFDEF Parametric
#DEFINE DFM_SANITY
#ENDIF
#ENDIF
#ENDIF

#IFDEF SANITY_CHECKER_FOR_PDE_AND_CO_PLACEMENT
#DEFINE DFM_SANITY
#DEFINE _ODDN4_
#DEFINE _ODDN5_
#DEFINE _ODDN6_
#DEFINE _ODDN7_
#DEFINE _ODDN8_
#DEFINE _ODDN9_
#DEFINE _DODR2_
#DEFINE _PODN4_
#DEFINE _PODN5_
#DEFINE _PODN6_
#DEFINE _PODN7_
#DEFINE _PODN8_
#DEFINE _PODN9_
#DEFINE _COS7_
#ENDIF

#IFDEF DFM_SANITY

#IFDEF _ODDN4_
RR:RE:ODDN4 { @ It is not recommended gate interact the region of {(OD local density < 10%) SIZING 20um}. The definition of gate: 1. Channel length <=0.05um 2. {(((Gate INTERACT SENDMY*) NOT LOGO) NOT CSRDMY) NOT (SRAMDMY AND RODMY)} The definition of the region OD local density: {OD OR DOD OR SR_DOD} local density (window 20umx20um, stepping 10um) 10%  
   X = DENSITY ALL_OD < OD_DN_4_R INSIDE OF LAYER CHIP WINDOW 20 STEP 10 BACKUP RDB OD.DN.4R.rep
       [AREA(ALL_OD)/AREA()]
   SEN_GATE INTERACT (X SIZE BY 20)
}
#ENDIF

#IFDEF _ODDN5_
RR:RE:ODDN5 { @ It is not recommended gate interact the region of {(OD local density > 55%) SIZING 20um}. The definition of gate: 1. Channel length <=0.05um 2. {(((Gate INTERACT SENDMY*) NOT LOGO) NOT CSRDMY) NOT (SRAMDMY AND RODMY)} The definition of the region OD local density: {OD OR DOD OR SR_DOD} local density (window 20umx20um, stepping 10um) 55%  
   X = DENSITY ALL_OD > OD_DN_5_R INSIDE OF LAYER CHIP WINDOW 20 STEP 10 BACKUP RDB OD.DN.5R.rep
       [AREA(ALL_OD)/AREA()]
   SEN_GATE INTERACT (X SIZE BY 20)
}
#ENDIF

#IFDEF _ODDN6_
RR:RE:ODDN6 { @ It is not recommended gate interact the region of {(OD local density < 20%) SIZING 100um}. The definition of gate: 1. Channel length <=0.05um 2. {(((Gate INTERACT SENDMY*) NOT LOGO) NOT CSRDMY) NOT (SRAMDMY AND RODMY)} The definition of the region OD local density: {OD OR DOD OR SR_DOD} local density (window 50umx50um, stepping 25um) 20%  
   X = DENSITY ALL_OD < OD_DN_6_R INSIDE OF LAYER CHIP WINDOW 50 STEP 25 BACKUP RDB OD.DN.6R.rep
       [AREA(ALL_OD)/AREA()]
   SEN_GATE INTERACT (X SIZE BY 100)
}
#ENDIF

#IFDEF _ODDN7_
RR:RE:ODDN7 { @ It is not recommended gate interact the region of {(OD local density > 55%) SIZING 100um}. The definition of gate: 1. Channel length <=0.05um 2. {(((Gate INTERACT SENDMY*) NOT LOGO) NOT CSRDMY) NOT (SRAMDMY AND RODMY)} The definition of the region OD local density: {OD OR DOD OR SR_DOD} local density (window 50umx50um, stepping 25um) 55%  
   X = DENSITY ALL_OD > OD_DN_7_R INSIDE OF LAYER CHIP WINDOW 50 STEP 25 BACKUP RDB OD.DN.7R.rep
       [AREA(ALL_OD)/AREA()]
   SEN_GATE INTERACT (X SIZE BY 100)
}
#ENDIF

#IFDEF _ODDN8_
RR:RE:ODDN8 { @ It is not recommended unsalicided poly resistor interact the region of {(OD local density < 20%) SIZING 100um}. The definition of unaslicided poly resistor: {(((RH AND (RPO AND PO)) AND RPDMY) AND SENDMY*)} The definition of the region OD local density: {OD OR DOD OR SR_DOD} local density (window 200umx200um, stepping 100um) 20%  
    X = DENSITY ALL_OD < OD_DN_8_R INSIDE OF LAYER CHIP WINDOW 200 STEP 100 BACKUP RDB OD.DN.8R.rep
       [AREA(ALL_OD)/AREA()]
    SEN_PO_RES_RPO INTERACT (X SIZE BY 100)

}
#ENDIF

#IFDEF _ODDN9_
RR:RE:ODDN9 { @ It is not recommended unsalicided poly resistor interact the region of {(OD local density > 60%) SIZING 100um}. The definition of unaslicided poly resistor: {(((RH AND (RPO AND PO)) AND RPDMY) AND SENDMY*)} The definition of the region OD local density: {OD OR DOD OR SR_DOD} local density (window 200umx200um, stepping 100um) 60%  
    X = DENSITY ALL_OD > OD_DN_9_R INSIDE OF LAYER CHIP WINDOW 200 STEP 100 BACKUP RDB OD.DN.9R.rep
       [AREA(ALL_OD)/AREA()]
    SEN_PO_RES_RPO INTERACT (X SIZE BY 100)
}
#ENDIF

#IFDEF _DODR2_
DODR2_POCellIn = INSIDE CELL POi CellsForRRuleRecommended  
DODR2_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRecommended 
DODR2_POCell = DODR2_POCellIn AND DODR2_POCellOut
DODR2_POMarker = POi AND RRuleRecommended
DODR2_PO = ((( DODR2_POCell OR DODR2_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:DODR2 { @ It is not allowed 1.8x1.8um2 empty rectangle area inside{(((((GATE SIZE 2.8) NOT (((OD OR DOD) OR SR_DOD) SIZE 0.12)) NOT ((PO SIZE 0.05) OR ((DPO OR SR_DPO) SIZE 0.03))) NOT ((NW SIZE 0.08) NOT (NW SIZE -0.08))) NOT TCDDMY)} It is very important to add SR_DOD into your IP before characterization.
   X = ((((((SIZE (GATEi AND DODR2_PO) BY 2.8) NOT (SIZE ALL_OD BY 0.12)) NOT ((SIZE POi BY 0.05) OR (SIZE (DPO OR SRDPO) BY 0.03))) NOT ( (SIZE NWi BY 0.08) NOT (SIZE NWi BY -0.08))) NOT TCDDMY) AND CHIP) NOT SEALRING_EXCLUDE
   WITH WIDTH X >= DOD_R_2_R    
}
#ENDIF

#IFDEF _PODN4_
RR:RE:PODN4 { @ It is not recommended gate interact the region of {(PO local density < 5%) SIZING 20um}. The definition of gate: 1. Channel length <=0.05um 2. {(((Gate INTERACT SENDMY*) NOT LOGO) NOT CSRDMY) NOT (SRAMDMY AND RODMY)} The definition of the region PO local density: {(PO OR DPO) OR SR_DPO} local density (window 20umx20um, stepping 10um) 5%  
    X = DENSITY ALL_POLY < PO_DN_4_R INSIDE OF LAYER CHIP WINDOW 20 STEP 10 BACKUP RDB PO.DN.4R.rep
        [AREA(ALL_POLY)/AREA()]
    SEN_GATE INTERACT (X SIZE BY 20)
}
#ENDIF

#IFDEF _PODN5_
RR:RE:PODN5 { @ It is not recommended gate interact the region of {(PO local density > 35%) SIZING 20um}. The definition of gate: 1. Channel length <=0.05um 2. {(((Gate INTERACT SENDMY*) NOT LOGO) NOT CSRDMY) NOT (SRAMDMY AND RODMY)} The definition of the region PO local density: {(PO OR DPO) OR SR_DPO} local density (window 20umx20um, stepping 10um) 35%  
    X = DENSITY ALL_POLY > PO_DN_5_R INSIDE OF LAYER CHIP WINDOW 20 STEP 10 BACKUP RDB PO.DN.5R.rep
        [AREA(ALL_POLY)/AREA()]
    SEN_GATE INTERACT (X SIZE BY 20)
}
#ENDIF

#IFDEF _PODN6_
RR:RE:PODN6 { @ It is not recommended gate interact the region of {(PO local density < 15%) SIZING 100um}. The definition of gate: 1. Channel length <=0.05um 2. {(((Gate INTERACT SENDMY*) NOT LOGO) NOT CSRDMY) NOT (SRAMDMY AND RODMY)} The definition of the region PO local density: {(PO OR DPO) OR SR_DPO} local density (window 50umx50um, stepping 25um) 15%  
    X = DENSITY ALL_POLY < PO_DN_6_R INSIDE OF LAYER CHIP WINDOW 50 STEP 25 BACKUP RDB PO.DN.6R.rep
        [AREA(ALL_POLY)/AREA()]
    SEN_GATE INTERACT (X SIZE BY 100)
}
#ENDIF

#IFDEF _PODN7_
RR:RE:PODN7 { @ It is not recommended gate interact the region of {(PO local density > 35%) SIZING 100um}. The definition of gate: 1. Channel length <=0.05um 2. {(((Gate INTERACT SENDMY*) NOT LOGO) NOT CSRDMY) NOT (SRAMDMY AND RODMY)} The definition of the region PO local density: {(PO OR DPO) OR SR_DPO} local density (window 50umx50um, stepping 25um) 35%  
    X = DENSITY ALL_POLY > PO_DN_7_R INSIDE OF LAYER CHIP WINDOW 50 STEP 25 BACKUP RDB PO.DN.7R.rep
        [AREA(ALL_POLY)/AREA()]
    SEN_GATE INTERACT (X SIZE BY 100)
}
#ENDIF

#IFDEF _PODN8_
RR:RE:PODN8 { @ It is not recommended unsalicided poly resistor interact the region of {(PO local density < 15%) SIZING 100um}. The definition of unaslicided poly resistor: {(((RH AND (RPO AND PO)) AND RPDMY) AND SENDMY*)} The definition of the region OD local density: {(PO OR DPO) OR SR_DPO} local density (window 200umx200um, stepping 100um) 15%  
    X = DENSITY ALL_POLY < PO_DN_8_R INSIDE OF LAYER CHIP WINDOW 200 STEP 100 BACKUP RDB PO.DN.8R.rep
        [AREA(ALL_POLY)/AREA()]
    SEN_PO_RES_RPO INTERACT (X SIZE BY 100)
}
#ENDIF

#IFDEF _PODN9_
RR:RE:PODN9 { @ It is not recommended unsalicided poly resistor interact the region of {(PO local density > 40%) SIZING 100um}. The definition of unaslicided poly resistor: {(((RH AND (RPO AND PO)) AND RPDMY) AND SENDMY*)} The definition of the region OD local density: {(PO OR DPO) OR SR_DPO} local density (window 200umx200um, stepping 100um) 40%  
    X = DENSITY ALL_POLY > PO_DN_9_R INSIDE OF LAYER CHIP WINDOW 200 STEP 100 BACKUP RDB PO.DN.9R.rep
        [AREA(ALL_POLY)/AREA()]
    SEN_PO_RES_RPO INTERACT (X SIZE BY 100)
}
#ENDIF

#IFDEF _COS7_
COS7_POCellIn = INSIDE CELL POi CellsForRRuleRecommended  
COS7_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRecommended 
COS7_POCell = COS7_POCellIn AND COS7_POCellOut
COS7_POMarker = POi AND RRuleRecommended
COS7_PO = ((( COS7_POCell OR COS7_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:COS7 { @ Recommended maximum effective CO space in Source/Drain <= 0.29
  SD_CHK  = SD INTERACT (CO OR DSTP)
  GATE_L_COS7   = LENGTH GATE_L <= CO_S_7_R_L
  GATE_W_COS7   = LENGTH GATE_W >= CO_S_7_R_W
  GATE_CHK_COS7 = (((GATE AND COS7_PO) WITH EDGE GATE_L_COS7) WITH EDGE GATE_W_COS7) NOT SRESD
  GATE_W_CHK_COS7  = (GATE_W_COS7 COIN INSIDE EDGE GATE_CHK_COS7) COIN OUTSIDE EDGE SD_CHK
  SD_CHK_COS7 = SD_CHK WITH EDGE GATE_W_CHK_COS7 
  CO_CHK_COS7 = CO AND SD_CHK_COS7
  CO_IN_GATE_W_COS7 = ENC CO_CHK_COS7 [SD_CHK_COS7] <= CO_S_7_R_S OPPOSITE EXCLUDE SHIELDED 4
  A = GATE_W_CHK_COS7 NOT COIN OUTSIDE EDGE CO_IN_GATE_W_COS7
  LENGTH A > CO_S_7_R
}
#ENDIF

#ENDIF


#IFDEF DFM
#IFDEF Recommended
#IFDEF First_priority
#IFDEF FULL_CHIP
OD_PO = ODi OR POi
MOS_R1 = OD_PO INTERACT (GATE NOT INTERACT ((TCDDMY OR CDUDMY) OR CSRDMY))
MOS_R2 = SIZE OD_PO BY SRDOD_DN_1_R_S2
MOS_R3 = SIZE MOS_R1 BY SRDOD_DN_1_R_S1
MOS_R4 = MOS_R3 NOT MOS_R2
MOS_AREA = (MOS_R4 NOT SRAMDMY) NOT OD2

#IFDEF _SRDODDN1_ 
RR:RE:SR_DOD.DN.1 { @ Recommended minimum SR_DOD density inside {((((((OD OR PO) INTERACT GATE) SIZING 2.5) NOT ((OD OR PO) SIZING 0.4)) NOT SRAMDMY;0) NOT OD2)} (The GATE doesn't include the regions covered by layer TCDDMY, CSRDMY, CDUDMY) >= 8%
  SRDOD_AREA = SRDOD AND MOS_AREA
  ERR = DENSITY SRDOD_AREA MOS_AREA < SRDOD_DN_1_R INSIDE OF LAYER CHIPx PRINT SR_DOD.DN.1.density
    [AREA(SRDOD_AREA)/AREA(MOS_AREA)]
  ERR AND MOS_AREA
}
#ENDIF

#IFDEF _SRDPODN1_
RR:RE:SR_DPO.DN.1 { @ Recommended minimum SR_DPO density inside {((((((OD OR PO) INTERACT GATE) SIZING 2.5) NOT ((OD OR PO) SIZING 0.4)) NOT SRAMDMY;0) NOT OD2)} (The GATE doesn't include the regions covered by layer TCDDMY, CSRDMY, CDUDMY) >= 4%
  SRDPO_AREA = SRDPO AND MOS_AREA
  ERR = DENSITY SRDPO_AREA MOS_AREA < SRDPO_DN_1_R INSIDE OF LAYER CHIPx PRINT SR_DPO.DN.1.density
    [AREA(SRDPO_AREA)/AREA(MOS_AREA)]
  ERR AND MOS_AREA
}
#ENDIF

#IFDEF _MxDN8_            
M2_ISLAND = RECTANGLE M2i == Mx_DN_8_W BY <= Mx_DN_8_L ORTHOGONAL ONLY
M2_SPACE = EXT M2_ISLAND M2i == Mx_DN_8_S OPPOSITE REGION
M2_LONG = (M2_SPACE ENCLOSE RECTANGLE GRID Mx_DN_8_R1) NOT ENCLOSE RECTANGLE GRID Mx_DN_8_R2
M2_AREA = M2_ISLAND INTERACT M2_LONG >= 2
M2_COUNT = EXTENTS M2_AREA CENTERS 0.1
M3_ISLAND = RECTANGLE M3i == Mx_DN_8_W BY <= Mx_DN_8_L ORTHOGONAL ONLY
M3_SPACE = EXT M3_ISLAND M3i == Mx_DN_8_S OPPOSITE REGION
M3_LONG = (M3_SPACE ENCLOSE RECTANGLE GRID Mx_DN_8_R1) NOT ENCLOSE RECTANGLE GRID Mx_DN_8_R2
M3_AREA = M3_ISLAND INTERACT M3_LONG >= 2
M3_COUNT = EXTENTS M3_AREA CENTERS 0.1
M4_ISLAND = RECTANGLE M4i == Mx_DN_8_W BY <= Mx_DN_8_L ORTHOGONAL ONLY
M4_SPACE = EXT M4_ISLAND M4i == Mx_DN_8_S OPPOSITE REGION
M4_LONG = (M4_SPACE ENCLOSE RECTANGLE GRID Mx_DN_8_R1) NOT ENCLOSE RECTANGLE GRID Mx_DN_8_R2
M4_AREA = M4_ISLAND INTERACT M4_LONG >= 2
M4_COUNT = EXTENTS M4_AREA CENTERS 0.1
M5_ISLAND = RECTANGLE M5i == Mx_DN_8_W BY <= Mx_DN_8_L ORTHOGONAL ONLY
M5_SPACE = EXT M5_ISLAND M5i == Mx_DN_8_S OPPOSITE REGION
M5_LONG = (M5_SPACE ENCLOSE RECTANGLE GRID Mx_DN_8_R1) NOT ENCLOSE RECTANGLE GRID Mx_DN_8_R2
M5_AREA = M5_ISLAND INTERACT M5_LONG >= 2
M5_COUNT = EXTENTS M5_AREA CENTERS 0.1
M6_ISLAND = RECTANGLE M6i == Mx_DN_8_W BY <= Mx_DN_8_L ORTHOGONAL ONLY
M6_SPACE = EXT M6_ISLAND M6i == Mx_DN_8_S OPPOSITE REGION
M6_LONG = (M6_SPACE ENCLOSE RECTANGLE GRID Mx_DN_8_R1) NOT ENCLOSE RECTANGLE GRID Mx_DN_8_R2
M6_AREA = M6_ISLAND INTERACT M6_LONG >= 2
M6_COUNT = EXTENTS M6_AREA CENTERS 0.1
M7_ISLAND = RECTANGLE M7i == Mx_DN_8_W BY <= Mx_DN_8_L ORTHOGONAL ONLY
M7_SPACE = EXT M7_ISLAND M7i == Mx_DN_8_S OPPOSITE REGION
M7_LONG = (M7_SPACE ENCLOSE RECTANGLE GRID Mx_DN_8_R1) NOT ENCLOSE RECTANGLE GRID Mx_DN_8_R2
M7_AREA = M7_ISLAND INTERACT M7_LONG >= 2
M7_COUNT = EXTENTS M7_AREA CENTERS 0.1
M8_ISLAND = RECTANGLE M8i == Mx_DN_8_W BY <= Mx_DN_8_L ORTHOGONAL ONLY
M8_SPACE = EXT M8_ISLAND M8i == Mx_DN_8_S OPPOSITE REGION
M8_LONG = (M8_SPACE ENCLOSE RECTANGLE GRID Mx_DN_8_R1) NOT ENCLOSE RECTANGLE GRID Mx_DN_8_R2
M8_AREA = M8_ISLAND INTERACT M8_LONG >= 2
M8_COUNT = EXTENTS M8_AREA CENTERS 0.1
RR:RE:Mx.DN.8 { @ Total Mx island (for all Mx layers) density<6.5E+4 ea/mm2 in whole chip. 
@ The definition of counts of small Mx island:
@ 1. Mx width == 0.07um 
@ 2. Mx length <= 0.52um 
@ 3. Mx has two segments with space == 0.07um with the parallel run length (0.209 <= parallel run length<0.52)
  DENSITY M2_COUNT M3_COUNT M4_COUNT M5_COUNT M6_COUNT M7_COUNT M8_COUNT >= Mx_DN_8 INSIDE OF LAYER CHIPx PRINT Mx.DN.8.density
  [(AREA(M2_COUNT)  + AREA(M3_COUNT) + AREA(M4_COUNT) + AREA(M5_COUNT) + AREA(M6_COUNT) + AREA(M7_COUNT) + AREA(M8_COUNT) )*100/AREA()]
}
#ENDIF

#IFDEF _ROMR3_               
RR:RE:ROM.R.3 { @ Each ROM cell must be covered by ROM(50;6). DRC only flags no ROM(50;6) in the chip. But if there is no ROM cell in the chip, the violation can be waived.
   CHIPx NOT INTERACT ROM
}
#ENDIF

#ENDIF
#ENDIF
#ENDIF
#ENDIF


#IFDEF DFM
#DEFINE ICOVL
#ENDIF

#IFDEF ICOVL

OVL_PO_OD = ICOVL NOT INTERACT COi
OVL_CO_PO = ICOVL INTERACT COi

#IFDEF TSMC_ROTATE 
CHIP_X = ANGLE CHIPx == 90
CHIP_Y = ANGLE CHIPx == 0
#ELSE
CHIP_X = ANGLE CHIPx == 0
CHIP_Y = ANGLE CHIPx == 90
#ENDIF

CHIP_X1 = LENGTH CHIP_X > 14310
CHIP_X2 = LENGTH CHIP_X > 9510 <= 14310
CHIP_Y1 = LENGTH CHIP_Y > 18240
CHIP_Y2 = LENGTH CHIP_Y > 12130 <= 18240

CHIP_1x1 = (CHIPx WITH EDGE CHIP_X1) WITH EDGE CHIP_Y1 
CHIP_1x2 = (CHIPx WITH EDGE CHIP_X1) WITH EDGE CHIP_Y2 
CHIP_2x1 = (CHIPx WITH EDGE CHIP_X2) WITH EDGE CHIP_Y1
CHIP_2x2 = (CHIPx WITH EDGE CHIP_X2) WITH EDGE CHIP_Y2

RR:RE:ICOVL.S.1{@ OVL_PO_OD space to OVL_CO_PO >= 40
  EXT OVL_PO_OD OVL_CO_PO < ICOVL_S_1 ABUT<90 SINGULAR REGION 
}
RR:RE:ICOVL.S.3{@ ICOVL (CAD layer no.: 165;3) space to {(OD OR PO) OR CO} >=	2
  EXT ICOVL ODi < ICOVL_S_3 ABUT<90 SINGULAR REGION 
  ODi CUT ICOVL     
  EXT ICOVL POi < ICOVL_S_3 ABUT<90 SINGULAR REGION 
  POi CUT ICOVL
  EXT ICOVL COi < ICOVL_S_3 ABUT<90 SINGULAR REGION 
  COi CUT ICOVL
}

#IFDEF FULL_CHIP
RR:RE:ICOVL.R.7 {@ At least 8 OVL_PO_ODs and 8 OVL_CO_POs for 1X1 Die
  CHIP_1x1 NOT INTERACT OVL_PO_OD >= ICOVL_R_7
  CHIP_1x1 NOT INTERACT OVL_CO_PO >= ICOVL_R_7
}

RR:RE:ICOVL.R.8 {@ At least 4 OVL_PO_ODs and 4 OVL_CO_POs for 1X2 Die or 2X1 Die
  CHIP_1x2 NOT INTERACT OVL_PO_OD >= ICOVL_R_8
  CHIP_1x2 NOT INTERACT OVL_CO_PO >= ICOVL_R_8
  CHIP_2x1 NOT INTERACT OVL_PO_OD >= ICOVL_R_8
  CHIP_2x1 NOT INTERACT OVL_CO_PO >= ICOVL_R_8
}
#ENDIF

#ENDIF






