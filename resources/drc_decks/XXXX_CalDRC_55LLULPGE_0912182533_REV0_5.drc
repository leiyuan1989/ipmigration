#! tvf
namespace import tvf::*


#//*******************************************************************************
#// Revision History:
#// Rev             Date                Who               Description
#// V0.5            2024-07-09          Warren            Initial
#//*******************************************************************************



#//##############################
#//#  <Choice 1>   IO Voltage   #
#//##############################

#//There are 2 kinds of voltage combinations, Please select one according to your own design.
#//For 55nm Logic LL 0.9/1.2/1.8/2.5V process or 2.5v overdrive to 3.3v, set this option to 1825;
#//For 55nm Logic LL 0.9/1.2/1.8/3.3V process, set this option to 1833;
#//Default value is 1825

VERBATIM {

#DEFINE IO 1825             //; The Valid value is: {1825,1833}
}

#//#########################################################
#//#  <Choice 2>   Total metal and Top metal choice        #
#//#########################################################

# Notice that below metal and via only means MET1~MET8,T2M1,T2V1,T2M2,T2V2,T4M1,T4V1,T4M2,T4V2,T8M1,T8V1,T8M2,T8V2
# if define top metal 1, please set T2V1_T2M1, T4V1_T4M1 or T8V1_T8M1 to 1 as your top metal layer

set total_metal 5          ; # The Valid value is: {10,9,8,7,6,5,4}
                            ; # Please set the total metal counts based on your design

set top_metal 1             ; # The Valid value is: {1,2}
                            ; # Please set the top metal counts based on your design
                            ; # Please change the default value "2" into "1" if there is only one top metal in your design

set T2V1_T2M1 0             ; # The Valid value is: {0,1}
                            ; # Please set the top metal "T2M1" and top via "T2V1" count based on your design
                            ; # The value "0" means that there is no this kind of top metal and top via in your design
                            ; # Please change the default value "0" into "1" if this kind of top metal and top via exists in your design

set T2V2_T2M2 0             ; # The Valid value is: {0,1}
                            ; # Please set the top metal "T2M2" and top via "T2V2" count based on your design
                            ; # The value "0" means that there is no this kind of top metal and top via in your design
                            ; # Please change the default value "0" into "1" if this kind of top metal and top via exists in your design

set T4V1_T4M1 1            ; # The Valid value is: {0,1}
                            ; # Please set the top metal "T4M1" and top via "T4V1" count based on your design
                            ; # The value "0" means that there is no this kind of top metal and top via in your design
                            ; # Please change the default value "0" into "1" if this kind of top metal and top via exists in your design

set T4V2_T4M2 0             ; # The Valid value is: {0,1}
                            ; # Please set the top metal "T4M2" and top via "T4V2" count based on your design
                            ; # The value "0" means that there is no this kind of top metal and top via in your design
                            ; # Please change the default value "0" into "1" if this kind of top metal and top via exists in your design

set T8V1_T8M1 0             ; # The Valid value is: {0,1}
                            ; # Please set the Ultra Thick top metal1 count based on your design
                            ; # The value "0" means that there is no this kind of top metal and top via1 in your design
                            ; # Please change the default value "0" into "1" if this kind of top metal1 and top via exists in your design

set T8V2_T8M2 0             ; # The Valid value is: {0,1}
                            ; # Please set the Ultra Thick top metal2 count based on your design
                            ; # The value "0" means that there is no this kind of top metal2 and top via2 in your design
                            ; # Please change the default value "0" into "1" if this kind of top metal and top via exists in your design
#//##########################################
#//#  <Choice 3>   Recommended rules Choice #
#//##########################################

#The rules with the superscript of [R] in DR are recommended rules which require performing DRC runset,
#but DRC checking is not gated for recommended rules. Pls consult with process integration engineer if customers have the doubt.

VERBATIM {
//; Default: YES
#DEFINE OPEN_RECOMMENDED_ON YES     //; The Valid value is: {YES,NO}
                                        //; # Please set the value for the switch to "YES" OR "NO" only based on the descriptions above.
                                        //; # Default value is "YES" to check recommended rules including  
                                        //; # ACT.W.3a[R], ACT.S.1[R], ACT.S.2a[R], 
                                        //; # PO.L.2[R], PO.S.4[R], PO.S.7a[R], PO.S.8[R], PO.S.10[R], PO.S.13[R], PO.S.15a[R],  PO.S.18[R], PO.EN.1[R], PO.EN.2[R], PO.EN.3[R], PO.EX1[R], PO.EX.3[R], PO.A.1[R]
                                        //; # SAB.EX.4[R],
                                        //; # CT.S.1a[R], CT.S.1a[R], CT.S.4[R], CT.EN.2[R], CT.EN.3[R], CT.EN.4a[R], CT.EN.4b[R],  
                                        //; # M1.S.1[R], Mn.S.1[R]
                                        //; # Vn.EN.2a[R], Vn.EN.2b[R], Vn.R.1[R], Vn.R.4[R], T4V1.R.1[R], T4V1.R.4[R], T4V2.R.1[R], T4V2.R.4[R]
                                        //; # T2V1.EN.2a[R], T2V1.EN.2b[R], T2V1.R.4[R], T2V2.EN.2a[R], T2V2.EN.2b[R], T2V2.R.4[R]
                                        //; # T8M1.D.1[R], T8M2.D.1[R]
                                        //; # Please change the value "YES" into "NO" if recommended rules shouldn't be checked. 

} 
#//#########################################
#//#  <Choice 4>   Guidelines rules choice #  
#//#########################################

VERBATIM {
//; Default: YES
#DEFINE LATCH_UP_CHECK      YES          //; The Valid value is: {YES,NO} 
                                         //; # Default value is "YES" to check Latch-Up rules.
                                         //; # Please change the value "YES" into "NO" if not to check Latch-Up rules.     
//; Default: YES
#DEFINE DUP_CHECK           YES          //; The Valid value is: {YES,NO} 
                                         //; # Default value is "YES" to check DUP rules.
                                         //; # Please change the value "YES" into "NO" if not to check DUP rules.
//; Default: YES
#DEFINE Metal_Slot_CHECK    YES          //; The Valid value is: {YES,NO}
                                         //; # Default value is "YES" to check Metal Slot rules.
                                         //; # Please change the value "YES" into "NO" if not to check Metal Slot rules.
//; Default: YES
#DEFINE MOM_CHECK           YES          //; The Valid value is: {YES,NO} 
                                         //; # Default value is "YES" to check MOM rules.
                                         //; # Please change the value "YES" into "NO" if not to check MOM rules.
//; Default: YES
#DEFINE ESD_CHECK           YES          //; The Valid value is: {YES,NO} 
                                         //; # Default value is "NO" not to check ESD rules.
                                         //; # Please change the value "NO" into "YES" if want to check ESD rules.
//; Default: NO
#DEFINE Poly_EFuse_CHECK    NO           //; The Valid value is: {YES,NO}
                                         //; # Default value is "NO" not to check Poly EFuse rules.
                                         //; # Please change the value "NO" into "YES" if want to check Poly EFuse rules.
}


#//###################################
#//#  <Choice 5>   ALLOW_V01         #
#//###################################

# If DRC needs to allow via size 0.1*0.1, then "set ALLOW_V01 YES"
# If DRC needs to highlight via size 0.1*0.1, then "set ALLOW_V01 NO"
# Default is "set ALLOW_V01 NO"

VERBATIM {
//; Default: NO
#DEFINE ALLOW_V01 NO                    //; The valid value is: {YES,NO}
}



#//##################################
#//#  <Choice 6>   CHIPEDGE Rules     #
#//##################################

VERBATIM {
//; Default: YES
#DEFINE CHIPEDGE_CHECK YES              //; The Valid value is: {YES,NO}
                                      //; # Please set the value for the switch to "YES" OR "NO" only based on the descriptions above.
                                      //; # Default value is "YES" to check CHIPEDGE rules.
                                      //; # Please change the value "YES" into "NO" if CHIPEDGE rules shouldn't be checked.
}

#//*************************************
#//*  <Choice 7>  Latch Up selection   *
#//*************************************

VERBATIM {
//; Default: 1
#DEFINE DEFINE_PAD_BY_TEXT  1         //; The Valid value is: {0,1}  
                                      //;# when\BF?VDD?\BF,\BF?VCC?\BF,\BF?VSS?\BF,\BF?GND?\BF as text name using layer ALPATXT on ALPA,
                                      //;# if value is 0, it is regarded as I/O PAD; if value is 1, it is regarded POWER PAD.    
                                     
//; Default: 0
#DEFINE CONNECT_ALL_RESISTOR 0        //; The Valid value is: {0,1}
                                      //;#when resistors are between PAD and AA injector   
                                      //;#if value is 0,the connection is broken; if value is 1,the connection is not broken;
//; Default: ACCURATE
#DEFINE LU_3_CHECK ACCURATE           //; The Valid value is: {ACCURATE,FAST}     
                                      //;#choose LU.3[G] check mode.
}


#//*************************************
#//*  <Choice 8>  Density rules  *
#//*************************************

VERBATIM {
//; Default: YES
#DEFINE Density_rules YES          //;The Valid value is: {YES,NO}
                                  //;#if value is NO, not to check Density rules; if value is YES, Check Density rules.
                                  //;#Related Rules:ACT_D_1_min, ACT_D_1_max, ACT_D_2, ACT_D_3, ACT_D_4_min, ACT_D_4_max, PO_D_1_min, PO_D_1_max, PO_D_2_min, PO_D_2_max, PO_D_3, MET1_D_1_min, MET1_D_1_max MET1_D_2, MET1_D_3, Mn_D_1_min, Mn_D_1_max, Mn_D_2, Mn_D_3, T4M1_D_1_min, T4M1_D_1_max, T4M1_D_2, T4M1_D_3, T4M2_D_1_min, T4M2_D_1_max, T4M2_D_2, T4M2_D_3, T2M1_D_1_min, T2M1_D_1_max,T2M1_D_2, T2M1_D_3, T2M2_D_1_min, T2M2_D_1_max, T2M2_D_2, T2M2_D_3, T8M1_D_1_R, T8M1_D_2, T8M1_D_3, T8M2_D_1_R, T8M2_D_2, T8M2_D_3, RDL_D_1_R, RDL_D_2_R
                                  //;# Default value is YES



}

#//*************************************
#//*  <Choice 9>  ESD1 rules  *
#//*************************************

#//Approach A: It applies to XXXX and 3rd party IO design. ESD1 mask is generated by XXXX logic operation formula. DRC switch(ESD1_A) need to turn on by default at ESD1 rule check.

#//Approach B: It applies to pure customer drawing and no logic operation formula is needed for ESD1 mask generation. DRC switch(ESD1_B) need to turn off by default at ESD1 rule check.

#//If there are both XXXX IO and customer\BFs own ESD design in circuit, please follow Approach A in ESD1 layer drawing & mask generation, or consult XXXX CE/FAE/DS for any issue.


VERBATIM {
//; Default: YES
#DEFINE ESD1_Approach_A  YES        //;The Valid value is: {YES,NO}
                                  //;#if value is YES,to check ESD1_Approach_A rules; if value is NO, NOT Check ESD1_Approach_A rules.
                                  //;# Default value is YES
//; Default: NO
#DEFINE ESD1_Approach_B NO       //;The Valid value is: {YES,NO}
                                  //;#if value is YES,to check ESD1_Approach_B rules; if value is NO, NOT Check ESD1_Approach_B rules.
                                  //;# Default value is NO

}

VERBATIM {
//##################################################The END for switch setting#############################################################################
}
                            


#--------------------------------------------------------------------------------------------
# Usher should not modify the below script.
# Vaild metal option setting control.
# Below matrix shows all of available 6 combinations for choice.
#set total_metal top_metal T2V1_T2M1 T2V2_T2M2 T4V1_T4M1 T4V2_T4M2 T8V1_T8M1 T8V2_T8M2 
set combinations {
{4 1 1 0 0 0 0 0}
{4 1 0 0 1 0 0 0}
{4 1 0 0 0 0 1 0}
{5 1 1 0 0 0 0 0}
{5 1 0 0 1 0 0 0}
{5 1 0 0 0 0 1 0}
{6 1 1 0 0 0 0 0}
{6 1 0 0 1 0 0 0}
{6 1 0 0 0 0 1 0}
{7 1 1 0 0 0 0 0}
{7 1 0 0 1 0 0 0}
{7 1 0 0 0 0 1 0}
{8 1 1 0 0 0 0 0}
{8 1 0 0 1 0 0 0}
{8 1 0 0 0 0 1 0} 
{9 1 1 0 0 0 0 0}
{9 1 0 0 1 0 0 0}
{9 1 0 0 0 0 1 0}
{5 2 1 1 0 0 0 0}
{5 2 1 0 0 1 0 0}
{5 2 1 0 0 0 0 1}
{5 2 0 0 1 1 0 0}
{5 2 0 0 1 0 0 1}
{5 2 0 0 0 0 1 1}
{6 2 1 1 0 0 0 0}
{6 2 1 0 0 1 0 0}
{6 2 1 0 0 0 0 1}
{6 2 0 0 1 1 0 0}
{6 2 0 0 1 0 0 1}
{6 2 0 0 0 0 1 1}
{7 2 1 1 0 0 0 0}
{7 2 1 0 0 1 0 0}
{7 2 1 0 0 0 0 1}
{7 2 0 0 1 1 0 0}
{7 2 0 0 1 0 0 1}
{7 2 0 0 0 0 1 1}
{8 2 1 1 0 0 0 0}
{8 2 1 0 0 1 0 0}
{8 2 1 0 0 0 0 1}
{8 2 0 0 1 1 0 0}
{8 2 0 0 1 0 0 1}
{8 2 0 0 0 0 1 1}
{9 2 1 1 0 0 0 0}
{9 2 1 0 0 1 0 0}
{9 2 1 0 0 0 0 1}
{9 2 0 0 1 1 0 0}
{9 2 0 0 1 0 0 1}
{9 2 0 0 0 0 1 1}
{10 2 1 1 0 0 0 0}
{10 2 1 0 0 1 0 0}
{10 2 1 0 0 0 0 1}
{10 2 0 0 1 1 0 0}
{10 2 0 0 1 0 0 1}
{10 2 0 0 0 0 1 1}
}
if { [lsearch -start 0 -all -inline $combinations "$total_metal $top_metal $T2V1_T2M1 $T2V2_T2M2 $T4V1_T4M1 $T4V2_T4M2 $T8V1_T8M1 $T8V2_T8M2"] eq "" } {
  puts "\nWrong metal option combination. Please check the setting for metal options.\n"
  exit
}

VERBATIM {
//==============================================================================================================

  VARIABLE PA_su 1.5        //; In XXXX LOTA, ALPA will be generated by the formual "(PA su 1.5) + RDL",
                            //; If CTM's LOTA not follows the value "1.5'" of PA grow, please fix it in the opition,
                            //; Be care that the value should not be smaller than 1.5um.


//DRC MAXIMUM RESULTS ALL

//*************************************
//     DIRECTIVE SECTION
//*************************************

LAYOUT PRIMARY "*"
LAYOUT PATH "*.gds"
LAYOUT SYSTEM GDSII
DRC RESULTS DATABASE "drc_CAL.OUT" ASCII
DRC SUMMARY REPORT "drc_CAL.SUM" HIER

PRECISION       1000
RESOLUTION      1

FLAG ACUTE YES
FLAG NONSIMPLE YES
FLAG SKEW YES
FLAG OFFGRID YES

LAYOUT BASE LAYER ACTi POLYi CTi NPi PPi

DGR_3 {
@ Only shapes of geometry that are orthogonal or 45-degree(0.1d tolerance) angle are allowed, excluding Inductor region.
 X = DFM COPY (DRAWN SKEW) EDGE
(X NOT COIN EDGE (ANGLE X >= 44.9 <= 45.1)) NOT INSIDE EDGE INDDMY
} 

skew_edge_check {
@ Only 0 degree (X), 90 degree (Y), and 45+/-0.1 degree (diagonal) is allowed in design layout.
  X = DRAWN SKEW 
  Y = DFM COPY X EDGE
  NOT ANGLE Y >= 44.9 <= 45.1
}
// does not check layers that do not appear in other rule
// checks used in the run

DRC EXCLUDE FALSE NOTCH YES
DRC CHECK TEXT ALL

//************************************
//     INPUT LAYER STATEMENTS
//************************************
LAYER MAP 2 DATATYPE 1 2001
LAYER ACTi  2001
LAYER MAP 2 DATATYPE 2 2002
LAYER ACTdmi  2002
LAYER MAP 2 DATATYPE 3 2003
LAYER ACTdmblk  2003
LAYER MAP 2 DATATYPE 4 2004
LAYER ACTres  2004
LAYER MAP 2 DATATYPE 5 2005
LAYER ACTopcblk  2005
LAYER MAP 7 DATATYPE 1 2006
LAYER DNWi  2006
LAYER MAP 9 DATATYPE 1 2007
LAYER NW1i   2007
LAYER MAP 9 DATATYPE 4 2008
LAYER NW1res  2008
LAYER MAP 17 DATATYPE 1 2009
LAYER NVT1  2009
LAYER MAP 18 DATATYPE 1 2010
LAYER PVT1  2010
LAYER MAP 21 DATATYPE 1 2011
LAYER NVT3  2011
LAYER MAP 22 DATATYPE 1 2012
LAYER PVT3  2012
LAYER MAP 27 DATATYPE 1 2013
LAYER DGOX  2013
LAYER MAP 28 DATATYPE 1 2014
LAYER TGOX  2014
LAYER MAP 41 DATATYPE 1 2015
LAYER MAP 41 TEXTTYPE 1 2015
LAYER POLYi  2015
LAYER MAP 41 DATATYPE 2 2016
LAYER POLYdmi  2016
LAYER MAP 41 DATATYPE 3 2017
LAYER POLYdmblk  2017
LAYER MAP 41 DATATYPE 4 2018
LAYER POLYres  2018
LAYER MAP 41 DATATYPE 5 2019
LAYER POLYopcblk  2019
LAYER MAP 41 TEXTTYPE 6 2020
LAYER POLYtext  2020
LAYER MAP 41 DATATYPE 7 2021
LAYER POLYbar  2021
LAYER MAP 43 DATATYPE 1 2022
LAYER NPD  2022
LAYER MAP 52 DATATYPE 1 2023
LAYER NPi  2023
LAYER MAP 53 DATATYPE 1 2024
LAYER PPi  2024
LAYER MAP 54 DATATYPE 1 2025
LAYER HRPi  2025
LAYER MAP 55 DATATYPE 1 2026
LAYER ESD1  2026
LAYER MAP 71 DATATYPE 1 2027
LAYER SABi  2027
LAYER MAP 72 DATATYPE 1 2028
LAYER CTi  2028
LAYER MAP 72 DATATYPE 5 2029
LAYER CTopcblk  2029
LAYER MAP 72 DATATYPE 7 2030
LAYER CTbar  2030
LAYER MAP 81 DATATYPE 1 2031
LAYER MAP 81 TEXTTYPE 1 2031
LAYER MET1o  2031
LAYER MAP 81 DATATYPE 2 2032
LAYER MET1dmi  2032
LAYER MAP 81 DATATYPE 3 2033
LAYER MET1dmblk  2033
LAYER MAP 81 DATATYPE 4 2034
LAYER MET1res  2034
LAYER MAP 81 DATATYPE 5 2035
LAYER MET1opcblk  2035
LAYER MAP 81 TEXTTYPE 6 2036
LAYER MET1text  2036
LAYER MAP 81 DATATYPE 8 2037
LAYER MET1sloti  2037
LAYER MAP 81 DATATYPE 9 2038
LAYER MET1slotblk  2038
LAYER MAP 81 DATATYPE 10 2039
LAYER MET1mom  2039
LAYER MAP 82 DATATYPE 1 2040
LAYER MAP 82 TEXTTYPE 1 2040
LAYER MET2o  2040
LAYER MAP 82 DATATYPE 2 2041
LAYER MET2dmi  2041
LAYER MAP 82 DATATYPE 3 2042
LAYER MET2dmblk  2042
LAYER MAP 82 DATATYPE 4 2043
LAYER MET2res  2043
LAYER MAP 82 DATATYPE 5 2044
LAYER MET2opcblk  2044
LAYER MAP 82 TEXTTYPE 6 2045
LAYER MET2text  2045
LAYER MAP 82 DATATYPE 8 2046
LAYER MET2sloti  2046
LAYER MAP 82 DATATYPE 9 2047
LAYER MET2slotblk  2047
LAYER MAP 82 DATATYPE 10 2048
LAYER MET2mom  2048
LAYER MAP 83 DATATYPE 1 2049
LAYER MAP 83 TEXTTYPE 1 2049
LAYER MET3o  2049
LAYER MAP 83 DATATYPE 2 2050
LAYER MET3dmi  2050
LAYER MAP 83 DATATYPE 3 2051
LAYER MET3dmblk  2051
LAYER MAP 83 DATATYPE 4 2052
LAYER MET3res  2052
LAYER MAP 83 DATATYPE 5 2053
LAYER MET3opcblk  2053
LAYER MAP 83 TEXTTYPE 6 2054
LAYER MET3text  2054
LAYER MAP 83 DATATYPE 8 2055
LAYER MET3sloti  2055
LAYER MAP 83 DATATYPE 9 2056
LAYER MET3slotblk  2056
LAYER MAP 83 DATATYPE 10 2057
LAYER MET3mom  2057
LAYER MAP 84 DATATYPE 1 2058
LAYER MAP 84 TEXTTYPE 1 2058
LAYER MET4o  2058
LAYER MAP 84 DATATYPE 2 2059
LAYER MET4dmi  2059
LAYER MAP 84 DATATYPE 3 2060
LAYER MET4dmblk  2060
LAYER MAP 84 DATATYPE 4 2061
LAYER MET4res  2061
LAYER MAP 84 DATATYPE 5 2062
LAYER MET4opcblk  2062
LAYER MAP 84 TEXTTYPE 6 2063
LAYER MET4text  2063
LAYER MAP 84 DATATYPE 8 2064
LAYER MET4sloti  2064
LAYER MAP 84 DATATYPE 9 2065
LAYER MET4slotblk  2065
LAYER MAP 84 DATATYPE 10 2066
LAYER MET4mom  2066
LAYER MAP 85 DATATYPE 1 2067
LAYER MAP 85 TEXTTYPE 1 2067
LAYER MET5o  2067
LAYER MAP 85 DATATYPE 2 2068
LAYER MET5dmi  2068
LAYER MAP 85 DATATYPE 3 2069
LAYER MET5dmblk  2069
LAYER MAP 85 DATATYPE 4 2070
LAYER MET5res  2070
LAYER MAP 85 DATATYPE 5 2071
LAYER MET5opcblk  2071
LAYER MAP 85 TEXTTYPE 6 2072
LAYER MET5text  2072
LAYER MAP 85 DATATYPE 8 2073
LAYER MET5sloti  2073
LAYER MAP 85 DATATYPE 9 2074
LAYER MET5slotblk  2074
LAYER MAP 85 DATATYPE 10 2075
LAYER MET5mom  2075
LAYER MAP 86 DATATYPE 1 2076
LAYER MAP 86 TEXTTYPE 1 2076
LAYER MET6o  2076
LAYER MAP 86 DATATYPE 2 2077
LAYER MET6dmi  2077
LAYER MAP 86 DATATYPE 3 2078
LAYER MET6dmblk  2078
LAYER MAP 86 DATATYPE 4 2079
LAYER MET6res  2079
LAYER MAP 86 DATATYPE 5 2080
LAYER MET6opcblk  2080
LAYER MAP 86 TEXTTYPE 6 2081
LAYER MET6text  2081
LAYER MAP 86 DATATYPE 8 2082
LAYER MET6sloti  2082
LAYER MAP 86 DATATYPE 9 2083
LAYER MET6slotblk  2083
LAYER MAP 86 DATATYPE 10 2084
LAYER MET6mom  2084
LAYER MAP 87 DATATYPE 1 2085
LAYER MAP 87 TEXTTYPE 1 2085
LAYER MET7o  2085
LAYER MAP 87 DATATYPE 2 2086
LAYER MET7dmi  2086
LAYER MAP 87 DATATYPE 3 2087
LAYER MET7dmblk  2087
LAYER MAP 87 DATATYPE 4 2088
LAYER MET7res  2088
LAYER MAP 87 DATATYPE 5 2089
LAYER MET7opcblk  2089
LAYER MAP 87 TEXTTYPE 6 2090
LAYER MET7text  2090
LAYER MAP 87 DATATYPE 8 2091
LAYER MET7sloti  2091
LAYER MAP 87 DATATYPE 9 2092
LAYER MET7slotblk  2092
LAYER MAP 87 DATATYPE 10 2093
LAYER MET7mom  2093
LAYER MAP 88 DATATYPE 1 2094
LAYER MAP 88 TEXTTYPE 1 2094
LAYER MET8o  2094
LAYER MAP 88 DATATYPE 2 2095
LAYER MET8dmi  2095
LAYER MAP 88 DATATYPE 3 2096
LAYER MET8dmblk  2096
LAYER MAP 88 DATATYPE 4 2097
LAYER MET8res  2097
LAYER MAP 88 DATATYPE 5 2098
LAYER MET8opcblk  2098
LAYER MAP 88 TEXTTYPE 6 2099
LAYER MET8text  2099
LAYER MAP 88 DATATYPE 8 2100
LAYER MET8sloti  2100
LAYER MAP 88 DATATYPE 9 2101
LAYER MET8slotblk  2101
LAYER MAP 88 DATATYPE 10 2102
LAYER MET8mom  2102
LAYER MAP 91 DATATYPE 1 2103
LAYER VIA1i  2103
LAYER MAP 91 DATATYPE 7 2104
LAYER VIA1bar  2104
LAYER MAP 92 DATATYPE 1 2105
LAYER VIA2i  2105
LAYER MAP 92 DATATYPE 7 2106
LAYER VIA2bar  2106
LAYER MAP 93 DATATYPE 1 2107
LAYER VIA3i  2107
LAYER MAP 93 DATATYPE 7 2108
LAYER VIA3bar  2108
LAYER MAP 94 DATATYPE 1 2109
LAYER VIA4i  2109
LAYER MAP 94 DATATYPE 7 2110
LAYER VIA4bar  2110
LAYER MAP 95 DATATYPE 1 2111
LAYER VIA5i  2111
LAYER MAP 95 DATATYPE 7 2112
LAYER VIA5bar  2112
LAYER MAP 96 DATATYPE 1 2113
LAYER VIA6i  2113
LAYER MAP 96 DATATYPE 7 2114
LAYER VIA6bar  2114
LAYER MAP 97 DATATYPE 1 2115
LAYER VIA7i  2115
LAYER MAP 97 DATATYPE 7 2116
LAYER VIA7bar  2116
LAYER MAP 100 DATATYPE 1 2117
LAYER MAP 100 TEXTTYPE 1 2117
LAYER T2M1o  2117
LAYER MAP 100 DATATYPE 2 2118
LAYER T2M1dmi  2118
LAYER MAP 100 DATATYPE 3 2119
LAYER T2M1dmblk  2119
LAYER MAP 100 DATATYPE 4 2120
LAYER T2M1res  2120
LAYER MAP 100 DATATYPE 5 2121
LAYER T2M1opcblk  2121
LAYER MAP 100 TEXTTYPE 6 2122
LAYER T2M1text  2122
LAYER MAP 100 DATATYPE 8 2123
LAYER T2M1sloti  2123
LAYER MAP 100 DATATYPE 9 2124
LAYER T2M1slotblk  2124
LAYER MAP 101 DATATYPE 1 2125
LAYER MAP 101 TEXTTYPE 1 2125
LAYER T2M2o  2125
LAYER MAP 101 DATATYPE 2 2126
LAYER T2M2dmi  2126
LAYER MAP 101 DATATYPE 3 2127
LAYER T2M2dmblk  2127
LAYER MAP 101 DATATYPE 4 2128
LAYER T2M2res  2128
LAYER MAP 101 DATATYPE 5 2129
LAYER T2M2opcblk  2129
LAYER MAP 101 TEXTTYPE 6 2130
LAYER T2M2text  2130
LAYER MAP 101 DATATYPE 8 2131
LAYER T2M2sloti  2131
LAYER MAP 101 DATATYPE 9 2132
LAYER T2M2slotblk  2132
LAYER MAP 102 DATATYPE 1 2133
LAYER MAP 102 TEXTTYPE 1 2133
LAYER T4M1o  2133
LAYER MAP 102 DATATYPE 2 2134
LAYER T4M1dmi  2134
LAYER MAP 102 DATATYPE 3 2135
LAYER T4M1dmblk  2135
LAYER MAP 102 DATATYPE 4 2136
LAYER T4M1res  2136
LAYER MAP 102 DATATYPE 5 2137
LAYER T4M1opcblk  2137
LAYER MAP 102 TEXTTYPE 6 2138
LAYER T4M1text  2138
LAYER MAP 102 DATATYPE 8 2139
LAYER T4M1sloti  2139
LAYER MAP 102 DATATYPE 9 2140
LAYER T4M1slotblk  2140
LAYER MAP 103 DATATYPE 1 2141
LAYER MAP 103 TEXTTYPE 1 2141
LAYER T4M2o  2141
LAYER MAP 103 DATATYPE 2 2142
LAYER T4M2dmi  2142
LAYER MAP 103 DATATYPE 3 2143
LAYER T4M2dmblk  2143
LAYER MAP 103 DATATYPE 4 2144
LAYER T4M2res  2144
LAYER MAP 103 DATATYPE 5 2145
LAYER T4M2opcblk  2145
LAYER MAP 103 TEXTTYPE 6 2146
LAYER T4M2text  2146
LAYER MAP 103 DATATYPE 8 2147
LAYER T4M2sloti  2147
LAYER MAP 103 DATATYPE 9 2148
LAYER T4M2slotblk  2148
LAYER MAP 104 DATATYPE 1 2149
LAYER MAP 104 TEXTTYPE 1 2149
LAYER T8M1o  2149
LAYER MAP 104 DATATYPE 2 2150
LAYER T8M1dmi  2150
LAYER MAP 104 DATATYPE 3 2151
LAYER T8M1dmblk  2151
LAYER MAP 104 DATATYPE 4 2152
LAYER T8M1res  2152
LAYER MAP 104 DATATYPE 5 2153
LAYER T8M1opcblk  2153
LAYER MAP 104 TEXTTYPE 6 2154
LAYER T8M1text  2154
LAYER MAP 104 DATATYPE 8 2155
LAYER T8M1sloti  2155
LAYER MAP 104 DATATYPE 9 2156
LAYER T8M1slotblk  2156
LAYER MAP 105 DATATYPE 1 2157
LAYER MAP 105 TEXTTYPE 1 2157
LAYER T8M2o  2157
LAYER MAP 105 DATATYPE 2 2158
LAYER T8M2dmi  2158
LAYER MAP 105 DATATYPE 3 2159
LAYER T8M2dmblk  2159
LAYER MAP 105 DATATYPE 4 2160
LAYER T8M2res  2160
LAYER MAP 105 DATATYPE 5 2161
LAYER T8M2opcblk  2161
LAYER MAP 105 TEXTTYPE 6 2162
LAYER T8M2text  2162
LAYER MAP 105 DATATYPE 8 2163
LAYER T8M2sloti  2163
LAYER MAP 105 DATATYPE 9 2164
LAYER T8M2slotblk  2164
LAYER MAP 110 DATATYPE 1 2165
LAYER T2V1i  2165
LAYER MAP 110 DATATYPE 7 2166
LAYER T2V1bar  2166
LAYER MAP 111 DATATYPE 1 2167
LAYER T2V2i  2167
LAYER MAP 111 DATATYPE 7 2168
LAYER T2V2bar  2168
LAYER MAP 112 DATATYPE 1 2169
LAYER T4V1i  2169
LAYER MAP 112 DATATYPE 7 2170
LAYER T4V1bar  2170
LAYER MAP 113 DATATYPE 1 2171
LAYER T4V2i  2171
LAYER MAP 113 DATATYPE 7 2172
LAYER T4V2bar  2172
LAYER MAP 114 DATATYPE 1 2173
LAYER T8V1i  2173
LAYER MAP 114 DATATYPE 7 2174
LAYER T8V1bar  2174
LAYER MAP 115 DATATYPE 1 2175
LAYER T8V2i  2175
LAYER MAP 115 DATATYPE 7 2176
LAYER T8V2bar  2176
LAYER MAP 120 DATATYPE 1 2177
LAYER RV  2177
LAYER MAP 121 DATATYPE 1 2178
LAYER CBi  2178
LAYER MAP 121 TEXTTYPE 6 2179
LAYER CBtext  2179
LAYER MAP 122 DATATYPE 1 2180
LAYER MAP 122 TEXTTYPE 1 2180
LAYER ALPAD  2180
LAYER MAP 122 DATATYPE 4 2181
LAYER ALPADres  2181
LAYER MAP 122 TEXTTYPE 6 2182
LAYER ALPADtext  2182
LAYER MAP 122 DATATYPE 8 2183
LAYER ALPADsloti  2183
LAYER MAP 122 DATATYPE 9 2184
LAYER ALPADslotblk  2184
LAYER MAP 123 DATATYPE 1 2185
LAYER MAP 123 TEXTTYPE 1 2185
LAYER RDLi  2185
LAYER MAP 123 TEXTTYPE 6 2186
LAYER RDLtext  2186
LAYER MAP 124 DATATYPE 1 2187
LAYER COVER  2187

LAYER MAP 140 DATATYPE 1 2500
LAYER BMIM  2500
LAYER MAP 141 DATATYPE 1 2501
LAYER TMIM  2501

LAYER MAP 150 DATATYPE 12 2188
LAYER IO  2188
LAYER MAP 151 DATATYPE 12 2189
LAYER CORE  2189
LAYER MAP 152 DATATYPE 12 2190
LAYER ULLD  2190
LAYER MAP 153 DATATYPE 12 2191
LAYER UD  2191
LAYER MAP 154 DATATYPE 12 2192
LAYER OD  2192
LAYER MAP 171 DATATYPE 12 2193
LAYER SRAMALL  2193
LAYER MAP 172 DATATYPE 12 2194
LAYER SRAMPG  2194
LAYER MAP 173 DATATYPE 12 2195
LAYER SRAM6THD  2195
LAYER MAP 174 DATATYPE 12 2196
LAYER SRAM6THS  2196
LAYER MAP 176 DATATYPE 12 2197
LAYER SRAM8THD  2197
LAYER MAP 177 DATATYPE 12 2198
LAYER SRAM8THS  2198
LAYER MAP 191 DATATYPE 12 2199
LAYER DIODE  2199
LAYER MAP 192 DATATYPE 12 2200
LAYER VARA  2200
LAYER MAP 193 DATATYPE 12 2201
LAYER VARAM  2201
LAYER MAP 194 DATATYPE 12 2202
LAYER VARAJ  2202
LAYER MAP 195 DATATYPE 12 2203
LAYER BJT  2203
LAYER MAP 211 DATATYPE 12 2204
LAYER LDMOS  2204
LAYER MAP 231 DATATYPE 12 2205
LAYER ESDIOT  2205
LAYER MAP 232 DATATYPE 12 2206
LAYER ESDIOE  2206
LAYER MAP 241 DATATYPE 12 2207
LAYER RFALL  2207
LAYER MAP 242 DATATYPE 12 2208
LAYER RFD  2208
LAYER MAP 243 DATATYPE 12 2209
LAYER RFTER  2209
LAYER MAP 261 DATATYPE 12 2210
LAYER PSUBi  2210
LAYER MAP 271 DATATYPE 12 2211
LAYER CAP  2211
LAYER MAP 281 DATATYPE 12 2212
LAYER MOMCAP  2212
LAYER MAP 282 DATATYPE 12 2213
LAYER MOMTER  2213
LAYER MAP 291 DATATYPE 12 2214
LAYER FUTR  2214
LAYER MAP 292 DATATYPE 12 2215
LAYER FUSEALL  2215
LAYER MAP 293 DATATYPE 12 2216
LAYER EFUSEALL  2216
LAYER MAP 294 DATATYPE 12 2217
LAYER POEFUSEBLK  2217
LAYER MAP 301 DATATYPE 12 2218
LAYER INDDMY  2218
LAYER MAP 302 DATATYPE 12 2219
LAYER INDALL  2219
LAYER MAP 303 DATATYPE 12 2220
LAYER INDVIA  2220
LAYER MAP 311 DATATYPE 12 2221
LAYER NOLVS  2221
LAYER MAP 312 DATATYPE 12 2222
LAYER MOSMF  2222
LAYER MAP 313 DATATYPE 12 2223
LAYER SUBCKTLVS  2223
LAYER MAP 314 DATATYPE 12 2224
LAYER RESCKTLVS  2224
LAYER MAP 315 DATATYPE 12 2225
LAYER MOSCKTLVS  2225
LAYER MAP 316 DATATYPE 12 2226
LAYER LATCHUP  2226
LAYER MAP 317 DATATYPE 12 2227
LAYER RFSDLVS  2227
LAYER MAP 318 DATATYPE 12 2228
LAYER RF5TERLVS  2228
LAYER MAP 319 DATATYPE 12 2229
LAYER RF6TERLVS  2229
LAYER MAP 320 DATATYPE 12 2230
LAYER VARAJMRK  2230
LAYER MAP 321 DATATYPE 12 2231
LAYER LDMOSSTI  2231
LAYER MAP 322 DATATYPE 12 2232
LAYER FUSEDRC  2232
LAYER MAP 323 DATATYPE 12 2233
LAYER MAP 323 TEXTTYPE 12 2233
LAYER MOMLVS1  2233
LAYER MAP 324 DATATYPE 12 2234
LAYER MOMLVS2  2234
LAYER MAP 325 DATATYPE 12 2235
LAYER MOMLVS3  2235
LAYER MAP 326 DATATYPE 12 2236
LAYER MOMLVS4  2236
LAYER MAP 327 DATATYPE 12 2237
LAYER MOMLVS5  2237
LAYER MAP 328 DATATYPE 12 2238
LAYER MOMLVS6  2238
LAYER MAP 329 DATATYPE 12 2239
LAYER RES3TPOLY  2239
LAYER MAP 351 DATATYPE 12 2240
LAYER CHIPBLK  2240
LAYER MAP 352 DATATYPE 12 2241
LAYER SRBLK  2241
LAYER MAP 353 DATATYPE 12 2242
LAYER GRBLK  2242
LAYER MAP 354 DATATYPE 12 2243
LAYER SRINGBLK  2243
LAYER MAP 355 DATATYPE 12 2244
LAYER LOGO  2244
LAYER MAP 356 DATATYPE 12 2245
LAYER NOSHRINK  2245
LAYER MAP 357 DATATYPE 12 2246
LAYER NODRC  2246
LAYER MAP 358 DATATYPE 12 2247
LAYER OPCBLKALL  2247
LAYER MAP 359 DATATYPE 12 2248
LAYER DMYBLK  2248
LAYER MAP 360 DATATYPE 12 2249
LAYER NOEBBLK  2249
LAYER MAP 361 DATATYPE 12 2250
LAYER METBLK  2250
LAYER MAP 381 DATATYPE 12 2251
LAYER DEUPADi  2251
LAYER MAP 382 DATATYPE 12 2252
LAYER PVDD  2252
LAYER MAP 383 DATATYPE 12 2253
LAYER PVSS  2253
LAYER MAP 384 DATATYPE 12 2254
LAYER NPR  2254
LAYER MAP 385 DATATYPE 12 2255
LAYER HPR  2255
LAYER MAP 386 DATATYPE 12 2256
LAYER TTXT  2256
LAYER MAP 387   DATATYPE 12 2257
LAYER NW1CAP  2257


//=====================================================
CHIPEDGE = CHIPBLK OR (HOLES CHIPBLK)
PWi = DRC:1 NOT (NW1i OR PSUBi)
PW = COPY PWi

AA      = COPY ACTi
NW      = COPY NW1i
DNW     = COPY DNWi
HVTN    = COPY NVT3
HVTP    = COPY PVT3
LVTP     = COPY PVT1
LVTN     = COPY NVT1
DG      = COPY DGOX
PO      = COPY POLYi
HRP	= COPY HRPi
SDN      = COPY NPi
SDP      = COPY PPi
SAB     = COPY SABi
CT      = OR CTi CTbar
PSUB    = COPY PSUBi
TG	= COPY TGOX
MD	= COPY MDi
RDLVIA	= COPY RV
RDL	= COPY RDLi
RDLPA2	= COPY COVER
FUSE	= COPY FUTR
PA	= COPY CBi
ALPA    = COPY ALPAi
GRID    = GRBLK OR SRINGBLK
DEUPAD    = COPY DEUPADi


//FOR DRC CHECK
M1      = MET1o NOT MET1sloti
M2      = MET2o NOT MET2sloti
M3	= MET3o NOT MET3sloti
M4	= MET4o NOT MET4sloti
M5	= MET5o NOT MET5sloti
M6	= MET6o NOT MET6sloti
M7	= MET7o NOT MET7sloti
M8	= MET8o NOT MET8sloti
T4M1	= T4M1o NOT T4M1sloti
T4M2	= T4M2o NOT T4M2sloti
T2M1    = T2M1o NOT T2M1sloti
T2M2    = T2M2o NOT T2M2sloti
T8M1     = T8M1o NOT  T8M1sloti
T8M2     = T8M2o NOT  T8M2sloti

M1sloti   = COPY MET1sloti
M2sloti   = COPY MET2sloti
M3sloti   = COPY MET3sloti
M4sloti   = COPY MET4sloti
M5sloti   = COPY MET5sloti
M6sloti   = COPY MET6sloti
M7sloti   = COPY MET7sloti
M8sloti   = COPY MET8sloti

M1o   = COPY MET1o
M2o   = COPY MET2o
M3o   = COPY MET3o
M4o   = COPY MET4o
M5o   = COPY MET5o
M6o   = COPY MET6o
M7o   = COPY MET7o
M8o   = COPY MET8o

M1DUM   = COPY MET1dmi
M2DUM   = COPY MET2dmi
M3DUM   = COPY MET3dmi
M4DUM   = COPY MET4dmi
M5DUM   = COPY MET5dmi
M6DUM   = COPY MET6dmi
M7DUM   = COPY MET7dmi
M8DUM   = COPY MET8dmi
T4M1DUM  = COPY T4M1dmi
T4M2DUM  = COPY T4M2dmi
T2M1DUM  = COPY T2M1dmi
T2M2DUM  = COPY T2M2dmi
T8M1DUM   = COPY T8M1dmi
T8M2DUM   = COPY T8M2dmi
AADUM	= COPY ACTdmi
PODUM	= COPY POLYdmi

M1MOM   = COPY MET1mom
M2MOM   = COPY MET2mom
M3MOM   = COPY MET3mom
M4MOM   = COPY MET4mom
M5MOM   = COPY MET5mom
M6MOM   = COPY MET6mom
M7MOM   = COPY MET7mom
M8MOM   = COPY MET8mom


M1DUMB   = COPY MET1dmblk
M2DUMB   = COPY MET2dmblk
M3DUMB   = COPY MET3dmblk
M4DUMB   = COPY MET4dmblk
M5DUMB   = COPY MET5dmblk
M6DUMB   = COPY MET6dmblk
M7DUMB   = COPY MET7dmblk
M8DUMB   = COPY MET8dmblk
T4M1DUMB  = COPY T4M1dmblk
T4M2DUMB  = COPY T4M2dmblk
T2M1DUMB  = COPY T2M1dmblk
T2M2DUMB  = COPY T2M2dmblk
T8M1DUMB   = COPY T8M1dmblk
T8M2DUMB   = COPY T8M2dmblk
AADUMB	= COPY ACTdmblk
PODUMB	= COPY POLYdmblk

M1R   = COPY MET1res
M2R   = COPY MET2res
M3R   = COPY MET3res
M4R   = COPY MET4res
M5R   = COPY MET5res
M6R   = COPY MET6res
M7R   = COPY MET7res
M8R   = COPY MET8res
T4M1R  = COPY T4M1res
T4M2R  = COPY T4M2res
T2M1R  = COPY T2M1res
T2M2R  = COPY T2M2res
T8M1R   = COPY T8M1res
T8M2R   = COPY T8M2res
ALPAR   = COPY ALPADres

M1slot   = COPY MET1sloti
M2slot   = COPY MET2sloti
M3slot   = COPY MET3sloti
M4slot   = COPY MET4sloti
M5slot   = COPY MET5sloti
M6slot   = COPY MET6sloti 
M7slot   = COPY MET7sloti
M8slot   = COPY MET8sloti
T4M1slot  = COPY T4M1sloti
T4M2slot  = COPY T4M2sloti
T2M1slot  = COPY T2M1sloti
T2M2slot  = COPY T2M2sloti
T8M1slot  = COPY T8M1sloti
T8M2slot  = COPY T8M2sloti
UVT = COPY ULLD


T4V1     = OR T4V1i T4V1bar
T4V2     = OR T4V2i T4V2bar
T2V1    = OR T2V1i T2V1bar
T2V2    = OR T2V2i T2V2bar
T8V1     = OR T8V1i T8V1bar
T8V2     = OR T8V2i T8V2bar

//FOR DRC CHECK
M1ALL = (M1 NOT M1slot) OR M1DUM
M2ALL = (M2 NOT M2slot) OR M2DUM
M3ALL = (M3 NOT M3slot) OR M3DUM
M4ALL = (M4 NOT M4slot) OR M4DUM
M5ALL = (M5 NOT M5slot) OR M5DUM
M6ALL = (M6 NOT M6slot) OR M6DUM
M7ALL = (M7 NOT M7slot) OR M7DUM
M8ALL = (M8 NOT M8slot) OR M8DUM
T4M1ALL = (T4M1 NOT T4M1slot) OR T4M1DUM
T4M2ALL = (T4M2 NOT T4M2slot) OR T4M2DUM
T2M1ALL = (T2M1 NOT T2M1slot) OR T2M1DUM
T2M2ALL = (T2M2 NOT T2M2slot) OR T2M2DUM
T8M1ALL = (T8M1 NOT T8M1slot) OR T8M1DUM
T8M2ALL = (T8M2 NOT T8M2slot) OR T8M2DUM

//FOR DENSITY CHECK
M1ALLi = (MET1o NOT MET1sloti) OR MET1dmi
M2ALLi = (MET2o NOT MET2sloti) OR MET2dmi
M3ALLi = (MET3o NOT MET3sloti) OR MET3dmi
M4ALLi = (MET4o NOT MET4sloti) OR MET4dmi
M5ALLi = (MET5o NOT MET5sloti) OR MET5dmi
M6ALLi = (MET6o NOT MET6sloti) OR MET6dmi
M7ALLi = (MET7o NOT MET7sloti) OR MET7dmi
M8ALLi = (MET8o NOT MET8sloti) OR MET8dmi
T4M1ALLi = (T4M1o NOT T4M1sloti) OR T4M1dmi
T4M2ALLi = (T4M2o NOT T4M2sloti) OR T4M2dmi
T2M1ALLi = (T2M1o NOT T2M1sloti) OR T2M1dmi
T2M2ALLi = (T2M2o NOT T2M2sloti) OR T2M2dmi
T8M1ALLi = (T8M1o NOT T8M1sloti) OR T8M1dmi
T8M2ALLi = (T8M2o NOT T8M2sloti) OR T8M2dmi
//FOR CONNECTIVITY
MDi = CBi OR COVER
ALPA_PAi = SIZE CBi BY PA_su
ALPAi	= OR ALPA_PAi RDLi ALPAD
M1i   = MET1o NOT MET1sloti
M2i   = MET2o NOT MET2sloti
M3i   = MET3o NOT MET3sloti
M4i   = MET4o NOT MET4sloti
M5i   = MET5o NOT MET5sloti
M6i   = MET6o NOT MET6sloti
M7i   = MET7o NOT MET7sloti
M8i   = MET8o NOT MET8sloti
T4M1i  = T4M1o NOT T4M1sloti
T4M2i  = T4M2o NOT T4M2sloti
T2M1i = T2M1o NOT T2M1sloti
T2M2i = T2M2o NOT T2M2sloti
T8M1i  = T8M1o NOT T8M1sloti
T8M2i  = T8M2o NOT T8M2sloti

M1M2 = M1 AND M2
SV1_metal = M1M2 INTERACT V1 == 1
U4V1_metal = M1M2 INTERACT V1 < 4
M2M3 = M2 AND M3
SV2_metal = M2M3 INTERACT V2 == 1
U4V2_metal = M2M3 INTERACT V2 < 4
M3M4 = M3 AND M4
SV3_metal = M3M4 INTERACT V3 == 1
U4V3_metal = M3M4 INTERACT V3 < 4
M4M5 = M4 AND M5
SV4_metal = M4M5 INTERACT V4 == 1
U4V4_metal = M4M5 INTERACT V4 < 4
M5M6 = M5 AND M6
SV5_metal = M5M6 INTERACT V5 == 1
U4V5_metal = M5M6 INTERACT V5 < 4
M6M7 = M6 AND M7
SV6_metal = M6M7 INTERACT V6 == 1
U4V6_metal = M6M7 INTERACT V6 < 4
M7M8 = M7 AND M8
SV7_metal = M7M8 INTERACT V7 == 1
U4V7_metal = M7M8 INTERACT V7 < 4

//WIDE METAL FOR REDUNDANT VIA CHECK
WIDE_M1_0P30 = M1 WITH WIDTH >= 0.30
WIDE_M1_0P70 = WIDE_M1_0P30 WITH WIDTH >= 0.7

WIDE_M2_0P30 = M2 WITH WIDTH >= 0.30
WIDE_M2_0P70 = WIDE_M2_0P30 WITH WIDTH >= 0.7

WIDE_M3_0P30 = M3 WITH WIDTH >= 0.30
WIDE_M3_0P70 = WIDE_M3_0P30 WITH WIDTH >= 0.7

WIDE_M4_0P30 = M4 WITH WIDTH >= 0.30
WIDE_M4_0P70 = WIDE_M4_0P30 WITH WIDTH >= 0.7

WIDE_M5_0P30 = M5 WITH WIDTH >= 0.30
WIDE_M5_0P70 = WIDE_M5_0P30 WITH WIDTH >= 0.7

WIDE_M6_0P30 = M6 WITH WIDTH >= 0.30
WIDE_M6_0P70 = WIDE_M6_0P30 WITH WIDTH >= 0.7

WIDE_M7_0P30 = M7 WITH WIDTH >= 0.30
WIDE_M7_0P70 = WIDE_M7_0P30 WITH WIDTH >= 0.7

WIDE_M8_0P30 = M8 WITH WIDTH >= 0.30
WIDE_M8_0P70 = WIDE_M8_0P30 WITH WIDTH >= 0.7
//------------------------------------------------------------------------------------------

V1_org = OR VIA1i VIA1bar
V2_org = OR VIA2i VIA2bar
V3_org = OR VIA3i VIA3bar
V4_org = OR VIA4i VIA4bar
V5_org = OR VIA5i VIA5bar
V6_org = OR VIA6i VIA6bar
V7_org = OR VIA7i VIA7bar

V1bar = COPY VIA1bar
V2bar = COPY VIA2bar
V3bar = COPY VIA3bar
V4bar = COPY VIA4bar
V5bar = COPY VIA5bar
V6bar = COPY VIA6bar
V7bar = COPY VIA7bar

V1_slot = ((ENCLOSE RECTANGLE V1_org 0.1 0.30) AND GRID) INTERACT (WITH WIDTH V1_org == 0.09)
V2_slot = ((ENCLOSE RECTANGLE V2_org 0.1 0.30) AND GRID) INTERACT (WITH WIDTH V2_org == 0.09)
V3_slot = ((ENCLOSE RECTANGLE V3_org 0.1 0.30) AND GRID) INTERACT (WITH WIDTH V3_org == 0.09)
V4_slot = ((ENCLOSE RECTANGLE V4_org 0.1 0.30) AND GRID) INTERACT (WITH WIDTH V4_org == 0.09)
V5_slot = ((ENCLOSE RECTANGLE V5_org 0.1 0.30) AND GRID) INTERACT (WITH WIDTH V5_org == 0.09)
V6_slot = ((ENCLOSE RECTANGLE V6_org 0.1 0.30) AND GRID) INTERACT (WITH WIDTH V6_org == 0.09)
V7_slot = ((ENCLOSE RECTANGLE V7_org 0.1 0.30) AND GRID) INTERACT (WITH WIDTH V7_org == 0.09)

V1_slot_SG = (((ENCLOSE RECTANGLE V1_org 0.09 0.27) AND GRID) INTERACT (WITH WIDTH V1_org == 0.09)) OR V1_slot
V2_slot_SG = (((ENCLOSE RECTANGLE V2_org 0.09 0.27) AND GRID) INTERACT (WITH WIDTH V2_org == 0.09)) OR V2_slot
V3_slot_SG = (((ENCLOSE RECTANGLE V3_org 0.09 0.27) AND GRID) INTERACT (WITH WIDTH V3_org == 0.09)) OR V3_slot
V4_slot_SG = (((ENCLOSE RECTANGLE V4_org 0.09 0.27) AND GRID) INTERACT (WITH WIDTH V4_org == 0.09)) OR V4_slot
V5_slot_SG = (((ENCLOSE RECTANGLE V5_org 0.09 0.27) AND GRID) INTERACT (WITH WIDTH V5_org == 0.09)) OR V5_slot
V6_slot_SG = (((ENCLOSE RECTANGLE V6_org 0.09 0.27) AND GRID) INTERACT (WITH WIDTH V6_org == 0.09)) OR V6_slot
V7_slot_SG = (((ENCLOSE RECTANGLE V7_org 0.09 0.27) AND GRID) INTERACT (WITH WIDTH V7_org == 0.09)) OR V7_slot

}

VERBATIM {
#IFDEF Density_rules NO
DRC UNSELECT CHECK ACT_D_1_min, ACT_D_1_max, ACT_D_2, ACT_D_3, ACT_D_4_min, ACT_D_4_max, PO_D_1_min, PO_D_1_max, PO_D_2_min, PO_D_2_max, PO_D_3, MET1_D_1_min, MET1_D_1_max MET1_D_2, MET1_D_3, Mn_D_1_min, Mn_D_1_max, Mn_D_2, Mn_D_3, T4M1_D_1_min, T4M1_D_1_max, T4M1_D_2, T4M1_D_3, T4M2_D_1_min, T4M2_D_1_max, T4M2_D_2, T4M2_D_3, T2M1_D_1_min, T2M1_D_1_max,T2M1_D_2, T2M1_D_3, T2M2_D_1_min, T2M2_D_1_max, T2M2_D_2, T2M2_D_3, T8M1_D_1_R, T8M1_D_2, T8M1_D_3, T8M2_D_1_R, T8M2_D_2, T8M2_D_3, RDL_D_1_R, RDL_D_2_R  


#ENDIF

}

VERBATIM {
#IFDEF ALLOW_V01 YES
}
SETLAYER V1ia = (RECTANGLE V1_org == 0.09 BY == 0.09) OR V1_slot
SETLAYER V2ia = (RECTANGLE V2_org == 0.09 BY == 0.09) OR V2_slot
SETLAYER V3ia = (RECTANGLE V3_org == 0.09 BY == 0.09) OR V3_slot
SETLAYER V4ia = (RECTANGLE V4_org == 0.09 BY == 0.09) OR V4_slot
SETLAYER V5ia = (RECTANGLE V5_org == 0.09 BY == 0.09) OR V5_slot
SETLAYER V6ia = (RECTANGLE V6_org == 0.09 BY == 0.09) OR V6_slot
SETLAYER V7ia = (RECTANGLE V7_org == 0.09 BY == 0.09) OR V7_slot

SETLAYER V1_sd = SIZE V1ia BY -0.005
SETLAYER V2_sd = SIZE V2ia BY -0.005
SETLAYER V3_sd = SIZE V3ia BY -0.005
SETLAYER V4_sd = SIZE V4ia BY -0.005
SETLAYER V5_sd = SIZE V5ia BY -0.005
SETLAYER V6_sd = SIZE V6ia BY -0.005
SETLAYER V7_sd = SIZE V7ia BY -0.005

SETLAYER V1r = V1_org NOT V1ia
SETLAYER V2r = V2_org NOT V2ia
SETLAYER V3r = V3_org NOT V3ia
SETLAYER V4r = V4_org NOT V4ia
SETLAYER V5r = V5_org NOT V5ia
SETLAYER V6r = V6_org NOT V6ia
SETLAYER V7r = V7_org NOT V7ia

SETLAYER V1O	= COPY V1ia 
SETLAYER V2O	= COPY V2ia
SETLAYER V1      = COPY V1O
SETLAYER V2      = COPY V2O
SETLAYER V3      = COPY V3ia
SETLAYER V4      = COPY V4ia
SETLAYER V5      = COPY V5ia
SETLAYER V6      = COPY V6ia
SETLAYER V7      = COPY V7ia
VERBATIM {
#ENDIF
}

VERBATIM {
#IFDEF ALLOW_V01 NO
}
SETLAYER V1	= COPY V1_org
SETLAYER V2	= COPY V2_org
SETLAYER V3	= COPY V3_org
SETLAYER V4	= COPY V4_org
SETLAYER V5	= COPY V5_org
SETLAYER V6	= COPY V6_org
SETLAYER V7	= COPY V7_org
VERBATIM {
#ENDIF
}

set MT_CHOICE 0
set CHECK_M1 1
set CHECK_V1 1
set CHECK_M2 1
set CHECK_V2 1
set CHECK_M3 1
set CHECK_V3 0
set CHECK_M4 0
set CHECK_V4 0
set CHECK_M5 0
set CHECK_V5 0
set CHECK_M6 0
set CHECK_V6 0
set CHECK_M7 0
set CHECK_V7 0
set CHECK_M8 0
set CHECK_T4V1 0
set CHECK_T4M1 0
set CHECK_T4V2 0
set CHECK_T4M2 0
set CHECK_T2V1 0
set CHECK_T2M1 0
set CHECK_T2V2 0
set CHECK_T2M2 0
set CHECK_T8V1 0
set CHECK_T8M1 0
set CHECK_T8V2 0
set CHECK_T8M2 0

if { $total_metal == 10 } {
           set CHECK_V3 1
           set CHECK_M4 1
           set CHECK_V4 1
           set CHECK_M5 1
           set CHECK_V5 1
           set CHECK_M6 1
           set CHECK_V6 1
           set CHECK_M7 1
           set CHECK_V7 1
           set CHECK_M8 1
  if { $top_metal == 2 } {
    if { $T2V1_T2M1 == 0 } {
      if { $T8V1_T8M1 == 0 } {
           set CHECK_T4V1 1
           set CHECK_T4M1 1
          if { $T8V2_T8M2 == 0 } {
           set CHECK_T4V2 1
           set CHECK_T4M2 1
        } else {
           set CHECK_T8V2 1
           set CHECK_T8M2 1
        }
       } else {
           set CHECK_T8V1 1
           set CHECK_T8M1 1
           set CHECK_T8V2 1
           set CHECK_T8M2 1
       }
     } else {
           set CHECK_T2V1 1
           set CHECK_T2M1 1
        if { $T8V2_T8M2 == 0 } {
         if { $T2V2_T2M2 == 0 } {
           set CHECK_T4V2 1
           set CHECK_T4M2 1
        } else {
           set CHECK_T2V2 1
           set CHECK_T2M2 1
        }
       } else {
           set CHECK_T8V2 1
           set CHECK_T8M2 1
       }
      }
     } else {
  puts "\nWrong metal option combination. Please check the setting for metal options.\n"
  exit
       }  
 } elseif { $total_metal == 9 } {
           set CHECK_V3 1
           set CHECK_M4 1
           set CHECK_V4 1
           set CHECK_M5 1
           set CHECK_V5 1
           set CHECK_M6 1
           set CHECK_V6 1
           set CHECK_M7 1
  if { $top_metal == 2 } {
    if { $T2V1_T2M1 == 0 } {
      if { $T8V1_T8M1 == 0 } {
           set CHECK_T4V1 1
           set CHECK_T4M1 1
          if { $T8V2_T8M2 == 0 } {
           set CHECK_T4V2 1
           set CHECK_T4M2 1
        } else {
           set CHECK_T8V2 1
           set CHECK_T8M2 1
        }
       } else {
           set CHECK_T8V1 1
           set CHECK_T8M1 1
           set CHECK_T8V2 1
           set CHECK_T8M2 1
       }
     } else {
           set CHECK_T2V1 1
           set CHECK_T2M1 1
        if { $T8V2_T8M2 == 0 } {
         if { $T2V2_T2M2 == 0 } {
           set CHECK_T4V2 1
           set CHECK_T4M2 1
        } else {
           set CHECK_T2V2 1
           set CHECK_T2M2 1
        }
       } else {
           set CHECK_T8V2 1
           set CHECK_T8M2 1
       }
      }
     }  elseif { $top_metal == 1 } {
           set CHECK_V7 1
           set CHECK_M8 1
    if { $T2V1_T2M1 == 0 } {
     if { $T8V1_T8M1 == 0 } {
           set CHECK_T4V1 1
           set CHECK_T4M1 1
         } else { 
           set CHECK_T8V1 1
           set CHECK_T8M1 1
         }
   } else {
           set CHECK_T2V1 1
           set CHECK_T2M1 1
    }
   } else {
  puts "\nWrong metal option combination. Please check the setting for metal options.\n"
  exit
       } 
} elseif { $total_metal == 8 } {
           set CHECK_V3 1
           set CHECK_M4 1
           set CHECK_V4 1
           set CHECK_M5 1
           set CHECK_V5 1
           set CHECK_M6 1
  if { $top_metal == 2 } {
    if { $T2V1_T2M1 == 0 } {
      if { $T8V1_T8M1 == 0 } {
           set CHECK_T4V1 1
           set CHECK_T4M1 1
          if { $T8V2_T8M2 == 0 } {
           set CHECK_T4V2 1
           set CHECK_T4M2 1
        } else {
           set CHECK_T8V2 1
           set CHECK_T8M2 1
        }
       } else {
           set CHECK_T8V1 1
           set CHECK_T8M1 1
           set CHECK_T8V2 1
           set CHECK_T8M2 1
       }
     } else {
           set CHECK_T2V1 1
           set CHECK_T2M1 1
        if { $T8V2_T8M2 == 0 } {
         if { $T2V2_T2M2 == 0 } {
           set CHECK_T4V2 1
           set CHECK_T4M2 1
        } else {
           set CHECK_T2V2 1
           set CHECK_T2M2 1
        }
       } else {
           set CHECK_T8V2 1
           set CHECK_T8M2 1
       }
      }
     }  elseif { $top_metal == 1 } {
           set CHECK_V6 1
           set CHECK_M7 1
    if { $T2V1_T2M1 == 0 } {
     if { $T8V1_T8M1 == 0 } {
           set CHECK_T4V1 1
           set CHECK_T4M1 1
         } else { 
           set CHECK_T8V1 1
           set CHECK_T8M1 1
         }
   } else {
           set CHECK_T2V1 1
           set CHECK_T2M1 1
    }
   } else {
  puts "\nWrong metal option combination. Please check the setting for metal options.\n"
  exit
       } 
} elseif { $total_metal == 7 } {
           set CHECK_V3 1
           set CHECK_M4 1
           set CHECK_V4 1
           set CHECK_M5 1
  if { $top_metal == 2 } {
    if { $T2V1_T2M1 == 0 } {
      if { $T8V1_T8M1 == 0 } {
           set CHECK_T4V1 1
           set CHECK_T4M1 1
          if { $T8V2_T8M2 == 0 } {
           set CHECK_T4V2 1
           set CHECK_T4M2 1
        } else {
           set CHECK_T8V2 1
           set CHECK_T8M2 1
        }
       } else {
           set CHECK_T8V1 1
           set CHECK_T8M1 1
           set CHECK_T8V2 1
           set CHECK_T8M2 1
       }
     } else {
           set CHECK_T2V1 1
           set CHECK_T2M1 1
        if { $T8V2_T8M2 == 0 } {
         if { $T2V2_T2M2 == 0 } {
           set CHECK_T4V2 1
           set CHECK_T4M2 1
        } else {
           set CHECK_T2V2 1
           set CHECK_T2M2 1
        }
       } else {
           set CHECK_T8V2 1
           set CHECK_T8M2 1
       }
      }
     }  elseif { $top_metal == 1 } {
           set CHECK_V5 1
           set CHECK_M6 1
    if { $T2V1_T2M1 == 0 } {
     if { $T8V1_T8M1 == 0 } {
           set CHECK_T4V1 1
           set CHECK_T4M1 1
         } else { 
           set CHECK_T8V1 1
           set CHECK_T8M1 1
         }
   } else {
           set CHECK_T2V1 1
           set CHECK_T2M1 1
    }
   } else {
  puts "\nWrong metal option combination. Please check the setting for metal options.\n"
  exit
       } 
} elseif { $total_metal == 6 } {
           set CHECK_V3 1
           set CHECK_M4 1
  if { $top_metal == 2 } {
    if { $T2V1_T2M1 == 0 } {
      if { $T8V1_T8M1 == 0 } {
           set CHECK_T4V1 1
           set CHECK_T4M1 1
          if { $T8V2_T8M2 == 0 } {
           set CHECK_T4V2 1
           set CHECK_T4M2 1
        } else {
           set CHECK_T8V2 1
           set CHECK_T8M2 1
        }
       } else {
           set CHECK_T8V1 1
           set CHECK_T8M1 1
           set CHECK_T8V2 1
           set CHECK_T8M2 1
       }
     } else {
           set CHECK_T2V1 1
           set CHECK_T2M1 1
        if { $T8V2_T8M2 == 0 } {
         if { $T2V2_T2M2 == 0 } {
           set CHECK_T4V2 1
           set CHECK_T4M2 1
        } else {
           set CHECK_T2V2 1
           set CHECK_T2M2 1
        }
       } else {
           set CHECK_T8V2 1
           set CHECK_T8M2 1
       }
      }
     }  elseif { $top_metal == 1 } {
           set CHECK_V4 1
           set CHECK_M5 1
    if { $T2V1_T2M1 == 0 } {
     if { $T8V1_T8M1 == 0 } {
           set CHECK_T4V1 1
           set CHECK_T4M1 1
         } else { 
           set CHECK_T8V1 1
           set CHECK_T8M1 1
         }
   } else {
           set CHECK_T2V1 1
           set CHECK_T2M1 1
    }
   } else {
  puts "\nWrong metal option combination. Please check the setting for metal options.\n"
  exit
       } 
} elseif { $total_metal == 5 } {
  if { $top_metal == 2 } {
    if { $T2V1_T2M1 == 0 } {
      if { $T8V1_T8M1 == 0 } {
           set CHECK_T4V1 1
           set CHECK_T4M1 1
          if { $T8V2_T8M2 == 0 } {
           set CHECK_T4V2 1
           set CHECK_T4M2 1
        } else {
           set CHECK_T8V2 1
           set CHECK_T8M2 1
        }
       } else {
           set CHECK_T8V1 1
           set CHECK_T8M1 1
           set CHECK_T8V2 1
           set CHECK_T8M2 1
       }
     } else {
           set CHECK_T2V1 1
           set CHECK_T2M1 1
        if { $T8V2_T8M2 == 0 } {
         if { $T2V2_T2M2 == 0 } {
           set CHECK_T4V2 1
           set CHECK_T4M2 1
        } else {
           set CHECK_T2V2 1
           set CHECK_T2M2 1
        }
       } else {
           set CHECK_T8V2 1
           set CHECK_T8M2 1
       }
      }
     }  elseif { $top_metal == 1 } {
           set CHECK_V3 1
           set CHECK_M4 1
    if { $T2V1_T2M1 == 0 } {
     if { $T8V1_T8M1 == 0 } {
           set CHECK_T4V1 1
           set CHECK_T4M1 1
         } else { 
           set CHECK_T8V1 1
           set CHECK_T8M1 1
         }
   } else {
           set CHECK_T2V1 1
           set CHECK_T2M1 1
    }
   } else {
  puts "\nWrong metal option combination. Please check the setting for metal options.\n"
  exit
       } 

} elseif { $total_metal == 4 } {
if { $top_metal == 1 } {
           set CHECK_V2 1
           set CHECK_M3 1
    if { $T2V1_T2M1 == 0 } {
     if { $T8V1_T8M1 == 0 } {
           set CHECK_T4V1 1
           set CHECK_T4M1 1
         } else { 
           set CHECK_T8V1 1
           set CHECK_T8M1 1
         }
   } else {
           set CHECK_T2V1 1
           set CHECK_T2M1 1
    }
   } else {
  puts "\nWrong metal option combination. Please check the setting for metal options.\n"
  exit
       } 
   } else {
  set MT_CHOICE 1
}




#define the list for all inner metals and vias,temporarily
#define the list for all inner metals and inner vias,respectively
set v_m_list " "
set v_m_list_for_connect " "
set v_j " "
set v_j_layer " "
set m_j " "
set m_j_layer " "
set m_j_dummy " "
set SRCK20_layer_tmp " "
set SRCK20_tmp " "

for { set j 1 } { $j <= [expr $total_metal -$top_metal] } { incr j } {
  if { [set CHECK_M$j] == 1 } { 
    lappend v_m_list M$j
    lappend v_m_list_for_connect M${j}i
    lappend m_j $j
    lappend m_j_layer M$j
    lappend m_j_dummy MET${j}dmi
    lappend SRCK20_layer_tmp M${j}S_RING
    lappend SRCK20_tmp !!(AREA(M${j}S_RING))
  }
  if { [set CHECK_M$j] == 0 } break
  if { $j < 8 } {
    if { [set CHECK_V$j] == 1 } {
    lappend v_m_list V$j
    lappend v_m_list_for_connect V${j}
    lappend v_j $j
    lappend v_j_layer V$j
    lappend SRCK20_layer_tmp V${j}S
    lappend SRCK20_tmp !!(AREA(V${j}S))
    }
  }
}
#define the list for all metals and vias
#define the list for top metals and top vias
set top_v_m_list " "
set top_v_m_list_all {  T2V1 T2M1 T2V2 T2M2 T4V1 T4M1 T4V2 T4M2 T8V1 T8M1 T8V2 T8M2 }
foreach top_v_m_layer $top_v_m_list_all {
  set tmp CHECK_$top_v_m_layer
  set tmp_v [set $tmp]
  if { $tmp_v == 1 } {
    lappend v_m_list $top_v_m_layer
    lappend v_m_list_for_connect ${top_v_m_layer}i
    lappend top_v_m_list $top_v_m_layer
  }
}


#define the lists for top metals and top vias,respectively
set t_v_j " "
set t_m_j " "
set t_v_list_all { T2V1 T2V2 T4V1 T4V2 T8V1 T8V2}
set t_m_list_all { T2M1 T2M2 T4M1 T4M2 T8M1 T8M2}

foreach t_v_list_layer $t_v_list_all {
  if { [set CHECK_$t_v_list_layer] == 1 } {
    lappend t_v_j $t_v_list_layer
  }
}
foreach t_m_list_layer $t_m_list_all {
  if { [set CHECK_$t_m_list_layer] == 1 } {
    lappend t_m_j $t_m_list_layer
  }
}


#define the lists for all metal layers and all via layers,respectively
set metal_all [concat $m_j_layer $t_m_j]
set via_all [concat $v_j_layer $t_v_j]


#define the list for T2M1 and T2M2,T4M1 and T4M2, T8M1 and T8M2 respectively
#define the list for T2M1DUM and T2M2DUM,T4M1DUM and T4M2DUM, T8M1DUM and  T8M2DUM respectively
set t_m_j_STM " "
set t_m_j_STDUM " "
set t_m_j_TM " "
set t_m_j_TMDUM " " 
set t_m_j_UTM " "
set t_m_j_UTMDUM " "
foreach t_m_j_STM_layer { T2M1 T2M2 } {
  if { [set CHECK_$t_m_j_STM_layer] == 1 } {
    lappend t_m_j_STM $t_m_j_STM_layer
    lappend t_m_j_STDUM ${t_m_j_STM_layer}dmi
  }
}
foreach t_m_j_TM_layer { T4M1 T4M2 } {
  if { [set CHECK_$t_m_j_TM_layer] == 1 } {
    lappend t_m_j_TM $t_m_j_TM_layer
    lappend t_m_j_TMDUM ${t_m_j_TM_layer}dmi
  }
}
foreach t_m_j_UTM_layer { T8M1 T8M2 } {
  if { [set CHECK_$t_m_j_UTM_layer] == 1 } {
    lappend t_m_j_UTM $t_m_j_UTM_layer
    lappend t_m_j_UTMDUM ${t_m_j_UTM_layer}dmi
  }
}


#define a list for all metal dummy layers
if {[lsearch $metal_all STM*] == -1 } {
  if { [lsearch $metal_all TM*] == -1} {
 set metal_dummy_list [concat $m_j_dummy $t_m_j_UTMDUM]
 } elseif {[lsearch $metal_all TM*] == 1} {
 set metal_dummy_list [concat $m_j_dummy $t_m_j_TMDUM $t_m_j_UTMDUM]
 } elseif {[lsearch $metal_all TM*] == 2} {
 set metal_dummy_list [concat $m_j_dummy $t_m_j_TMDUM]
 } else {
 puts "\nWrong metal option combination. Please check the setting for metal options.\n"
 exit
 }
} elseif { [lsearch $metal_all STM*] == 1 } {
  if { [lsearch $metal_all TM*] == -1 } {
 set metal_dummy_list [concat $m_j_dummy $t_m_j_STMDUM $t_m_j_UTMDUM]
 } elseif { [lsearch $metal_all TM*] == 1 } {
  set metal_dummy_list [concat $m_j_dummy $t_m_j_STMDUM $t_m_j_TMDUM]
 } else {  
  puts "\nWrong metal option combination. Please check the setting for metal options.\n"
 exit
 }
} elseif { [lsearch $metal_all STM*] == 2 } {
  set metal_dummy_list [concat $m_j_dummy $t_m_j_STMDUM]
 } else { 
 puts "\nWrong metal option combination. Please check the setting for metal options.\n"
 exit
 }

for { set i 0 } { $i < [expr [llength $v_m_list_for_connect] -2] } { incr i 2 } {
  CONNECT [lindex $v_m_list_for_connect $i] [lindex $v_m_list_for_connect [expr $i +2]] BY [lindex $v_m_list_for_connect [expr $i +1]]
}
if { [string equal $T2V2_T2M2 1] == 1 } {
CONNECT T2M2i CBi
CONNECT T2M2i RDLi BY RV
} 
if { [string equal $T4V2_T4M2 1] == 1 } {
CONNECT T4M2i CBi
CONNECT T4M2i RDLi BY RV
} 
if { [string equal $T8V2_T8M2 1] == 1 } {
CONNECT T8M2i CBi
CONNECT T8M2i RDLi BY RV
} 
if { [string equal $T2V1_T2M1 1] == 1 && [string equal $top_metal 1] == 1} {
CONNECT T2M1i CBi
CONNECT T2M1i RDLi BY RV
} 
if { [string equal $T4V1_T4M1 1] == 1 && [string equal $top_metal 1] == 1} {
CONNECT T4M1i CBi
CONNECT T4M1i RDLi BY RV
} 
if { [string equal $T8V1_T8M1 1] == 1 && [string equal $top_metal 1] == 1} {
CONNECT T8M1i CBi
CONNECT T8M1i RDLi BY RV
}
CONNECT RDLi COVER
CONNECT CBi ALPAi
CONNECT RDLi ALPAi
CONNECT ALPAi MDi
CONNECT M1i PO0 NTAP0 PTAP0 PSDi NSDi BY CTi
CONNECT NTAP0 NW0 
CONNECT NW1i DNWi                                //NW interact with DNW
CONNECT NTAP0 NW1i                               //N+pickup interact with NW
CONNECT PTAP0 PWi				//P+pickup interact with (NOT NW)
CONNECT NTAP0 PSDi				//N+pickup butted P+ silicided S/D
CONNECT PTAP0 NSDi				//P+pickup butted N+ silicided S/D
CONNECT PSDi PSD
CONNECT NSDi NSD
CONNECT NW1i NW
CONNECT DNWi DNW
CONNECT PWi PW
CONNECT CTi CT
set metal_all_reverse " "
for { set i 0 } { $i < [llength $metal_all] } { incr i } {
  lappend metal_all_reverse [lindex $metal_all end-$i]i
}

TEXT DEPTH PRIMARY
#LAYOUT TOP LAYER $metal_all_reverse
LVS POWER NAME "?VDD?" "?VCC?"

LABEL ORDER $metal_all_reverse NTAP0 PTAP0 NSDi PSDi PO0 NW1i



#// VIRTUAL CONNECT NOTICE!
#// Power name below should be adjusted following the power naming convention to detect NW spacing rule violations correctly.
VIRTUAL CONNECT NAME "?VDD?" "?VCC?" "?VSS?" "?GND?"
VIRTUAL CONNECT COLON YES


VERBATIM {
//******************************************
//    LAYER DERIVATIONS AND OPERATIONS
//******************************************


//==================
// For Connectivity
//==================

PACTi   = PPi AND ACTi
NACTi   = NPi AND ACTi

PTAPi   = PACTi NOT NW1i
NTAPi   = NACTi AND NW1i
ALL_TAPi    = PTAPi OR NTAPi
PGATEi  = PACTi AND POLYi
NGATEi  = NACTi AND POLYi

PSDi    = (PACTi NOT PGATEi) AND NW1i
NSDi    = (NACTi NOT NGATEi) NOT NW1i
ALL_SDi = PSDi OR NSDi
PMOSi   = (PGATEi OR PSDi) INTERACT GATE
NMOSi   = (NGATEi OR NSDi) INTERACT GATE

AARES = COPY ACTres
PORES = COPY POLYres

AA_resistor = ((AA AND AARES) AND SAB) OR ((AA AND AARES) NOT INTERACT SAB)
PO_resistor = (((PO AND PORES) AND SAB) OR ((PO AND PORES) NOT INTERACT SAB)) OR HPR
NW_resistor_AA = ((NW1res AND AA) AND NW) AND SAB
NW_resistor_STI = (NW1res AND NW) NOT INTERACT SAB
NW_resistor = NW_resistor_AA OR NW_resistor_STI

PO_all = POLYi OR POLYdmi
AA_all = ACTi OR ACTdmi

//AA0 = (ACTi NOT (AA_resistor OR NW1res)) NOT POLYi
PO0 = POLYi NOT (SAB AND (PORES OR HPR))
NW0 = NW1i NOT NW1res
NW00 = NW NOT NW1res

PTAP0   = PACTi NOT NW1i
NTAP0   = NACTi AND NW1i

HVNW0    = NW00 AND HVNW
MVNW0    = NW00 AND MVNW
LVNW0    = NW00 AND LVNW

//PO_raw = PO NOT SAB
PO_raw   = COPY PO

//==================
//  Resistor Def
//==================

NWR     = NW INTERACT NW1res
AAR     = AA INTERACT AARES
POR     = PO INTERACT PORES


NR      = NWR INSIDE AA
AANR    = AA INTERACT NWR
SDNNR    = SDN INTERACT NWR
SDPNR    = SDP INTERACT NWR

NWDEV   = NW NOT (NWR OR NR)
AADEV   = AA NOT (AAR OR AANR)
PODEV   = PO NOT POR
SDNDEV   = SDN NOT SDNNR
SDPDEV   = SDP NOT SDPNR

//=============
//   HRP Def
//=============

PO_HRP   =  ((HPR AND PO) AND HRP) AND SAB
//PO_HRP   = PO INTERACT HRP
//HR_PO    = PO_HRP AND HPR

//==================
//   Well Def
//==================

DRC:1   = EXTENT drawn original
BULK    = SIZE DRC:1 BY 1.0
CHIP = COPY DRC:1

//EMPTY = COPY CHIP
EMPTY1 = COPY EMPTY
//EMPTY4 = COPY EMPTY
EMPTY5 = COPY EMPTY

PW_INNW = DNW NOT NW
DNW_EDGE = EXPAND EDGE (DNW INSIDE EDGE NW) OUTSIDE BY 0.001
NW_DNW = NW INTERACT DNW_EDGE

DGTG    = TG OR DG

HVNW    = NW NOT OUTSIDE TG
MVNW    = NW NOT OUTSIDE DG
LVNW    = (NW NOT HVNW) NOT MVNW

HVNW1i	= NW1i NOT OUTSIDE TGOX 
MVNW1i	= NW1i NOT OUTSIDE DGOX 
LVNW1i	= (NW1i NOT HVNW1i) NOT MVNW1i


//==================
// Transistor Def
//==================

PACT    = SDP AND AA
NACT    = SDN AND AA
ACT     = PACT OR NACT


PPO     = SDP AND PO
NPO     = SDN AND PO

PTAP    = PACT NOT NW
NTAP    = NACT AND NW
TAP     = PTAP OR NTAP

PICKAA = TAP NOT ((TAP INTERACT GATE) AND VARAM)
NON_PICKAA = AA NOT PICKAA


PGATE   = PACT AND PO
NGATE   = NACT AND PO

GATE0 = PO AND AA 
AA1 = (AA INTERACT GATE0) NOT GATE0
AA2 = AA1 TOUCH GATE0 == 2
AA3 = AA1 INTERACT CT 
AA4 = AA2 OR AA3
GATE1 = GATE0 TOUCH AA4 == 2
GATE2 = GATE0 AND LDMOS
GATE  = GATE1 OR GATE2

FPOLY = PO NOT AA
GATE_L = (GATE COIN EDGE AA) NOT COIN EDGE PO
GATE_W = GATE COIN EDGE PO
GATE_60nm = (EXPAND EDGE GATE_W INSIDE BY 0.06) INSIDE EDGE GATE       //for SAB_5

GATE_core = GATE NOT (DG OR TG)                        //1.0/1.2V MOS GATE
GATE_core_L  = (GATE_core COIN EDGE AA) NOT COIN EDGE PO  //1.0/1.2V MOS GATE LENGTH
GATE_core_W  = GATE_core COIN EDGE PO			    //1.0/1.2V MOS GATE WIDTH

GATE_io1 = (GATE AND DG) NOT TG     //1.8V MOS GATE
GATE_io1_L = (GATE_io1 COIN EDGE AA) NOT COIN EDGE PO
GATE_io1_W = GATE_io1 COIN EDGE PO

GATE_io2 = (GATE AND TG) NOT DG
GATE_io2_L = (GATE_io2 COIN EDGE AA) NOT COIN EDGE PO
GATE_io2_W = GATE_io2 COIN EDGE PO

GATE_var = GATE AND VARAM                        //VARMOS GATE
GATE_var_L  = (GATE_var COIN EDGE AA) NOT COIN EDGE PO  //VARMOS GATE LENGTH
GATE_var_W  = GATE_var COIN EDGE PO			    //VARMOS GATE WIDTH

PSD     = (PACT NOT PGATE) TOUCH PGATE
NSD     = (NACT NOT NGATE) TOUCH NGATE

PMOS    = PGATE OR PSD
NMOS    = NGATE OR NSD
MOS     = PMOS OR NMOS

NMOS_CAP = NMOS AND NW

PBAA   	= AA AND PSUB
PBMOS   = NMOS AND PSUB
PBPO   	= PO INTERACT PSUB
NOMI_AA = AA NOT PBAA


AAEIPO  = AA INSIDE EDGE PO
POEIAA  = PO INSIDE EDGE AA

INTERPO = PO NOT GATE


//=====================
//   Poly E-Fuse Def
//=====================

EFU    = PO INTERACT EFUSEALL
EFU_BO = EFU AND POEFUSEBLK
RCT    = CT INTERACT EFU
RCT_RT = RECTANGLE RCT == 0.09 BY == 0.30


//=====================
//     CT Def
//=====================

ACT_CT   = CT AND AA
INTERCT  = CT AND INTERPO

}

#//=====================
#//   AL Fuse Def
#//=====================

SETLAYER ALFUSE = (RDL AND FUSE) AND FUTR
SETLAYER Al_fuse_1 = LENGTH ALFUSE >= 4.44
SETLAYER Al_fuse   = ALFUSE WITH EDGE Al_fuse_1 >= 2
SETLAYER Alfuse_edge = LENGTH Al_fuse >= 4.44
SETLAYER Alfuse_edge_1 = CONVEX EDGE ALFUSE ANGLE1 == 270 ANGLE2 == 270

for { set i 0 } { $i <= [llength $v_m_list] } { incr i 2 } {
  SETLAYER H[lindex $v_m_list $i] = (HOLES [lindex $v_m_list $i] INNER) INTERACT FUSE
  SETLAYER G[lindex $v_m_list $i] = ([lindex $v_m_list $i] TOUCH H[lindex $v_m_list $i]) AND GRID
   
  set j [expr $i +1]
  if { $j < [llength $v_m_list] } {
    SETLAYER G[lindex $v_m_list $j] = [lindex $v_m_list $j] INTERACT G[lindex $v_m_list $i]
    SETLAYER [lindex $v_m_list $j]FUSE = [lindex $v_m_list $j] INSIDE H[lindex $v_m_list $i]
  }

  VERBATIM { }
}

SETLAYER GCT = CT INTERACT GM1
SETLAYER CTFUSE = CT INSIDE HM1

SETLAYER HRDL = (HOLES RDL inner ) INTERACT FUSE
SETLAYER GRDL = (RDL TOUCH HRDL) AND GRID
SETLAYER GRDLV = RDLVIA INTERACT GRDL
SETLAYER RDLVF = RDLVIA INSIDE HRDL

set Stack_Vn "[lindex $via_all end]FUSE INTERACT RDLVF"
for { set i 1 } { $i < [llength $via_all] } { incr i } {
  set Stack_Vn "[lindex $via_all end-$i]FUSE INTERACT (${Stack_Vn})"
}
SETLAYER Stack_Vn  = $Stack_Vn

set Stack_MR "G[lindex $metal_all end] OR GRDL"
for { set i 1 } { $i < [llength $metal_all] } { incr i } {
  set Stack_MR "G[lindex $metal_all end-$i] OR (${Stack_MR})"
}
SETLAYER Stack_MR  = $Stack_MR


SETLAYER LMARK = (RDL AND FUSE) AND LOGO


#--------------------------------------------------------------------------------------------------------------------------------

#****************************************************
# MACRO for wide metal space rule
#****************************************************

proc Mn_2b { MTLAY MTLEN MTWID MTSPA } {
  SETLAYER span_edge_0 = DFM COPY (DFM SPACE $MTLAY < $MTWID BY INT) EDGE
  SETLAYER span_edge_1 = $MTLAY NOT COIN EDGE span_edge_0
  SETLAYER span_edge = EXT \[span_edge_1\] $MTLAY < $MTSPA ABUT < 90 OPPOSITE
  OUTLAYER (LENGTH span_edge >= $MTLEN) NOT INSIDE EDGE NODRC
}
proc Mn_2b_SPECIAL { MTLAY MTLEN MTWID MTSPA } {
  SETLAYER span_edge_0 = DFM COPY (DFM SPACE $MTLAY < $MTWID BY INT) EDGE
  SETLAYER span_edge_1 = $MTLAY NOT COIN EDGE span_edge_0
  SETLAYER span_edge = EXT \[span_edge_1\] $MTLAY < $MTSPA ABUT < 89.9 OPPOSITE
  OUTLAYER (LENGTH span_edge >= $MTLEN) NOT INSIDE EDGE NODRC
}



proc Mn_2b_DUM { MTLAY DUMMY2 MTLEN MTWID MTSPA } {
  SETLAYER X0_a = $MTLAY WITH WIDTH >= $MTWID
  SETLAYER X0 = ENCLOSE RECTANGLE X0_a $MTLEN $MTWID
  SETLAYER X1 = EXT $MTLAY < $MTSPA OPPOSITE REGION PARA ONLY
  SETLAYER X2 = LENGTH X1 >= $MTLEN
  SETLAYER X3 = X2 TOUCH EDGE X0
  SETLAYER X4_near = EXPAND EDGE X3 OUTSIDE BY $MTWID
  SETLAYER X4_far  = (EXPAND EDGE X3 OUTSIDE BY ($MTWID + 0.01)) NOT X4_near
  SETLAYER X5 = X4_near NOT $MTLAY
  SETLAYER X6_near = EXT X1 X5 < $MTWID OPPOSITE REGION
  SETLAYER X6_far  = EXT X4_far X5 < $MTWID OPPOSITE REGION
  SETLAYER X7 = (X4_near NOT X5) NOT (X6_near OR X6_far)
  SETLAYER X7_edge = LENGTH (X7 COIN EDGE X1) >= $MTLEN
  SETLAYER X7_expand = EXPAND EDGE X7_edge OUTSIDE BY $MTSPA
  SETLAYER X8 = (X7_expand AND X1) NOT X5
  OUTLAYER (X8 INTERACT $DUMMY2) NOT INSIDE NODRC 
}

proc Mn_2c_DUM { MTLAY DUMMY2 MTLEN MTWID MTSPA } {
  SETLAYER X0_a = $MTLAY WITH WIDTH >= $MTLEN
  SETLAYER X0 = ENCLOSE RECTANGLE X0_a $MTLEN $MTWID
  SETLAYER X1 = EXT $MTLAY < $MTSPA OPPOSITE REGION PARA ONLY
  SETLAYER X2 = LENGTH X1 >= $MTLEN
  SETLAYER X3 = X2 TOUCH EDGE X0
  SETLAYER X4_near = EXPAND EDGE X3 OUTSIDE BY $MTWID
  SETLAYER X4_far  = (EXPAND EDGE X3 OUTSIDE BY ($MTWID + 0.01)) NOT X4_near
  SETLAYER X5 = X4_near NOT $MTLAY
  SETLAYER X6_near = EXT X1 X5 < $MTWID OPPOSITE REGION
  SETLAYER X6_far  = EXT X4_far X5 < $MTWID OPPOSITE REGION
  SETLAYER X7 = (X4_near NOT X5) NOT (X6_near OR X6_far)
  SETLAYER X7_edge = LENGTH (X7 COIN EDGE X1) >= $MTLEN
  SETLAYER X7_expand = EXPAND EDGE X7_edge OUTSIDE BY $MTSPA
  SETLAYER X8 = (X7_expand AND X1) NOT X5
  OUTLAYER (X8 INTERACT $DUMMY2) NOT INSIDE NODRC 
}

#--------For AA PO shape -------------------------------------------------------------------------------------------------------------------------------
proc SHAPE { LAYER } {
SETLAYER  ${LAYER}_VEX_0 = CONVEX EDGE $LAYER == 0
SETLAYER  ${LAYER}_VEX_1 = CONVEX EDGE $LAYER == 1
SETLAYER  ${LAYER}_VEX_2 = CONVEX EDGE $LAYER == 2


SETLAYER  ${LAYER}_LS = (($LAYER NOT WITH EDGE ${LAYER}_VEX_0) WITH EDGE ${LAYER}_VEX_1 == 2) WITH EDGE ${LAYER}_VEX_2 == 4

SETLAYER  ${LAYER}_TS1 = (($LAYER NOT WITH EDGE ${LAYER}_VEX_0) WITH EDGE ${LAYER}_VEX_1 == 4) WITH EDGE ${LAYER}_VEX_2 == 4
SETLAYER  ${LAYER}_TS2 = EXPAND EDGE (${LAYER}_VEX_2 COIN EDGE ${LAYER}_TS1) OUTSIDE BY 0.005 CORNER FILL
SETLAYER  ${LAYER}_TS3 = ${LAYER}_TS2 WITH EDGE ${LAYER}_VEX_2 == 3
SETLAYER  ${LAYER}_TS = ${LAYER}_TS1 INTERACT ${LAYER}_TS3 == 1

SETLAYER  ${LAYER}_US = (($LAYER WITH EDGE ${LAYER}_VEX_0 == 1) WITH EDGE ${LAYER}_VEX_1 == 2) WITH EDGE ${LAYER}_VEX_2 == 5

SETLAYER  ${LAYER}_OS = (($LAYER WITH EDGE ${LAYER}_VEX_0 == 4) NOT WITH EDGE ${LAYER}_VEX_1) WITH EDGE ${LAYER}_VEX_2 == 4

SETLAYER ${LAYER}_HS = (($LAYER WITH EDGE ${LAYER}_VEX_0 ==2) WITH EDGE ${LAYER}_VEX_1 == 4) WITH EDGE ${LAYER}_VEX_2 == 6
}

SHAPE PO
SHAPE AA

#------------------FOR H SHAPE--------------------------
proc via_in_H_bar { via metal hole_length hole_area bar_l bar_w } {

SETLAYER X0 = AREA (RECTANGLE (HOLES $metal INNER)) <= $hole_area
SETLAYER X1 = X0 NOT WITH EDGE (LENGTH X0 > 5)
SETLAYER Y = $metal COIN EDGE X1
SETLAYER Y1 = (EXT Y <= $bar_w OPPOSITE REGION) NOT $metal
SETLAYER Z0 = $metal INTERACT Y1 == 2
SETLAYER Z1 = LENGTH ($metal COIN EDGE Z0) <= 1 
SETLAYER Z = Z0 WITH EDGE Z1
}
#------------------FOR T4V1.10--------------------------
proc two_via_within_space_in_wide_metal { via metal_bottom metal_up metal_width } {

SETLAYER  X1a = WITH WIDTH $metal_bottom > $metal_width
SETLAYER  X1b = WITH WIDTH $metal_up > $metal_width
SETLAYER  WIDE = X1a OR X1b
SETLAYER  X2 = ($metal_bottom AND $metal_up) ENCLOSE ($via NOT OUTSIDE WIDE)
SETLAYER  X3 =  $via INSIDE X2
SETLAYER  X5c = WITH NEIGHBOR X3 >= 1 INSIDE OF LAYER X2 
SETLAYER  X6c = X2 ENCLOSE X5c
OUTLAYER  ((X2 NOT X6c) NOT SRINGBLK) NOT INSIDE NODRC
}


#//==================================
#//  DNW -  Deep N-Well  DRC
#//==================================

GROUP GDNW DNW_?

RULECHECK DNW_W_1 {
@ DNW width >= 3.00um
OUTLAYER (INT DNW < 3.0 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK DNW_S_1 {
@ Space between two DNWs >= 3.50um
OUTLAYER (EXT DNW < 3.5 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK DNW_S_2a {
@ Space between DNW and NW1 at different net >= 2.35um
OUTLAYER (EXT DNW NW < 2.35 SINGULAR REGION MEASURE ALL NOT CONNECTED) NOT INSIDE NODRC
}

RULECHECK DNW_S_3 {
@ Space between TPW and (TPW OR PW) >= 0.80um
SETLAYER X = PW INSIDE DNW 
SETLAYER Y = PW OR X 
OUTLAYER ((EXT X Y < 0.80 ABUT<90 SINGULAR REGION) NOT INSIDE LDMOS) NOT INSIDE NODRC
}

RULECHECK DNW_S_4 {
@ Space between TPW and (TPW OR PW) when at least one TPW OR PW interact DGOX >= 1.20um
SETLAYER X0 = (PW INSIDE DNW) INTERACT (DG OR TG)
SETLAYER X1 = ((PW INSIDE DNW) OR PW) INTERACT (DG OR TG)
SETLAYER X2 = ((PW INSIDE DNW) OR PW) NOT INTERACT (DG OR TG)
SETLAYER X3 = (PW INSIDE DNW) NOT INTERACT (DG OR TG)
OUTLAYER ((EXT X0 X2 < 1.20 ABUT<90 SINGULAR REGION ) NOT INSIDE LDMOS) NOT INSIDE NODRC
OUTLAYER ((EXT X3 X1 < 1.20 ABUT<90 SINGULAR REGION ) NOT INSIDE LDMOS) NOT INSIDE NODRC
}

RULECHECK DNW_S_5 {
@ Space between DNW and N+ACT >= 1.60um
OUTLAYER (EXT DNW NSDi < 1.60 SINGULAR REGION ) NOT INSIDE NODRC
}

RULECHECK DNW_EN_1 {
@ NW1 Enclosure of DNW >= 1.00um
OUTLAYER (ENC DNW NW < 1.0 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
OUTLAYER (DNW COINCIDENT EDGE NW) NOT INSIDE EDGE NODRC
OUTLAYER (DNW OUTSIDE EDGE NW) NOT INSIDE EDGE NODRC
}
RULECHECK DNW_EN_2 {
@ Enclosure of N+ ACT >= 0.55um
OUTLAYER (ENC (NACT NOT (NTAP OR PTAP)) DNW < 0.55 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
RULECHECK DNW_O_1 {
@ Overlap of NW1 and DNW. >= 0.40um 
  SETLAYER X = SIZE DNW BY -0.4
  OUTLAYER ((DNW NOT X) NOT NW) NOT INSIDE NODRC 
}

RULECHECK DNW_R_1 {
@ It is recommanded DNW be enclosed by NW1
OUTLAYER ((DNW NOT INSIDE EDGE NW_DNW) NOT COIN EDGE NW_DNW) NOT INSIDE EDGE NODRC
}

#RULECHECK DNW_R_2 {
#  @ NWs in same DNW must be same potential
#}    // checked in LVS ERC

RULECHECK DNW_R_3 {
@ Floating TPW is not allowed. DRC flags TPW not TOUCH CT in P+ pickup ACT
SETLAYER  X = PW INSIDE DNW
OUTLAYER  X NOT INTERACT (CT INTERACT PTAP)  
}

#//===========================
#//  ACT - Active Area DRC
#//===========================

GROUP GAA ACT_?

RULECHECK ACT_W_1 {
@ ACT width >= 0.08um
OUTLAYER (INT AA < 0.08 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
RULECHECK ACT_W_2 {
@ Width of 45 degree bent ACT >= 0.18um
SETLAYER X = ANGLE AA == 45
OUTLAYER (INT X < 0.18 ABUT<90 REGION) NOT INSIDE NODRC
}
RULECHECK ACT_W_3a {
@ Channel width for 0.9/1.2V NMOS/PMOS transistors >= 0.12um
SETLAYER Y = LENGTH GATE_core_W < 0.12
OUTLAYER ((EXPAND EDGE Y INSIDE BY 0.001) NOT INSIDE SRAMALL) NOT INSIDE NODRC
}
RULECHECK ACT_W_3b {
@ Channel width for 1.8/2.5V/3.3V NMOS/PMOS transistors >= 0.21um
SETLAYER Y = LENGTH GATE_io1_W < 0.21
OUTLAYER ((EXPAND EDGE Y INSIDE BY 0.001) NOT INSIDE SRAMALL) NOT INSIDE NODRC
SETLAYER Z = LENGTH GATE_io2_W < 0.21
OUTLAYER ((EXPAND EDGE Z INSIDE BY 0.001) NOT INSIDE SRAMALL) NOT INSIDE NODRC
}
VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK ACT_W_3a_R {
@ Recommended Channel width for 0.9/1.2V NMOS/PMOS transistors >= 0.15um
SETLAYER Y = LENGTH GATE_core_W < 0.15
OUTLAYER ((EXPAND EDGE Y INSIDE BY 0.001) NOT INSIDE SRAMALL) NOT INSIDE NODRC
}

VERBATIM {
#ENDIF
}
RULECHECK ACT_L_1 {
@ Maximum ACT length between two contacts, or between one contact and ACT line end when ACT width < 0.15um <= 25.00um
SETLAYER AA_1 = AA INTERACT CT
SETLAYER AA_CHECK = AA_1 WITH WIDTH < 0.15

SETLAYER Z0 = SIZE CT BY 12.5 INSIDE OF AA_CHECK STEP 0.02
SETLAYER Z1 = Z0 INTERACT CT < 2
SETLAYER Z2 = (AA_CHECK INTERACT Z1) NOT (AA_CHECK INTERACT CT == 1)
OUTLAYER Z2 NOT INSIDE NODRC
SETLAYER AA_CHECK_2 = INT AA_1 < 0.15 OPPOSITE REGION
SETLAYER Z4 = AA_CHECK_2 NOT INTERACT CT 
SETLAYER Z6 = LENGTH Z4 >25
OUTLAYER Z6 NOT INSIDE EDGE NODRC

SETLAYER X = CONVEX EDGE AA ANGLE1>=89.9<=90.1 ANGLE2>=89.9<=90.1 WITH LENGTH<0.15 
SETLAYER Y = (AA WITH WIDTH <0.15) INTERACT CT
SETLAYER Z = Y TOUCH EDGE X    
SETLAYER Z3 = SIZE CT BY 25 INSIDE OF Y STEP 0.02
OUTLAYER ((Z NOT INSIDE EDGE Z3) NOT TOUCH EDGE Z3) NOT INSIDE EDGE NODRC
}
RULECHECK ACT_L_2 {
@ Maximum ACT length of Source Active (without CT, width <= 0.15um) which butted with tap <= 0.5um
SETLAYER AA_1 = ALL_SDi NOT INTERACT CT
SETLAYER AA_2 = AA_1 WITH WIDTH < 0.15
SETLAYER AA_3 = AA_2 INTERACT ALL_TAPi
SETLAYER AA_4 = LENGTH AA_3 > 0.5
OUTLAYER ((ALL_SDi WITH EDGE AA_4) NOT INSIDE SRAMALL) NOT INSIDE NODRC
}

RULECHECK ACT_S_1 {
@ Space between two ACTs > = 0.11um
OUTLAYER (EXT AA < 0.11 ABUT<90 SINGULAR REGION) NOT INSIDE (NODRC OR SRAMALL)
}

VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK ACT_S_1_R {
@ Recommended Space between two ACTs > = 0.16um

OUTLAYER (EXT AA < 0.16 ABUT<90 SINGULAR REGION) NOT INSIDE (NODRC OR SRAMALL)
}

RULECHECK ACT_S_2a_R {
@ Recommended Space between ACT and huge ACT(area> 2000000um2) is 0.35um

SETLAYER ACT_huge = AREA AA > 2000000
OUTLAYER (EXT AA ACT_huge < 0.35 ABUT<90 SINGULAR REGION) NOT INSIDE (NODRC OR SRAMALL)
}

VERBATIM {
#ENDIF
}

RULECHECK ACT_S_1a {
@ Space between two ACTs at least one ACT inside by TGOX
SETLAYER AA_TG = AA INSIDE TG
OUTLAYER (EXT AA AA_TG < 0.16 ABUT<90 SINGULAR REGION) NOT INSIDE (NODRC OR SRAMALL)
}

RULECHECK ACT_S_2 {
@ Space between ACTs when one or both ACT width greater than 0.2um parallel length >= 0.3,  >= 0.125
SETLAYER X = AA WITH WIDTH > 0.2
SETLAYER Y = EXT X AA < 0.125 OPPOSITE REGION 
OUTLAYER (ENCLOSE RECTANGLE Y 0.3 0.08 ORTHOGONAL ONLY) NOT INSIDE (NODRC OR SRAMALL)
}

RULECHECK ACT_S_3 {
@ Space to 45 degree bent ACT >= 0.18um
SETLAYER X = ANGLE AA == 45
OUTLAYER (EXT X AA < 0.18 ABUT<90 REGION) NOT INSIDE NODRC
}

RULECHECK ACT_S_4 {
@ Space between U-shape (or O-shape) ACT inner edges >= 0.18um
OUTLAYER (CONVEX EDGE AA_OS == 0 WITH LENGTH < 0.18) NOT INSIDE EDGE NODRC
OUTLAYER (CONVEX EDGE AA_US == 0 WITH LENGTH < 0.18) NOT INSIDE EDGE NODRC
}
RULECHECK ACT_S_5 {
@ Space between NW1 and N+ACT inside PW except NW1 resistor region >= 0.15um
SETLAYER X = EXT (NW NOT INTERACT NW1res) (NACT INSIDE PW) < 0.15 ABUT<90 SINGULAR REGION
OUTLAYER (X NOT INSIDE SRAMALL) NOT INSIDE NODRC
}
RULECHECK ACT_S_6 {
@ Space between NW1 and N+ACT inside TGOX >= 0.31um
SETLAYER X = EXT (NW NOT INTERACT NW1res) (NACT INSIDE TG) < 0.31 ABUT<90 SINGULAR REGION
OUTLAYER (X NOT INSIDE SRAMALL) NOT INSIDE NODRC
}

RULECHECK ACT_S_7 {
@ Space between N+ACT, which is not enclosed by DNW, and NW1 which encloses a DNW >= 0.32um
SETLAYER X = EXT NACT NW_DNW < 0.32 ABUT<90 SINGULAR REGION
OUTLAYER (X NOT DNW) NOT INSIDE NODRC

}
RULECHECK ACT_S_8 {
@ Space between NW1 and P+ pickup ACT except LDMOS region >= 0.15um
SETLAYER X = EXT NW (((PACT NOT NW) NOT PSUB) NOT INSIDE LDMOS) < 0.15 ABUT<90 SINGULAR REGION
OUTLAYER (X NOT INSIDE SRAMALL) NOT INSIDE NODRC
}
RULECHECK ACT_EN_1 {
@ Enclosure of N+ACT by NW1 (excluding NW1 interacting with NW1res) >= 0.15um
SETLAYER X = ENC NACT (NW NOT INTERACT NW1res) < 0.15 ABUT<90 SINGULAR REGION
OUTLAYER (X NOT INSIDE SRAMALL) NOT INSIDE NODRC
}

RULECHECK ACT_EN_2 {
@ Enclosure P+ACT by NW1 >= 0.15um
SETLAYER X = ENC PACT NW < 0.15 ABUT<90 SINGULAR REGION 
OUTLAYER (X NOT INSIDE SRAMALL) NOT INSIDE NODRC
}

RULECHECK ACT_EN_2a {
@ Enclosure P+ACT by (NW1 INTERACT TGOX) >= 0.31um
SETLAYER X = ENC PACT (NW INTERACT TG) < 0.31 ABUT<90 SINGULAR REGION 
OUTLAYER (X NOT INSIDE SRAMALL) NOT INSIDE NODRC
}

RULECHECK ACT_A_1 {
@ AA area >= 0.038um2
SETLAYER X = AREA AA < 0.038
OUTLAYER (X NOT INSIDE SRAMALL) NOT INSIDE NODRC
}
RULECHECK ACT_A_2 {
@ Enclosed area >= 0.08um2
OUTLAYER (AREA ((HOLES AA INNER) NOT AA) < 0.08) NOT INSIDE NODRC
}

VERBATIM {
#IFDEF Density_rules YES
}
RULECHECK ACT_D_1_min {
@ AA density (including dummy ACT) in 100umX100um window with step size 50um >= 20%
@ <= 80%
OUTLAYER (DENSITY AA_all < 0.20 WINDOW 100 STEP 50 BACKUP PRINT density_report_ACT_D_1_min.log) NOT INSIDE NODRC
}
RULECHECK ACT_D_1_max {
@ AA density (including dummy ACT) in 100umX100um window with step size 50um >= 20%
@ <= 80%
OUTLAYER (DENSITY AA_all > 0.80 WINDOW 100 STEP 50 BACKUP PRINT density_report_ACT_D_1_max.log) NOT INSIDE NODRC
}

RULECHECK ACT_D_2 {
@ ACT density inside of dummy block area size up 2.5um, >= 10%
SETLAYER X1 = AA_all INSIDE ((AADUMB OR SRBLK) SIZE BY 2.5)
OUTLAYER (DENSITY X1 < 0.10 WINDOW 20 STEP 10 BACKUP PRINT density_report_ACT_D_2.log) NOT INSIDE NODRC
}
RULECHECK ACT_D_3 {
@ ACT density gradienct <= 20%
  SETLAYER X = DENSITY AA_all >= 0 GRADIENT > 0.2 ABSOLUTE BACKUP INSIDE OF LAYER density_checkarea PRINT density_report_ACT_D_3.log
  OUTLAYER ((((X NOT FUTR) NOT GRID) NOT SRINGBLK) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK ACT_D_4_min {
@ Global ACT density for fully chip (including dummy ACT) >= 25%
@ <= 75%
OUTLAYER (DENSITY AA_all < 0.25 PRINT density_report_ACT_D_4_min.log) NOT INSIDE NODRC
}
RULECHECK ACT_D_4_max {
@ Global ACT density for fully chip (including dummy ACT) >= 25%
@ <= 75%
OUTLAYER (DENSITY AA_all > 0.75 PRINT density_report_ACT_D_4_max.log) NOT INSIDE NODRC
} 
VERBATIM {
#ENDIF
}
RULECHECK ACT_R_1 {
@ ACT must be fully covered by (NP OR PP), except NW1 resistor region
OUTLAYER (AA NOT (SDN OR SDP)) NOT INTERACT NW1res
}

#//==================================
#//  NW1 -  N-Well  DRC
#//==================================

GROUP GNW1 NW1_?

SETLAYER NW_RE = NW NOT OUTSIDE EDGE NW1res
SETLAYER LVNW_RE = NW_RE COIN EDGE LVNW
SETLAYER MVNW_RE = NW_RE COIN EDGE MVNW
SETLAYER HVNW_RE = NW_RE COIN EDGE HVNW

SETLAYER NW_RES = NW AND NW1res

RULECHECK NW1_W_1 {
@ NW1 width >= 0. 47um
OUTLAYER (INT NW < 0.47 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}


RULECHECK NW1_S_1 {
@ Space between NW1s >= 0. 47um
OUTLAYER ((EXT LVNW0 < 0.47 ABUT<90 SINGULAR REGION) NOT NW_RES) NOT INSIDE NODRC
}

RULECHECK NW1_S_2 {
@ Space between 0.9/1.2V NW1s at different nets >= 1.0um
OUTLAYER ((EXT LVNW0 < 1.0 ABUT<90 SINGULAR REGION NOT CONNECTED) NOT NW_RES) NOT INSIDE NODRC
OUTLAYER ((EXT MVNW0 < 1.0 ABUT<90 SINGULAR REGION NOT CONNECTED) NOT NW_RES) NOT INSIDE NODRC
OUTLAYER ((EXT HVNW0 < 1.0 ABUT<90 SINGULAR REGION NOT CONNECTED) NOT NW_RES) NOT INSIDE NODRC
OUTLAYER (EXT LVNW_RE LVNW < 1.0 REGION) NOT INSIDE NODRC
}

RULECHECK NW1_S_3 {
@ Space between 0.9/1.2V NW1 and 1.8/2.5/3.3V NW1 at different nets. >= 1.20um
OUTLAYER (EXT LVNW0 HVNW0 < 1.2  ABUT<90 SINGULAR REGION NOT CONNECTED) NOT INSIDE NODRC
OUTLAYER (EXT LVNW0 MVNW0 < 1.2  ABUT<90 SINGULAR REGION NOT CONNECTED) NOT INSIDE NODRC

OUTLAYER (EXT LVNW_RE MVNW < 1.2 ABUT<90 REGION) NOT INSIDE NODRC
OUTLAYER (EXT LVNW_RE HVNW < 1.2 ABUT<90 REGION) NOT INSIDE NODRC
OUTLAYER (EXT MVNW_RE LVNW < 1.2 ABUT<90 REGION) NOT INSIDE NODRC
OUTLAYER (EXT HVNW_RE LVNW < 1.2 ABUT<90 REGION) NOT INSIDE NODRC
}
RULECHECK NW1_S_4 {
@ Space between 1.8/2.5/3.3V NW1s at same nets. >= 0.47um
OUTLAYER ((EXT MVNW0 < 0.47 ABUT<90 SINGULAR REGION CONNECTED) NOT INSIDE NW_RES) NOT INSIDE NODRC
OUTLAYER ((EXT HVNW0 < 0.47 ABUT<90 SINGULAR REGION CONNECTED) NOT INSIDE NW_RES) NOT INSIDE NODRC
OUTLAYER (EXT MVNW0 HVNW0 < 0.47 ABUT<90 SINGULAR REGION CONNECTED) NOT INSIDE NODRC
}

RULECHECK NW1_S_5 {
@ Space between 1.8/2.5/3.3V NW1s at different nets. >= 1.2 um
OUTLAYER ((EXT MVNW0 < 1.2 ABUT<90 SINGULAR REGION NOT CONNECTED) NOT NW_RES) NOT INSIDE NODRC
OUTLAYER ((EXT HVNW0 < 1.2 ABUT<90 SINGULAR REGION NOT CONNECTED) NOT NW_RES) NOT INSIDE NODRC
OUTLAYER (EXT MVNW0 HVNW0 < 1.2 ABUT<90 SINGULAR REGION NOT CONNECTED) NOT INSIDE NODRC

OUTLAYER (EXT MVNW_RE MVNW < 1.2 ABUT<90 REGION) NOT INSIDE NODRC
OUTLAYER (EXT HVNW_RE HVNW < 1.2 ABUT<90 REGION) NOT INSIDE NODRC
OUTLAYER (EXT MVNW_RE HVNW < 1.2 ABUT<90 REGION) NOT INSIDE NODRC
OUTLAYER (EXT HVNW_RE MVNW < 1.2 ABUT<90 REGION) NOT INSIDE NODRC
}

RULECHECK NW1_A_1 {
@ NW1 area >= 0.30um2
OUTLAYER (AREA NW < 0.3) NOT INSIDE NODRC
}

RULECHECK NW1_A_2 {
@ Enclosed area >= 0.3um2
OUTLAYER (AREA ((HOLES NW INNER) NOT NW) < 0.3) NOT INSIDE NODRC
}

RULECHECK NW1_R_1 {
@ Floating NW1 is not allowed.
OUTLAYER ( NW NOT INTERACT (NTAP ENCLOSE CT)) NOT INSIDE NODRC
}

#//==========================================
#//  PSUB - Native NMOS blocked implant DRC
#//==========================================

GROUP GPSUB PSUB_?


RULECHECK PSUB_W_1 {
@ PSUB width >= 0.47um
OUTLAYER (INT PSUB < 0.47 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
RULECHECK PSUB_W_2a {
@ 0.9/1.2/1.8/2.5/3.3V native NMOS channel width >= 0.50um
@ 0.9/1.2/1.8/2.5/3.3V native NMOS channel width <= 100um
SETLAYER X = LENGTH GATE_W < 0.5
SETLAYER Y = LENGTH GATE_W > 100
OUTLAYER ((EXPAND EDGE X INSIDE BY 0.005) AND PSUB) NOT INSIDE NODRC
OUTLAYER ((EXPAND EDGE Y INSIDE BY 0.005) AND PSUB) NOT INSIDE NODRC
}

RULECHECK PSUB_W_3a {
@ 0.9/1.2V native NMOS channel length >= 0.70um
@ 0.9/1.2V native NMOS channel length <= 100um
SETLAYER X = (PBPO INSIDE EDGE PBAA) NOT INSIDE EDGE (OR DG TG)
SETLAYER Y = LENGTH GATE_core_L > 100
OUTLAYER (INT X < 0.70 ABUT<90 OPPOSITE REGION) NOT INSIDE NODRC
OUTLAYER ((EXPAND EDGE Y INSIDE BY 0.005) AND PSUB) NOT INSIDE NODRC
}
RULECHECK PSUB_W_3b {
@ 1.8V native NMOS channel length >= 0.8um
@ 1.8V native NMOS channel length <= 20um
SETLAYER X = PBPO INSIDE EDGE (PBAA AND DG)
SETLAYER Y = LENGTH GATE_io1_L > 20
OUTLAYER (INT X < 0.80 ABUT<90 OPPOSITE REGION) NOT INSIDE NODRC
OUTLAYER ((EXPAND EDGE Y INSIDE BY 0.005) AND PSUB) NOT INSIDE NODRC
}

VERBATIM {
#IFDEF IO 1825
}
RULECHECK PSUB_W_3c {
@ 2.5V (or overdrive to 3.3V and underdrive to 1.8V) native NMOS channel length >= 1.0um
SETLAYER X = PBPO INSIDE EDGE (PBAA AND TG) 
OUTLAYER (INT X < 1.0 ABUT<90 OPPOSITE REGION) NOT INSIDE NODRC
}
VERBATIM {
#ENDIF
}


VERBATIM {
#IFDEF IO 1833
}
RULECHECK PSUB_W_3d {
@ 3.3V native NMOS channel length >= 1.2um
SETLAYER X = PBPO INSIDE EDGE (PBAA AND TG)
OUTLAYER (INT X < 1.2 ABUT<90 OPPOSITE REGION) NOT INSIDE NODRC
}
VERBATIM {
#ENDIF
}

RULECHECK PSUB_S_1 {
@ Space between two PSUBs >= 0.47um
OUTLAYER (EXT PSUB < 0.47 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK PSUB_S_2 {
@ Space between PSUB and native MOS ACT >= 0.36um
OUTLAYER (EXT PSUB MOS < 0.36 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
OUTLAYER (EXT PSUB AA_LDMOS < 0.36 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK PSUB_S_3 {
@ Space between PSUB and NW1 >= 1.15um
OUTLAYER (EXT PSUB NW < 1.15 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK PSUB_EN_1 {
@ Native NMOS ACT enclosure by PSUB = 0.285um
SETLAYER X = SIZE PBMOS BY 0.285
SETLAYER Y = PSUB INTERACT PBMOS
OUTLAYER (XOR X Y) NOT INSIDE NODRC
}

RULECHECK PSUB_EX_1 {
@ Extension of native NMOS poly GATE outside of ACT
@ DRC doesn't flag INDALL covered regions. >= 0.32um
OUTLAYER ((ENC PBAA PBPO < 0.32 ABUT<90 REGION OPPOSITE) NOT INSIDE INDALL) NOT INSIDE NODRC
}

RULECHECK PSUB_R_1 {
@ PSUB inside, overlapping with, or crossing over a DNW area is not allowed
OUTLAYER (PSUB AND DNW) NOT INSIDE NODRC
OUTLAYER (PSUB COINCIDENT OUTSIDE EDGE DNW) NOT INSIDE EDGE NODRC
}

RULECHECK PSUB_R_2 {
@ It is not allowed PSUB overlap PP ,DRC waive check INDALL covered region, and P+ pickup can be waived.
SETLAYER X = (SDP AND PSUB) NOT INSIDE INDALL
SETLAYER Y = ((AA OR PO) INTERACT GATE) AND PSUB
OUTLAYER (X INTERACT Y) NOT INSIDE NODRC
}

RULECHECK PSUB_R_3 {
@ Only one ACT pattern is allowed in o PSUB region, except for NMOS capacitors
OUTLAYER (PSUB INTERACT (AA NOT INTERACT INDALL) > 1) NOT INSIDE NODRC
}

RULECHECK PSUB_A_1 {
@ PSUB area >= 0.60um2
OUTLAYER (AREA PSUB < 0.6) NOT INSIDE NODRC
}
RULECHECK PSUB_A_2 {
@ Enclosed area >= 0.60um2
OUTLAYER (AREA ((HOLES PSUB INNER) NOT PSUB) < 0.60) NOT INSIDE NODRC
}

VERBATIM {

//===============================
//   NVT3: High Vt NMOS Implant
//===============================

GROUP GNVT3 NVT3_?

NVT3_W_1 {
@ NVT3 width. Single-point-interaction is allowed. >= 0.18um
  (INT HVTN < 0.18 ABUT<90 REGION) NOT INSIDE NODRC
}

NVT3_S_1 {
@ Space between two NVT3s >= 0.18um
  (EXT HVTN < 0.18 ABUT<90 OPPOSITE REGION) NOT INSIDE NODRC
}

NVT3_S_2 {
@ Space between NVT3 and GATE along source/drain direction >= 0.180um
  X = (PO INSIDE EDGE (AA NOT HVTN)) COIN EDGE GATE
  (EXT X HVTN < 0.180 ABUT<90 REGION OPPOSITE) NOT INSIDE NODRC
}

NVT3_S_3 {
@ Space between NVT3 and ACT along GATE poly direction, excluding SRAM region >= 0.15um
  X1 = NACT TOUCH EDGE (AA INSIDE EDGE PO)
  X2 = PACT TOUCH EDGE (AA INSIDE EDGE PO)
  X = X1 OR EDGE X2
  ((EXT X HVTN < 0.15 ABUT<90 REGION OPPOSITE) NOT INSIDE SRAMALL) NOT INSIDE NODRC
}

NVT3_S_4 {
@ NVT3 space to non-silicide ACT >=0.21
 X = (AA AND SAB) NOT INSIDE HVTN
 (EXT X HVTN < 0.21 ABUT<90 REGION OPPOSITE) NOT INSIDE NODRC
}

NVT3_EX_1 {
@ NVT3 extension outside of GATE along source/drain direction >= 0.18um
  X = (PO INSIDE EDGE (NACT AND HVTN)) COIN EDGE GATE
  Y = EXPAND EDGE X OUTSIDE BY 0.18
  (Y NOT HVTN) NOT INSIDE NODRC
}

NVT3_EX_2 {
@ NVT3 extension outside of MOS ACT along GATE poly length direction. >= 0.15um
  X = (NACT AND HVTN) TOUCH EDGE GATE 
  Y = ENC X HVTN < 0.15 ABUT<90 REGION OPPOSITE
  (Y NOT INSIDE SRAMALL) NOT INSIDE NODRC
 }

NVT3_A_1 {
@ NVT3 area >= 0.18um2
  ((AREA HVTN < 0.18) NOT INSIDE SRAMALL) NOT INSIDE NODRC
}

NVT3_A_2 {
@ NVT3 Enclosed area >= 0.18um2
  (AREA ((HOLES HVTN INNER) NOT HVTN) < 0.18) NOT INSIDE NODRC
}

NVT3_R_1 {
@ It is not allowed NVT3 overlap with PSUB, P+ active ACT(exclude pick-up ACT), NVT1, DGOX or TGOX
  (AND HVTN PSUB) NOT INSIDE NODRC
  (AND HVTN (PACT NOT (NTAP OR PTAP))) NOT INSIDE NODRC
  (AND HVTN LVTN) NOT INSIDE NODRC
  (AND HVTN DG) NOT INSIDE NODRC
  (AND HVTN TG) NOT INSIDE NODRC
}


//===============================
//   PVT3: High Vt PMOS Implant
//===============================

GROUP GPVT3 PVT3_?

PVT3_W_1 {
@ PVT3 width. Single-point-interaction is allowed. >= 0.18um
  (INT HVTP < 0.18 ABUT<90 REGION) NOT INSIDE NODRC
}

PVT3_S_1 {
@ Space between two PVT3s >= 0.18um
  (EXT HVTP < 0.18 ABUT<90 OPPOSITE REGION) NOT INSIDE NODRC
}

PVT3_S_2 {
@ Space between PVT3 and GATE along source/drain direction >= 0.180um
  X = (PO INSIDE EDGE AA) COIN EDGE GATE
  (EXT X HVTP < 0.180 ABUT<90 REGION OPPOSITE) NOT INSIDE NODRC
}

PVT3_S_3 {
@ Space between PVT3 and ACT along poly length direction, excluding SRAM region >= 0.15um
  X1 = PACT TOUCH EDGE (AA INSIDE EDGE PO)
  X2 = NACT TOUCH EDGE (AA INSIDE EDGE PO)
  X = X1 OR EDGE X2
  ((EXT X HVTP < 0.15 ABUT<90 REGION OPPOSITE) NOT INSIDE SRAMALL)NOT INSIDE NODRC
  }

PVT3_S_4 {
@ PVT3 space to non-silicide ACT >=0.21
 X = (AA AND SAB) NOT INSIDE HVTP
 (EXT X HVTP < 0.21 ABUT<90 REGION OPPOSITE) NOT INSIDE NODRC
}

PVT3_EX_1 {
@ PVT3 extension outside of GATE along source/drain direction >= 0.180um
  X = (PO INSIDE EDGE (PACT AND HVTP)) COIN EDGE GATE
  Y = EXPAND EDGE X OUTSIDE BY 0.180
  (Y NOT HVTP) NOT INSIDE NODRC
}

PVT3_EX_2 {
@ PVT3 extension outside of ACT along GATE poly length direction. >= 0.15um
  X = (PACT AND HVTP) TOUCH EDGE GATE
  Y = ENC X HVTP < 0.15 ABUT<90 REGION OPPOSITE
  (Y NOT INSIDE SRAMALL) NOT INSIDE NODRC
}

PVT3_A_1 {
@ PVT3 area >= 0.18um2
  ((AREA HVTP < 0.18) NOT INSIDE SRAMALL) NOT INSIDE NODRC
}

PVT3_A_2 {
@ PVT3 Enclosed area >= 0.18um2
  (AREA ((HOLES HVTP INNER) NOT HVTP)< 0.18) NOT INSIDE NODRC
}

PVT3_R_1 {
@ It is not allowed PVT3 overlap with PSUB, N+ active ACT(exclude pick-up ACT), PVT1, DGOX or TGOX 
  (AND HVTP PSUB) NOT INSIDE NODRC
  (AND HVTP (NACT NOT (NTAP OR PTAP))) NOT INSIDE NODRC
  (AND HVTP LVTP) NOT INSIDE NODRC
  (AND HVTP DG) NOT INSIDE NODRC
  (AND HVTP TG) NOT INSIDE NODRC
}

//===========================================
//  NVT1: low Vt NMOS design minima 
//===========================================

GROUP GNVT1 NVT1_?

NVT1_W_1 {
@ NVT1 width. Single-point-interaction is allowed. >= 0.18um
  (INT LVTN < 0.18 ABUT<90 REGION) NOT INSIDE NODRC
}

NVT1_S_1 {
@ Space between two NVT1s >= 0.18um
  (EXT LVTN < 0.18 ABUT<90 OPPOSITE REGION) NOT INSIDE NODRC
}

NVT1_S_2 {
@ Space between NVT1 and GATE along source/drain direction >= 0.180um
  X1 = PO INSIDE EDGE (NACT NOT LVTN)
  X2 = PO INSIDE EDGE (PACT NOT LVTN)
  X = X1 OR EDGE X2
  (EXT LVTN X < 0.180 ABUT<90 REGION OPPOSITE) NOT INSIDE NODRC
}

NVT1_S_3 {
@ Space between NVT1 and ACT along poly length direction. >= 0.15um
  X1 = NACT TOUCH EDGE (AA INSIDE EDGE PO)
  X2 = PACT TOUCH EDGE (AA INSIDE EDGE PO)
  X = X1 OR EDGE X2
  (EXT X LVTN < 0.15 ABUT<90 REGION OPPOSITE) NOT INSIDE NODRC
}

NVT1_S_4 {
@ NVT1 space to non-silicide ACT >=0.21
  A = LVTN INSIDE EDGE GATE
  B = LVTN OUTSIDE EDGE GATE
 X = (AA AND SAB) NOT INSIDE LVTN
 (EXT X LVTN < 0.21 ABUT<90 REGION OPPOSITE) NOT INSIDE NODRC
}

NVT1_EX_1 {
@ NVT1 extension outside of GATE along source/drain direction >= 0.180um
  X = PO INSIDE EDGE (NACT AND LVTN)
  Y = EXPAND EDGE X OUTSIDE BY 0.180
  (Y NOT LVTN) NOT INSIDE NODRC
}

NVT1_EX_2 {
@ NVT1 extension outside of ACT along GATE poly length direction. >= 0.15um
  X = (NACT AND LVTN) TOUCH EDGE GATE
  (ENC X LVTN < 0.15 ABUT<90 REGION OPPOSITE) NOT INSIDE NODRC
}

NVT1_A_1 {
@ NVT1 area >= 0.18um2
  (AREA LVTN < 0.18) NOT INSIDE NODRC
}
NVT1_A_2 {
@ NVT1 enclosed area >= 0.18um2
  (AREA ((HOLES LVTN INNER) NOT LVTN)< 0.18) NOT INSIDE NODRC
}

NVT1_R_1 {
@ It is not allowed NVT1 overlap with PSUB, P+ active ACT(exclude pick-up ACT),DGOX or TGOX 
  (AND LVTN PSUB) NOT INSIDE NODRC
  (AND LVTN (PACT NOT (NTAP OR PTAP))) NOT INSIDE NODRC
  (AND LVTN DG) NOT INSIDE NODRC
  (AND LVTN TG) NOT INSIDE NODRC
}


//============================================
//  PVT1:  low Vt PMOS design minima 
//============================================

GROUP GPVT1 PVT1_?

PVT1_W_1 {
@ PVT1 width >= 0.18um
  (INT LVTP < 0.18 ABUT<90 REGION) NOT INSIDE NODRC
}
PVT1_S_1 {
@ Space between two PVT1s >= 0.62um
  (EXT LVTP < 0.62 ABUT<90 OPPOSITE REGION) NOT INSIDE NODRC
}

PVT1_S_2 {
@ Space between PVT1 and GATE of along source/drain direction >= 0.268um
  X1 = PO INSIDE EDGE (PACT NOT LVTP)
  X2 = PO INSIDE EDGE (NACT NOT LVTP)
  X = X1 OR EDGE X2
  (EXT LVTP X < 0.268 ABUT<90 REGION OPPOSITE) NOT INSIDE NODRC
}

PVT1_S_3 {
@ Space between PVT1 and ACT along poly length direction. >= 0.18um
  X1 = PACT TOUCH EDGE (AA INSIDE EDGE PO)
  X2 = NACT TOUCH EDGE (AA INSIDE EDGE PO)
  X = X1 OR EDGE X2
  (EXT X LVTP < 0.18 ABUT<90  REGION OPPOSITE) NOT INSIDE NODRC
}


PVT1_EX_1 {
@ PVT1 extension outside of GATE along source/drain direction >= 0.268um
  X = PO INSIDE EDGE (PACT AND LVTP)
  Y = EXPAND EDGE X OUTSIDE BY 0.268
  (Y NOT LVTP) NOT INSIDE NODRC
}

PVT1_EX_2 {
@ PVT1 extension outside of ACT along GATE poly length direction. >= 0.18um
  X = (PACT AND LVTP) TOUCH EDGE GATE
  (ENC X LVTP < 0.18 ABUT<90 REGION OPPOSITE) NOT INSIDE NODRC
}


PVT1_A_1 {
@ PVT1 area >= 0.18um2
  (AREA LVTP < 0.18) NOT INSIDE NODRC
}
PVT1_A_2 {
@ PVT1 enclosed area >= 0.18um2
  (AREA ((HOLES LVTP INNER) NOT LVTP)< 0.18) NOT INSIDE NODRC
}

PVT1_R_1 {
@ PVT1 overlap with PSUB is not allowed
  (AND LVTP PSUB) NOT INSIDE NODRC
}


//===============================
// ULLD-- Ultra Low Leakage(ULLD)  
//===============================

GROUP GULLD ULLD_?

ULLD_W_1 {
@ ULLD width single-point-interaction is allowed. >= 0.18
  (INT UVT <0.18 ABUT<90 REGION) NOT INSIDE NODRC 
}

ULLD_S_1 {
@ Space between two ULLDs >= 0.18um
  (EXT UVT < 0.18 ABUT<90 REGION) NOT INSIDE NODRC
}

ULLD_S_2 {
@ Space between ULLD and ACT >= 0.02um
  (EXT UVT AA < 0.02 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}

ULLD_S_4 {
@ Space between ULLD and NACT >=0.055um.
  (EXT UVT NACT < 0.055 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}

ULLD_S_5 {
@ Space between ULLD and GATE along source/drain direction >= 0.18 um.
  LAY_POLY = COPY POLYi
  ACT = PACT OR NACT
  X1 = LAY_POLY INSIDE EDGE ACT
  (EXT X1 UVT < 0.18 ABUT < 90 OPPOSITE REGION) NOT INSIDE NODRC
}

ULLD_S_6 {
@ Space between ULLD and ACT along GATE poly length direction is >= 0.15um.
  LAY_POLY = COPY POLYi
  ACT = PACT OR NACT
  X1 = ACT INSIDE EDGE LAY_POLY
  X2 = AA TOUCH EDGE X1
  (EXT X2 UVT < 0.15 ABUT < 90 OPPOSITE REGION) NOT INSIDE NODRC
}

ULLD_EX_1 {
@ ULLD extention outside of ACT is >= 0.02um
  (ENC AA UVT < 0.02 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}

ULLD_EX_2 {
@ ULLD extention GATE along source/drain direction >= 0.18um.
  LAY_POLY = COPY POLYi
  ACT = PACT OR NACT
  X1 = LAY_POLY INSIDE EDGE ACT
  (ENC X1 UVT < 0.18 ABUT < 90 OPPOSITE REGION) NOT INSIDE NODRC
}

ULLD_EX_3a {
@ ULLD extention outside of N+ ACT along GATE poly length direction >= 0.15um.
@ if the distance to the related poly is less than or qual to 0.20um.
  LAY_POLY = COPY POLYi
  ACT = PACT OR NACT
  X1 = ACT INSIDE EDGE LAY_POLY
  X2 = AA TOUCH EDGE X1
  X3 = EXPAND EDGE X1 OUTSIDE BY 0.001 EXTEND BY 0.20
  X4 = X2 COIN EDGE X3
 (ENC X4 UVT < 0.16 ABUT < 90 OPPOSITE REGION) NOT INSIDE NODRC
}

ULLD_EX_3b {
@ ULLD extention outside of N+ ACT along GATE poly length direction >= 0.12um.
@ if the distance to the related poly is larger than 0.20um.
  LAY_POLY = COPY POLYi
  ACT = PACT OR NACT
  X1 = ACT INSIDE EDGE LAY_POLY
  X2 = AA TOUCH EDGE X1
  X3 = EXPAND EDGE X1 OUTSIDE BY 0.001 EXTEND BY 0.20
  X4 = X2 NOT COIN EDGE X3
  (ENC X4 UVT < 0.12 ABUT < 90 OPPOSITE REGION) NOT INSIDE NODRC
}

ULLD_A_1 {
@ULLD area >= 0.18um2
(AREA UVT < 0.18) NOT INSIDE NODRC 
}

ULLD_A_2 {
@ULLD area >= 0.18um2
(AREA (HOLES UVT INNER) < 0.18) NOT INSIDE NODRC 
}

ULLD_R_1 {
@ It is not alloweded ULLD overlap with (PSUB, DGOX OR TGOX)
 (UVT AND PSUB) NOT INSIDE NODRC 
 (UVT AND DG) NOT INSIDE NODRC 
 (UVT AND TG) NOT INSIDE NODRC 
}

ULLD_R_2 {
@ ULLD must interact NVT3 or PVT3
 (UVT NOT INTERACT HVTN) NOT INSIDE NODRC 
 (UVT NOT INTERACT HVTP) NOT INSIDE NODRC 
}

//============================
//   DGOX - Dual Gate DRC
//============================


GROUP DGOX DGOX_?

DGOX_W_1 {
@ DGOX width >= 0.47 um
  (INT DG < 0.47 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

DGOX_S_1 {
@ Space between two DGOXs >= 0.47um
  (EXT DG < 0.47 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

DGOX_S_2 {
@ Space between DGOX and MOS ACT, overlap is not allowed  >= 0.25um
  (EXT DG MOS < 0.25 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
  (EXT DG AA_LDMOS < 0.25 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

DGOX_S_3 {
@ Space between DGOX and GATE, overlap is not allowed >= 0.32um
  (EXT DG GATE < 0.32 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

DGOX_S_4 {
@ Space between DGOX and NW1 >= 0.47um
  (EXT NW DG > 0 < 0.47 ABUT>0<90 SINGULAR REGION) NOT INSIDE NODRC
}

DGOX_S_5 {
@ Space between DGOX and PSUB >= 0.47um
  (EXT PSUB DG > 0 < 0.47 ABUT>0<90 SINGULAR REGION) NOT INSIDE NODRC
}

DGOX_EN_1 {
@ Enclosure of ACT by DGOX(Except pick-up ACT) >= 0.25um
  (ENC (AA NOT (NTAP OR PTAP)) DG < 0.25 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

DGOX_EN_2 {
@ Enclosure of ACT by DGOX along GATE poly direction >= 0.25um
  X = MOS TOUCH EDGE (GATE INSIDE DG)
  ENC X DG < 0.25 ABUT<90 REGION
}

DGOX_EN_3 {
@ Enclosure of GATE by DGOX, along source/drain direction >= 0.32um
  (ENC GATE_W DG < 0.32 ABUT<90  REGION OPPOSITE) NOT INSIDE NODRC
}

DGOX_EX_1 {
@ NW1 extention to DGOX, Extention = 0 is allowed >= 0.47um
  (ENC DG NW > 0 < 0.47 ABUT>0<90 SINGULAR REGION) NOT INSIDE NODRC
}

DGOX_EX_2 {
@ DGOX extention on NW1, Extention = 0 is allowed  >= 0.47um
  (ENC NW DG > 0 < 0.47 ABUT>0<90 SINGULAR REGION) NOT INSIDE NODRC
}

DGOX_EX_3 {
@ DGOX extention on PSUB, Extention = 0 is allowed  >= 0.47um
  (ENC PSUB DG > 0 < 0.47 ABUT>0<90 SINGULAR REGION) NOT INSIDE NODRC
}

DGOX_O_1 {
@ Overlap of DGOX and NW1, Overlap = 0 is allowed  >= 0.47um
  (INT DG NW > 0 < 0.47 ABUT>0<90 SINGULAR REGION) NOT INSIDE NODRC
}

DGOX_O_2 {
@ Overlap of DGOX and PSUB, Overlap = 0 is allowed >= 0.47um
  (INT DG PSUB > 0 < 0.47 ABUT>0<90 SINGULAR REGION) NOT INSIDE NODRC
}


//==========================
//   TGOX - Triple Gate DRC
//==========================

GROUP GTGOX TGOX_? 

TGOX_W_1 {
@ TGOX width >= 0.47um
  (INT TG < 0.47 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
TGOX_S_1 { 
@ Space between two TGOXs >= 0.47um
  (EXT TG < 0.47 ABUT<90 SINGULAR REGION ) NOT INSIDE NODRC
} 
TGOX_S_2 { 
@ Space between TGOX and MOS ACT >= 0.25um.
  (EXT TG MOS < 0.25 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

TGOX_S_3 {
@ Space between TGOX and GATE >= 0.32um
  (EXT GATE TG < 0.32 ABUT<90  REGION) NOT INSIDE NODRC 
}

TGOX_S_4 {
@ Space between TGOX and NW1 >= 0.47um
  (EXT NW TG > 0 < 0.46 ABUT>0<90 SINGULAR REGION) NOT INSIDE NODRC
}

TGOX_S_5 {
@ Space between TGOX and PSUB >= 0.47um
  (EXT TG PSUB < 0.47 ABUT<90 SINGULAR REGION ) NOT INSIDE NODRC
}

TGOX_S_6 {
@ Space between TGOX and DGOX >= 0.47um
  (EXT TG DG < 0.47 ABUT<90 SINGULAR REGION INSIDE ALSO ) NOT INSIDE NODRC
}

TGOX_EN_1 { 
@ Enclosure of ACT by TGOX(except pickup ACT) >= 0.25um 
  ENC MOS TG < 0.25 ABUT<90 SINGULAR REGION
  X = (LDMOSSTI AND LDMOS) INTERACT PO
  Y = AA TOUCH X
  (ENC Y TG < 0.25 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
} 

TGOX_EN_2 { 
@ Enclosure of GATE along GATE poly direction >= 0.25um
  X = MOS TOUCH EDGE (GATE INSIDE TG)
  (ENC X TG < 0.25 ABUT<90 REGION) NOT INSIDE NODRC
}
TGOX_EN_3 {
@ Enclosure of GATE by TGOX, along source/drain direction >= 0.32um
  (ENC GATE_W TG < 0.32 ABUT<90  REGION OPPOSITE ) NOT INSIDE NODRC 
}
TGOX_EX_1 {
@ NW1 extention on TGOX, Extention = 0 is allowed >= 0.47um
  (ENC TG NW > 0 < 0.47 ABUT>0<90 SINGULAR REGION) NOT INSIDE NODRC
}
TGOX_EX_2 {
@ TGOX extension on NW, Extention = 0 is allowed >= 0.47um
  (ENC NW TG > 0 < 0.47 ABUT>0<90 SINGULAR REGION) NOT INSIDE NODRC
}

TGOX_EX_3 {
@ TGOX extension of PSUB, Extention = 0 is allowed >= 0.47um
  (ENC PSUB TG > 0 < 0.47 ABUT>0<90 SINGULAR REGION) NOT INSIDE NODRC
}

TGOX_O_1 {
@ Overlap of TGOX and NW1, overlap = 0 is allowed >= 0.47um
  (INT TG NW > 0 < 0.47 ABUT>0<90 SINGULAR REGION) NOT INSIDE NODRC
}

TGOX_O_2 {
@ Overlap of TGOX and PSUB, overlap = 0 is allowed >= 0.47um
  (INT TG PSUB > 0 < 0.47 ABUT>0<90 SINGULAR REGION) NOT INSIDE NODRC
}
		

}


#//==========================
#//    PO - Poly Rule DRC
#//==========================

GROUP GPO PO_?

RULECHECK PO_W_1 {
@ PO width
OUTLAYER (INT PO <0.06 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
RULECHECK PO_W_2a {
@ Channel length for 0.9/1.2V NMOS/PMOS transistors >= 0.06um
SETLAYER X = PO INSIDE EDGE (AA NOT (DG OR TG))
OUTLAYER (INT X < 0.06 ABUT<90 OPPOSITE REGION) NOT INSIDE NODRC
}
RULECHECK PO_W_2b {
@ Channel length for 1.8V NMOS/PMOS transistors >= 0.20um
SETLAYER X = PO INSIDE EDGE (AA AND DG )
SETLAYER Y = INT X < 0.20  ABUT<90 OPPOSITE REGION
OUTLAYER (Y NOT INSIDE SRAMALL) NOT INSIDE NODRC
}

VERBATIM {
#IFDEF IO 1825
}
RULECHECK PO_W_2c  {
@ Channel length for 2.5V NMOS/PMOS transistors >= 0.28um
SETLAYER X = PO INSIDE EDGE ((AA AND TG) NOT INTERACT UD)
SETLAYER Y = INT X < 0.28  ABUT<90 OPPOSITE REGION
OUTLAYER (Y NOT INSIDE SRAMALL) NOT INSIDE NODRC
}
VERBATIM {
#ENDIF
}


VERBATIM {
#IFDEF IO 1833
}

RULECHECK PO_W_2d {
@ Min Channel length for 3.3V NMOS transistors is 0.38
@ Min Channel length for 3.3V PMOS transistors is 0.38
SETLAYER X = (PO AND SDN) INSIDE EDGE (AA AND TG)  
SETLAYER Y = INT X < 0.38 ABUT<90 OPPOSITE REGION
OUTLAYER (Y NOT INSIDE SRAMALL) NOT INSIDE NODRC
SETLAYER X1 = (PO AND SDP) INSIDE EDGE (AA AND TG)  
SETLAYER Y1 = INT X1 < 0.38 ABUT<90 OPPOSITE REGION
OUTLAYER (Y1 NOT INSIDE SRAMALL) NOT INSIDE NODRC
}
VERBATIM {
#ENDIF
}



VERBATIM {
#IFDEF IO 1825
}  
RULECHECK PO_W_2f {
@ Channel length for 2.5V NMOS/PMOS transistors (over drive to 3.3V and 4.1V) >= 0.50(NMOS)um
@ >= 0.40(PMOS)um

SETLAYER X = PO INSIDE EDGE ((NACT AND TG) AND OD)
SETLAYER Y = PO INSIDE EDGE ((PACT AND TG) AND OD)
SETLAYER Z1 = INT X < 0.50  ABUT<90 OPPOSITE REGION
SETLAYER Z2 = INT Y < 0.40  ABUT<90 OPPOSITE REGION
OUTLAYER (Z1 NOT INSIDE SRAMALL) NOT INSIDE NODRC
OUTLAYER (Z2 NOT INSIDE SRAMALL) NOT INSIDE NODRC
}
RULECHECK PO_W_2e {
@ Channel length for 2.5V NMOS/PMOS transistors (under drive to 1.8V) >= 0.22um
SETLAYER X = PO INSIDE EDGE ((AA AND TG) AND UD)
SETLAYER Y = INT X < 0.22 ABUT<90 OPPOSITE REGION
OUTLAYER (Y NOT INSIDE SRAMALL) NOT INSIDE NODRC
}
VERBATIM {
#ENDIF
}
RULECHECK PO_W_3 {
@ Width of 45 degree PO >= 0.18um
SETLAYER PO_CHECK = PO NOT INSIDE (AA OR AADUM)
SETLAYER X = ANGLE PO_CHECK == 45
OUTLAYER (INT X < 0.18 ABUT<90 REGION) NOT INSIDE NODRC
}


RULECHECK PO_S_1 {
@ Space between two POs
@ DRC waive check the INDALL covered region. >= 0.12um
SETLAYER X = EXT PO < 0.12 ABUT<90 SINGULAR REGION
OUTLAYER (X NOT INSIDE (SRAMALL OR INDALL)) NOT INSIDE NODRC
}
RULECHECK PO_S_2 {
@ Space between two POs when one or both PO width is >= 0.13um, and the run length of two POs is >= 0.18um. >= 0.18um
SETLAYER PO_W = WITH WIDTH PO >= 0.13
SETLAYER PO_S = EXT PO_W PO < 0.18 OPPOSITE REGION PARA ONLY
SETLAYER PO_LS = LENGTH PO_S >= 0.18
OUTLAYER (PO_S WITH EDGE PO_LS) NOT INSIDE EDGE NODRC

}

RULECHECK PO_S_3 {
@ Space between two POs on ACT
@ DRC waive check the INDALL covered region. >= 0.13um
SETLAYER X = (AA AND PO) COIN EDGE PO
SETLAYER Y = EXT X < 0.13 ABUT < 90 REGION
OUTLAYER (Y NOT INSIDE INDALL) NOT INSIDE NODRC
}

LAYER MAP 999 DATATYPE 1111 4321
LAYER EMPTY 4321
SETLAYER PO_EMPTY = EMPTY OR (PO AND AA)
SETLAYER AA_EMPTY = EMPTY OR AA
CONNECT PO_EMPTY AA_EMPTY

VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK PO_S_4_R {
@ Recommended Space between POs on the same ACT
@ DRC waive check if no contacts between two POs, and waive check the INDALL covered region. >= 0.2um
SETLAYER X = EXT PO_EMPTY < 0.2 ABUT<90 SINGULAR REGION CONNECTED
SETLAYER Y = X INTERACT CT
OUTLAYER (Y NOT INSIDE (INDALL OR SRAMALL) ) NOT INSIDE NODRC

}

VERBATIM {
#ENDIF
}

RULECHECK PO_S_5 {
@ Space between POs on the same ACT inside TGOX
@ DRC waive check if no contacts between two POs, and waive check the INDALL covered region. >= 0.24um
SETLAYER X = EXT (PO_EMPTY AND TG) < 0.24 ABUT<90 SINGULAR REGION CONNECTED
SETLAYER Y = X INTERACT CT
OUTLAYER (Y NOT INSIDE (INDALL OR SRAMALL)) NOT INSIDE NODRC
}

RULECHECK PO_S_6 {
@ Space to 45-degree PO, except EFUSEALL and FUSEALL region. >= 0.19um
SETLAYER PO_CHECK = PO NOT INSIDE (OR EFUSEALL AA AADUM)
SETLAYER X = (ANGLE PO_CHECK == 45) NOT INSIDE EDGE EFUSEALL
OUTLAYER (((EXT X (PO NOT INSIDE EFUSEALL) < 0.19 ABUT<90 REGION) NOT INSIDE EFUSEALL) NOT INSIDE FUSEALL) NOT INSIDE NODRC
}


RULECHECK PO_S_7 {
@ GATE space when L-shape ACT and L-shape PO enclosed area is < 0.012um2 >= 0.15um
SETLAYER X = AA_LS OR PO_LS
SETLAYER Y = AREA (HOLES X INNER) < 0.012
SETLAYER Z = GATE INTERACT Y SINGULAR ONLY
OUTLAYER ((EXT Z < 0.15 ABUT<90 REGION) INTERACT Y) NOT INSIDE NODRC
}


VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK PO_S_7a_R {
@ Recommended GATE space when L-shape ACT and L-shape PO enclosed area is < 0.0196um2 >= 0.2um
SETLAYER X = AA_LS OR PO_LS
SETLAYER Y = AREA (HOLES X INNER) < 0.0196
SETLAYER Z = GATE INTERACT Y SINGULAR ONLY
OUTLAYER ((EXT Z < 0.2 ABUT<90 REGION) INTERACT Y) NOT INSIDE NODRC
}

RULECHECK PO_S_8_R {
@ Recommended space of GATE (channel length <= 0.08um) to neighboring poly for thr CDU control <= 1.0
 SETLAYER   X = LENGTH GATE_L <= 0.08
 SETLAYER   Y = GATE INTERACT (EXPAND EDGE X OUTSIDE BY 0.001) 
 OUTLAYER   (EXT GATE Y < 1 ABUT<90 REGION) NOT INSIDE NODRC
}

RULECHECK PO_S_9 {
@ Space between PO dense line end to line (Dh) or PO line to line (Ds) when:
@ 1. PO line end definition: PO width < 0.09um
@ 2. Run length of PO line to line or PO line to end: E1 >= -0.03um
@ 3. Any one edge distance from the corner of the two edges: K1 < 0.14um
@ Any one of Dh or Ds meet this rule value is ok
@ DRC waive check PO small jogs < 0.06um and exclude SRAM region. >= 0.14um
SETLAYER LINE_END = CONVEX EDGE PO ANGLE1 ==90 LENGTH1 >=0.06 ANGLE2  ==90 LENGTH2  >=0.04 WITH LENGTH  < 0.09
SETLAYER LINE_END_SHAPE1 = EXPAND EDGE LINE_END INSIDE BY 0.11
SETLAYER LINE_SIDE1 = (PO COIN EDGE LINE_END_SHAPE1 ) NOT COIN EDGE LINE_END
SETLAYER LINE_END_SHAPE = EXPAND EDGE LINE_END INSIDE BY 0.14
SETLAYER LINE_SIDE = (PO COIN EDGE LINE_END_SHAPE ) NOT COIN EDGE LINE_END
SETLAYER LINE_END_EXP = EXPAND EDGE LINE_END INSIDE BY 0.001 EXTEND BY 0.03
SETLAYER LINE_SIDE_EXP = EXPAND EDGE LINE_SIDE1 INSIDE BY 0.001 EXTEND BY 0.03
SETLAYER LINE_END_1 = LINE_END_EXP TOUCH EDGE LINE_END
SETLAYER LINE_SIDE_1 = LINE_SIDE_EXP TOUCH EDGE LINE_SIDE
SETLAYER E1 = EXT \[LINE_END_1\] PO < 0.14 OPPOSITE PERP ALSO OBTUSE ALSO
SETLAYER E2 = EXT \[LINE_SIDE\] < 0.14 OPPOSITE 
SETLAYER LINE_END_E1 = LINE_END_1 TOUCH EDGE E1
SETLAYER LINE_SIDE_E2 = LINE_SIDE_1 TOUCH EDGE E2
SETLAYER PO_CORNER = INT LINE_END_E1 LINE_SIDE_E2 <= 0.002 ABUT==90 REGION
OUTLAYER ((LINE_END_SHAPE INTERACT PO_CORNER) OUTSIDE SRAMALL) NOT INSIDE NODRC
}
VERBATIM {
#ENDIF
}

RULECHECK PO_S_11 {
@ Space between ACT and PO on STI >= 0.05um
SETLAYER X = EXT AA PO < 0.05 ABUT<90 SINGULAR REGION
OUTLAYER ((X NOT INSIDE (AA OR AADUM)) NOT INSIDE (SRAMALL OR INDALL)) NOT INSIDE NODRC
}

RULECHECK PO_S_12   {
@ Minimum space of PO within SAB >=0.25
 SETLAYER   PO_SAB = PO NOT OUTSIDE SAB
 OUTLAYER  (EXT PO_SAB < 0.25 ABUT < 90 OPPOSITE REGION ) NOT INSIDE NODRC
}

SETLAYER AAconer = EXT AA <0.01 ABUT == 90 INTERSECTING ONLY REGION
SETLAYER POconer = EXT PO < 0.01 ABUT == 90 INTERSECTING ONLY REGION

VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK PO_S_13_R {
@ Strongly suggest the minimum space of GATE to neighboring poly for sensitive circuit with minimum  PO width = 0.06um, >=0.19
 SETLAYER  X = WITH WIDTH GATE == 0.06
 OUTLAYER (EXT X PO < 0.19 ABUT < 90 OPPOSITE REGION) NOT INSIDE NODRC 
}
VERBATIM {
#ENDIF
}

RULECHECK PO_S_15 {
@ Min space between L-shape ACT to PO in the same MOS when channel width <0.15um is 0.1.
SETLAYER PO_CHECK = EXPAND EDGE (LENGTH GATE_W < 0.15) INSIDE BY 0.001 
SETLAYER POmergeAA = (PO OR AA) INTERACT PO_CHECK
SETLAYER U_edge = CONVEX EDGE POmergeAA ANGLE1 == 270 ANGLE2 == 270
SETLAYER U_edge_ = EXPAND EDGE U_edge INSIDE BY 0.001

SETLAYER LAA_ = U_edge_ TOUCH AAconer == 1
SETLAYER LAA = U_edge COIN EDGE LAA_
SETLAYER X = LENGTH LAA  <  0.1
OUTLAYER (X COIN EDGE (AA TOUCH EDGE GATE)) NOT INSIDE EDGE NODRC
}

VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK PO_S_15a_R {
@ Min space between L-shape ACT to PO in the same MOS when channel width >= 0.15um is 0.1.
SETLAYER PO_CHECK = EXPAND EDGE (LENGTH GATE_W >= 0.15) INSIDE BY 0.001 
SETLAYER POmergeAA = (PO OR AA) INTERACT PO_CHECK
SETLAYER U_edge = CONVEX EDGE POmergeAA ANGLE1 == 270 ANGLE2 == 270
SETLAYER U_edge_ = EXPAND EDGE U_edge INSIDE BY 0.001

SETLAYER LAA_ = U_edge_ TOUCH AAconer == 1
SETLAYER LAA = U_edge COIN EDGE LAA_
SETLAYER X = LENGTH LAA  <  0.1
OUTLAYER (X COIN EDGE (AA TOUCH EDGE GATE)) NOT INSIDE EDGE NODRC
}
VERBATIM {
#ENDIF
}
RULECHECK PO_S_16 {
@ Min space between L-shape PO to ACT in the same MOSwhen channel width < 0.15um is 0.1.
SETLAYER PO_CHECK = EXPAND EDGE (LENGTH GATE_W < 0.15) INSIDE BY 0.001
SETLAYER POmergeAA = (PO OR AA) INTERACT PO_CHECK
SETLAYER U_edge = CONVEX EDGE POmergeAA ANGLE1 == 270 ANGLE2 == 270
SETLAYER U_edge_ = EXPAND EDGE U_edge INSIDE BY 0.001

SETLAYER LPO_ = U_edge_ TOUCH POconer == 1
SETLAYER LPO = U_edge COIN EDGE LPO_
OUTLAYER ((LENGTH LPO < 0.1) TOUCH EDGE (EXPAND EDGE PO_CHECK OUTSIDE BY 0.001)) NOT INSIDE EDGE NODRC
}


RULECHECK PO_S_17 {
@ Space between large PO and GATE with narrow channel length <= 0.08um
@ The large PO definition:
@ PO area >= 630um2 and within regions of density > 70% in window 30um x 30um, stepping 15um. Dummy poly isn\BFt included in the density check. >= 1.00um
SETLAYER  Density_region = DENSITY POLYi > 0.7 WINDOW 30 STEP 15
SETLAYER  Large_PO = (AREA POLYi >= 630) INSIDE Density_region
SETLAYER  GATE_check = GATE WITH EDGE (LENGTH GATE_LE <= 0.08)
SETLAYER  GATE_LE = (GATE TOUCH EDGE (INT GATE_W \[GATE\] < 0.005 ABUT INTERSECTING ONLY)) NOT COIN EDGE GATE_W
OUTLAYER  EXT Large_PO GATE_check < 1 ABUT<90 SINGULAR REGION 
}

VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK PO_S_18_R { 
@ Recommended core nmos gate space to (TGOX OR (NW1 OR PSUB), >=1.0
SETLAYER CHECK_GATE = GATE_core AND SDN
SETLAYER CHECK_WELL = OR TG NW PSUB
OUTLAYER (EXT CHECK_GATE CHECK_WELL < 1.0 ABUT<90 REGION OPPOSITE) NOT INSIDE NODRC
}

VERBATIM {
#ENDIF
}

VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK PO_EN_1_R { 
@ Recommended core pmos gate enclose by (NW1 NOT TGOX), >=1.0
SETLAYER CHECK_GATE = (GATE_core AND SDP) NOT TG
SETLAYER CHECK_WELL = NW NOT TG
OUTLAYER (ENC CHECK_GATE CHECK_WELL < 1.0 ABUT<90 REGION OPPOSITE) NOT INSIDE NODRC
}
RULECHECK PO_EN_2_R { 
@ Recommended IO nmos gate enclose by (TGOX NOT (NW1 OR PSUB)), >=2.0
SETLAYER CHECK_GATE = (GATE AND SDN) AND TG
SETLAYER CHECK_WELL = TG NOT NW
OUTLAYER (ENC CHECK_GATE CHECK_WELL < 2.0 ABUT<90 REGION OPPOSITE) NOT INSIDE NODRC
}
RULECHECK PO_EN_3_R { 
@ Recommended IO pmos gate enclose by (TGOX AND NW1), >=2.0
SETLAYER CHECK_GATE = (GATE AND SDP) AND TG
SETLAYER CHECK_WELL = TG AND NW
OUTLAYER (ENC CHECK_GATE CHECK_WELL < 2.0 ABUT<90 REGION OPPOSITE) NOT INSIDE NODRC
}
VERBATIM {
#ENDIF
}

RULECHECK PO_EX_1 {
@ Extension of ACT outside of PO >= 0.11um
SETLAYER X = ENC PO (AA NOT COIN EDGE LDMOSSTI) < 0.11 ABUT<90 REGION OPPOSITE
OUTLAYER ((X NOT INSIDE SRAMALL) NOT INSIDE INDALL) NOT INSIDE NODRC
}
VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK PO_EX_1_R {
@ Recommended Extension of ACT outside of PO(when channel width >1 um) >= 0.18um
SETLAYER X = LENGTH GATE  >= 1.0  
SETLAYER Y = GATE WITH EDGE X
SETLAYER Z = ENC Y (AA NOT TOUCH LDMOSSTI) < 0.18 ABUT<90 REGION OPPOSITE
OUTLAYER ((Z NOT INSIDE SRAMALL) NOT INSIDE INDALL) NOT INSIDE NODRC
}
VERBATIM {
#ENDIF
}

RULECHECK PO_EX_2 {
@ Extension of GATE poly outside of ACT >= 0.14um
SETLAYER Y = ENC AA PO < 0.14 ABUT<90 opposite REGION
SETLAYER Z = EXT PO < 0.002 ABUT==90 REGION INTERSECTING ONLY
OUTLAYER (((Y NOT TOUCH Z) NOT INSIDE SRAMALL) NOT INSIDE LDMOS) NOT INSIDE NODRC
}


VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK PO_EX_3_R {
@ PO end-cap extension of ACT when:
@ 1. PO space to L-shape ACT in the same MOS is < 0.14um
@ 2. GATE channel width (W) is >= 0.15um
@ DRC only check the L-shape opposite side PO end-cap. >= 0.16um
 SETLAYER A = ENC AA PO < 0.16 OPPOSITE REGION
 SETLAYER X = LENGTH GATE_W >= 0.15
 SETLAYER Y = GATE WITH EDGE X
 SETLAYER B = EXT Y AA < 0.14 ABUT==90 PERP ONLY REGION  
 OUTLAYER (A WITH EDGE (A TOUCH EDGE B)) NOT INSIDE NODRC
}
VERBATIM {
#ENDIF
}

RULECHECK PO_L_1 {
@ PO length between two CTs without GATE, and the length from any point inside GATE to nearest CT, when the PO width is < 0.13um
@ This rule is for voltage drop concern. DRC waive check ESDIOE covered region. <= 25.00um
SETLAYER PO_CHECK = ((WITH WIDTH PO < 0.13) NOT GATE) INTERACT CT
SETLAYER Z0 = SIZE CT BY 12.5 INSIDE OF PO_CHECK STEP 0.02
OUTLAYER ((PO_CHECK INTERACT Z0 > 1) NOT INSIDE ESDIOE) NOT INSIDE NODRC
SETLAYER PO_CHECK1 = (PO INTERACT CT) NOT GATE
SETLAYER Z4 = ((INT PO_CHECK1 < 0.13 OPPOSITE REGION) NOT GATE) NOT INTERACT CT 
SETLAYER Z6 = LENGTH Z4 >25
OUTLAYER (Z6 NOT INSIDE EDGE ESDIOE) NOT INSIDE EDGE NODRC


SETLAYER X = GATE WITH EDGE (LENGTH GATE_L < 0.13)
SETLAYER Y = (PO INTERACT X) INTERACT CT
SETLAYER Z = SIZE CT BY 25 INSIDE OF Y STEP 0.02
OUTLAYER (((GATE INTERACT Y) NOT INSIDE Z) NOT INSIDE ESDIOE) NOT INSIDE NODRC
}

VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK PO_L_2_R {
@ Recommanded maximum L shape length of L-shape ACT which  space to PO (in the same MOS with width >= 0.15um) <= 0.1 is <=0.21
SETLAYER PO_CHECK = EXPAND EDGE (LENGTH GATE_W >= 0.15) INSIDE BY 0.001 
SETLAYER POmergeAA = (PO OR AA) INTERACT PO_CHECK
SETLAYER L_edge = CONVEX EDGE POmergeAA ANGLE1 == 90 ANGLE2 == 270
SETLAYER L_edge_ = EXPAND EDGE L_edge INSIDE BY 0.001

SETLAYER LAA_ = L_edge_ TOUCH AAconer == 1
SETLAYER LAA = L_edge COIN EDGE LAA_
SETLAYER X = LENGTH LAA  >  0.21
SETLAYER Y = EXT X PO < 0.1 REGION
#OUTLAYER (X COIN EDGE (AA NOT TOUCH EDGE GATE)) NOT INSIDE EDGE NODRC
OUTLAYER (X COIN EDGE Y) NOT INSIDE EDGE NODRC
}
VERBATIM {
#ENDIF
}

VERBATIM {
#IFDEF Density_rules YES
}
RULECHECK PO_D_1_min {
@ Global PO density for fully chip (including dummy) >= 14%
OUTLAYER (DENSITY PO_all < 0.14 PRINT density_report_PO_D_1_min.log) NOT INSIDE NODRC
}

RULECHECK PO_D_1_max {
@ Global PO density for fully chip (including dummy)  <= 40%
OUTLAYER (DENSITY PO_all > 0.40 PRINT density_report_PO_D_1_max.log) NOT INSIDE NODRC
}

RULECHECK PO_D_2_min {
@ Local PO density (including dummy) in 100um*100um window with step size: 50um
@ Maximum density check exclude INDALL region >= 20%
OUTLAYER (DENSITY PO_all < 0.2 WINDOW 100 STEP 50 BACKUP PRINT density_report_PO_D_2_min.log) NOT INSIDE NODRC
}

RULECHECK PO_D_2_max {
@ Local PO density (including dummy) in 100um*100um window with step size: 50um
@ Maximum density check exclude INDALL region @ <= 40%
SETLAYER PO_check = PO_all NOT INDALL
OUTLAYER (DENSITY PO_check > 0.4 WINDOW 100 STEP 50 BACKUP PRINT density_report_PO_D_2_max.log) NOT INSIDE NODRC
}

RULECHECK PO_D_3 { 
@ The poly density difference between any two neighboring checking windows  <= 20%
 OUTLAYER ( DENSITY PO_all DRC:1 <=1 WINDOW 100 BACKUP GRADIENT > 0.2 ABSOLUTE CORNER INSIDE OF LAYER BULK PRINT density_report_PO_D_3.log) NOT INSIDE NODRC
}

VERBATIM {
#ENDIF
}


RULECHECK PO_A_1 {
@ PO area >= 0.04um2
OUTLAYER ((AREA PO < 0.04) NOT INSIDE SRAMALL) NOT INSIDE NODRC
}

VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}

RULECHECK PO_A_1_R {
@ PO area when PO is not GATE poly. >= 0.05um2
OUTLAYER ((AREA (PO NOT INTERACT GATE) < 0.05) NOT INSIDE SRAMALL) NOT INSIDE NODRC
}
VERBATIM {
#ENDIF
}

RULECHECK PO_A_2 {
@ PO enclosed area >= 0.09um2
OUTLAYER (AREA ((HOLES PO INNER) NOT PO) < 0.09) NOT INSIDE NODRC
}

RULECHECK PO_R_1 {
@ No bent PO on ACT is allowed.All PO patterns on ACT have to be orthogonal to ACT edage.
@ DRC waive check the INDALL and SRAMALL covered region, and waive check (ACT AND PO) width <= 0.01um pattern.
SETLAYER POEIAA1 = POEIAA COIN EDGE ((PO AND AA) WITH WIDTH > 0.01)
SETLAYER POEIAA = PO IN EDGE AA
OUTLAYER ((INT POEIAA1 < 0.01 ABUT == 90 REGION) NOT INSIDE (INDALL OR SRAMALL)) NOT INSIDE NODRC
OUTLAYER ((EXT POEIAA1 < 0.01 ABUT == 90 REGION) NOT INSIDE (INDALL OR SRAMALL)) NOT INSIDE NODRC
OUTLAYER ((INT POEIAA1 < 0.01 ABUT == 45 REGION) NOT INSIDE (INDALL OR SRAMALL)) NOT INSIDE NODRC
OUTLAYER ((EXT POEIAA1 < 0.01 ABUT == 45 REGION) NOT INSIDE (INDALL OR SRAMALL)) NOT INSIDE NODRC
OUTLAYER ((INT POEIAA1 < 0.01 ABUT == 135 REGION) NOT INSIDE (INDALL OR SRAMALL)) NOT INSIDE NODRC
OUTLAYER ((EXT POEIAA1 < 0.01 ABUT == 135 REGION) NOT INSIDE (INDALL OR SRAMALL)) NOT INSIDE NODRC
SETLAYER AAEIPO1 = (IN EDGE AA PO) COIN EDGE ((PO AND AA) WITH WIDTH > 0.01)
OUTLAYER ((INT POEIAA1 AAEIPO1 < 0.01 ABUT!=90 REGION) NOT INSIDE (INDALL OR SRAMALL)) NOT INSIDE NODRC
}

RULECHECK PO_R_2 {
@ PO must be enclosed by NP and/or PP.
SETLAYER HRPR = PO INTERACT HPR
SETLAYER HRP_END = SIZE (HRPR NOT HPR) BY 0.3
SETLAYER PO_MID = ( PO INTERACT (HPR OR HRP)) NOT HRP_END
SETLAYER Y = ((((PO INTERACT CT) NOT PO_MID) NOT SDP) NOT SDN) NOT INTERACT MOMLVS1
OUTLAYER (Y NOT INSIDE SRAMALL) NOT INSIDE NODRC
}


VERBATIM {

DMACRO NPLH_68 LAY_IMP LAY_ACT ENC_SD ENC_PO ENC_EXTENSION {
 X = PO INSIDE EDGE LAY_ACT
 A = EXPAND EDGE X INSIDE BY ENC_EXTENSION OUTSIDE BY ENC_EXTENSION CORNER FILL
 Y = (PO AND LAY_ACT) COIN EDGE LAY_ACT
 B = EXPAND EDGE Y OUTSIDE BY ENC_PO EXTEND BY ENC_EXTENSION
 C = A OR B
 (ENC LAY_ACT (LAY_IMP INSIDE EDGE C) < ENC_PO ABUT<90 REGION OPPOSITE) NOT INSIDE NODRC
 (ENC X LAY_IMP < ENC_SD ABUT<90 REGION OPPOSITE) NOT INSIDE NODRC
}
DMACRO SNP_68 LAY_IMP LAY_ACT ENC_SD ENC_PO ENC_EXTENSION {
 X = PO INSIDE EDGE LAY_ACT
 A = EXPAND EDGE X INSIDE BY ENC_EXTENSION OUTSIDE BY ENC_EXTENSION CORNER FILL
 Y = (PO AND LAY_ACT) COIN EDGE LAY_ACT
 B = EXPAND EDGE Y OUTSIDE BY ENC_PO EXTEND BY ENC_EXTENSION
 C = A OR B
 D = ENC LAY_ACT (LAY_IMP INSIDE EDGE C) < ENC_PO ABUT<90 REGION OPPOSITE
 (D NOT INSIDE SRAMALL) NOT INSIDE NODRC
 E = ENC X LAY_IMP < ENC_SD ABUT<90 REGION OPPOSITE
 (E NOT INSIDE SRAMALL) NOT INSIDE NODRC
}

//=================================
//  NP - N+ S/D Implantation DRC
//=================================

GROUP GNP NP_?

NP_W_1 {
@ NP width. Single-point-interaction is allowed. >= 0.18um
  (INT SDN < 0.18 ABUT<90 REGION) NOT INSIDE NODRC
}

NP_S_1 {
@ Space between two NPs. >= 0.18um
  (EXT SDN < 0.18 ABUT<90 OPPOSITE REGION) NOT INSIDE NODRC
}

NP_S_2 {
@ Space between NP and P+ ACT inside NW >= 0.12um
  X = (PACT NOT PTAP) NOT TOUCH EDGE SDN
  Y = EXT SDN X < 0.12 ABUT<90 REGION
  (Y NOT INSIDE SRAMALL) NOT INSIDE NODRC
}

NP_S_3 {
@ Space between NP and P+ pick-up ACT inside PW >= 0.02um
  X = PTAP NOT TOUCH EDGE NACT
  Y = X NOT TOUCH EDGE SDN
  (EXT SDN Y < 0.02 ABUT<90 REGION) NOT INSIDE NODRC
}

NP_S_4 {
@ Space between NP and butted P+ACT (except SRAM area). = 0.00um
  X = SDN AND PACT
  (X NOT INSIDE SRAMALL) NOT INSIDE NODRC
}

NP_S_5 {
@ Space between NP and PMOS GATE >= 0.3um
  X = GATE_W INSIDE EDGE SDP
  Y = EXT X SDN < 0.3 ABUT<90 OPPOSITE  REGION
  (Y NOT INSIDE SRAMALL) NOT INSIDE NODRC
}

NP_S_6 {
@ Butted P+ pick-up ACT space to PO in the same ACT (the butted N+ACT extending <0.16um) is 0.3
  NAAL = NACT TOUCH INSIDE EDGE NGATE
  NAAL_EP = EXPAND EDGE NAAL OUTSIDE BY 0.16 EXTEND BY 0.01
  BUTNA_ED = PACT COIN EDGE (NACT NOT NTAP)
  BUTNA_ED_1 = BUTNA_ED INSIDE EDGE NAAL_EP
  BUTSDN_1 = (PACT INTERACT PW) WITH EDGE BUTNA_ED_1
  
  POSDN_1 = (PO INSIDE EDGE ((NACT NOT NTAP) TOUCH PACT)) COIN EDGE NGATE
  POSDN   = (PO WITH EDGE POSDN_1) TOUCH EDGE NGATE  
  (EXT BUTSDN_1 POSDN < 0.30 ABUT<90 REGION) NOT INSIDE NODRC
}

NP_EN_1 {
@ ACT enclosure by NP, except the SRAMALL region. >= 0.02um
  X = ((ACT NOT SDNNR) NOT COIN EDGE PACT) NOT COIN EDGE SDP
  (ENC X SDN < 0.02 ABUT<90 REGION) NOT INSIDE NODRC
}

NP_EN_2 {
@ N+AA enclosure by NP, except the SRAMALL region. >= 0.12um
  X = (((NACT NOT INTERACT NWR) NOT COIN EDGE PACT) NOT COIN EDGE SDP) INSIDE EDGE PW
  ((ENC X (SDN AND PW) < 0.12 ABUT<90 REGION) NOT INSIDE SRAMALL) NOT INSIDE NODRC
}

NP_EN_3 {
@Minimum NP Enclosure PO >= 0.15um
(ENC POLYi SDN < 0.15 ABUT<90 REGION) NOT INSIDE NODRC
}

NP_EX_1_EX_1a {
@ NP extension outside of NMOS GATE poly when NP edge is on ACT . >= 0.3um
@ NP extension outside of GATE >= 0.16um
  SDN_S = SDN NOT INSIDE SRAMALL
  NACT_S = NACT NOT INSIDE SRAMALL
  CMACRO SNP_68 SDN_S NACT_S 0.3 0.16 0.2
}


NP_O_1 {
@ Overlap of NP and ACT >= 0.12um
  (INT SDN AA < 0.12 ABUT >0 <90 SINGULAR REGION) NOT INSIDE NODRC
}
NP_A_1 {
@ NP area >= 0.12um2
  (AREA SDN < 0.12) NOT INSIDE NODRC
}
NP_A_2 {
@ NP enclosed area >= 0.12um2
  (AREA ((HOLES SDN INNER) NOT SDN) < 0.12 ) NOT INSIDE NODRC
}
NP_A_3 {
@ Minimum area of butted NW1 TAP >= 0.04um2
  (AREA (NTAP TOUCH (NACT NOT NTAP))< 0.04 ) NOT INSIDE NODRC
}

//=======================================
//  PP - P+ S/D implantation DRC
//=======================================

GROUP GPP PP_?

PP_W_1 {
@ PP width. Single-point-interaction is allowed. >= 0.18um
  (INT SDP < 0.18 ABUT<90 REGION) NOT INSIDE NODRC
}

PP_S_1 {
@ Space between two PPs. >= 0.18um
  (EXT SDP < 0.18 ABUT<90 OPPOSITE REGION) NOT INSIDE NODRC
}

PP_S_2 {
@ Space between PP and N+ ACT >= 0.12um
  X = (NACT NOT NTAP) NOT TOUCH EDGE SDP
  Y = EXT SDP X < 0.12 ABUT<90 REGION
  (Y NOT INSIDE SRAMALL) NOT INSIDE NODRC
}
PP_S_3 {
@ Space between PP and N+ ACT inside Nwell >= 0.02um
  X = NTAP NOT TOUCH EDGE PACT
  Y = X NOT TOUCH EDGE SDP
  (EXT SDP Y < 0.02 ABUT<90 REGION) NOT INSIDE NODRC
}
PP_S_4 {
@ Space between PP and butted N+ACT (except SRAM area). = 0.00um
  X = SDP AND NACT
  (X NOT INSIDE SRAMALL) NOT INSIDE NODRC
} 

PP_S_5 {
@ Space between PP and NMOS GATE. >= 0.30um
  X = PO INSIDE EDGE NACT
  Y = EXT SDP X < 0.30 ABUT<90 REGION OPPOSITE
  (Y NOT INSIDE SRAMALL) NOT INSIDE NODRC
}

PP_S_6 {
@ Space between utted N+ pick-up ACT and PO in the same ACT (the butted P+ACT extending < 0.16um) >= 0.30um
  PAAL = PACT TOUCH INSIDE EDGE PGATE
  PAAL_EP = EXPAND EDGE PAAL OUTSIDE BY 0.16 EXTEND BY 0.01
  BUTNA_ED = NACT COIN EDGE (PACT NOT PTAP)
  BUTNA_ED_1 = BUTNA_ED INSIDE EDGE PAAL_EP
  BUTSDN_1 = (NACT INTERACT NW) WITH EDGE BUTNA_ED_1
  POSDP_1 = (PO INSIDE EDGE (PACT  TOUCH NACT)) COIN EDGE PGATE
  POSDP   = (PO WITH EDGE POSDP_1) TOUCH EDGE PGATE  
  (EXT BUTSDN_1 POSDP < 0.30 ABUT<90 REGION) NOT INSIDE NODRC
}


PP_EN_1 {
@ Enclosure of P+ ACT in PW, except the SRAMALL region >= 0.02um
  X = ((PTAP NOT INTERACT NWR) NOT COIN EDGE NACT) NOT COIN EDGE SDN
  ((ENC X SDP < 0.02 ABUT<90 REGION) NOT INSIDE SRAMALL) NOT INSIDE NODRC
}
PP_EN_2 {
@ Enclosure of P+ ACT NW1, except the SRAMALL region. >= 0.12um
  X = (((PACT NOT INTERACT NWR) NOT COIN EDGE NACT) NOT COIN EDGE SDN) INSIDE EDGE NW
  ((ENC X (SDP AND NW) < 0.12 ABUT<90 REGION) NOT INSIDE SRAMALL) NOT INSIDE NODRC
}

PP_EN_3 {
@Minimum PP Enclosure of POLY >=0.15um
((ENC POLYi SDP < 0.15 ABUT<90 REGION) NOT INSIDE SRAMALL) NOT INSIDE NODRC
}

PP_EX_1_EX_1a {
@ PP extension outside of PMOS GATE along source/drain direction. >= 0.16um
@ PP extension of PMOS gate poly when PP edge on ACT. >= 0.3um
 SDP_S = SDP NOT INSIDE SRAMALL
 PACT_S = PACT NOT INSIDE SRAMALL
 CMACRO SNP_68 SDP_S PACT_S 0.3 0.16 0.2
}

PP_O_1 {
@ Overlap of PP and ACT >= 0.12um
  (INT SDP (AA NOT TOUCH EDGE SDP) < 0.12 ABUT<90 REGION) NOT INSIDE NODRC
}
PP_A_1 {
@ PP area >= 0.12um2
  (AREA SDP < 0.120) NOT INSIDE NODRC
}
PP_A_2 {
@ PP enclosed area >= 0.12um2
  (AREA ((HOLES SDP INNER) NOT SDP) < 0.12) NOT INSIDE NODRC
}
PP_A_3 {
@ Minimum area of butted PW TAP >= 0.04um2
  (AREA (PTAP TOUCH (PACT NOT PTAP))< 0.04 ) NOT INSIDE NODRC
}

PP_R_1 {
@ PP overlap with NP is not allowed
  (AND SDN SDP) NOT INSIDE NODRC
}

PP_R_3 {
@ It is not allowed NP butted PP on unsilicided ACT/POLY
 A = SDN COIN EDGE SDP
 A INSIDE EDGE ((AA OR PO) AND SAB)
}

//=================================
//  SAB - Salicide Block DRC
//=================================

GROUP GSAB SAB_?

SAB_W_1 {
@ SAB width >= 0.42um
  (INT SAB < 0.42 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
SAB_S_1 {
@ Space between two SABs >= 0.42um
  (EXT SAB < 0.42 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
SAB_S_2 {
@ Space between two SABs when one or both SABs interact with PO. DRC waive if no (PO OR ACT) exists in the space region. >= 0.44um
  ((EXT (SAB INTERACT PO) SAB < 0.44 ABUT<90 SINGULAR REGION) INTERACT (PO OR AA)) NOT INSIDE NODRC
}
SAB_S_3 {
@ Space between SAB and ACT >= 0.21um
  (EXT SAB AA < 0.21 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
SAB_S_4 {
@ Space between SAB and GATE
@ SAB overlap with GATE is forbidden, DRC waive ESDIOE regions and waive the total SAB which overlaps GATE 60nm. >= 0.36um
  (EXT SAB GATE < 0.36 ABUT<90 REGION) NOT INSIDE NODRC
  ESD_REGION = INT GATE_W SAB == 0.06 OPPOSITE REGION 
  (((SAB NOT INTERACT ESD_REGION) AND GATE) NOT INSIDE ESDIOE ) NOT INSIDE NODRC 
}
SAB_S_5 {
@ Space between SAB and poly on field oxide. >= 0.3um
  PO_CHECK = PO NOT (AA OR AADUM)
  (EXT SAB PO_CHECK < 0.3 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
SAB_S_6 {
@ Space between SAB and CT >= 0.21um
  (EXT SAB CT < 0.21 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
SAB_EX_1 {
@ ACT extension outside of SAB >= 0.21um
  (ENC SAB AA < 0.21 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
SAB_EX_2 {
@ Extension of SAB outside of ACT >= 0.21um
  (ENC AA SAB < 0.21 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
SAB_EX_3 {
@ Extension of SAB outside of poly on field oxide >= 0.21um
  (ENC (PO NOT (AA OR AADUM)) SAB < 0.21 ABUT<90 REGION) NOT INSIDE NODRC
}

#IFDEF OPEN_RECOMMENDED_ON YES

 SAB_EX_4_R {
@ Extension on unsilicided ACT/POLY when SAB width is > 10um
@ DRC waive if >= 5 poly fingers interact with the SAB. >= 0.30um
   SAB_CHECK = (SAB WITH WIDTH > 10) NOT INTERACT (PO AND SAB) > 4
  (ENC ((AA OR PO) INTERACT SAB) SAB_CHECK < 0.3 ABUT < 90 REGION) NOT INSIDE NODRC
}
#ENDIF
SAB_A_1 {
@ SAB area >= 0.8um2
  (AREA SAB < 0.8) NOT INSIDE NODRC
}
SAB_A_2 {
@ SAB enclosed area >= 0.8um2
  (AREA ((HOLES SAB INNER) NOT SAB)< 0.8) NOT INSIDE NODRC
}


SAB_R_1 {
@ SAB butted  ACT/POLY is not allowed
  (SAB COIN EDGE PO) NOT INSIDE EDGE NODRC
  (SAB COIN EDGE AA) NOT INSIDE EDGE NODRC
}
SAB_R_2 {
@ SAB overlap GATE is not allowed except ESD MOS
  ((SAB AND GATE) NOT INSIDE ESDIOE) NOT INSIDE EDGE NODRC
}

//========================
//  CT - Contact DRC
//========================

GROUP GCT CT_?

CTN = CT AND (RECTANGLE CT ASPECT == 1)

CT_W_1 {
@ Fixed CT width (square shape) exclude SRAMALL(177;4) FUSEALL, and GRID
@ DRC waive rectangular CT in SRAM and EFUSEALL area, and waive protection ring purpose non-rectangular CT in GRID area =0.09um
  X = NOT RECTANGLE ((CT NOT RCT) NOT GCT) == 0.09 BY == 0.09
  (X NOT INSIDE ((GRID OR SRAMALL) OR EFUSEALL)) NOT INSIDE (SRINGBLK OR NODRC)
  (NOT RECTANGLE (RECTANGLE (CT AND GRID)) == 0.09 BY == 0.09) NOT INSIDE (SRINGBLK OR NODRC)
  (NOT RECTANGLE (RECTANGLE (CT AND EFUSEALL) ASPECT == 1) == 0.09 BY == 0.09) NOT INSIDE (SRINGBLK OR NODRC)
  (NOT RECTANGLE (RECTANGLE (CT AND SRAMALL) ASPECT == 1) == 0.09 BY == 0.09) NOT INSIDE (SRINGBLK OR NODRC)
 
}
CT_W_2 {
@ Fixed CT bar width, except rectangular CT in SRAMALL (177;4) FUSEALL region = 0.09um
   (WITH WIDTH CTbar < 0.09) NOT INSIDE (OR SRAMALL EFUSEALL)
   (WITH WIDTH CTbar > 0.09) NOT INSIDE (OR SRAMALL EFUSEALL)
}


CT_S_1 {
@ Space between two contacts >= 0.11um
  X = EXT CT < 0.11 ABUT<90 SINGULAR REGION
  (X NOT INSIDE SRAMALL) NOT INSIDE NODRC
}
CT_S_1a {
@ Space between CT and 3-neighboring CTs (space is <= 0.15um)  >= 0.14um
  X = SIZE CT BY 0.075 OVERUNDER
  Y = SIZE X BY 0.340 UNDEROVER
  Z = CT INSIDE Y
  (EXT Z < 0.14 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
  

CT_S_2 {
@ CT space at different nets, except SRAMALL region. >= 0.12um
 (EXT CT < 0.12 SINGULAR REGION NOT CONNECTED) NOT INSIDE (SRAMALL OR NODRC)

}
CT_S_3 {
@ Space between ACT and contact on POLY >= 0.065um
  (EXT CT AA < 0.065 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
CT_S_4 {
@ Space between POLY and contact on ACT for 0.9V/1.2V >= 0.055um
  X = EXT (PO INTERACT GATE_core) ACT_CT < 0.055 ABUT<90 SINGULAR REGION 
  (X NOT INSIDE SRAMALL) NOT INSIDE NODRC
}
#IFDEF OPEN_RECOMMENDED_ON YES

CT_S_4_R {
@ Recomended Space between POLY and contact on ACT for 0.9V/1.2V >= 0.06 um
  X = EXT (PO INTERACT GATE_core) ACT_CT < 0.06 ABUT<90 SINGULAR REGION 
  (X NOT INSIDE SRAMALL) NOT INSIDE NODRC
}
#ENDIF

CT_S_5 {
@ Space between GATE and contact on ACT for 1.8/2.5/3.3V >= 0.09um
  X1 = EXT GATE_io1 (ACT_CT AND DG) < 0.09 ABUT<90 SINGULAR REGION
  X2 = EXT GATE_io2 (ACT_CT AND TG) < 0.09 ABUT<90 SINGULAR REGION
  (X1 OR X2) NOT INSIDE NODRC
}

 CT_S_6 {
@ Space to butted SDN/SDP edge on ACT (overlap of NP/PP boundary on ACT is not allowed) >= 0.06um
   X = (SDN COIN EDGE SDP) NOT OUTSIDE EDGE AA
   Y = (SDP COIN EDGE SDN) NOT OUTSIDE EDGE AA
   (X INSIDE EDGE CT) NOT INSIDE EDGE NODRC
   (Y INSIDE EDGE CT) NOT INSIDE EDGE NODRC
   (ENC CT X < 0.06 ABUT<90 REGION ) NOT INSIDE NODRC
   (ENC CT Y < 0.06 ABUT<90 REGION ) NOT INSIDE NODRC
}

CT_EN_1 {
@ CT must be fully covered by M1 and (ACT OR POLY), except SRAMALL region.
  ((CT NOT (M1 AND (PO OR AA))) NOT INSIDE SRAMALL) NOT INSIDE NODRC
}

CT_EN_2a {
@ CT enclosure by ACT for CT >= 0.015um
  X = CT INTERACT AA
  Y = ENC X AA < 0.015 ABUT<90 SINGULAR REGION OUTSIDE ALSO
  (Y NOT INSIDE SRAMALL) NOT INSIDE NODRC
}
CT_EN_2b {
@ CT enclosure by ACT for at least two opposite sides >= 0.03um
 X = RECTANGLE ENC (CT INTERACT AA) AA ABUT<90 OUTSIDE ALSO\
  GOOD 0.015 OPPOSITE 0.03 OPPOSITE 0.015 OPPOSITE 0.03 OPPOSITE
  A = ENC [X] AA < 0.03 OPPOSITE
  D2 = INT A < 0.01 ABUT==90 INTERSECTING ONLY REGION      
  D2 NOT INSIDE SRAMALL
  ((CT INTERACT AA) NOT AA) NOT INSIDE SRAMALL
}
#IFDEF OPEN_RECOMMENDED_ON YES
CT_EN_2_R {
@ Recomended CT enclosure by ACT for all sides >= 0.04um
  X = CT INTERACT AA
  Y = ENC X AA < 0.04 ABUT<90 SINGULAR REGION OUTSIDE ALSO
  (Y NOT INSIDE SRAMALL) NOT INSIDE NODRC
}
#ENDIF
CT_EN_3a_3b_3c {
@ Min CT enclosure by poly is 0.01
@ Min CT enclosure by poly when one or both perpendicular directions <0.04um is 0.04um
   X = RECTANGLE ENC (CT INTERACT PO) PO ABUT<90 OUTSIDE ALSO
  GOOD 0.01 OPPOSITE 0.04 OPPOSITE 0.01 OPPOSITE 0.04 OPPOSITE
  GOOD 0.025 0.025 0.025 0.025 

  D1 = ENC X PO < 0.01 ABUT<90 SINGULAR REGION OVERLAP OUTSIDE ALSO
  (D1 NOT INSIDE SRAMALL) NOT INSIDE NODRC

  A = ENC [X] PO < 0.04 OPPOSITE
  D2 = INT A < 0.01 ABUT==90 INTERSECTING ONLY REGION      //; For CT not touching M1
  D2 NOT INSIDE SRAMALL

  B = ENC X PO < 0.025 ABUT<90 SINGULAR REGION OVERLAP OUTSIDE ALSO
  (B NOT INSIDE SRAMALL) NOT INSIDE NODRC

  ((CT INTERACT PO) NOT PO) NOT INSIDE SRAMALL
  }
#IFDEF OPEN_RECOMMENDED_ON YES
CT_EN_3_R {
@ Recommended CT enclosure by poly for all sides to avoid high RC >= 0.06um
  X = CT INTERACT PO
  Y = ENC X PO < 0.06 ABUT<90 SINGULAR REGION OUTSIDE ALSO
  (Y NOT INSIDE SRAMALL) NOT INSIDE NODRC
}
#ENDIF
CT_EN_4b {
@ Minimum M1 enclosure of CT in line end region at least two opposite sides >= 0.04.
   X = RECTANGLE ENC (CT INTERACT M1) M1 ABUT<90 OUTSIDE ALSO GOOD 0.0 0.04 OPPOSITE 0.0 0.04 OPPOSITE
   (X NOT INSIDE SRAMALL) NOT INSIDE NODRC

   A = ENC X M1 < 0.04 OPPOSITE REGION
   A NOT INSIDE SRAMALL
   ((CT INTERACT M1) NOT M1) NOT INSIDE SRAMALL
}

CT_EN_4a_4b_4c {
@ Enclosure by M1 >= 0 um
@ Enclosure by M1 at least two opposite sides < 0.04um >= 0.04um
@ Enclosure by M1 for all sides >= 0.025 um
  X = RECTANGLE ENC (CT NOT TOUCH M1) M1 ABUT<90 OUTSIDE ALSO
  GOOD 0 0.04 OPPOSITE 0 0.04 OPPOSITE GOOD 0.025 0.025 0.025 0.025 OPPOSITE

  A = ENC [X] M1 < 0.04 OPPOSITE
  D1 = INT A < 0.01 ABUT==90 INTERSECTING ONLY REGION      //; For CT not touching M1
  (D1 NOT INSIDE SRAMALL) NOT INSIDE NODRC

  B = CT COIN EDGE M1
  D2 = INT B < 0.01 ABUT==90 REGION        //; For CT touch M1 with >= 2 butting edges
  (D2 NOT INSIDE SRAMALL) NOT INSIDE NODRC

  Y = ENC CT M1 < 0.04 OPPOSITE REGION
  C1 = CT COIN EDGE M1
  C2 = CT COIN EDGE Y
  D3 = INT C1 C2 < 0.01 ABUT==90 REGION	//; For CT touch M1 with only 1 edge
  (D3 NOT INSIDE SRAMALL) NOT INSIDE NODRC

  ((CT NOT M1) NOT INSIDE SRAMALL) NOT INSIDE NODRC
  (CT NOT INTERACT M1) NOT INSIDE NODRC
}

#IFDEF OPEN_RECOMMENDED_ON YES
CT_EN_4a_R_4b_R {
@ Recomended M1 enclosure of CT to avoide high RC >= 0.04 um
@ Recommended Minimum M1 enclosure of CT in line end region (at least two opposite sides) >=0.06 
   X = RECTANGLE ENC (CT INTERACT M1) M1 ABUT<90 OUTSIDE ALSO GOOD 0.04 0.06 OPPOSITE 0.04 0.06 OPPOSITE
  (X NOT INSIDE SRAMALL) NOT INSIDE NODRC

  A = ENC X M1 < 0.06 OPPOSITE REGION
  A NOT INSIDE SRAMALL

  ((CT INTERACT M1) NOT M1) NOT INSIDE SRAMALL
}

#ENDIF

CT_EN_4d {
@ Enclosure by M1, when M1 width is > 1um. >= 0.04um
  M1_CHECK = M1 WITH WIDTH > 1
  CT_CHECK = CT NOT OUTSIDE M1_CHECK
  (ENC CT_CHECK M1 < 0.04 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

CT_R_1  {
@ CT is not allowed to land on GATE
  ((AND GATE CT) NOT INSIDE SRAMALL) NOT INSIDE NODRC
}
CT_R_2 {
@ CT is not allowed to interact SAB
@ Waive the CT cutting AA in SRAM area.
  ((CT INTERACT SAB) NOT INSIDE (SRAMALL OR EFUSEALL)) NOT INSIDE NODRC
}

CT_R_3 {
@ 45 degree CT is not allowed
    (CT WITH EDGE (ANGLE CT == 45)) NOT INSIDE NODRC 
}

CT_R_4 {
@ Recomended at least two CTs for connection except Reserved area, DRC help to mark single CT
  X1 = (NSD OR NTAP) INTERACT CT == 1
  (CT AND X1) NOT NODRC
  X2 = (PSD OR PTAP) INTERACT CT == 1
  (CT AND X2) NOT NODRC
}

CT_R_5 {
@ Recomended to put CTs at both source side and butted well tap side. DRC can flag if the tap is butted on source and the tap or source region without CT
  X1 = (TOUCH NTAP NSDi) NOT INTERACT CT
  X2 = (TOUCH PTAP PSDi) NOT INTERACT CT
  X3 = (TOUCH NTAP PSDi) NOT INTERACT CT
  X4 = (TOUCH PTAP NSDi) NOT INTERACT CT
  (OR X1 X2 X3 X4) NOT NODRC
}
}
#//=====================
#//  MET1 - Metal 1 DRC
#//=====================

GROUP GMET1 MET1_?


SETLAYER density_checkarea = DRC:1 NOT INDALL


RULECHECK MET1_W_1 {
@ M1 width >= 0.09um
@ M1 width <= 10.00um
  OUTLAYER (M1 WITH WIDTH > 10) NOT INSIDE NODRC
  OUTLAYER (INT M1 < 0.09 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
RULECHECK MET1_W_2 {
@ Width of metal1 with 45 degree,  >= 0.19um
  SETLAYER X = ANGLE M1 == 45
  OUTLAYER (INT X < 0.19 REGION) NOT INSIDE NODRC
}

RULECHECK MET1_W_3 {
@ Minimum M1 width adjoining a huge non-metal region \[ area > 2000000 um2\], non-metal region is defined as (NOT (Mx OR MxDUM)) >= 0.35um
  SETLAYER NON_METAL_REG = AREA (DRC:1 NOT (OR M1 M1DUM)) > 2000000 
  SETLAYER CHECK_REGION = ENCLOSE RECTANGLE NON_METAL_REG 10 0.35
  SETLAYER CHECK_METAL = M1 INTERACT CHECK_REGION 
  OUTLAYER (INT CHECK_METAL < 0.35 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK MET1_S_1 {
@ Space between two M1s, DRC don\BFt flag 89 to 90 degree spaces in the INDALL region. >= 0.09um
  SETLAYER X = EXT M1 < 0.09 ABUT<90 SINGULAR REGION
  OUTLAYER ((X NOT INDALL) NOT INSIDE SRAMALL) NOT INSIDE NODRC
  SETLAYER Y = EXT M1 < 0.09 ABUT<89 SINGULAR REGION
  OUTLAYER ((Y AND INDALL) NOT INSIDE SRAMALL) NOT INSIDE NODRC
}

VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK MET1_S_1_R {
@ Recomended pace between two M1s. >= 0.12um
  SETLAYER X = EXT M1 < 0.12 ABUT<90 SINGULAR REGION
  OUTLAYER (X NOT INSIDE SRAMALL) NOT INSIDE NODRC
}
VERBATIM {
#ENDIF
}

RULECHECK MET1_S_2 {
@ Min Space between two M1 is 0.15 um when one or both M1 width >= 0.42um, and the parallel run length of two M1s is >= 0.42um
  Mn_2b M1ALL 0.42 0.42 0.15
}
RULECHECK MET1_S_3 {
@ Min Space between two M1 is 0.5 um when one or both M1 width >= 1.5um, and the parallel run length of two M1s is >= 1.5um
  Mn_2b M1ALL 1.5 1.5 0.5
}

RULECHECK MET1_S_5 {
@ Space between metal lines with one or both are 45 degree,  >= 0.19um
  SETLAYER X = ANGLE M1 == 45
  OUTLAYER (EXT X M1 < 0.19 REGION) NOT INSIDE NODRC
}

RULECHECK MET1_S_6 { 
@ Space to dense M1 line-end , Definition of dense M1 line-end: 1. M1 line-end: M1 edge with length < 0.11 um (W) between 2 outer vertex. 2. Other metal INTERACT Region 1. Region 1 = (T+Q) x S2. (W+S2) < 0.11 um. 
@ Space (S1) to dense M1 line-end (parallel run length > -0.025 um (T)), Definition of dense M1 line-end: 1. M1 line-end: M1 edge with length < 0.07 um (W) between 2 outer vertex. 2. Other metal INTERACT Region 1. Region 1 = (T+Q) x S2. (W+S2) < 0.12 um. This check doesn't include small jog with edge length < 0.05 um (R) >= 0.11
 SETLAYER A = CONVEX EDGE M1 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < 0.11
 SETLAYER B = EXT \[A\] M1 < 0.11 ABUT < 90 OPPOSITE EXTENDED 0.045
 SETLAYER C = A TOUCH INSIDE EDGE B
 SETLAYER D = INT C \[M1\] < 0.11 ABUT == 90 INTERSECTING ONLY
 SETLAYER I = LENGTH D >= 0.09
 SETLAYER J = EXPAND EDGE I INSIDE BY 0.005 
 SETLAYER K = LENGTH J == 0.005
 SETLAYER L = K NOT TOUCH EDGE C
 SETLAYER M = EXPAND EDGE L INSIDE BY 0.045
 SETLAYER N = J NOT M
 SETLAYER O = I COIN INSIDE EDGE N
 SETLAYER PW = INT O M1 < (0.2 - 0.09) ABUT < 90 OPPOSITE EXTENDED 0.045
 SETLAYER PS = EXT O M1 < (0.2 - 0.09) ABUT < 90 OPPOSITE EXTENDED 0.045
 SETLAYER Q = DFM PROPERTY O PS PW OVERLAP ABUT ALSO MULTI \[-= MIN(EW(PW)) + MIN(EW(PS))\] < 0.2
 SETLAYER R = C TOUCH EDGE (J WITH EDGE Q)
 OUTLAYER (EXT R M1 < 0.11 ABUT < 90 OPPOSITE EXTENDED 0.045 REGION) NOT INSIDE (OR MOMLVS1 NODRC)
}

RULECHECK MET1_A_1 {
@ M1 area >= 0.042um2
  SETLAYER X = AREA M1 < 0.042
  OUTLAYER (X NOT INSIDE SRAMALL) NOT INSIDE NODRC
}

RULECHECK MET1_A_2 {
@ Enclosed dielectric area by M1 >= 0.18um2
  SETLAYER X = (HOLES M1 INNER EMPTY) NOT M1
  OUTLAYER (AREA X < 0.18) NOT INSIDE NODRC
}

VERBATIM {
#IFDEF Density_rules YES
}
RULECHECK MET1_D_1_min {
@ M1 density (including dummy) in 100umX100um window with step size 50um. INDALL/FUTR/GRID/SRINGBLK covered areas are excluded for this rule checking >= 10%
SETLAYER check_region_1 = ((((DRC:1 NOT FUTR) NOT GRID) NOT SRINGBLK) NOT INDALL) NOT INSIDE NODRC
SETLAYER check_region = check_region_1 WITH WIDTH >= 50
SETLAYER check_pattern = M1ALLi AND check_region
SETLAYER err1_TMP1 = DENSITY check_pattern check_region \[!AREA(check_region) + !!AREA(check_region)*AREA(check_pattern)/AREA(check_region)\] < 0.10 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON 

SETLAYER check_window = WITH WIDTH (err1_TMP1 AND check_region) >= 50
OUTLAYER DENSITY check_pattern check_window \[!AREA(check_window) + !!AREA(check_window)*AREA(check_pattern)/AREA(check_window)\] < 0.10 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON PRINT MET1_D_1_min.log RDB MET1_D_1_min.rdb
 
}

RULECHECK MET1_D_1_max {
@ M1 density (including dummy) in 100umX100um window with step size 50um. INDALL/FUTR/GRID/SRINGBLK covered areas are excluded for this rule checking <= 80% 
SETLAYER check_region_1 = ((((DRC:1 NOT FUTR) NOT GRID) NOT SRINGBLK) NOT INDALL) NOT INSIDE NODRC
SETLAYER check_region = check_region_1 WITH WIDTH >= 50
SETLAYER check_pattern = M1ALLi AND check_region
SETLAYER err1_TMP1 = DENSITY check_pattern check_region \[!!AREA(check_region)*AREA(check_pattern)/AREA(check_region)\] > 0.8 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON 

SETLAYER check_window = WITH WIDTH (err1_TMP1 AND check_region) >= 50
OUTLAYER DENSITY check_pattern check_window \[!!AREA(check_window)*AREA(check_pattern)/AREA(check_window)\] > 0.8 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON PRINT MET1_D_1_max.log RDB MET1_D_1_max.rdb

}

RULECHECK MET1_D_2 {
@ M1 average density inside the {SIZE dummy block BY 2.5um} area in 100umX100um window with step size 50um when the dummy block area >= 100umX100um. INDALL/FUTR/GRID/SRINGBLK covered areas are excluded for this rule checking
@ Device sensitive areas can be waived. >= 10%
  SETLAYER X = DENSITY M1ALLi < 0.1 WINDOW 100 STEP 50 backup PRINT density_report_MET1_D_2.log
  SETLAYER Y = ((SIZE  M1DUMB BY 2.5) OR SRBLK) NOT (OR INDALL FUTR GRID SRINGBLK)
  SETLAYER Z = SIZE Y BY 12.5 UNDEROVER
  OUTLAYER (X AND Z) NOT INSIDE NODRC
}

RULECHECK MET1_D_3 {
@ The difference between M1 density in 100x100 window (including dummy)
@ INDID/GRID/FUTR/SRINGBLK covered areas are excluded for this rule checking <= 20%

  SETLAYER X = DENSITY M1ALLi >= 0 WINDOW 200 GRADIENT > 0.2 ABSOLUTE BACKUP INSIDE OF LAYER density_checkarea PRINT density_report_MET1_D_3.log
  OUTLAYER ((((X NOT FUTR) NOT GRID) NOT SRINGBLK) NOT INDALL) NOT INSIDE NODRC
}
VERBATIM {
#ENDIF
}

RULECHECK MET1_R_1 {
@ M1 line end must be rectangular.
  SETLAYER A = INT M1 < 0.01 ABUT == 45 REGION
  SETLAYER B = EXT M1 < 0.01 ABUT == 45 REGION
  SETLAYER C = INT M1 < 0.01 ABUT == 135 REGION
  SETLAYER D = EXT M1 < 0.01 ABUT == 135 REGION
  OUTLAYER A NOT INSIDE NODRC
  OUTLAYER B NOT INSIDE NODRC
  OUTLAYER C NOT INSIDE NODRC
  OUTLAYER D NOT INSIDE NODRC
}

#**********************************************
# Mn: Metal n (n=2~8) design rules
#**********************************************



set metal_list { M2 M3 M4 M5 M6 M7 M8 }
foreach metal_layer $metal_list {
  set tmp CHECK_$metal_layer
  set tmp_v [set $tmp]

  if { $tmp_v == 1 } {
    GROUP G${metal_layer} ${metal_layer}_?

RULECHECK ${metal_layer}_W_1a {
@ Mn width >= 0.10um
  OUTLAYER (INT $metal_layer < 0.10 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK ${metal_layer}_W_1b {
@ Mn width
@ (Exclude DEUPAD region when Mn as TM-1 in 1 top metal option) <= 10.00um
set M_inner_last M[expr $total_metal-$top_metal]
if { [string equal $top_metal 1] == 1 } {
if { [string equal $metal_layer $M_inner_last] == 1 } {
 SETLAYER X = $metal_layer NOT DEUPAD
 OUTLAYER (X WITH WIDTH > 10) NOT INSIDE NODRC
} else {
  OUTLAYER ($metal_layer WITH WIDTH > 10) NOT INSIDE NODRC
}

} else {
  OUTLAYER ($metal_layer WITH WIDTH > 10) NOT INSIDE NODRC
}
}

RULECHECK ${metal_layer}_W_2 {
@ Width of Mn with 45 degree,  >= 0.19um
  SETLAYER X = ANGLE $metal_layer == 45
  OUTLAYER (INT X < 0.19 REGION) NOT INSIDE NODRC
}

RULECHECK ${metal_layer}_W_3 {
@ Minimum Mn width adjoining a huge non-metal region \[ area > 2000000 um2\], non-metal region is defined as (NOT (Mx OR MxDUM)) >= 0.35um
  SETLAYER NON_METAL_REG = AREA (DRC:1 NOT (OR $metal_layer ${metal_layer}DUM)) > 2000000 
  SETLAYER CHECK_REGION = ENCLOSE RECTANGLE NON_METAL_REG 10 0.35
  SETLAYER CHECK_METAL = $metal_layer INTERACT CHECK_REGION 
  OUTLAYER (INT CHECK_METAL < 0.35 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

#-----------------------------------------------------------------------------------------------
    if { [string equal $metal_layer M2] == 1 } {
RULECHECK ${metal_layer}_S_1 {
@ Space between two Mns,
  SETLAYER X = EXT $metal_layer < 0.10 ABUT<90 SINGULAR REGION
  OUTLAYER (X NOT INSIDE SRAMALL) NOT INSIDE NODRC
}
    } else {
RULECHECK ${metal_layer}_S_1 {
@ Space between two Mns,
  OUTLAYER (EXT $metal_layer < 0.10 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
    }
VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
    if { [string equal $metal_layer M2] == 1 } {
RULECHECK ${metal_layer}_S_1_R {
@ Recommended Space between two Mns,
  SETLAYER X = EXT $metal_layer < 0.13 ABUT<90 SINGULAR REGION
  OUTLAYER (X NOT INSIDE SRAMALL) NOT INSIDE NODRC
}
    } else {
RULECHECK ${metal_layer}_S_1_R {
@ Recommended Space between two Mns,
  OUTLAYER (EXT $metal_layer < 0.13 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
    }
VERBATIM {
#ENDIF
}

#----------------------------------------------------------------------------------------------------

RULECHECK ${metal_layer}_S_2 {
@ Space between two Mns when one or both Mn width >=0.42um, and the parallel run length of two Mns is >= 0.42um.>=0.15um
  Mn_2b ${metal_layer}ALL 0.42 0.42 0.15
}
RULECHECK ${metal_layer}_S_3 {
@ Space between two Mns when one or both Mn width >=1.5um, and the parallel run length of two Mns is >= 1.5um.>=0.5um
  Mn_2b ${metal_layer}ALL 1.5 1.5 0.5
}

RULECHECK ${metal_layer}_S_5 {
@ Space between metal lines with one or both is 45 degree  (the area with 0.1um distance from bending point need not follow this rule) >= 0.19um
  SETLAYER X = ANGLE $metal_layer == 45
  OUTLAYER (EXT X < 0.19 REGION) NOT INSIDE NODRC
  OUTLAYER (EXT $metal_layer X < 0.19 REGION corner to edge) NOT INSIDE NODRC
}
RULECHECK ${metal_layer}_S_6 { 
@ Space to dense M1 line-end , Definition of dense M1 line-end: 1. M1 line-end: M1 edge with length < 0.11 um (W) between 2 outer vertex. 2. Other metal INTERACT Region 1. Region 1 = (T+Q) x S2. (W+S2) < 0.12 um. 
@ Space (S1) to dense M1 line-end (parallel run length > -0.025 um) (T), Definition of dense M1 line-end: 1. M1 line-end: M1 edge with length < 0.07 um (W) between 2 outer vertex. 2. Other metal INTERACT Region 1. Region 1 = (T+Q) x S2. (W+S2) < 0.12 um. This check doesn't include small jog with edge length < 0.05 um (R) >= 0.12
SETLAYER  A = CONVEX EDGE ${metal_layer} ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < 0.12
SETLAYER  B = EXT \[A\] ${metal_layer} < 0.12 ABUT < 90 OPPOSITE EXTENDED 0.05
SETLAYER  C = A TOUCH INSIDE EDGE B
SETLAYER  D = INT C \[${metal_layer}\] < 0.12 ABUT == 90 INTERSECTING ONLY
SETLAYER  I = LENGTH D >= 0.09
SETLAYER  J = EXPAND EDGE I INSIDE BY 0.005 
SETLAYER  K = LENGTH J == 0.005
SETLAYER  L = K NOT TOUCH EDGE C
SETLAYER  M = EXPAND EDGE L INSIDE BY 0.05
SETLAYER  N = J NOT M
SETLAYER  O = I COIN INSIDE EDGE N
SETLAYER  PW = INT O ${metal_layer} < (0.22 - 0.1) ABUT < 90 OPPOSITE EXTENDED 0.05
SETLAYER  PS = EXT O ${metal_layer} < (0.22 - 0.1) ABUT < 90 OPPOSITE EXTENDED 0.05
SETLAYER  Q = DFM PROPERTY O PS PW OVERLAP ABUT ALSO MULTI  \[-= MIN(EW(PW)) + MIN(EW(PS))\] < 0.22
SETLAYER  R = C TOUCH EDGE (J WITH EDGE Q)
OUTLAYER  (EXT R ${metal_layer} < 0.12 ABUT < 90 OPPOSITE EXTENDED 0.05 REGION) NOT INSIDE (OR MOMLVS1 NODRC)
}

    if { [string equal $metal_layer M2] == 1 } {
RULECHECK ${metal_layer}_A_1 {
@ Mn area >= 0.052um2
  SETLAYER X = AREA $metal_layer  < 0.052
  OUTLAYER (X NOT INSIDE SRAMALL) NOT INSIDE NODRC
}
    } else {
RULECHECK ${metal_layer}_A_1 {
@ Mn area >= 0.052um2
  OUTLAYER (AREA $metal_layer < 0.052) NOT INSIDE NODRC
}
    }
#-----------------------------------------------------------------------------------------------

RULECHECK ${metal_layer}_A_2 {
@ Enclosed dielectric area by Mn >= 0.18um2
  SETLAYER X = (HOLES $metal_layer INNER) NOT $metal_layer
  OUTLAYER (AREA X < 0.18) NOT INSIDE NODRC
}


VERBATIM {
#IFDEF Density_rules YES
}

RULECHECK ${metal_layer}_D_1_min {
@ Mn density (including dummy) in 100umX100um window with step size 50um. INDALL/FUTR/GRID/SRINGBLK covered areas are excluded for this rule checking
@ (Exclude DEUPAD region when when Mn as TM-1 in 1 top metal option) >= 10%
set M_inner_last M[expr $total_metal-$top_metal]
if { [string equal $top_metal 1] == 1 } {
if { [string equal $metal_layer $M_inner_last] == 1 } {
 
SETLAYER check_region_1 = (((((DRC:1 NOT FUTR) NOT GRID) NOT SRINGBLK) NOT INDALL) NOT DEUPAD) NOT INSIDE NODRC
SETLAYER check_region = check_region_1 WITH WIDTH >= 50
SETLAYER check_pattern = ${metal_layer}ALLi AND check_region
SETLAYER err1_TMP1 = DENSITY check_pattern check_region \[!AREA(check_region) + !!AREA(check_region)*AREA(check_pattern)/AREA(check_region)\] < 0.10 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON  

SETLAYER check_window = WITH WIDTH (err1_TMP1 AND check_region) >= 50
OUTLAYER DENSITY check_pattern check_window \[!AREA(check_window) + !!AREA(check_window)*AREA(check_pattern)/AREA(check_window)\] < 0.10 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON PRINT ${metal_layer}_D_1_min.log RDB ${metal_layer}_D_1_min.rdb

} else {
  
SETLAYER check_region_1 = ((((DRC:1 NOT FUTR) NOT GRID) NOT SRINGBLK) NOT INDALL) NOT INSIDE NODRC
SETLAYER check_region = check_region_1 WITH WIDTH >= 50
SETLAYER check_pattern = ${metal_layer}ALLi AND check_region
SETLAYER err1_TMP1 = DENSITY check_pattern check_region \[!AREA(check_region) + !!AREA(check_region)*AREA(check_pattern)/AREA(check_region)\] < 0.10 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON 

SETLAYER check_window = WITH WIDTH (err1_TMP1 AND check_region) >= 50
OUTLAYER DENSITY check_pattern check_window \[!AREA(check_window) + !!AREA(check_window)*AREA(check_pattern)/AREA(check_window)\] < 0.10 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON PRINT ${metal_layer}_D_1_min.log RDB ${metal_layer}_D_1_min.rdb

}
} else {
  
SETLAYER check_region_1 = ((((DRC:1 NOT FUTR) NOT GRID) NOT SRINGBLK) NOT INDALL) NOT INSIDE NODRC
SETLAYER check_region = check_region_1 WITH WIDTH >= 50
SETLAYER check_pattern = ${metal_layer}ALLi AND check_region
SETLAYER err1_TMP1 = DENSITY check_pattern check_region \[!AREA(check_region) + !!AREA(check_region)*AREA(check_pattern)/AREA(check_region)\] < 0.10 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON 

SETLAYER check_window = WITH WIDTH (err1_TMP1 AND check_region) >= 50
OUTLAYER DENSITY check_pattern check_window \[!AREA(check_window) + !!AREA(check_window)*AREA(check_pattern)/AREA(check_window)\] < 0.10 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON PRINT ${metal_layer}_10_D_1_min.log RDB ${metal_layer}_D_1_min.rdb

}
}

RULECHECK ${metal_layer}_D_1_max {
@ Mn density (including dummy) in 100umX100um window with step size 50um. INDALL/FUTR/GRID/SRINGBLK covered areas are excluded for this rule checking
@ (Exclude DEUPAD region when when Mn as TM-1 in 1 top metal option) @ <= 80%

set M_inner_last M[expr $total_metal-$top_metal]
if { [string equal $top_metal 1] == 1 } {
if { [string equal $metal_layer $M_inner_last] == 1 } {
 
SETLAYER check_region_1 = (((((DRC:1 NOT FUTR) NOT GRID) NOT SRINGBLK) NOT INDALL) NOT DEUPAD) NOT INSIDE NODRC
SETLAYER check_region = check_region_1 WITH WIDTH >= 50
SETLAYER check_pattern = ${metal_layer}ALLi AND check_region
SETLAYER err1_TMP1 = DENSITY check_pattern check_region \[!!AREA(check_region)*AREA(check_pattern)/AREA(check_region)\] > 0.8 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON 

SETLAYER check_window = WITH WIDTH (err1_TMP1 AND check_region) >= 50
OUTLAYER DENSITY check_pattern check_window \[!!AREA(check_window)*AREA(check_pattern)/AREA(check_window)\] > 0.8 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON PRINT ${metal_layer}_D_1_max.log RDB ${metal_layer}_D_1_max.rdb

} else {
 
SETLAYER check_region_1 = ((((DRC:1 NOT FUTR) NOT GRID) NOT SRINGBLK) NOT INDALL) NOT INSIDE NODRC
SETLAYER check_region = check_region_1 WITH WIDTH >= 50
SETLAYER check_pattern = ${metal_layer}ALLi AND check_region
SETLAYER err1_TMP1 = DENSITY check_pattern check_region \[!!AREA(check_region)*AREA(check_pattern)/AREA(check_region)\] > 0.8 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON 

SETLAYER check_window = WITH WIDTH (err1_TMP1 AND check_region) >= 50
OUTLAYER DENSITY check_pattern check_window \[!!AREA(check_window)*AREA(check_pattern)/AREA(check_window)\] > 0.8 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON PRINT ${metal_layer}_D_1_max.log RDB ${metal_layer}_D_1_max.rdb

}
} else {
 
SETLAYER check_region_1 = ((((DRC:1 NOT FUTR) NOT GRID) NOT SRINGBLK) NOT INDALL) NOT INSIDE NODRC
SETLAYER check_region = check_region_1 WITH WIDTH >= 50
SETLAYER check_pattern = ${metal_layer}ALLi AND check_region
SETLAYER err1_TMP1 = DENSITY check_pattern check_region \[!!AREA(check_region)*AREA(check_pattern)/AREA(check_region)\] > 0.8 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON 

SETLAYER check_window = WITH WIDTH (err1_TMP1 AND check_region) >= 50
OUTLAYER DENSITY check_pattern check_window \[!!AREA(check_window)*AREA(check_pattern)/AREA(check_window)\] > 0.8 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON PRINT ${metal_layer}_D_1_max.log RDB ${metal_layer}_D_1_max.rdb

}
}

RULECHECK ${metal_layer}_D_2 {
@ Average density for Mn inside the dummy block area size 2.5um in 100umX100um window with step size 50um
@ when the dummy block area >= 100umX100um. INDALL/FUTR/GRID/SRINGBLK covered areas are excluded from this rule checking
@ Device sensitive areas can be waived. >= 10%
  SETLAYER X = DENSITY ${metal_layer}ALLi < 0.1 WINDOW 100 STEP 50 backup PRINT density_report_${metal_layer}_D_2.log
  SETLAYER Y = ((SIZE ${metal_layer}DUMB BY 2.5) OR SRBLK) NOT (OR INDALL FUTR GRID SRINGBLK)
  SETLAYER Z = SIZE Y BY 12.5 UNDEROVER
  OUTLAYER (X AND Z) NOT INSIDE NODRC
}

RULECHECK ${metal_layer}_D_3 {
@ The difference between Mn density in 100umX100um with step size 200um and those of the adjacent checking windows (including dummy)
@ INDALL/GRID/FUTR/SRINGBLK covered areas are excluded for this rule checking <= 20%
  SETLAYER X = DENSITY ${metal_layer}ALLi >= 0 WINDOW 200 GRADIENT > 0.20 ABSOLUTE BACKUP INSIDE OF LAYER density_checkarea PRINT density_report_${metal_layer}_D_3.log
  OUTLAYER ((((X NOT FUTR) NOT GRID) NOT SRINGBLK) NOT INDALL) NOT INSIDE NODRC
}

VERBATIM {
#ENDIF
}

RULECHECK ${metal_layer}_R_1 {
@ Mn line end must be rectangular.
  SETLAYER A = INT ${metal_layer} < 0.01 ABUT == 45 REGION
  SETLAYER B = EXT ${metal_layer} < 0.01 ABUT == 45 REGION
  SETLAYER C = INT ${metal_layer} < 0.01 ABUT == 135 REGION
  SETLAYER D = EXT ${metal_layer} < 0.01 ABUT == 135 REGION
  OUTLAYER A NOT INSIDE NODRC
  OUTLAYER B NOT INSIDE NODRC
  OUTLAYER C NOT INSIDE NODRC
  OUTLAYER D NOT INSIDE NODRC
}

  }
}


#***********************************************
# Vn: Via n (n=1, 2,3,4,5,6,7) design rules
#***********************************************


set via_list { V1 V2 V3 V4 V5 V6 V7 }
foreach via_layer $via_list {
  set tmp CHECK_$via_layer
  set tmp_v [set $tmp]

  if { $tmp_v == 1 } {
    GROUP G${via_layer} ${via_layer}_?
  set number [string index $via_layer 1]
  set bottom_metal M$number
  set up_metal M[expr $number +1]
#  set wide_metal

RULECHECK ${via_layer}_W_1 {
@ Fixed $via_layer size (square shape) is 0.09,exclude GRING OR SRINGBLK area
  OUTLAYER (NOT RECTANGLE $via_layer  == 0.09 BY == 0.09)  NOT INSIDE (OR GRID SRINGBLK NODRC)
}

RULECHECK ${via_layer}_W_2 {
@ Fixed $via_layer width(datatype 13) is 0.09,exclude EFUSEALL OR SRAMALL OR FUSEALL area
  OUTLAYER (WITH WIDTH ${via_layer}bar < 0.09 ) INSIDE (OR SRAMALL EFUSEALL FUSEALL)
  OUTLAYER (WITH WIDTH ${via_layer}bar > 0.09 ) INSIDE (OR SRAMALL EFUSEALL FUSEALL)
}

RULECHECK ${via_layer}_S_1 {
@ Space between two $via_layer is 0.11
  OUTLAYER (EXT $via_layer < 0.11 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK ${via_layer}_S_2 {
@ Space between ${via_layer}s between VIA and 3-neighboring  VIAs whose space is < 0.14um.  >= 0.13.
  SETLAYER X = SIZE $via_layer BY 0.07 OVERUNDER
  SETLAYER Y = SIZE X BY 0.340 UNDEROVER
  SETLAYER Z = $via_layer INSIDE Y
  OUTLAYER (EXT Z < 0.13 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK ${via_layer}_S_3 {
@ Minimum Space between two neighbor ${via_layer}s (different net and run length>0) >= 0.13um.
  OUTLAYER (EXT $via_layer < 0.13 ABUT<90 OPPOSITE REGION NOT CONNECTED) NOT INSIDE NODRC
}

RULECHECK ${via_layer}_EN_2a_2b_2c {
@ Vn must be fully enclosed by Mn >= 0
@ Min $bottom_metal enclosure of $via_layer for two opposite sides >=0.04
@ Vn must be fully enclosed by Mn/Mn+1 all sides >=0.03
 SETLAYER  X = RECTANGLE ENC $via_layer $bottom_metal ABUT<90 OUTSIDE ALSO \
            GOOD 0 0.04 OPPOSITE 0 0.04 OPPOSITE GOOD 0.03 0.03 0.03 0.03 OPPOSITE
  OUTLAYER X NOT INSIDE NODRC
  OUTLAYER ($via_layer NOT $bottom_metal) NOT INSIDE NODRC 

 SETLAYER  X1 = RECTANGLE ENC $via_layer $up_metal ABUT<90 OUTSIDE ALSO \
            GOOD 0 0.04 OPPOSITE 0 0.04 OPPOSITE GOOD 0.03 0.03 0.03 0.03 OPPOSITE
  OUTLAYER X1 NOT INSIDE NODRC
  OUTLAYER ($via_layer NOT $up_metal) NOT INSIDE NODRC 
}

VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK ${via_layer}_2a_R_2b_R {
@ Vn must be fully enclosed by Mn >= 0.04
@ Min $bottom_metal enclosure of $via_layer for two opposite sides >=0.07
@ Vn must be fully enclosed by Mn/Mn+1 all sides >=0.03
 SETLAYER  X = RECTANGLE ENC $via_layer $bottom_metal ABUT<90 OUTSIDE ALSO \
            GOOD 0.04 0.07 OPPOSITE 0.04 0.07 OPPOSITE GOOD 0.03 0.03 0.03 0.03 OPPOSITE 
 OUTLAYER  X NOT INSIDE NODRC  
  OUTLAYER ($via_layer NOT $bottom_metal) NOT INSIDE NODRC 

 SETLAYER  X1 = RECTANGLE ENC $via_layer $up_metal ABUT<90 OUTSIDE ALSO \
            GOOD 0.04 0.07 OPPOSITE 0.04 0.07 OPPOSITE GOOD 0.03 0.03 0.03 0.03 OPPOSITE 
 OUTLAYER  X1 NOT INSIDE NODRC
  OUTLAYER ($via_layer NOT $up_metal) NOT INSIDE NODRC 
}
VERBATIM {
#ENDIF
}

RULECHECK ${via_layer}_EN_5a_5b {
@ Vn must be fully enclosed by Mn+1
@ Min $up_metal enclsoure of $via_layer is 0.005
@ Min $up_metal enclosure of $via_layer is 0.02 when $up_metal enclosure on one or both perpendicular directions<0.02um
SETLAYER  X = RECTANGLE ENC $via_layer $up_metal ABUT<90 OUTSIDE ALSO \
                GOOD 0.005 OPPOSITE 0.02 OPPOSITE 0.005 OPPOSITE 0.02 OPPOSITE
  OUTLAYER (ENC X $up_metal < 0.005 ABUT<90 SINGULAR REGION OVERLAP OUTSIDE ALSO) NOT INSIDE NODRC
  SETLAYER Y = ENC \[X\] $up_metal < 0.02 OPPOSITE
  OUTLAYER (INT Y < 0.01 ABUT==90 INTERSECTING ONLY REGION) NOT INSIDE NODRC
  OUTLAYER ($via_layer NOT $up_metal) NOT INSIDE NODRC

  }


VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK ${via_layer}_R_1_R {
@ There should be at least two ${via_layer}s in the $bottom_metal and $up_metal intersection area when either or both $bottom_metal and $up_metal with width >= 0.5um
@ There should be at least two ${via_layer}s in the $bottom_metal and $up_metal intersection area when either or both $bottom_metal and $up_metal 
@ connected with metal line of width>=0.5um and space between $via_layer and wider metal edge <0.5um
@ NOTICE: It is a recommended rule.

  SETLAYER  X = SIZE ($bottom_metal WITH WIDTH >= 0.5) BY 0.499 INSIDE OF $bottom_metal STEP 0.01
  SETLAYER  S$via_layer = $via_layer INTERACT S${via_layer}_metal
  OUTLAYER  (S${via_layer}_metal ENCLOSE (((S$via_layer INTERACT X) NOT LOGO) NOT GRID)) NOT INSIDE NODRC
  SETLAYER  Y = SIZE ($up_metal WITH WIDTH >= 0.5) BY 0.499 INSIDE OF $up_metal STEP 0.01
  OUTLAYER  (S${via_layer}_metal ENCLOSE (((S$via_layer INTERACT Y) NOT LOGO) NOT GRID)) NOT INSIDE NODRC
}
VERBATIM {
#ENDIF
}

RULECHECK ${via_layer}_R_2a_2b {
@ There should be at least two Vns at the intersection of Mn and Mn+1 when either Mn or Mn+1 width >= 0.3um
@ There should be at least 4 Vns at the intersection of Mn and Mn+1, if either Mn or Mn+1 is connected to a metal line with width d>=0.7um and space c<0.2um (space between Vns at the intersection and the wide metal)
  SETLAYER X = SIZE (($bottom_metal AND $up_metal) WITH WIDTH >= 0.3) BY 0.199 INSIDE OF ($bottom_metal AND $up_metal) STEP 0.01
  SETLAYER S${via_layer} = $via_layer INTERACT S${via_layer}_metal
  OUTLAYER (S${via_layer}_metal ENCLOSE (((S$via_layer INTERACT X) NOT LOGO) NOT GRID)) NOT INSIDE NODRC

  SETLAYER X1 = SIZE (($bottom_metal AND $up_metal) WITH WIDTH >= 0.7) BY 0.199 INSIDE OF ($bottom_metal AND $up_metal) STEP 0.01
  SETLAYER U4$via_layer = $via_layer INTERACT U4${via_layer}_metal
  OUTLAYER (U4${via_layer}_metal ENCLOSE (((U4${via_layer} INTERACT X1) NOT LOGO) NOT GRID)) NOT INSIDE NODRC
}

RULECHECK ${via_layer}_R_5 {
@ 45-dgree rotated via is not allowed
OUTLAYER ANGLE $via_layer == 45
}

}

}


SETLAYER TMP = AA AND PO
#------------------------for via stack------------------------
for {set j 1} { $j < [expr $total_metal - $top_metal ] } {incr j} {
  SETLAYER V${j}N_M = V${j}N INTERACT st_${j}
  SETLAYER st_${j} = (M${j} AND M[expr $j+1]) ENCLOSE V${j} == 1
  SETLAYER V${j}N = V${j} AND (RECTANGLE V${j} == 0.09 BY == 0.09)
  SETLAYER RV${j} = V${j} AND (RECTANGLE V${j} ASPECT != 1)
#--------------------------------------------------------------------------
RULECHECK V${j}_R_3 {
@ Single Vn is not allowed in "H-shape" Mn+1 when:
@ 1) The Mn+1 has "H-shape" metal interact with two metal holes: both two metal holes' length (L2) <= 5um and area <= 5um2.
@ 2) The Vn overlaps on the center metal bar of this "H-shape" Mn+1
@ 3) The center metal bar has the length (L) <= 1um and the width <= 3um
  via_in_H_bar V${j}N M[expr $j +1] 5 5 1 3
  OUTLAYER (Z INTERACT V${j}N == 1) NOT INSIDE NODRC
}
if { [expr $total_metal - $top_metal -1 -$j -4] >= 0} {

VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK V${j}_R_4_R {
@ Single vias stacked by more than 4 layers are not allowed. <=4
  SETLAYER X = V${j}N_M INTERACT (V[expr $j +1]N_M INTERACT (V[expr $j +2]N_M INTERACT (V[expr $j +3]N_M INTERACT V[expr $j +4]N_M)))
  OUTLAYER X NOT INSIDE NODRC
}
VERBATIM {
#ENDIF
}
}

#----stack end-----
}

#=======================
#  T4V1 - Top Via 1a DRC
#=======================


if { [set CHECK_T4V1] == 1 } {
  set bottom_metal_list { M8 M7 M6 M5 M4 M3 }
  foreach bottom_metal $bottom_metal_list {
    set tmp CHECK_$bottom_metal
    set tem_v [set $tmp]
    if { $tem_v == 1 } break
  }
  
GROUP GT4V1 T4V1_?

RULECHECK T4V1_W_1 {
@ Fixed T4V1 size (square shape),exclude GRDID and SRINGBLK region = 0.36
  OUTLAYER  ((NOT RECTANGLE (T4V1 NOT GT4V1) == 0.36 BY == 0.36) NOT GRID) NOT INSIDE (SRINGBLK OR NODRC)
  OUTLAYER  (NOT RECTANGLE (RECTANGLE (T4V1 AND GRID)) == 0.36 BY == 0.36 ) NOT INSIDE (SRINGBLK OR NODRC)
}

RULECHECK T4V1_W_2 {
@ Fixed T4V1bar width  = 0.36
 OUTLAYER T4V1bar WITH WIDTH < 0.36
 OUTLAYER T4V1bar WITH WIDTH > 0.36
}

RULECHECK T4V1_S_1 {
@ Min Space between two T4V1s >= 0.34
  OUTLAYER  (EXT T4V1 < 0.34 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK T4V1_S_2 {
@ Min Space between T4V1s within array greater or equal to 3x3 (Two via regions whose space is <= 0.56um are considered to be in the same array) >= 0.5

  SETLAYER  X = SIZE T4V1 BY 0.28 OVERUNDER
  SETLAYER  Y = SIZE X BY 0.855 UNDEROVER
  SETLAYER  Z = T4V1 INSIDE Y
  OUTLAYER  (EXT Z < 0.5 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK T4V1_EN_2_EN_3 {
@ Min $bottom_metal fully enclosure of T4V1 ($bottom_metal is Metal layer directly underneath T4V1) >= 0.01
@ Min $bottom_metal enclosure of T4V1, when $bottom_metal enclosure on one or both perpendicular directions< 0.05um ($bottom_metal is Metal layer directly underneath T4V1) >= 0.05 
SETLAYER  X = RECTANGLE ENC T4V1 $bottom_metal ABUT<90 OUTSIDE ALSO \
  GOOD 0.01 OPPOSITE 0.05 OPPOSITE 0.01 OPPOSITE 0.05 OPPOSITE
  OUTLAYER  (ENC X $bottom_metal < 0.01 ABUT<90 SINGULAR REGION OVERLAP OUTSIDE ALSO) NOT INSIDE NODRC
  SETLAYER  Y = ENC \[X\] $bottom_metal < 0.05 OPPOSITE
  OUTLAYER  (INT Y < 0.01 ABUT==90 REGION INTERSECTING ONLY) NOT INSIDE NODRC
  OUTLAYER  (T4V1 NOT $bottom_metal) NOT INSIDE NODRC
}
RULECHECK T4V1_EN_5_EN_6 {
@ T4V1 must be fully covered by T4M1.
@ Min T4M1 fully enclosure of T4V1  >= 0.02
  OUTLAYER  (ENC T4V1 T4M1 < 0.02 ABUT < 90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE NODRC
}

VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK T4V1_R_1_R {
@ There should be at least two square T4V1s at the intersection of Mn and T4M1 when either Mn or T4M1 width,exclude GRBLK and SRINGBLK region >= 0.5um
SETLAYER T4V1_SQ = RECTANGLE T4V1 ASPECT == 1
SETLAYER X1_Mn = $bottom_metal ENCLOSE ($bottom_metal WITH WIDTH >= 0.5)
SETLAYER X1_T4M1 = T4M1 ENCLOSE (T4M1 WITH WIDTH >= 0.5)
SETLAYER T4M1Mn = $bottom_metal AND T4M1
SETLAYER X1 = X1_Mn OR X1_T4M1
OUTLAYER ((T4M1Mn INTERACT T4V1_SQ == 1) INTERACT X1) NOT INSIDE (OR SRINGBLK NODRC GRBLK)
}
VERBATIM {
#ENDIF
}
RULECHECK T4V1_R_3 {
@ 45-dgree T4V1 is not allowed
OUTLAYER ANGLE T4V1 == 45
}

VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK T4V1_R_4_R {
@ Recommended us redundant T4V1s as possible, DRC can help to flag single T4V1
OUTLAYER ($bottom_metal AND T4M1) INTERACT T4V1 == 1
}

VERBATIM {
#ENDIF
}


#=========================
#  T4M1 - Top Metal 1a DRC
#=========================

GROUP GT4M1 T4M1_?

RULECHECK T4M1_W_1 {
@ T4M1 width >= 0.40um
@ T4M1 width <= 20um
@ DRC doesn't check DEUPAD and INDALL region
  OUTLAYER (INT T4M1 < 0.40 ABUT<90 SINGULAR REGION) NOT INSIDE (OR INDALL DEUPAD NODRC)
  OUTLAYER (T4M1 WITH WIDTH > 20) NOT INSIDE (OR INDALL DEUPAD NODRC)
}

RULECHECK T4M1_S_1 {
@ Min Space between two T4M1s is 0.40um,DRC waive check 89 to 90 degree spaces in the INDALL region.
  OUTLAYER ((EXT T4M1 < 0.40 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
  OUTLAYER ((EXT T4M1 < 0.40 ABUT<89 SINGULAR REGION) AND INDALL) NOT INSIDE NODRC
}

RULECHECK T4M1_S_2 {
@ Min Space between two T4M1s when one or both T4M1 width or length >=2um, and the run length of two T4M1s is >= 2um. >= 0.5um 
  Mn_2b T4M1ALL 2 2 0.5
}

RULECHECK T4M1_A_1 {
@ T4M1 area >= 0.40
  OUTLAYER (AREA T4M1 < 0.40) NOT INSIDE NODRC
}

RULECHECK T4M1_A_2 {
@ Min Enclosed area by T4M1 is 0.6
  SETLAYER X = (HOLES T4M1 INNER) NOT T4M1
  OUTLAYER (AREA X < 0.6) NOT INSIDE NODRC
}

VERBATIM {
#IFDEF Density_rules YES
}
RULECHECK T4M1_D_1_min {
@ T4M1 density (including dummy) in 100umX100um window with step size 100um >= 20%  
@ INDALL/FUTR/GRID/SRINGBLK covered areas are excluded for this rule checking. 
@ (Top metal bond pad areas and DEUPAD regions can be waived.)
  SETLAYER X1 = T4M1ALLi NOT DEUPAD
  SETLAYER X = DENSITY X1 < 0.20 WINDOW 100 STEP 50 backup INSIDE OF LAYER density_checkarea PRINT density_report_T4M1__D_1_min.log
  SETLAYER Y = OR FUTR GRID SRINGBLK PA INDALL
  OUTLAYER (X NOT Y) NOT INSIDE NODRC
}


RULECHECK T4M1_D_1_max {
@ T4M1 density (including dummy) in 100umX100um window with step size 100um <= 85%. 
@ INDALL/FUTR/GRID/SRINGBLK covered areas are excluded for this rule checking. 
@ (Top metal bond pad areas can be waived.)
  SETLAYER X1 = T4M1ALLi NOT DEUPAD
  SETLAYER X = DENSITY X1 > 0.85 WINDOW 100 STEP 50 backup INSIDE OF LAYER density_checkarea PRINT density_report_T4M1_D_1_max.log
  SETLAYER Y = OR FUTR GRID SRINGBLK PA INDALL
  OUTLAYER (X NOT Y) NOT INSIDE NODRC
}

RULECHECK T4M1_D_2 {
@ T4M1 density inside (T4M1dumb sizing up 2.5um) in 100umX100um window with step size 100um >= 10%  
  SETLAYER CHECK_AREA = SIZE T4M1DUMB BY 2.5
  SETLAYER X1 = T4M1ALLi NOT DEUPAD
  SETLAYER X = DENSITY X1 < 0.10 WINDOW 100 STEP 50 backup INSIDE OF LAYER CHECK_AREA PRINT density_report_T4M1_D_2.log
  SETLAYER Y = OR FUTR GRID SRINGBLK PA INDALL
  OUTLAYER (X NOT Y) NOT INSIDE NODRC
}


RULECHECK T4M1_D_3 {
@ T4M1 density difference in 100umX100um window <= 20%. 
@ INDALL/FUTR/GRID/SRINGBLK covered areas are excluded for this rule checking. 
  SETLAYER X1 = T4M1ALLi NOT DEUPAD
  SETLAYER X = DENSITY X1 >0 WINDOW 100 GRADIENT > 0.2  ABSOLUTE BACKUP INSIDE OF LAYER density_checkarea PRINT density_report_T4M1_D_3.log
  SETLAYER Y = OR FUTR GRID SRINGBLK PA INDALL
  OUTLAYER (X NOT Y) NOT INSIDE NODRC
}

VERBATIM {
#ENDIF
}

RULECHECK T4M1_R_1 {
@ T4M1 line end must be rectangular.
  SETLAYER A = INT T4M1 < 0.01 ABUT == 45 REGION
  SETLAYER B = EXT T4M1 < 0.01 ABUT == 45 REGION
  SETLAYER C = INT T4M1 < 0.01 ABUT == 135 REGION
  SETLAYER D = EXT T4M1 < 0.01 ABUT == 135 REGION
  OUTLAYER A NOT INSIDE NODRC
  OUTLAYER B NOT INSIDE NODRC
  OUTLAYER C NOT INSIDE NODRC
  OUTLAYER D NOT INSIDE NODRC
  }

}


#---------------------------------------------------------------------------------------------------------------------------------------------------

#=====================================================
#  Special offering for 2X design rule T2V1-T2M1
#=====================================================


#==========================
#  T2V1 - Top Via T2V1 DRC
#==========================


if { [set CHECK_T2V1] == 1 } {
  set bottom_metal_list { M8 M7 M6 M5 M4 M3 }
  foreach bottom_metal $bottom_metal_list {
    set tmp CHECK_$bottom_metal
    set tem_v [set $tmp]
    if { $tem_v == 1 } break
  }
  
GROUP GT2V1 T2V1_?

RULECHECK T2V1_W_1 {
@ Fixed T2V1 size (square shape) except guard ring and seal ring application is 0.2
  OUTLAYER  ((NOT RECTANGLE (T2V1 NOT GT2V1) == 0.2 BY == 0.2) NOT GRID) NOT INSIDE NODRC
  OUTLAYER  (NOT RECTANGLE (RECTANGLE (T2V1 AND GRID)) == 0.2 BY == 0.2 ) NOT INSIDE NODRC
}

RULECHECK T2V1_W_2 {
@ Fixed T2V1bar width = 0.2
OUTLAYER T2V1bar WITH WIDTH < 0.2
OUTLAYER T2V1bar WITH WIDTH >0.2
}

RULECHECK T2V1_S_1 {
@ Space between T2V1s >= 0.2
  OUTLAYER  (EXT T2V1 < 0.2 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK T2V1_S_2 {
@ Min Space between T2V1s and 3-neighboring T2V1s space is <= 0.28um. >= 0.25
  SETLAYER  X = SIZE T2V1 BY 0.15 OVERUNDER
  SETLAYER  Y = SIZE X BY 0.455 UNDEROVER
  SETLAYER  Z = T2V1 INSIDE Y
  OUTLAYER  (EXT Z < 0.25 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK T2V1_EN_2a_EN_2b {
@ T2V1 must be fully enclosed by $bottom_metal.
@ $bottom_metal enclosure of T2V1 ($bottom_metal is Metal layer directly underneath T2V1) >= 0
@ $bottom_metal enclosure of T2V1 when $bottom_metal enclosure on one or both perpendicular directions< 0.05um ($bottom_metal is Metal layer directly underneath T2V1). >= 0.05 
 
   SETLAYER X = RECTANGLE ENC (T2V1 NOT TOUCH $bottom_metal) $bottom_metal ABUT < 90 OUTSIDE ALSO \
   GOOD 0 0.05 OPPOSITE 0 0.05 OPPOSITE


   SETLAYER A = ENC \[X\] $bottom_metal < 0.05 OPPOSITE
   SETLAYER D1 = INT A < 0.01 ABUT==90 INTERSECTING ONLY REGION
   OUTLAYER D1 NOT INSIDE NODRC

   SETLAYER B = T2V1 COIN EDGE $bottom_metal
   SETLAYER D2 = INT B < 0.01 ABUT==90 REGION
   OUTLAYER D2 NOT INSIDE NODRC

   
   SETLAYER Y = ENC T2V1 $bottom_metal< 0.05 OPPOSITE REGION
   SETLAYER C1 = T2V1 COIN EDGE $bottom_metal 
   SETLAYER C2 = T2V1 COIN EDGE Y
   SETLAYER D3 = INT C1 C2 < 0.01 ABUT==90 REGION
   OUTLAYER D3 NOT INSIDE NODRC
   
   OUTLAYER (T2V1 NOT $bottom_metal) NOT INSIDE NODRC  
}

VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK T2V1_EN_2a_R_EN_2b_R {
@ Recommended enclosure by Mn to avoid high Rc >= 0.05
@ Recommended enclosure by Mn for at least 2 opposite sides >= 0.08
   SETLAYER X = RECTANGLE ENC T2V1 $bottom_metal ABUT < 90 OUTSIDE ALSO \
   GOOD 0.05 0.08 OPPOSITE 0.05 0.08 OPPOSITE
   COPY X
}

VERBATIM {
#ENDIF
}

RULECHECK T2V1_EN_4a_EN_4b {
@ T2V1 must be fully enclosed by T2M1.
@ Enclosed by T2M1 >=  0
@ Enclosed by T2M1 when T2M1 enclosure on one or both perpendicular directions< 0.05um. >= 0.05 

  SETLAYER X = RECTANGLE ENC T2V1 T2M1 ABUT < 90 OUTSIDE ALSO \
               GOOD 0.0 0.05 OPPOSITE 0.0 0.05 OPPOSITE       
 
  OUTLAYER X NOT INSIDE NODRC

  SETLAYER Y = ENC \[X\] T2M1 < 0.05 OPPOSITE
  SETLAYER D2 = INT Y < 0.01 ABUT==90 INTERSECTING ONLY REGION
  OUTLAYER D2 NOT INSIDE NODRC
  OUTLAYER (T2V1 NOT T2M1) NOT INSIDE NODRC
 }

RULECHECK T2V1_R_1 {
@ There should be at least two square T2V1s space <= 0.4um for Mn and T2M1 connection when either or both Mn (Mn is Metal layer directly underneath T2V1) and T2M1 width is > 0.6um.
SETLAYER T2V1_SQ_CHECK = RECTANGLE T2V1 ASPECT == 1
SETLAYER T2V1_SQ_REG = EXT T2V1_SQ_CHECK <=0.4 SINGULAR REGION
SETLAYER T2V1_SQ_CHECK_VIA = T2V1_SQ_CHECK INTERACT T2V1_SQ_REG
SETLAYER T2V1_SQ = T2V1_SQ_CHECK_VIA OR T2V1_SQ_REG
SETLAYER X1_Mn = $bottom_metal ENCLOSE ($bottom_metal WITH WIDTH > 0.6)
SETLAYER X1_T2M1 = T2M1 ENCLOSE (T2M1 WITH WIDTH > 0.6)
SETLAYER T2M1Mn = $bottom_metal AND T2M1
SETLAYER X1 = X1_Mn OR X1_T2M1
OUTLAYER (T2M1Mn INTERACT T2V1_SQ == 1) INTERACT X1
}

RULECHECK T2V1_R_2 {
@ There should be at least four square T2V1s in this Mn and T2M1 intersection area when either or both Mn (Mn is Metal layer directly underneath T2V1) and T2M1 width is > 1.4um.
SETLAYER T2V1_SQ_CHECK = RECTANGLE T2V1 ASPECT == 1
SETLAYER T2V1_SQ = RECTANGLE T2V1 ASPECT == 1
SETLAYER T2V1_SQ_REG = EXT T2V1_SQ_CHECK <=0.4 SINGULAR REGION
SETLAYER T2V1_SQ_CHECK_VIA = T2V1_SQ_CHECK INTERACT T2V1_SQ_REG
SETLAYER X1_Mn = $bottom_metal ENCLOSE ($bottom_metal WITH WIDTH > 1.4)
SETLAYER X1_T2M1 = T2M1 ENCLOSE (T2M1 WITH WIDTH > 1.4)
SETLAYER T2M1Mn = $bottom_metal AND T2M1
SETLAYER X1 = X1_Mn OR X1_T2M1
OUTLAYER (T2M1Mn INTERACT T2V1_SQ_CHECK_VIA < 4) INTERACT X1
}

RULECHECK T2V1_R_3 {
@ 45-dgree T2V1 is not allowed
OUTLAYER ANGLE T2V1 == 45
}

VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK T2V1_R_4_R {
@ Recommended us redundant T2V1s as possible, DRC can help to flag single T4V1
OUTLAYER ($bottom_metal AND T2M1) INTERACT T2V1 == 1
}

VERBATIM {
#ENDIF
}

#=============================
#  T2M1 - Top Metal T2M1 DRC
#=============================

GROUP GT2M1 T2M1_?


RULECHECK T2M1_W_1 {
@ T2M1 width >= 0.20
@ Max T2M1 width is 10,except DEUPAD and INDALL region.
@ Exclude top metal bond pad and INDALL and DEUPAD regions.
  SETLAYER X = (T2M1 NOT DEUPAD) NOT PA
  OUTLAYER ((X WITH WIDTH > 10) NOT INDALL) NOT INSIDE NODRC
  OUTLAYER (INT T2M1 < 0.2 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK T2M1_W_2 {
@ 45 dgree T2M1 width >= 0.39
SETLAYER X = ANGLE T2M1 == 45
OUTLAYER INT X < 0.39 ABUT < 90 REGION
}

RULECHECK T2M1_W_3 {
@ Minimum T2M1 width adjoining a huge non-metal region \[ area > 2000000 um2\], non-metal region is defined as (NOT (T2M1 OR T2M1DUM)) >= 0.35um
  SETLAYER NON_METAL_REG = AREA (DRC:1 NOT (OR T2M1 T2M1DUM)) > 2000000 
  SETLAYER CHECK_REGION = ENCLOSE RECTANGLE NON_METAL_REG 10 0.35
  SETLAYER CHECK_METAL = T2M1 INTERACT CHECK_REGION 
  OUTLAYER (INT CHECK_METAL < 0.35 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK T2M1_S_1 {
@ Space between T2M1s, DRC waive check 89 to 90 degree spaces in the INDALL region.>= 0.20
  OUTLAYER ((EXT T2M1 < 0.20 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
  OUTLAYER ((EXT T2M1 < 0.20 ABUT<89 SINGULAR REGION) AND INDALL) NOT INSIDE NODRC
#  OUTLAYER EXT T2M1 T2M1DUM < 0.20 REGION
#  OUTLAYER EXT T2M1DUM < 0.20 REGION
}

RULECHECK T2M1_S_2 {
@ Space between two T2M1s when one or both T2M1 width or length >= 0.39um, and the run length of two T2M1s is >= 1um. >= 0.24 
  Mn_2b T2M1ALL 1 0.39 0.24
}

RULECHECK T2M1_S_3 {
@ Space between two T2M1s when one or both T2M1 width or length >= 1.5um, and the run length of two T2M1s is >= 1.5um >= 0.50 
  Mn_2b T2M1ALL 1.5 1.5 0.5
}

RULECHECK T2M1_S_4 {
@ Space between two T2M1s when one or both T2M1 width or length >= 4.5um, and the run length of two T2M1s is >= 4.5um >= 1.50 
  Mn_2b T2M1ALL 4.5 4.5 1.5
}

RULECHECK T2M1_S_5 {
@ Min Space between T2M1 metal lines with one or both are 45 degree bent metal lines >= 0.39
  SETLAYER X = ANGLE T2M1 == 45
  OUTLAYER (EXT X T2M1 < 0.39 ABUT<90 REGION) NOT INSIDE NODRC
}

RULECHECK T2M1_A_1 {
@ T2M1 area >= 0.14
  OUTLAYER (AREA T2M1 < 0.14) NOT INSIDE NODRC
}

RULECHECK T2M1_A_2 {
@ T2M1 enclosed area >= 0.26
  SETLAYER X = (HOLES T2M1 INNER) NOT T2M1  
  OUTLAYER (AREA X < 0.26) NOT INSIDE NODRC
}


VERBATIM {
#IFDEF Density_rules YES
}
RULECHECK T2M1_D_1_min {
@ T2M1 density (including dummy) in 100umX100um window with step size 50um is >= 10% and <= 80%. 
@ INDALL/FUTR/GRID/SRINGBLK covered areas are excluded for this rule checking. 
@ (Top metal bond pad areas and DEUPAD region can be waived.)

SETLAYER check_region_1 = ((((((DRC:1 NOT FUTR) NOT GRID) NOT SRINGBLK) NOT INDALL) NOT PA) NOT DEUPAD) NOT INSIDE NODRC
SETLAYER check_region = check_region_1 WITH WIDTH >= 25
SETLAYER check_pattern = T2M1ALLi AND check_region
SETLAYER err1_TMP1 = DENSITY check_pattern check_region \[!AREA(check_region) + !!AREA(check_region)*AREA(check_pattern)/AREA(check_region)\] < 0.1 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON 

SETLAYER check_window = WITH WIDTH (err1_TMP1 AND check_region) >= 25
OUTLAYER DENSITY check_pattern check_window \[!AREA(check_window) + !!AREA(check_window)*AREA(check_pattern)/AREA(check_window)\] < 0.1 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON PRINT T2M1_D_1_min.log RDB T2M1_D_1_min.rdb

}

RULECHECK T2M1_D_1_max {
@ T2M1 density (including dummy) in 100umX100um window with step size 50um is >= 10% and <= 80%. 
@ INDALL/FUTR/GRID/SRINGBLK covered areas are excluded for this rule checking. 
@ (Top metal bond pad areas and DEUPAD region can be waived.)

SETLAYER check_region_1 = ((((((DRC:1 NOT FUTR) NOT GRID) NOT SRINGBLK) NOT INDALL) NOT PA) NOT DEUPAD) NOT INSIDE NODRC
SETLAYER check_region = check_region_1 WITH WIDTH >= 25
SETLAYER check_pattern = T2M1ALLi AND check_region
SETLAYER err1_TMP1 = DENSITY check_pattern check_region \[!!AREA(check_region)*AREA(check_pattern)/AREA(check_region)\] > 0.8 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON 

SETLAYER check_window = WITH WIDTH (err1_TMP1 AND check_region) >= 25
OUTLAYER DENSITY check_pattern check_window \[!!AREA(check_window)*AREA(check_pattern)/AREA(check_window)\] > 0.8 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON PRINT T2M1_D_1_max.log RDB T2M1_D_1_max.rdb

}

RULECHECK T2M1_D_2 {
@ T4M1 density inside (T2M1dumb sizing up 2.5um) in 100umX100um window with step size 50um >= 10%  
  SETLAYER CHECK_AREA = SIZE T2M1DUMB BY 2.5
  SETLAYER X1 = T2M1ALLi NOT DEUPAD
  SETLAYER X = DENSITY X1 < 0.10 WINDOW 100 STEP 50 backup INSIDE OF LAYER CHECK_AREA PRINT density_report_T2M1_D_2.log
  SETLAYER Y = OR FUTR GRID SRINGBLK PA INDALL
  OUTLAYER (X NOT Y) NOT INSIDE NODRC
}


RULECHECK T2M1_D_3 {
@ T2M1 density difference in 100umX100um window <= 20%. 
@ INDALL/FUTR/GRID/SRINGBLK covered areas are excluded for this rule checking. 
  SETLAYER X1 = T2M1ALLi NOT DEUPAD
  SETLAYER X = DENSITY X1 >0 WINDOW 100 GRADIENT > 0.2  ABSOLUTE BACKUP INSIDE OF LAYER density_checkarea PRINT density_report_T2M1_D_3.log
  SETLAYER Y = OR FUTR GRID SRINGBLK PA INDALL
  OUTLAYER (X NOT Y) NOT INSIDE NODRC
}


VERBATIM {
#ENDIF
}

RULECHECK T2M1_R_1 {
@ T2M1 line end must be rectangular.
  SETLAYER A = INT T2M1 < 0.01 ABUT == 45 REGION
  SETLAYER B = EXT T2M1 < 0.01 ABUT == 45 REGION
  SETLAYER C = INT T2M1 < 0.01 ABUT == 135 REGION
  SETLAYER D = EXT T2M1 < 0.01 ABUT == 135 REGION
  OUTLAYER A NOT INSIDE NODRC
  OUTLAYER B NOT INSIDE NODRC
  OUTLAYER C NOT INSIDE NODRC
  OUTLAYER D NOT INSIDE NODRC
 }

}


#=====================================================
#  Special offering for 2X design rule T2V2-T2M2
#=====================================================


#==========================
#  T2V2 - Top Via T2V2 DRC
#==========================


if { [set CHECK_T2V2] == 1 } {
  set bottom_metal_list {T2M1 }
  foreach bottom_metal $bottom_metal_list {
    set tmp CHECK_$bottom_metal
    set tem_v [set $tmp]
    if { $tem_v == 1 } break
  }
  
GROUP GT2V2 T2V2_?

RULECHECK T2V2_W_1 {
@ Fixed T2V1 (square shape) size ,exclude SRINGBLK and GRBLK area  = 0.2
  OUTLAYER  ((NOT RECTANGLE (T2V2 NOT GT2V2) == 0.2 BY == 0.2) NOT GRID) NOT INSIDE (SRINGBLK OR NODRC)
  OUTLAYER  (NOT RECTANGLE (RECTANGLE (T2V2 AND GRID)) == 0.2 BY == 0.2) NOT INSIDE (SRINGBLK OR NODRC)
}

RULECHECK T2V2_W_2 {
@ Fixed T2V2bar width = 0.2
OUTLAYER T2V2bar WITH WIDTH < 0.2
OUTLAYER T2V2bar WITH WIDTH >0.2
}

RULECHECK T2V2_S_1 {
@ Space between two T2V2s >= 0.2
  OUTLAYER  (EXT T2V2 < 0.2 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK T2V2_S_2 {
@ Space between T2V2 and neighboring T2V2s with space < 0.28um. >= 0.25
  SETLAYER  X = SIZE T2V2 BY 0.14 OVERUNDER
  SETLAYER  Y = SIZE X BY 0.655 UNDEROVER
  SETLAYER  Z = T2V2 INSIDE Y
  OUTLAYER  (EXT Z < 0.25 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK T2V2_EN_2a_EN_2b {
@ T2V2 must be fully enclosed by T2M1.
@ Enclosed by $bottom_metal ($bottom_metal is Metal layer directly underneath T2V2) >= 0
@ Enclosed by $bottom_metal when $bottom_metal enclosure on one or both perpendicular directions< 0.05um ($bottom_metal is Metal layer directly underneath T2V2). >= 0.05
  SETLAYER X = RECTANGLE ENC (T2V2 NOT TOUCH $bottom_metal) $bottom_metal ABUT < 90 OUTSIDE ALSO \
               GOOD 0 0.05 OPPOSITE 0 0.05 OPPOSITE   
  
  SETLAYER A = ENC \[X\] $bottom_metal < 0.05 OPPOSITE
  SETLAYER D1 = INT A < 0.01 ABUT==90 INTERSECTING ONLY REGION
  OUTLAYER D1 NOT INSIDE NODRC

  SETLAYER B = T2V2 COIN EDGE $bottom_metal
  SETLAYER D2 = INT B < 0.01 ABUT==90 REGION
  OUTLAYER D2 NOT INSIDE NODRC

  SETLAYER Y = ENC T2V2 $bottom_metal < 0.05 OPPOSITE REGION
  SETLAYER C1 = T2V2 COIN EDGE $bottom_metal
  SETLAYER C2 = T2V2 COIN EDGE Y
  SETLAYER D3 = INT C1 C2 < 0.01 ABUT==90 REGION
  OUTLAYER D3 NOT INSIDE NODRC

  OUTLAYER (T2V2 NOT $bottom_metal) NOT INSIDE NODRC 
}

VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK T2V2_EN_2a_R_EN_2b_R {
@ Recommended enclosure by Mn to avoid high Rc >= 0.05
@ Recommended enclosure by Mn for at least 2 opposite sides >= 0.08
   SETLAYER X = RECTANGLE ENC T2V2 $bottom_metal ABUT < 90 OUTSIDE ALSO \
   GOOD 0.05 0.08 OPPOSITE 0.05 0.08 OPPOSITE
   COPY X
}

VERBATIM {
#ENDIF
}

RULECHECK T2V2_EN_4a_EN_4b {
@ T2V2 must be fully enclosed by T2M2.
@ Enclosed by T2M1  >= 0
@ Enclosed By T2M1 when T2M2 enclosure on one or both perpendicular directions< 0.05um. >= 0.05 
 SETLAYER X =  RECTANGLE ENC T2V2 T2M2 ABUT < 90 OUTSIDE ALSO \
                 GOOD 0 0.05 OPPOSITE 0 0.05 OPPOSITE
   SETLAYER A = ENC X T2M2 < 0.05 OPPOSITE REGION
   OUTLAYER A NOT INSIDE NODRC

   SETLAYER B = T2V2 COIN EDGE T2M2
   SETLAYER D2 = INT B < 0.01 ABUT==90 REGION
   OUTLAYER D2 NOT INSIDE NODRC

   SETLAYER Y = ENC T2V2 T2M2 < 0.05 OPPOSITE REGION
   SETLAYER C1 = T2V2 COIN EDGE T2M2
   SETLAYER C2 = T2V2 COIN EDGE Y
   SETLAYER D3 = INT C1 C2 < 0.01 ABUT==90 REGION
   OUTLAYER D3 NOT INSIDE NODRC

  OUTLAYER (T2V2 NOT T2M2) NOT INSIDE NODRC
}

RULECHECK T2V2_R_1 {
@ There should be at least two square T2V2s space <= 0.4um for T2M1 and T2M2 connection when either or both T2M1 (T2M1 is Metal layer directly underneath T2V2) and T2M2 width is > 0.6um.
SETLAYER T2V2_SQ_CHECK = RECTANGLE T2V2 ASPECT == 1
SETLAYER T2V2_SQ_REG = EXT T2V2_SQ_CHECK <=0.4 SINGULAR REGION
SETLAYER T2V2_SQ_CHECK_VIA = T2V2_SQ_CHECK INTERACT T2V2_SQ_REG
SETLAYER T2V2_SQ = T2V2_SQ_CHECK_VIA OR T2V2_SQ_REG
SETLAYER X1_Mn = $bottom_metal ENCLOSE ($bottom_metal WITH WIDTH > 0.6)
SETLAYER X1_T2M2 = T2M2 ENCLOSE (T2M2 WITH WIDTH > 0.6)
SETLAYER T2M2T2M1 = $bottom_metal AND T2M2
SETLAYER X1 = X1_Mn OR X1_T2M2
OUTLAYER (T2M2T2M1 INTERACT T2V2_SQ == 1) INTERACT X1
}

RULECHECK T2V2_R_2 {
@ There should be at least four square T2V2s in this T2M2 and T2M1 intersection area when either or both T2M1 (T2M1 is Metal layer directly underneath T2V2) and T2M2 width is > 1.4um.
SETLAYER T2V2_SQ_CHECK = RECTANGLE T2V2 ASPECT == 1
SETLAYER T2V2_SQ = RECTANGLE T2V2 ASPECT == 1
SETLAYER T2V2_SQ_REG = EXT T2V2_SQ_CHECK <=0.4 SINGULAR REGION
SETLAYER T2V2_SQ_CHECK_VIA = T2V2_SQ_CHECK INTERACT T2V2_SQ_REG
SETLAYER X1_Mn = $bottom_metal ENCLOSE ($bottom_metal WITH WIDTH > 1.4)
SETLAYER X1_T2M2 = T2M1 ENCLOSE (T2M2 WITH WIDTH > 1.4)
SETLAYER T2M2T2M1 = $bottom_metal AND T2M2
SETLAYER X1 = X1_Mn OR X1_T2M2
OUTLAYER (T2M2T2M1 INTERACT T2V2_SQ_CHECK_VIA < 4) INTERACT X1
}

RULECHECK T2V2_R_3 {
@ 45-dgree T2V2 is not allowed
OUTLAYER ANGLE T2V2 == 45
}

VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK T2V2_R_4_R {
@ Recommended use redundant T2V2s as possible, DRC can help to flag single T2V2
OUTLAYER ($bottom_metal AND T2M2) INTERACT T2V2 == 1
}

VERBATIM {
#ENDIF
}




#=============================
#  T2M2 - Top Metal T2M2 DRC
#=============================

GROUP GT2M2 T2M2_?


RULECHECK T2M2_W_1 {
@ Min T2M2 width, DRC waive check 89 to 90 degree widths in the DEUPAD and INDALL region. >= 0.20
  SETLAYER X = (T2M2 NOT DEUPAD) WITH WIDTH > 10
  OUTLAYER ((X NOT INTERACT PA) NOT INDALL) NOT INSIDE NODRC
  OUTLAYER ((INT T2M2 < 0.2 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
  OUTLAYER ((INT T2M2 < 0.2 ABUT<89 SINGULAR REGION) AND INDALL) NOT INSIDE NODRC
}

RULECHECK T2M2_W_2 {
@ 45 dgree T2M2 width >= 0.39
SETLAYER X = ANGLE T2M2 == 45
OUTLAYER INT X < 0.39 ABUT < 90 REGION
}

RULECHECK T2M2_W_3 {
@ Minimum T2M2 width adjoining a huge non-metal region \[ area > 2000000 um2\], non-metal region is defined as (NOT (T2M2 OR T2M2DUM)) >= 0.35um
  SETLAYER NON_METAL_REG = AREA (DRC:1 NOT (OR T2M2 T2M2DUM)) > 2000000 
  SETLAYER CHECK_REGION = ENCLOSE RECTANGLE NON_METAL_REG 10 0.35
  SETLAYER CHECK_METAL = T2M2 INTERACT CHECK_REGION 
  OUTLAYER (INT CHECK_METAL < 0.35 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK T2M2_S_1 {
@ Space between T2M2s,DRC waive check 89 to 90 degree spaces in the INDALL region  >= 0.20
  OUTLAYER ((EXT T2M2 < 0.20 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
  OUTLAYER ((EXT T2M2 < 0.20 ABUT<89 SINGULAR REGION) AND INDALL) NOT INSIDE NODRC
}

RULECHECK T2M2_S_2 {
@ Min Space between two T2M2s when one or both T2M2 width or length >= 0.39um, and the run length of two T2M2s is >= 1um. is 0.24
  Mn_2b T2M2ALL 1 0.39 0.24
}

RULECHECK T2M2_S_3 {
@ Space between two T2M2s when one or both T2M1 width or length >= 1.5um, and the run length of two T2M2s is >= 1.5um >= 0.50 
  Mn_2b T2M2ALL 1.5 1.5 0.5
}

RULECHECK T2M2_S_4 {
@ Space between two T2M2s when one or both T2M2 width or length >= 4.5um, and the run length of two T2M2s is >= 4.5um >= 1.50 
  Mn_2b T2M2ALL 4.5 4.5 1.5
}

RULECHECK T2M2_S_5 {
@ Min Space between T2M2 metal lines with one or both are 45 degree bent metal lines >= 0.39
  SETLAYER X = ANGLE T2M2 == 45
  OUTLAYER (EXT X T2M2 < 0.39 ABUT<90 REGION) NOT INSIDE NODRC
}


RULECHECK T2M2_A_1 {
@ T2M2 area >= 0.14
  OUTLAYER (AREA T2M2 < 0.14) NOT INSIDE NODRC
}

RULECHECK T2M2_A_2 {
@ T2M2 enclosed area >= 0.26
  SETLAYER X = (HOLES T2M2 INNER) NOT T2M2
  OUTLAYER (AREA X < 0.26) NOT INSIDE NODRC
}

VERBATIM {
#IFDEF Density_rules YES
}
RULECHECK T2M2_D_1_min {
@ T2M2 density (including dummy) in 100umX100um window with step size 200um is >= 10% and <= 80%. 
@ INDALL/FUTR/GRID/SRINGBLK covered areas are excluded for this rule checking. 
@ (Top metal bond pad areas can be waived.)
@ (Exclude Top metal bond pad areas and DEUPAD region)

SETLAYER check_region_1 = ((((((DRC:1 NOT FUTR) NOT GRID) NOT SRINGBLK) NOT INDALL) NOT PA) NOT DEUPAD) NOT INSIDE NODRC
SETLAYER check_region = check_region_1 WITH WIDTH >= 25
SETLAYER check_pattern = T2M2ALLi AND check_region
SETLAYER err1_TMP1 = DENSITY check_pattern check_region \[!AREA(check_region) + !!AREA(check_region)*AREA(check_pattern)/AREA(check_region)\] < 0.1 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON 

SETLAYER check_window = WITH WIDTH (err1_TMP1 AND check_region) >= 25
OUTLAYER DENSITY check_pattern check_window \[!AREA(check_window) + !!AREA(check_window)*AREA(check_pattern)/AREA(check_window)\] < 0.1 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON PRINT T2M2_D_1_min.log RDB T2M2_D_1_min.rdb 
}

RULECHECK T2M2_D_1_max {
@ T2M2 density (including dummy) in 100umX100um window with step size 50um is >= 10% and <= 80%. 
@ INDALL/FUTR/GRID/SRINGBLK covered areas are excluded for this rule checking. 
@ (Top metal bond pad areas can be waived.)
@ (Exclude Top metal bond pad areas and DEUPAD region)

SETLAYER check_region_1 = ((((((DRC:1 NOT FUTR) NOT GRID) NOT SRINGBLK) NOT INDALL) NOT PA) NOT DEUPAD) NOT INSIDE NODRC
SETLAYER check_region = check_region_1 WITH WIDTH >= 25
SETLAYER check_pattern = T2M2ALLi AND check_region
SETLAYER err1_TMP1 = DENSITY check_pattern check_region \[!!AREA(check_region)*AREA(check_pattern)/AREA(check_region)\] > 0.8 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON 

SETLAYER check_window = WITH WIDTH (err1_TMP1 AND check_region) >= 25
OUTLAYER DENSITY check_pattern check_window \[!!AREA(check_window)*AREA(check_pattern)/AREA(check_window)\] > 0.8 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON PRINT T2M2_D_1_max.log RDB T2M2_D_1_max.rdb

}


RULECHECK T2M2_D_2 {
@ T4M1 density inside (T2M2dumb sizing up 2.5um) in 100umX100um window with step size 50um >= 10%  
  SETLAYER CHECK_AREA = SIZE T2M2DUMB BY 2.5
  SETLAYER X1 = T2M2ALLi NOT DEUPAD
  SETLAYER X = DENSITY X1 < 0.10 WINDOW 100 STEP 50 backup INSIDE OF LAYER CHECK_AREA PRINT density_report_T2M2_D_2.log
  SETLAYER Y = OR FUTR GRID SRINGBLK PA INDALL
  OUTLAYER (X NOT Y) NOT INSIDE NODRC
}


RULECHECK T2M2_D_3 {
@ T2M1 density difference in 100umX100um window <= 20%. 
@ INDALL/FUTR/GRID/SRINGBLK covered areas are excluded for this rule checking. 
  SETLAYER X1 = T2M2ALLi NOT DEUPAD
  SETLAYER X = DENSITY X1 >0 WINDOW 100 GRADIENT > 0.2  ABSOLUTE BACKUP INSIDE OF LAYER density_checkarea PRINT density_report_T2M2_D_3.log
  SETLAYER Y = OR FUTR GRID SRINGBLK PA INDALL
  OUTLAYER (X NOT Y) NOT INSIDE NODRC
}

VERBATIM {
#ENDIF
}

RULECHECK T2M2_R_1 {
@ T2M2 line end must be rectangular.
  SETLAYER A = INT T2M2 < 0.01 ABUT == 45 REGION
  SETLAYER B = EXT T2M2 < 0.01 ABUT == 45 REGION
  SETLAYER C = INT T2M2 < 0.01 ABUT == 135 REGION
  SETLAYER D = EXT T2M2 < 0.01 ABUT == 135 REGION
  OUTLAYER A NOT INSIDE NODRC
  OUTLAYER B NOT INSIDE NODRC
  OUTLAYER C NOT INSIDE NODRC
  OUTLAYER D NOT INSIDE NODRC
 }

}


#---------------------------------------------------------------------------------------------------------------------------------------------------

if { [set CHECK_T4V2] == 1 } {
 
#=======================
#  T4V2 - Top Via 2 DRC
#=======================


  set bottom_metal_list { T2M1 T4M1 }
  foreach bottom_metal $bottom_metal_list {
    set tmp CHECK_$bottom_metal
    set tem_v [set $tmp]
    if { $tem_v == 1 } break
    }

GROUP GT4V2 T4V2_?

RULECHECK T4V2_W_1 {
@ Fixed T4V2 size (square shape),exclude SRINGBLK and GRBLK region. >= 0.36,
  OUTLAYER ((NOT RECTANGLE (T4V2 NOT GT4V2) == 0.36 BY == 0.36) NOT GRID) NOT INSIDE (SRINGBLK OR NODRC)
  OUTLAYER (NOT RECTANGLE (RECTANGLE (T4V2 AND GRID)) == 0.36 BY == 0.36 ) NOT INSIDE (SRINGBLK OR NODRC)
}

RULECHECK T4V2_W_2 {
@ Fixed T4V2bar width  = 0.36,
OUTLAYER T4V2bar WITH WIDTH < 0.36 
OUTLAYER T4V2bar WITH WIDTH > 0.36 
}

RULECHECK T4V2_S_1 {
@ Space between two T4V2s >= 0.34
  OUTLAYER (EXT T4V2 < 0.34 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK T4V2_S_2 {
@ Space between T4V2s within array greater or equal to 3x3 (Two via regions whose space is <=0.56um are considered to be in the same array) is 0.5
@ NOTICE: It is a recommended rule.
  SETLAYER X = SIZE T4V2 BY 0.28 OVERUNDER
  SETLAYER Y = SIZE X BY 0.855 UNDEROVER
  SETLAYER Z = T4V2 INSIDE Y
  OUTLAYER (EXT Z < 0.5 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}
 
RULECHECK T4V2_EN_2_EN_3 {
@ Min $bottom_metal fully enclosure of T4V2 >= 0.01
@ Min $bottom_metal enclosure of T4V2 when T4M1 enclosure on one or both perpendicular directions < 0.05um. >= 0.05 

SETLAYER X = RECTANGLE ENC T4V2 $bottom_metal ABUT<90 OUTSIDE ALSO \
  GOOD 0.01 OPPOSITE 0.05 OPPOSITE 0.01 OPPOSITE 0.05 OPPOSITE

  OUTLAYER (ENC X $bottom_metal < 0.01 ABUT<90 SINGULAR REGION OVERLAP OUTSIDE ALSO) NOT INSIDE NODRC

  SETLAYER Y = ENC \[X\] $bottom_metal < 0.05 OPPOSITE
  OUTLAYER (INT Y < 0.01 ABUT==90 INTERSECTING ONLY REGION) NOT INSIDE NODRC
  OUTLAYER (T4V2 NOT $bottom_metal) NOT INSIDE NODRC
}

RULECHECK T4V2_EN_5_EN_6 {
@ Min T4V2 fully enclosure by T4M2  >= 0.02
  OUTLAYER (ENC T4V2 T4M2 < 0.02 ABUT < 90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE NODRC
}

VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK T4V2_R_1_R {
@ There should be at least two square T4V2s at the intersection of Mn/T4M1/T2M1 and T4M2 when either metal width >= 0.5um,exclude SRINGBLK and GRBLK region.
SETLAYER T4V2_SQ = RECTANGLE T4V2 ASPECT == 1
SETLAYER X1_${bottom_metal} = ${bottom_metal} ENCLOSE (${bottom_metal} WITH WIDTH >= 0.5)
SETLAYER X1_T4M2 = T4M2 ENCLOSE (T4M2 WITH WIDTH >= 0.5)
SETLAYER ${bottom_metal}T4M2 = ${bottom_metal} AND T4M2
SETLAYER X1 = X1_${bottom_metal} OR X1_T4M2
OUTLAYER ((${bottom_metal}T4M2 INTERACT T4V2_SQ == 1) INTERACT X1) NOT INSIDE (OR SRINGBLK GRBLK NODRC)
}
VERBATIM {
#ENDIF
}

RULECHECK T4V2_R_3 {
@ 45-dgree T4V2 is not allowed
OUTLAYER ANGLE T4V2 == 45
}

VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK T4V2_R_4_R {
@ Recommended us redundant T4V2s as possible, DRC can help to flag single T4V2
OUTLAYER ($bottom_metal AND T4M2) INTERACT T4V2 == 1
}

VERBATIM {
#ENDIF
}

#=========================
#  T4M2 - Top Metal 2 DRC
#=========================


GROUP GT4M2 T4M2_?

RULECHECK T4M2_W_1 {
@ T4M2 width ,DRC waive check 89 to 90 degree widths in the INDALL and DEUPAD region >= 0.40
@ T4M2 width <= 20
  OUTLAYER ((INT T4M2 < 0.40 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
  OUTLAYER ((INT T4M2 < 0.40 ABUT<89 SINGULAR REGION) AND INDALL) NOT INSIDE NODRC
  SETLAYER X = (T4M2 NOT DEUPAD) WITH WIDTH > 20.00
  OUTLAYER ((X NOT INTERACT PA) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M2_S_1 {
@ Space between T4M2s DRC waive check 89 to 90 degree spaces in the INDALL region. >= 0.40,
  OUTLAYER ((EXT T4M2 < 0.40 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
  OUTLAYER ((EXT T4M2 < 0.40 ABUT<89 SINGULAR REGION) AND INDALL) NOT INSIDE NODRC 
}

RULECHECK T4M2_S_2 {
@ Space between two T4M2s when one or both T4M2 width or length >= 2um, and the run length of two T4M2s is >= 2um.  >= 0.5
  Mn_2b T4M2ALL 2 2 0.5
}

RULECHECK T4M2_A_1 {
@ T4M2 area >= 0.40
  OUTLAYER (AREA T4M2 < 0.40) NOT INSIDE NODRC
}

RULECHECK T4M2_A_2 {
@ Enclosed area by T4M2 >= 0.6
  SETLAYER X = (HOLES T4M2 INNER) NOT T4M2
  OUTLAYER (AREA X < 0.6) NOT INSIDE NODRC
}


VERBATIM {
#IFDEF Density_rules YES
}
RULECHECK T4M2_D_1_min {
@ T4M2 density (including dummy) in 400umX400um window with step size 200um is >= 20% and <= 85%. 
@ INDALL/FUTR/GRID/SRINGBLK covered areas are excluded for this rule checking. 
@ Top metal bond pad areas and DEUPAD regions  can be waived.

  SETLAYER X1 = T4M2ALLi NOT DEUPAD
  SETLAYER X = DENSITY X1 < 0.20 WINDOW 400 STEP 200 backup INSIDE OF LAYER density_checkarea PRINT density_report_T4M2_D_1_min.log
  SETLAYER Y = ((INDALL OR FUTR) OR GRID) OR SRINGBLK
  OUTLAYER (X NOT Y) NOT INSIDE NODRC


}

RULECHECK T4M2_D_1_max {
@ T4M2 density (including dummy) in 400umX400um window with step size 200um is >= 20% and <= 85%. 
@ INDALL/FUTR/GRID/SRINGBLK covered areas are excluded for this rule checking. 
@ Top metal bond pad areas and DEUPAD regions can be waived.
 
SETLAYER check_region_1 = ((((((DRC:1 NOT FUTR) NOT GRID) NOT SRINGBLK) NOT INDALL) NOT PA) NOT DEUPAD) NOT INSIDE NODRC
SETLAYER check_region = check_region_1 WITH WIDTH >= 100
SETLAYER check_pattern = T4M2ALLi AND check_region
SETLAYER err1_TMP1 = DENSITY check_pattern check_region \[!!AREA(check_region)*AREA(check_pattern)/AREA(check_region)\] > 0.85 WINDOW 400 STEP 200 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON 

SETLAYER check_window = WITH WIDTH (err1_TMP1 AND check_region) >= 100
OUTLAYER DENSITY check_pattern check_window \[!!AREA(check_window)*AREA(check_pattern)/AREA(check_window)\] > 0.85 WINDOW 400 STEP 200 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON PRINT T4M2_7_h.log RDB T4M2_D_1_max.rdb

}

RULECHECK T4M2_D_2 {
@ T4M2 density inside (T4M2dumb sizing up 2.5um) in 100umX100um window with step size 50um >= 10%  
  SETLAYER CHECK_AREA = SIZE T4M2DUMB BY 2.5
  SETLAYER X1 = T4M2ALLi NOT DEUPAD
  SETLAYER X = DENSITY X1 < 0.10 WINDOW 100 STEP 50 backup INSIDE OF LAYER CHECK_AREA PRINT density_report_T4M2_D_2.log
  SETLAYER Y = OR FUTR GRID SRINGBLK PA INDALL
  OUTLAYER (X NOT Y) NOT INSIDE NODRC
}


RULECHECK T4M2_D_3 {
@ T4M2 density difference in 100umX100um window <= 20%. 
@ INDALL/FUTR/GRID/SRINGBLK covered areas are excluded for this rule checking. 
  SETLAYER X1 = T4M2ALLi NOT DEUPAD
  SETLAYER X = DENSITY X1 >0 WINDOW 100 GRADIENT > 0.2  ABSOLUTE BACKUP INSIDE OF LAYER density_checkarea PRINT density_report_T4M2_D_3.log
  SETLAYER Y = OR FUTR GRID SRINGBLK PA INDALL
  OUTLAYER (X NOT Y) NOT INSIDE NODRC
}

VERBATIM {
#ENDIF
}

RULECHECK T4M2_R_1 {
@ T4M2 line end must be rectangular.
  SETLAYER A = INT T4M2 < 0.01 ABUT == 45 REGION
  SETLAYER B = EXT T4M2 < 0.01 ABUT == 45 REGION
  SETLAYER C = INT T4M2 < 0.01 ABUT == 135 REGION
  SETLAYER D = EXT T4M2 < 0.01 ABUT == 135 REGION
  OUTLAYER A NOT INSIDE NODRC
  OUTLAYER B NOT INSIDE NODRC
  OUTLAYER C NOT INSIDE NODRC
  OUTLAYER D NOT INSIDE NODRC
   }

} 


if { [set CHECK_T8V1] == 1 } {
  
#=======================================
# T8V1  -  For RF product application
#=======================================

  set bottom_metal_list { M8 M7 M6 M5 M4 M3 }
  foreach bottom_metal $bottom_metal_list {
    set tmp CHECK_$bottom_metal
    set tem_v [set $tmp]
    if { $tem_v == 1 } break
    }

GROUP GT8V1 T8V1_?

RULECHECK T8V1_W_1 {
@ Fixed T8V1 size (square shape),exclude SRINGBLK and GRBLK area = 0.36
  OUTLAYER ((NOT RECTANGLE (T8V1 NOT GT8V1) == 0.36 BY == 0.36) NOT GRID) NOT INSIDE (SRINGBLK OR NODRC)
  OUTLAYER (NOT RECTANGLE (RECTANGLE (T8V1 AND GRID)) == 0.36 BY == 0.36) NOT INSIDE (SRINGBLK OR NODRC)
}
RULECHECK T8V1_W_2 {
@ Fixed T8V1bar width = 0.36
OUTLAYER T8V1bar WITH WIDTH < 0.36
OUTLAYER T8V1bar WITH WIDTH > 0.36
}

RULECHECK T8V1_S_1 {
@ Space between T8V1s >= 0.34
  OUTLAYER (EXT T8V1 < 0.34 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK T8V1_S_2 {
@ Space between T8V1s when array equal to or greater than 4x4(with space <=0.56um. >= 0.5
  SETLAYER X = SIZE T8V1 BY 0.28 OVERUNDER
  SETLAYER Y = SIZE X BY 1.22 UNDEROVER
  SETLAYER Z = T8V1 INSIDE Y
  OUTLAYER (EXT Z < 0.5 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK T8V1_EN_2_EN_3 {
@ Enclosed by $bottom_metal  >= 0.01
@ Enclosed by $bottom_metal when $bottom_metal enclosure on perpendicular directions < 0.05um >= 0.05 

  SETLAYER X = RECTANGLE ENC T8V1 $bottom_metal ABUT<90 OUTSIDE ALSO \
  GOOD 0.01 OPPOSITE 0.05 OPPOSITE 0.01 OPPOSITE 0.05 OPPOSITE

  OUTLAYER (ENC X $bottom_metal < 0.01 ABUT<90 SINGULAR OVERLAP OUTSIDE ALSO REGION) NOT INSIDE NODRC

  SETLAYER Y = ENC \[X\] $bottom_metal < 0.05 OPPOSITE
  OUTLAYER (INT Y < 0.01 ABUT==90 INTERSECTING ONLY REGION) NOT INSIDE NODRC
  OUTLAYER (T8V1 NOT $bottom_metal) NOT INSIDE NODRC 
}
RULECHECK T8V1_EN_5_EN_6 {
@ Enclosed by T8M1 >= 0.3
  OUTLAYER (ENC T8V1 T8M1 < 0.3 ABUT < 90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE NODRC
}

RULECHECK T8V1_R_1 {
@ There should be at least two square T8V1s at the intersection of Mn/T8M1  when either metal width >= 0.5um,exclude SRINGBLK and GRBLK area
SETLAYER T8V1_SQ = RECTANGLE T8V1 ASPECT == 1
SETLAYER X1_${bottom_metal} = ${bottom_metal} ENCLOSE (${bottom_metal} WITH WIDTH >= 0.5)
SETLAYER X1_T8M1 = T8M1 ENCLOSE (T8M1 WITH WIDTH >= 0.5)
SETLAYER ${bottom_metal}T8M1 = ${bottom_metal} AND T8M1
SETLAYER X1 = X1_${bottom_metal} OR X1_T8M1
OUTLAYER ((${bottom_metal}T8M1 INTERACT T8V1_SQ == 1) INTERACT X1) NOT INSIDE (OR SRINGBLK GRBLK NODRC)
}


#=======================================
#  T8M1 - For RF product application
#=======================================


GROUP GT8M1 T8M1_?

RULECHECK T8M1_W_1 {
@ T8M1 metal width,DRC waive check 89 to 90 degree widths in the INDALL region >= 1.50
@ T8M1 width, except bond pad and INDALL and DEUPAD regions. <= 50
  SETLAYER X = (T8M1 NOT DEUPAD) WITH WIDTH > 50
  OUTLAYER ((X NOT INTERACT PA) NOT INDALL) NOT INSIDE NODRC
  OUTLAYER ((INT T8M1 < 1.50 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
  OUTLAYER ((INT T8M1 < 1.50 ABUT<89 SINGULAR REGION) AND INDALL) NOT INSIDE NODRC
}
RULECHECK T8M1_S_1 {
@ Min Space between T8M1s is 1.5,DRC waive check 89 to 90 degree spaces in the INDALL region
  OUTLAYER ((EXT T8M1 < 1.50 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
  OUTLAYER ((EXT T8M1 < 1.50 ABUT<89 SINGULAR REGION) AND INDALL) NOT INSIDE NODRC
}
RULECHECK T8M1_S_2 {
@ Min Space between two T8M1s when one or both T8M1 width or length >= 16um, and the run length of two T8M1s >2um.  >= 2.0
  Mn_2b_SPECIAL T8M1ALL 2.001 16 2
}
RULECHECK T8M1_S_3 {
@ Space between an Inductor T8M1 and other T8M1 (including Inductor T8M1) >= 30um
@ Inductor T8M1 definition: (INDALL AND T8M1)
  OUTLAYER (EXT (T8M1 AND INDALL) (T8M1 NOT INDALL) < 30 OPPOSITE REGION) NOT INSIDE NODRC
}
RULECHECK T8M1_EX_1 {
@ INDID extention on T8M1, T8M1 CUT INDALL is not allowed  >= 15
  OUTLAYER (ENC (T8M1 INTERACT INDALL) INDALL < 15 ABUT < 90 OPPOSITE REGION) NOT INSIDE NODRC
  OUTLAYER T8M1 CUT INDALL
}
RULECHECK T8M1_A_1 {
@ T8M1 Metal area >= 6.00
  OUTLAYER (AREA T8M1 < 6.00) NOT INSIDE NODRC
}
RULECHECK T8M1_A_2 {
@ T8M1 enclosed area >= 6.0
  SETLAYER X = (HOLES T8M1 INNER) NOT T8M1
  OUTLAYER (AREA X < 6.0) NOT INSIDE NODRC
}

VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
#IFDEF Density_rules YES
}
RULECHECK T8M1_D_1_R {
@ Recommend the average T8M1 density of whole chip is larger than 20% (including dummy patterns).
@ NOTICE: It is a recommended rule.
  OUTLAYER (DENSITY T8M1ALLi < 0.2 PRINT density_report_T8M1_D_1_R.log) NOT INSIDE NODRC
}
VERBATIM {
#ENDIF
#ENDIF
}
VERBATIM {
#IFDEF Density_rules YES
}
RULECHECK T8M1_D_2 {
@ T8M1 pattern density on the whole chip (including dummy patterns) <= 55%
  OUTLAYER (DENSITY T8M1ALLi > 0.55 PRINT density_report_T8M1_D_2.log) NOT INSIDE NODRC
}
RULECHECK T8M1_D_3  {
@ T8M1 density (including dummy) in 400umX400um window with step size 200um <= 70%
@ (Exclude DEUPAD regions)
  SETLAYER X = T8M1ALLi NOT DEUPAD
  OUTLAYER (DENSITY X > 0.70 WINDOW 400 STEP 200 backup PRINT density_report_T8M1_D_3.log) NOT INSIDE NODRC
}
VERBATIM {
#ENDIF
}

RULECHECK T8M1_R_1 {
@ T8M1 line end must be rectangular.
  SETLAYER A = INT T8M1 < 0.01 ABUT == 45 REGION
  SETLAYER B = EXT T8M1 < 0.01 ABUT == 45 REGION
  SETLAYER C = INT T8M1 < 0.01 ABUT == 135 REGION
  SETLAYER D = EXT T8M1 < 0.01 ABUT == 135 REGION
  OUTLAYER A NOT INSIDE NODRC
  OUTLAYER B NOT INSIDE NODRC
  OUTLAYER C NOT INSIDE NODRC
  OUTLAYER D NOT INSIDE NODRC
   }

VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}

RULECHECK T8M1_R_2 {
@ Both active and passive devices inside INDALL region are not allowed
  SETLAYER Metal_res = ((((((((M1R OR M2R) OR M3R) OR M4R) OR M5R) OR M6R) OR M7R) OR M8R) OR T4M1R) OR T8M1R
  SETLAYER X = ((((((DIODE OR BJT) OR MOMLVS1) OR VARAJ) OR PORES) OR AARES) OR NW1res) OR Metal_res
  OUTLAYER (AND X INDALL) NOT INSIDE NODRC
}

VERBATIM {
#ENDIF
 }


}

if { [set CHECK_T8V2] == 1 } {
  
#=======================================
# T8V2  -  For RF product application
#=======================================

  set bottom_metal_list { T2M1 T4M1 T8M1 }
  foreach bottom_metal $bottom_metal_list {
    set tmp CHECK_$bottom_metal
    set tem_v [set $tmp]
    if { $tem_v == 1 } break
    }

GROUP GT8V2 T8V2_?

RULECHECK T8V2_W_1 {
@ Fixed T8V2 size (square shape) is 0.36,exclude SRINGBLK and GRBLK area
  OUTLAYER ((NOT RECTANGLE (T8V2 NOT GT8V2) == 0.36 BY == 0.36) NOT GRID) NOT INSIDE (SRINGBLK OR NODRC)
  OUTLAYER (NOT RECTANGLE (RECTANGLE (T8V2 AND GRID)) == 0.36 BY == 0.36) NOT INSIDE (SRINGBLK OR NODRC)
}
RULECHECK T8V2_W_2 {
@ Fixed T8V2bar width = 0.36
OUTLAYER T8V2bar WITH WIDTH < 0.36
OUTLAYER T8V2bar WITH WIDTH > 0.36
}
RULECHECK T8V2_S_1 {
@ Space between T8V2s >= 0.34
  OUTLAYER (EXT T8V2 < 0.34 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK T8V2_S_2 {
@ Space between T8V2s when array equal to or greater than 4x4. >= 0.5
@ (Two via regions whose space is <=0.56um are considered to be in the same array.)
  SETLAYER X = SIZE T8V2 BY 0.28 OVERUNDER
  SETLAYER Y = SIZE X BY 1.22 UNDEROVER
  SETLAYER Z = T8V2 INSIDE Y
  OUTLAYER (EXT Z < 0.5 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK T8V2_EN_2_EN_3 {
@ Enclosed by $bottom_metal >= 0.01
@ Enclosed by $bottom_metal when $bottom_metal enclosure on perpendicular directions < 0.05um. >= 0.05 

  SETLAYER X = RECTANGLE ENC T8V2 $bottom_metal ABUT<90 OUTSIDE ALSO \
  GOOD 0.01 OPPOSITE 0.05 OPPOSITE 0.01 OPPOSITE 0.05 OPPOSITE

  OUTLAYER (ENC X $bottom_metal < 0.01 ABUT<90 SINGULAR OVERLAP OUTSIDE ALSO REGION) NOT INSIDE NODRC

  SETLAYER Y = ENC \[X\] $bottom_metal < 0.05 OPPOSITE
  OUTLAYER (INT Y < 0.01 ABUT==90 INTERSECTING ONLY REGION) NOT INSIDE NODRC
  OUTLAYER (T8V2 NOT $bottom_metal) NOT INSIDE NODRC 
}
RULECHECK T8V2_EN_5_6 {
@ Enclosed by T8M2 >= 0.3
@ T8V2 must be fully covered by T8M2 where is the metal layer directly above T8V2
  OUTLAYER (ENC T8V2 T8M2 < 0.3 ABUT < 90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE NODRC
  OUTLAYER T8V2 NOT T8M2
}
RULECHECK T8V2_R_1 {
@ There should be at least two square T8V2s at the intersection of T8M2/T8M1  when either metal width >= 0.5um,exclude SRINGBLK and GRBLK area
SETLAYER T8V2_SQ = RECTANGLE T8V2 ASPECT == 1
SETLAYER X1_${bottom_metal} = ${bottom_metal} ENCLOSE (${bottom_metal} WITH WIDTH >= 0.5)
SETLAYER X1_T8M2 = T8M2 ENCLOSE (T8M2 WITH WIDTH >= 0.5)
SETLAYER ${bottom_metal}T8M2 = ${bottom_metal} AND T8M2
SETLAYER X1 = X1_${bottom_metal} OR X1_T8M2
OUTLAYER ((${bottom_metal}T8M2 INTERACT T8V2_SQ == 1) INTERACT X1) NOT INSIDE (OR SRINGBLK GRID NODRC)
}

#=======================================
#  T8M2 - For RF product application
#=======================================


GROUP GT8M2 T8M2_?

RULECHECK T8M2_1 {
@ T8M2 metal width,DRC waive check 89 to 90 degree widths in the INDALL region. >= 1.50
@ T8M2 width, except bond pad and INDALL and DEUPAD regions. <= 50
  SETLAYER X = (T8M2 NOT DEUPAD) WITH WIDTH > 50
  OUTLAYER ((X NOT INTERACT PA) NOT INDALL) NOT INSIDE NODRC
  OUTLAYER ((INT T8M2 < 1.50 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
  OUTLAYER ((INT T8M2 < 1.50 ABUT<89 SINGULAR REGION) AND INDALL) NOT INSIDE NODRC

}
RULECHECK T8M2_S_1 {
@ Space between T8M2s,DRC waive check 89 to 90 degree spaces in the INDALL region  >= 1.5
  OUTLAYER ((EXT T8M2 < 1.50 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
  OUTLAYER ((EXT T8M2 < 1.50 ABUT<89 SINGULAR REGION) AND INDALL) NOT INSIDE NODRC
}
RULECHECK T8M2_S_2 {
@ Min Space between two T8M2s when one or both T8M2 width or length >= 16um, and the run length of two T8M2s >2um.  >= 2.0 
  Mn_2b_SPECIAL T8M2ALL 2.001 16 2
}
RULECHECK T8M2_S_3 {
@ Space between an Inductor T8M2 and other T8M2 (including Inductor T8M2). >= 30
@ Inductor T8M2 definition: (INDALL AND T8M2)
  OUTLAYER (EXT (T8M2 AND INDALL) (T8M2 NOT INDALL) < 30 OPPOSITE REGION) NOT INSIDE NODRC
}
RULECHECK T8M2_EX_1 {
@ INDALL extension on T8M2, T8M2 CUT INDALL is not allowed >= 15
  OUTLAYER (ENC (T8M2 INTERACT INDALL) INDALL < 15 ABUT < 90 OPPOSITE REGION) NOT INSIDE NODRC
  OUTLAYER T8M2 CUT INDALL
}
RULECHECK T8M2_A_1 {
@ T8M2 area >= 6.00
  OUTLAYER (AREA T8M2 < 6.00) NOT INSIDE NODRC
}
RULECHECK T8M2_A_2 {
@ T8M2 enclosed  area >= 6.0
  SETLAYER X = (HOLES T8M2 INNER) NOT T8M2
  OUTLAYER (AREA X < 6.0) NOT INSIDE NODRC
}
VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
#IFDEF Density_rules YES
}
RULECHECK T8M2_D_1_R {
@ Recommend the average T8M2 density of whole chip is larger than 20% (including dummy patterns), otherwise XXXX would help to add dummy patterns.
@ NOTICE: It is a recommended rule.
  OUTLAYER (DENSITY T8M2ALLi < 0.2 PRINT density_report_T8M2_D_1_R.log) NOT INSIDE NODRC
}
VERBATIM {
#ENDIF
#ENDIF
}

VERBATIM {
#IFDEF Density_rules YES
}
RULECHECK T8M2_D_2 {
@ Max T8M2 pattern density on the whole chip (including dummy patterns) is 55%
  OUTLAYER (DENSITY T8M2ALLi > 0.55 PRINT density_report_T8M2_D_2.log) NOT INSIDE NODRC
}
RULECHECK T8M2_D_3  {
@ Max. T8M2 density (including dummy) in 400umX400um window with step size 200um is 70%
@ (Exclude DEUPAD regions)
  SETLAYER X = T8M2ALLi NOT DEUPAD
  OUTLAYER (DENSITY X > 0.70 WINDOW 400 STEP 200 backup PRINT density_report_T8M2_D_3.log) NOT INSIDE NODRC
}
VERBATIM {
#ENDIF
}

RULECHECK T8M2_R_2 {
@ Both active and passive devices inside INDALL region are not allowed
  SETLAYER Metal_res = ((((((((M1R OR M2R) OR M3R) OR M4R) OR M5R) OR M6R) OR M7R) OR M8R) OR T4M1R) OR T8M2R
  SETLAYER X = ((((((DIODE OR BJT) OR MOMLVS1) OR VARAJ) OR PORES) OR AARES) OR NW1res) OR Metal_res
  OUTLAYER (AND X INDALL) NOT INSIDE NODRC
}

RULECHECK T8M2_R_1 {
@ T8M2 line end must be rectangular.
  SETLAYER A = INT T8M2 < 0.01 ABUT == 45 REGION
  SETLAYER B = EXT T8M2 < 0.01 ABUT == 45 REGION
  SETLAYER C = INT T8M2 < 0.01 ABUT == 135 REGION
  SETLAYER D = EXT T8M2 < 0.01 ABUT == 135 REGION
  OUTLAYER A NOT INSIDE NODRC
  OUTLAYER B NOT INSIDE NODRC
  OUTLAYER C NOT INSIDE NODRC
  OUTLAYER D NOT INSIDE NODRC
   }

}



#//=====================================              
#//  CB -  Passivation One Rules DRC
#//===================================== 

GROUP GCB CB_?

RULECHECK CB_W_1 {
@ CB width  >= 3.0um
 OUTLAYER ((INT PA < 3 - 0.001 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
 OUTLAYER ((INT PA < 3 - 0.001 ABUT<90 SINGULAR REGION) AND INDALL) NOT INSIDE NODRC
}
RULECHECK CB_S_1 {
@ Space between two CBs >= 5.0um
 OUTLAYER ((EXT PA < 5 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
 OUTLAYER ((EXT PA < 5 - 0.002 ABUT<90 SINGULAR REGION) AND INDALL) NOT INSIDE NODRC
}
RULECHECK CB_EN_1_EN_2 {
@ CB edge fully enclosure by T4M1 or T2M1 or T8M1, T4M2 or T2M2 or T8M2 directly underneath PA >= 1.5um
 OUTLAYER ((ENC PA (OR T2M1 T4M1 T8M1 T4M2 T2M2 T8M2) < 1.50 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT INDALL) NOT INSIDE NODRC
 OUTLAYER ((ENC PA (OR T2M1 T4M1 T8M1 T4M2 T2M2 T8M2) < 1.50 - 0.002 ABUT<90 SINGULAR REGION OUTSIDE ALSO) AND INDALL) NOT INSIDE NODRC
}

VERBATIM {

//===============================
// RV -  RDL via design rules
//===============================

GROUP GRV RV_?

RDV_Fuse = RDLVF OR GRDLV

 
RV_W_1 {
@ Fixed RDL Via width and length = 3.0um
  NOT RECTANGLE ((RDLVIA NOT RDV_Fuse) NOT GRID) == 3 BY == 3
}
RV_S_1 {
@ Space between two RDL vias >= 3.0um
  (EXT (RDLVIA NOT RDV_Fuse) < 3 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
RV_S_2 {
@ Space between RDL via and CB >= 6.0um
  ((EXT RDLVIA PA < 6 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}
RV_EN_1_2 {
@ RDL via enclosure by T4M2 or other metal layer directly underneath RV >= 1.5um
  X11 = ENC (RDLVIA NOT RDV_Fuse) T4M2 < 1.50 ABUT<90 SINGULAR REGION OVERLAP OUTSIDE ALSO
  ((X11 NOT LOGO) NOT GRID) NOT INSIDE NODRC
  X12 = ENC (RDLVIA NOT RDV_Fuse) T2M2 < 1.50 ABUT<90 SINGULAR REGION OVERLAP OUTSIDE ALSO
  ((X12 NOT LOGO) NOT GRID) NOT INSIDE NODRC
  X13 = ENC (RDLVIA NOT RDV_Fuse) T8M2 < 1.50 ABUT<90 SINGULAR REGION OVERLAP OUTSIDE ALSO
  ((X13 NOT LOGO) NOT GRID) NOT INSIDE NODRC
  RDLVIA NOT T4M2
  RDLVIA NOT T2M2
  RDLVIA NOT T8M2
  
}
RV_EN_3_4 {
@ RDL via enclosure by RDL >= 1.5um
  X11 = ENC (RDLVIA NOT RDV_Fuse) RDL < 1.50 ABUT<90 SINGULAR REGION OVERLAP OUTSIDE ALSO
  ((X11 NOT LOGO) NOT INSIDE (OR SRINGBLK FUTR GRID)) NOT INSIDE NODRC
  RDLVIA NOT RDL
}

 RV_R_1 {
@ Recommended us redundant RVs as possible, DRC can help to flag single RV
 ( (OR T4M2 T2M2 T8M2) AND RDL) INTERACT RDLVIA == 1
}


//==================================================             
//  RDL -  Al RDL (re-distribution layer) Rules DRC
//================================================== 

GROUP GRDL RDL_?

RDL_W_1 {
@ RDL Width >= 3.0um
@ RDL width <= 35um
  ((INT RDL < 3.0 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
  ((INT RDL < 3.0 - 0.002 ABUT<90 SINGULAR REGION) AND INDALL) NOT INSIDE NODRC
  ((RDL WITH WIDTH >= 35) NOT INDALL) NOT INSIDE NODRC
}
RDL_S_1 {
@ Space between two (RDL OR ALPAD) >= 2.0um
  ((EXT ALPA < 2.0 ABUT<89.9 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
  ((EXT ALPA < 2.0 - 0.002 ABUT<89.9 SINGULAR REGION) AND INDALL) NOT INSIDE NODRC
}
RDL_S_2 {
@ Space between (RDL OR ALPAD) with one or both (RDL OR ALPAD) width larger than 10um >= 3.0um
  X1 = (ALPA WITH WIDTH > 10) COIN EDGE ALPA
  ((EXT X1 ALPA <3.0 REGION) NOT INDALL) NOT INSIDE NODRC
  X2 = (ALPA WITH WIDTH > 10) COIN EDGE ALPA
  ((EXT X2 ALPA <3.0 - 0.002 REGION) AND INDALL) NOT INSIDE NODRC
}
RDL_S_3 {
@ Space between (RDL OR ALPAD) with one or both (RDL OR ALPAD) width larger than 35um >= 5.0um
  X1 = (ALPA WITH WIDTH > 35) COIN EDGE ALPA
  ((EXT X1 ALPA <5.0 REGION) NOT INDALL) NOT INSIDE NODRC
  X2 = (ALPA WITH WIDTH > 35) COIN EDGE ALPA
  ((EXT X2 ALPA <5.0 - 0.002 REGION) AND INDALL) NOT INSIDE NODRC
}
RDL_EN_1 {
@ ALPAD must fully enclosure of Cover
 RDLPA2 NOT ALPA
}

RDL_EN_2 {
@ ALPA must fully enclosure of CB
  CBi NOT ALPAD
}

}

VERBATIM {
//=====================================              
//  COVER -  Passivation Two Rules DRC
//===================================== 

GROUP GCOVER COVER_?
}

RULECHECK COVER_W_1 {
@ COVER width (suggest to consult with package vendor) >= 40.0um
   OUTLAYER ((INT RDLPA2 < 40 - 0.002 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE (OR SRBLK SRINGBLK NODRC)
   OUTLAYER ((INT RDLPA2 < 40 - 0.002 ABUT<90 SINGULAR REGION) AND INDALL) NOT INSIDE (OR SRBLK SRINGBLK NODRC)
}

RULECHECK COVER_L_1 {
@ COVER length (suggest to consult with package vendor) >= 65.0um
  OUTLAYER (NOT ENCLOSE RECTANGLE RDLPA2 40 65) NOT INSIDE (OR SRBLK SRINGBLK NODRC)
}

RULECHECK COVER_S_1 {
@ Covers space (suggest to consult with package vendor) >= 5.0um
   OUTLAYER ((EXT RDLPA2 < 5 - 0.002 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE (OR SRBLK SRINGBLK NODRC)
   OUTLAYER ((EXT RDLPA2 < 5 - 0.002 ABUT<90 SINGULAR REGION) AND INDALL) NOT INSIDE (OR SRBLK SRINGBLK NODRC)
}

RULECHECK COVER_S_2 {
@ Space between metal pad and metal line  >= 2.5um
   SETLAYER RDLLINE = ALPA WITH WIDTH < 35
   SETLAYER RDLPAD = ALPA NOT RDLLINE
   OUTLAYER ((EXT RDLPAD RDLLINE < 2.5 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
   OUTLAYER ((EXT RDLPAD RDLLINE < 2.5 - 0.002 ABUT<90 SINGULAR REGION) AND INDALL) NOT INSIDE NODRC
}

VERBATIM {
COVER_EN_1 {
@ Cover enclosed by ALPAD >= 1.5um
  ((ENC RDLPA2 ALPA < 1.5 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
  ((ENC RDLPA2 ALPA < 1.5-0.002 ABUT<90 SINGULAR REGION) AND INDALL) NOT INSIDE NODRC
}

}


VERBATIM {
#IFDEF CHIPEDGE_CHECK YES
}
#//==================
#//  Chip Edge  Rules
#//==================

GROUP GCHIPEDGE CHIPEDGE_?

SETLAYER BD_EXTENT = EXTENT DRAWN ORIGINAL
SETLAYER BD_EXTENT_OTHER = EXTENT DRAWN ORIGINAL IGNORE CHIPBLK
SETLAYER BD_OTHER_OUTSIDE = BD_EXTENT_OTHER NOT CHIPEDGE

SETLAYER MS_OUT_TEMP1 = (((((((M1i AND SRINGBLK) OR (M2i AND SRINGBLK)) OR (M3i AND SRINGBLK)) OR (M4i AND SRINGBLK)) OR (M5i AND SRINGBLK)) OR (M6i AND SRINGBLK)) OR (M7i AND SRINGBLK))  OR (M8i AND SRINGBLK)
SETLAYER MS_OUT_TEMP2 = ((T4M1i AND SRINGBLK) OR (T4M2i AND SRINGBLK)) OR (RDLi AND SRINGBLK)
SETLAYER MS_OUT = MS_OUT_TEMP1 OR MS_OUT_TEMP2

RULECHECK CHIPEDGE_EN_1 {
@ Border layer must enclose all chip layout patterns (all chip design, excluding SRINGBLK, SRBLK marking layer)
@ This rule is not applicable if customers insert seal ring by themselves
@ This rule checking layer are DNW, ACT, NW1, PSUB, NVT3, PVT3, NVT1, PVT1, DGOX, TGOX, PO, NP, PP, NPR, HRP, ESD1, SAB, CT, Mn(n = 1-8), Vn(n = 1-7), T4V1, T4V2, T4M1, T4M2, T2V1, T2V2, T2M1, T2M2, PA, RV, BCB2, RDL, FUSE, ACTDUM, PODUM, MnDUM(n = 1-8), T4M1DUM, T4M2DUM, T2M1DUM, T2M2DUM. >= 0.37um

SETLAYER BD_EXTENT_OTHER_temp = EXTENT DRAWN DNWi ACTi NW1i PSUBi NVT3 PVT3 NVT1 PVT1 DGOX TGOX POLYi NPi PPi NPR HRPi ESD1 SABi CTi CTbar MET1o MET2o MET3o MET4o MET5o MET6o MET7o MET8o VIA1i VIA2i VIA3i VIA4i VIA5i VIA6i VIA7i VIA1bar VIA2bar VIA3bar VIA4bar VIA5bar VIA6bar VIA7bar T4V1i T4V2i T4V1bar T4V2bar T4M1o T4M2o T2V1i T2V2i T2V1bar T2V2bar T2M1o T2M2o T8V1i T8V2i T8V1bar T8V2bar T8M1o T8M2o CBi RV COVER RDLi FUTR ACTdmi POLYdmi MET1dmi MET2dmi MET3dmi MET4dmi MET5dmi MET6dmi MET7dmi MET8dmi T4M1dmi T4M2dmi T2M1dmi T2M2dmi T8M1dmi T8M2dmi IGNORE CHIPBLK SRINGBLK SRBLK  
OUTLAYER (ENC BD_EXTENT_OTHER_temp CHIPEDGE < 0.37 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK CHIPEDGE_EN_2 {
@ Enclosure of DNW by the chip edge (CHIPEDGE layer) if it need XXXX to add seal ring. >= 6.0um
OUTLAYER (ENC DNW CHIPEDGE < 6 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK CHIPEDGE_EN_3 {
@ Enclosure of seal ring outer ring outline edge by CHIPEDGE layer if seal ring has been added by designers. >= 1.5
OUTLAYER (ENC MS_OUT CHIPEDGE < 1.5 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}
RULECHECK CHIPEDGE_R_3 {
@ CHIPEDGE layer size should exactly same as chip window size in tape out information file
 OUTLAYER XOR CHIP CHIPEDGE
}
VERBATIM {
#ENDIF
}


VERBATIM {
//===========================
//   ACTres - ACT Resistor DRC
//===========================

GROUP GRACTres ACTres_?

AAR_SA = AAR AND SAB
AAR_NS = NOT INTERACT AAR SAB


ACTres_W_1 {
@ Non-silicide ACT resistor width, and it is suggest that ACT resistor length/width ratio >1 for stable Rs  >= 0.4um
  X = (AARES AND AA) AND SAB
  L = X INSIDE EDGE AA
  (LENGTH L < 0.4) NOT INSIDE EDGE NODRC
}

ACTres_S_1_NP {
@ Space between non-silicide ACT resistors area and other implant region >= 0.18um
  X = SDN NOT INTERACT AARES
  (EXT X AAR_SA < 0.18 ABUT<90 REGION) NOT INSIDE NODRC
}
ACTres_S_1_PP {
@ Space between non-silicide ACT resistors area and other implant region >= 0.18um
  X = SDP NOT INTERACT AARES
  (EXT X AAR_SA < 0.18 ABUT<90 REGION) NOT INSIDE NODRC
}
ACTres_S_1_NVT3 {
@ Space between non-silicide ACT resistors area and other implant region >= 0.18um
  X = HVTN NOT INTERACT AARES
  (EXT X AAR_SA < 0.18 ABUT<90 REGION) NOT INSIDE NODRC
}
ACTres_S_1_PVT3 {
@ Space between non-silicide ACT resistors area and other implant region >= 0.18um
  X = HVTP NOT INTERACT AARES
  (EXT X AAR_SA < 0.18 ABUT<90 REGION) NOT INSIDE NODRC
}
ACTres_S_1_NVT1 {
@ Space between non-silicide ACT resistors area and other implant region >= 0.18um
  X = LVTN NOT INTERACT AARES
  (EXT X AAR_SA < 0.18 ABUT<90 REGION) NOT INSIDE NODRC
}
ACTres_S_1_PVT1 {
@ Space between non-silicide ACT resistors area and other implant region >= 0.18um
  X = LVTP NOT INTERACT AARES
  (EXT X AAR_SA < 0.18 ABUT<90 REGION) NOT INSIDE NODRC
}
ACTres_S_1_ESD {
@ Space between non-silicide ACT resistors area and other implant region >= 0.18um
  X = ESD1 NOT INTERACT AARES
  (EXT X AAR_SA < 0.18 ABUT<90 REGION) NOT INSIDE NODRC
}
ACTres_S_1_HRP {
@ Space between non-silicide ACT resistors area and other implant region >= 0.18um
  X = HRP NOT INTERACT AARES
  (EXT X AAR_SA < 0.18 ABUT<90 REGION) NOT INSIDE NODRC
}
ACTres_S_2 {
@ Space between SAB and CT for non-silicide ACT resistor = 0.21um
  X = AAR AND SAB
  Y = CT AND (AAR INTERACT SAB)
  ((SIZE Y BY 0.21) NOT TOUCH AAR_SA) NOT INSIDE NODRC
}
ACTres_EN_1 {
@ PP/NP enclosure of resistor ACT >= 0.18um
  X = SDP OR SDN
  (ENC (AA AND AARES) X < 0.18 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
ACTres_EX_1 {
@ Extension of AARES outside of non-silicide ACT resistor area >= 0.2um
  (ENC AAR_SA AARES < 0.2 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

ACTres_R_1 {
@ Non-silicide ACT resistor region should be covered by SAB and implanted by NP or PP
  X = AAR INTERACT SAB
  (X NOT (OR SDN SDP)) NOT INSIDE NODRC
}
ACTres_R_2 {
@ Non-silicide ACT resistor with PP must be inside NW1
 AARES_SAB = (AARES AND AA) AND SAB  
((AARES_SAB AND SDP) NOT INSIDE NW) NOT INSIDE NODRC
}
ACTres_R_3 {
@ It is not allowed dog-bone design at the end of ACT resistor for contact pick-up
   X = AAR INTERACT SAB
   (CONVEX EDGE X ==1) NOT INSIDE EDGE NODRC
}

ACTres_R_4 {
@ For Silicide ACT resistor, two sides of ACTRES must be along the CT edge
  X = CT AND AAR_NS 
  Y = (AARES NOT INTERACT SAB) INSIDE EDGE AA
  (Y NOT TOUCH EDGE X ) NOT INSIDE EDGE NODRC
}

}


VERBATIM {
//====================
//  NW1res_ACT Rules
//====================

GROUP GRNW1res_ACT NW1res_ACT_?

NW1res_ACT_W_1 {
@ NW1-Resistor width,and suggest NW1 resistor length/width ratio > 5,length >= 20um for SPICE simulation accuracy >= 1.8 um
 X = ((NW1res AND AA) AND NW) AND SAB
 (LENGTH (X INSIDE EDGE NW) < 1.8) NOT INSIDE EDGE NODRC
}

NW1res_ACT_S_1 {
@ Space between NW1 of NW1 resistors and un-related implant region >= 0.60um
 X = NWR INTERACT (HOLES SAB)
 (EXT X (NW NOT INTERACT NWR) < 0.6 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
 (EXT X (HVTN NOT INTERACT NWR) < 0.6 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
 (EXT X (HVTP NOT INTERACT NWR) < 0.6 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
 (EXT X (LVTN NOT INTERACT NWR) < 0.6 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
 (EXT X (LVTP NOT INTERACT NWR) < 0.6 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
 (EXT X (SDN NOT INTERACT NWR) < 0.6 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
 (EXT X (SDP NOT INTERACT NWR) < 0.6 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
 (EXT X (NPR NOT INTERACT NWR) < 0.6 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
 (EXT X (ESD1 NOT INTERACT NWR) < 0.6 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
 (EXT X (HRP NOT INTERACT NWR) < 0.6 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

NW1res_ACT_S_2 {
@ Space between SAB and CT for NW1 ressitor = 0.28 um
 X = SIZE (CT AND (AA INTERACT NW1res)) BY 0.28
 Y = SAB INSIDE EDGE (NW INTERACT NW1res)
 Y NOT TOUCH EDGE X
}

NW1res_ACT_S_3 {
@ Space between NW1 resistor and (NW1 resistor OR NW1) >= 1.2um
  X = NW INTERACT NW1res
 (EXT X NW < 1.2 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

NW1res_ACT_S_4 {
@ Space between NW1 resistor and NP = 0
 (NW1res INSIDE EDGE (NW INTERACT (AA ENCLOSE (NW AND NW1res)))) NOT TOUCH EDGE SDN
} 


NW1res_ACT_EN_1 {
@ ACT enclosure of NW1-Resistor >= 0.90um
 X = ((NW1res AND AA) AND NW) AND SAB
 (ENC X (AA ENCLOSE X) < 0.9 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
NW1res_ACT_EN_2 {
@ SAB enclosure of ACT >= 0.20um
 X = ((NW1res AND AA) AND NW) AND SAB
 Y1 = AA ENCLOSE X
 Y2 = SAB NOT COIN EDGE (HOLES SAB)
 (ENC Y1 Y2 < 0.2 ABUT<90 REGION) NOT INSIDE EDGE NODRC
}

NW1res_ACT_EN_3 {
@ Enclosure of SAB and related NW1 >= 0.28um
 X1 = HOLES SAB
 X2 = SAB TOUCH X1
 (ENC NWR X1 < 0.28 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
 (ENC NWR X2 < 0.28 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
 (((NWR INTERACT X1) NOT X1) NOT SAB) NOT INSIDE NODRC
}

NW1res_ACT_EN_4 {
@ NW1 enclosure of CT >= 0.28um
 X = ((NW1res AND AA) AND NW) AND SAB
 (ENC (CT AND (HOLES SAB)) (NW ENCLOSE X) < 0.28 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

NW1res_ACT_EX_1 {
@ Extension of NW1res outside of ACT >= 0.20um
  (ENC AA (NW1res INTERACT SAB) < 0.2 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
NW1res_ACT_O_1 {
@ Overlap of a NP and SAB (SAB INTERACT NW1res) >= 0.38um
X = ((NW1res AND AA) AND NW) AND SAB
Y = HOLES (SAB INTERACT X)
SDN_1 = SDN INTERACT X
(ENC Y SDN_1 < 0.38 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE NODRC
}		

NW1res_ACT_R_1 {
@ NW1 resistor must be covered by SAB except CT area
  X = NW1res ENCLOSE (NW1res AND AA)
  Y = (SAB OR (HOLES SAB)) INTERACT X
  (Y NOT ENCLOSE (NW1res AND NW)) NOT INSIDE NODRC
}
  
NW1res_ACT_R_2 {
@ recommanded to use rectangle shape resistor for the spice simulation accuracy. DRC flag (NW1 resistor AND NW1) not a rectangle
X = NW1res AND NW
NOT RECTANGLE X
}

NW1res_ACT_R_4 {
@ In one NW1 resistor
@ 1. There is only one NW1 is allowed in same ACT
@ 2. There is only two NPs are allowed in same ACT
@ 3. There is only two SAB holes allowed in same ACT
RESNWAA_CHECK = AA ENCLOSE  ((NW1res AND NW) AND SAB)
RESNWAA_CHECK INTERACT NW > 1
RESNWAA_CHECK INTERACT SDN > 2
RESNWAA_CHECK INTERACT SDN == 1
RESNWAA_CHECK INTERACT ((HOLES SAB) INTERACT RESNWAA_CHECK) > 2
}

 
//=======================
//  NW1res_STI Rules
//=======================

GROUP GNW1es_STI NW1res_STI_?

NWRSTI = NWR NOT INTERACT SAB
NWRSTI_L = NWRSTI INSIDE EDGE NW1res
NWRSTI_W = ((NW1res AND NW) NOT INTERACT SAB) INSIDE EDGE NW

NW1res_STI_W_1 {
@ NW-Resistor width and suggest NW1 resistor length/width ratio > 5,length >= 20um for SPICE simulation accuracy >= 1.8um
 X = (NW1res AND NW) NOT INTERACT SAB
 (LENGTH (X INSIDE EDGE NW) < 1.8) NOT INSIDE EDGE NODRC
}
NW1res_STI_S_1 {
@ Space between NW resistor and adjacent ACT >= 0.50um
 (EXT NWRSTI AA < 0.5 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
NW1res_STI_S_2 {
@ Space between NW1res to silicided ACT area = 0.00um
 X = NW1res INTERACT NWRSTI
 (AND X AA) NOT INSIDE NODRC
Y = X INSIDE EDGE NW
Z = EXPAND EDGE Y INSIDE BY 0.001
(Z NOT TOUCH AA) NOT INSIDE NODRC
}

NW1res_STI_S_3 {
@ Space between NW1 STI resistor and (NW1 STI resistor OR NW1) >= 1.2um.
  X = NW INTERACT NWRSTI
 (EXT X NW < 1.2 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

NW1res_STI_EN_1 {
@ (ACT INTERACT NW1res) enclosure CT = 0.28 um
 X = SIZE (CT AND NWRSTI) BY 0.28
 Y = (AA INTERACT X) INSIDE EDGE NWRSTI
 Y NOT TOUCH EDGE X
}

NW1res_STI_EN_2 {
@ NP enclosure of ACT interact NW1res >= 0.38um
 X = AA AND NWRSTI
 Y = SDN INTERACT NWRSTI
 (ENC X Y < 0.38 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
NW1res_STI_EN_3 {
@ NW1 enclosure of silicide CT >= 0.28um
ENC CT NWRSTI <0.28 SINGULAR REGION
}

NW1res_STI_EX_1 {
@ Extension of NW1res outside of NW1 >= 0.20um
  (ENC NW NW1res < 0.2 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}

NW1res_STI_EX_2 {
@ ACT extention outside of NW1 resistor >= 0.28um
 X = AA INTERACT NWRSTI
 Y = NW INTERACT NWRSTI
 (ENC Y X < 0.28 OPPOSITE REGION) NOT INSIDE NODRC
}
NW1res_STI_R_1 {
@ NW1 Resistor must be fully covered by SAB except for CT area
 X = (NW1res AND NW) NOT INTERACT SAB
 (X AND (AA NOT INTERACT CT)) NOT INSIDE NODRC
}
NW1res_STI_R_2 {
@ NW1res(ineract with NP) must not overlap with ACTdm,POLYdm,PP,ULLD,PVT3,NVT3,PVT1,NVT1,NPR,HRP and ESD
 ((NW1res INTERACT SDN) AND AADUM) NOT INSIDE NODRC
 ((NW1res INTERACT SDN) AND PODUM) NOT INSIDE NODRC
 (NW1res AND HVTN) NOT INSIDE NODRC
 (NW1res AND UVT) NOT INSIDE NODRC
 (NW1res AND HVTP) NOT INSIDE NODRC
 (NW1res AND LVTN) NOT INSIDE NODRC
 (NW1res AND LVTP) NOT INSIDE NODRC
 (NW1res AND SDP) NOT INSIDE NODRC
 (NW1res AND NPR) NOT INSIDE NODRC
 (NW1res AND ESD1) NOT INSIDE NODRC
 (NW1res AND HRP) NOT INSIDE NODRC
}
NW1res_STI_R_3 {
@ recommanded to use rectangle shape resistor for the spice simulation accuracy. DRC flag (NW1 resistor AND NW1) not a rectangle
X = NW1res AND NW
NOT RECTANGLE X
}
}

VERBATIM {
//==========================
//  GR - Poly Resistor DRC
//==========================

GROUP GPORES PORES_?

POR_SA = POR AND SAB
POR_NS = POR NOT INTERACT SAB

PORES_W_1 {
@ Width of non-silicide poly resistor >= 0.4um
@ Suggest the Nsq >= 1 for stable Resistivity >= 1
  X = (PORES AND PO) AND SAB
  L = X INSIDE EDGE PO
  (LENGTH L < 0.4) NOT INSIDE EDGE NODRC
  X1 = PORES AND SAB 
  Y1 = (PO AND PORES) AND SAB 
  L1 = (INSIDE EDGE PO X1) OR EDGE (PO COIN EDGE X1)
  W1 = INSIDE EDGE Y1 PO
  (DFM PROPERTY Y1 L1 W1 OVERLAP ABUT ALSO [SQUARES = LENGTH(L1)/LENGTH(W1)] < 1) NOT INSIDE NODRC
}

PORES_S_1a:PP {
@ Space between N type PO resistors and NP, PP, NPR, HRP, ESD  >= 0.18um
  X = SDP NOT INTERACT PORES
  (EXT X POR_SA < 0.18 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
PORES_S_1b:NP {
@ Space between P type PO resistors and NP, PP, NPR, HRP, ESD (follow GT.10 rule) >= 0.18um
  X = SDN NOT INTERACT PORES
  (EXT X POR_SA < 0.18 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
PORES_S_1:ESD {
@ Space between N/P type PO resistors and NP, PP, NPR, HRP, ESD (follow GT.10 rule) >= 0.18um
  X = ESD1 NOT INTERACT PORES
 (EXT X POR_SA < 0.18 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
PORES_S_1:HRP {
@ Space between N/P type PO resistors and NP, PP, NPR, HRP, ESD (follow GT.10 rule) >= 0.18um
  X = HRP NOT INTERACT PORES
  (EXT X POR_SA < 0.18 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
PORES_S_1:NPR {
@ Space between N/P type PO resistors and NP, PP, NPR, HRP, ESD (follow GT.10 rule) >= 0.18um
  X = NPR NOT INTERACT PORES
  (EXT X POR_SA < 0.18 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
PORES_S_2 {
@ Space between SAB and CT for non-silicide poly resistor = 0.21um
  X = POR INTERACT SAB
  Y = CT AND X
  ((SIZE Y BY 0.21) NOT TOUCH POR_SA) NOT INSIDE NODRC
}
PORES_EN_1 {
@ Enclosure of PP/NP outside of a Poly resistor area >= 0.18um
  X = PORES AND PO
  (ENC X SDN < 0.18 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
  (ENC X SDP < 0.18 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}
PORES_EX_1 {
@ PORES extention outside of PO resistor >= 0.2um
  X = POR_SA COIN EDGE PO
  (ENC X PORES < 0.2 ABUT <90 REGION) NOT INSIDE EDGE NODRC
}
PORES_EX_2 {
@ Extension of SAB outside of non-silicide poly resistor area(follow SAB.6 rule) >= 0.2um
  (ENC POR SAB < 0.2 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}
PORES_R_1 {
@ Non-silicide PO resistor must be covered by SAB and implanted by either NP or PP
  X = POR INTERACT SAB
  (X NOT (SDN OR SDP)) NOT INSIDE NODRC
}
PORES_R_3 {
@ For silicide Poly resistor, two sides of PORES must be along the CT edge
  X = CT AND POR_NS
  Y = (PORES NOT INTERACT SAB) INSIDE EDGE PO
 (Y NOT TOUCH EDGE X) NOT INSIDE EDGE NODRC
}
}




VERBATIM {
#IFDEF Poly_EFuse_CHECK YES

//=======================
//    Poly E-Fuse DRC 
//======================

GROUP GEFU EFU_?
EFU_1b_G {
@ FUSEALL (292;12) must interact with EFUSEALL (293;12) region
(FUSEALL NOT INTERACT EFUSEALL) NOT INSIDE NODRC
}
EFU_1c_G {
@ FUSEALL (292;12) must fully cover EFUSEALL (293;12) region
(EFUSEALL NOT FUSEALL) NOT INSIDE NODRC
}
EFU_2b_G {
@ EFUSEALL (293;12) must interact with POEFUSEBLK(294;12)
(EFUSEALL NOT INTERACT POEFUSEBLK) NOT INSIDE NODRC
}
EFU_2c_G {
@ EFUSE (293;12) must fully cover POEFUSEBLK(294;12)
(POEFUSEBLK NOT EFUSEALL) NOT INSIDE NODRC
}
#ENDIF
}


VERBATIM {
//==================================
//  HRP - High Resistance Poly DRC
//==================================

GROUP GHRP HRP_?

HRP_W_1 {
@ Width of HRP >= 0.21um
@ It is strongly suggested that the resistor square number (length/width ratio) >= 5 for precise Rs. >= 5
  (INT HRP < 0.21 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
HRP_W_2 {
@ Width of high resistance poly >= 2.00um
  X = (PO INTERACT PO_HRP) NOT COIN EDGE SDP
  (INT X < 2.0 OPPOSITE REGION) NOT INSIDE NODRC
}
HRP_S_1 {
@ Space between two HRP >= 0.21um
  (EXT HRP < 0.21 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}
HRP_S_2 {
@ Space between HRP region and NMOS poly >= 0.16um
@ Space between HRP region and PMOS poly >= 0.16um
  PO_MOS = PO INTERACT GATE
  (EXT HRP PO_MOS < 0.16 ABUT SINGULAR REGION) NOT INSIDE NODRC
}
HRP_S_3 {
@ Fixed Space between SAB and CT in HRP region is 0.21um
  X = HRP INTERACT SAB
  Y = CT AND X
  (SIZE Y BY 0.21) NOT TOUCH (SAB INTERACT HRP)
}
HRP_EN_1 {
@ HRP enclosure of high resistance poly >= 0.20um

  (ENC PO_HRP HRP < 0.20 ABUT SINGULAR REGION) NOT INSIDE NODRC
}
HRP_EX_1 {
@ SAB extension outside of high resistance poly >= 0.22um
  (ENC (PO INTERACT PO_HRP) SAB < 0.22 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}
HRP_O_1 {
@ PP overlap with SAB = 0.30um
RES_HRP = ((HPR AND HRP) AND PO) AND SAB
 ((INT (SAB INTERACT RES_HRP) SDP < 0.3 ABUT < 90 SINGULAR REGION) NOT INSIDE SRINGBLK) NOT INSIDE SRAMALL
 SDP_CK = SDP INSIDE EDGE (PO INTERACT RES_HRP)
 ((INT (SDP_CK) (SAB INTERACT RES_HRP) <= 0.3 ABUT < 90) NOT INSIDE EDGE SRINGBLK) NOT INSIDE EDGE SRAMALL
}
HRP_R_1 {
@ It is not allowed (NP,PP) overlap HPR region (when checking the rule, size down the HPR by 0.3um along the current direction)
 HRPR    = PO INTERACT HRP
 HRP_END = SIZE (HRPR NOT HPR) BY 0.3
 HRP_MID = HRPR NOT HRP_END
 ((SDN OR SDP) AND HRP_MID) NOT INSIDE NODRC
}
HRP_R_2 {
@ HPR edge should align with SAB edge
 SAB_AND_HRP = (SAB INTERACT HRP) AND PO
 DMY_AND_HRP = HPR AND PO
 (SAB_AND_HRP XOR DMY_AND_HRP) NOT INSIDE NODRC
}
}

VERBATIM {
LDAA = AA AND LDMOS
LDPAA = LDAA AND SDP
LDNAA = LDAA AND SDN
LDPGATE = LDPAA AND PO
LDNGATE = LDNAA AND PO
LDPD = (LDPAA NOT INTERACT PO) TOUCH LDMOSSTI
LDND = (LDNAA NOT INTERACT PO) TOUCH LDMOSSTI
LDPS = (LDPAA INTERACT PO) NOT LDPGATE
LDNS = (LDNAA INTERACT PO) NOT LDNGATE
SD_LDMOS = OR LDPD LDND LDPS LDNS
PO_LDMOS = LDPGATE OR LDNGATE
AA_LDMOS = SD_LDMOS OR PO_LDMOS
}

VERBATIM {
#IFDEF DUP_CHECK YES
}
VERBATIM {
//=========================================
// DEUPAD (Device Under Pad) Pad Guidelines
//=========================================

padarea = DEUPAD AND MD
}

GROUP GDEUPAD DEUPAD_?

RULECHECK DEUPAD_R_2 {
@  DEUPAD must fully enclose COVER
OUTLAYER  ((MD INTERACT DEUPAD) NOT DEUPAD) NOT INSIDE NODRC
}		
RULECHECK DEUPAD_R_3 {
@ Two top metal layers (TM and TM-1) are needed between DEUPAD and device, where the metal design must be solid.
OUTLAYER ( padarea ENCLOSE (padarea NOT [lindex $metal_all end])) NOT INSIDE NODRC
OUTLAYER ( padarea ENCLOSE (padarea NOT [lindex $metal_all end-1])) NOT INSIDE NODRC
}
RULECHECK DEUPAD_R_5 {
@ ALPADres, MOMLVS1, INDALL, Resistor of TM or TM-1 must be outside of DEUPAD area.
SETLAYER X1 = (ALPAR OR MOMLVS1) OR INDALL
SETLAYER X2 = ([lindex $metal_all end]R AND [lindex $metal_all end]) OR ([lindex $metal_all end-1]R AND [lindex $metal_all end-1])
OUTLAYER  ((X1 OR X2) AND padarea) NOT INSIDE NODRC
}
RULECHECK DEUPAD_R_6 {
@ For one top metal process: TV-1 pattern is not allowed under the DEUPAD opening area
@ For two top metal process: T4V1 patterns are not allowed under the DEUPAD opening area
OUTLAYER (padarea AND [lindex $via_all end-1]) NOT INSIDE NODRC
}
RULECHECK DEUPAD_R_7 {
@ DEUPAD area must have top via array between (top metal and the top metal directly underneath top metal) 
@ two vias which space is within 0.51um are considerd to be same array
  SETLAYER VIA_ARRAY_S_REG = EXT [lindex $via_all end-1] <= 0.51 SINGULAR REGION
  SETLAYER VIA_ARRAY = [lindex $via_all end-1] INTERACT VIA_ARRAY_S_REG
  OUTLAYER padarea NOT INTERACT VIA_ARRAY
}

VERBATIM {
#ENDIF
}

#//====================
#//  Seal Ring Rules
#//====================

GROUP GSRCK SRCK_?


#//Contact, via and TV slots are not permitted for main chip design except guard ring/seal ring applications.
#//(CT/via patterns, with the width/length ratio larger than 3, should be taken as Contact/via slots.)

SETLAYER CTS = CT AND SRINGBLK
SETLAYER CTS_SL = (SRINGBLK AND CTbar) OR (CTS NOT CTS_SQ) 
SETLAYER CTS_SQ = RECTANGLE CTS == 0.09  BY == 0.09 

SETLAYER AAS = ACTi AND (ACTi ENCLOSE CTS)

foreach j $m_j {
  SETLAYER M${j}S = M${j}i AND SRINGBLK
  SETLAYER M${j}S_INNER = M${j}S TOUCH (HOLES M${j}S INNER) == 1
  SETLAYER M${j}S_OUTER = M${j}S TOUCH (HOLES M${j}S) == 1
  SETLAYER M${j}S_RING = M${j}i AND (M${j}S INTERACT M${j}S_OUTER)
  if { ($j < 8) && ([set CHECK_V$j] == 1) } {
  SETLAYER V${j}S = V${j} AND SRINGBLK
  SETLAYER V${j}S_SL = (V${j} AND V${j}bar) OR (V${j}S NOT V${j}S_SQ)
  SETLAYER V${j}S_SQ = RECTANGLE V${j}S == 0.09  BY == 0.09
  VERBATIM { }
  }

}

if { ([set CHECK_T4V1] == 1) && ([set CHECK_T4M1] == 1) } {
  SETLAYER T4V1S = T4V1 AND SRINGBLK
  SETLAYER T4V1S_SL = (T4V1S AND T4V1bar) OR (T4V1S NOT T4V1S_SQ)
  SETLAYER T4V1S_SQ = RECTANGLE T4V1S == 0.36  BY == 0.36

  SETLAYER T4M1S = T4M1i AND SRINGBLK
  SETLAYER T4M1S_INNER = T4M1S TOUCH (HOLES T4M1S INNER) == 1
  SETLAYER T4M1S_OUTER = T4M1S TOUCH (HOLES T4M1S) == 1
  SETLAYER T4M1S_RING = T4M1i AND (T4M1S INTERACT T4M1S_OUTER)

  VERBATIM { }
}

if { ([set CHECK_T4V2] == 1) && ([set CHECK_T4M2] == 1) } {
  SETLAYER T4V2S = T4V2 AND SRINGBLK
  SETLAYER T4V2S_SL = (T4V2S AND T4V2bar) OR (T4V2S NOT T4V2S_SQ) 
  SETLAYER T4V2S_SQ = RECTANGLE T4V2S == 0.36  BY == 0.36

  SETLAYER T4M2S = T4M2i AND SRINGBLK
  SETLAYER T4M2S_INNER = T4M2S TOUCH (HOLES T4M2S INNER) == 1
  SETLAYER T4M2S_OUTER = T4M2S TOUCH (HOLES T4M2S) == 1
  SETLAYER T4M2S_RING = T4M2i AND (T4M2S INTERACT T4M2S_OUTER)

  VERBATIM { }
}

if { ([set CHECK_T2V1] == 1) && ([set CHECK_T2M1] == 1) } {
  SETLAYER T2V1S = T2V1 AND SRINGBLK
  SETLAYER T2V1S_SL = (T2V1S AND T2V1bar) OR (T2V1S NOT T2V1S_SQ)
  SETLAYER T2V1S_SQ = RECTANGLE T2V1S == 0.2  BY == 0.2

  SETLAYER T2M1S = T2M1 AND SRINGBLK
  SETLAYER T2M1S_INNER = T2M1S TOUCH (HOLES T2M1S INNER) == 1
  SETLAYER T2M1S_OUTER = T2M1S TOUCH (HOLES T2M1S) == 1
  SETLAYER T2M1S_RING = T2M1i AND (T2M1S INTERACT T2M1S_OUTER)

  VERBATIM { }
}

if { ([set CHECK_T2V2] == 1) && ([set CHECK_T2M2] == 1) } {
  SETLAYER T2V2S = T2V2 AND SRINGBLK
  SETLAYER T2V2S_SL = (T2V2S AND T2V2bar) OR (T2V2S NOT T2V2S_SQ)
  SETLAYER T2V2S_SQ = RECTANGLE T2V2S == 0.2  BY == 0.2

  SETLAYER T2M2S = T2M2i AND SRINGBLK
  SETLAYER T2M2S_INNER = T2M2S TOUCH (HOLES T2M2S INNER) == 1
  SETLAYER T2M2S_OUTER = T2M2S TOUCH (HOLES T2M2S) == 1
  SETLAYER T2M2S_RING = T2M2i AND (T2M2S INTERACT T2M2S_OUTER)

  VERBATIM { }
}
if { ([set CHECK_T8V1] == 1) && ([set CHECK_T8M1] == 1) } {
  SETLAYER T8V1S = T8V1 AND SRINGBLK
  SETLAYER T8V1S_SL = (T8V1S AND T8V1bar) OR (T8V1S NOT T8V1S_SQ)
  SETLAYER T8V1S_SQ = RECTANGLE T8V1S == 0.36  BY == 0.36

  SETLAYER T8M1S = T8M1i AND SRINGBLK
  SETLAYER T8M1S_INNER = T8M1S TOUCH (HOLES T8M1S INNER) == 1
  SETLAYER T8M1S_OUTER = T8M1S TOUCH (HOLES T8M1S) == 1
  SETLAYER T8M1S_RING = T8M1i AND (T8M1S INTERACT T8M1S_OUTER)

  VERBATIM { }
}


if { ([set CHECK_T8V2] == 1) && ([set CHECK_T8M2] == 1) } {
  SETLAYER T8V2S = T8V2 AND SRINGBLK
  SETLAYER T8V2S_SL = (T8V2S AND T8V2bar) OR (T8V2S NOT T8V2S_SQ)
  SETLAYER T8V2S_SQ = RECTANGLE T8V2S == 0.36  BY == 0.36

  SETLAYER T8M2S = T8M2i AND SRINGBLK
  SETLAYER T8M2S_INNER = T8M2S TOUCH (HOLES T8M2S INNER) == 1
  SETLAYER T8M2S_OUTER = T8M2S TOUCH (HOLES T8M2S) == 1
  SETLAYER T8M2S_RING = T8M2i AND (T8M2S INTERACT T8M2S_OUTER)

  VERBATIM { }
}
SETLAYER RDLVIAS = RDLVIA AND SRINGBLK
SETLAYER RDLS = RDLi AND SRINGBLK
SETLAYER RDLS_INNER = RDLS TOUCH (HOLES RDLS INNER) == 1
SETLAYER RDLS_OUTER = RDLS TOUCH (HOLES RDLS) == 1
SETLAYER RDLS_RING = RDLi AND (RDLS INTERACT RDLS_OUTER)
SETLAYER RDLPA2S = RDLPA2 AND SRINGBLK

VERBATIM { }


set MS_RING_INNER "RDLS_INNER OR [lindex $metal_all 0]S_INNER"
foreach metal_each [lreplace $metal_all 0 0] {
  set MS_RING_INNER "(${MS_RING_INNER}) OR ${metal_each}S_INNER"
}
SETLAYER MS_RING_INNER = $MS_RING_INNER

set M_ALL "[lindex $metal_all 0]i OR [lindex $metal_all 1]i"
foreach metal_each [lreplace $metal_all 0 1] {
  set M_ALL "(${M_ALL}) OR ${metal_each}i"
}
SETLAYER M_ALL = $M_ALL

set MDUM_ALL "[lindex $metal_dummy_list 0] OR [lindex $metal_dummy_list 1]"
foreach metal_dummy_each [lreplace $metal_dummy_list 0 1] {
  set MDUM_ALL "(${MDUM_ALL}) OR $metal_dummy_each"
}
SETLAYER MDUM_ALL = $MDUM_ALL

SETLAYER MA_ALL = M_ALL NOT INSIDE SRINGBLK

set ISOLATION "SRINGBLK AND (HOLES M1S_INNER INNER)"
foreach metal_each [lreplace $metal_all 0 0] {
  set ISOLATION "(${ISOLATION}) AND (SRINGBLK AND (HOLES ${metal_each}S_INNER INNER))"
}
SETLAYER ISOLATION = $ISOLATION


CONNECT AAS M1S_RING BY CTS
for { set i 0 } { $i < [expr [llength $v_m_list] -2] } { incr i 2 } {
  CONNECT [lindex $v_m_list $i]S_RING [lindex $v_m_list [expr $i +2]]S_RING BY [lindex $v_m_list [expr $i +1]]S
}
CONNECT SRINGBLK [lindex $v_m_list end]S_RING
CONNECT [lindex $v_m_list end]S_RING RDLS_RING BY RDLVIAS

foreach j $m_j {

RULECHECK SRCK_3_M${j} {
@ Space between outer ring metal and window edge >= 2
 OUTLAYER ENC M${j}S_OUTER DRC:1 < 2 ABUT < 90 SINGULAR REGION
}

} 

if { ([set CHECK_T2V1] == 1) && ([set CHECK_T2M1] == 1) } {
RULECHECK SRCK_3_T2M1 {
@ Space between outer ring metal and window edge >= 2
 OUTLAYER ENC T2M1S_OUTER DRC:1 < 2 ABUT < 90 SINGULAR REGION
}
}
if { ([set CHECK_T2V2] == 1) && ([set CHECK_T2M2] == 1) } {
RULECHECK SRCK_3_T2M2 {
@ Space between outer ring metal and window edge >= 2
 OUTLAYER ENC T2M2S_OUTER DRC:1 < 2 ABUT < 90 SINGULAR REGION
}
}
if { ([set CHECK_T4V1] == 1) && ([set CHECK_T4M1] == 1) } {
RULECHECK SRCK_3_T4M1 {
@ Space between outer ring metal and window edge >= 2
 OUTLAYER ENC T4M1S_OUTER DRC:1 < 2 ABUT < 90 SINGULAR REGION
}
}
if { ([set CHECK_T4V2] == 1) && ([set CHECK_T4M2] == 1) } {
RULECHECK SRCK_3_T4M2 {
@ Space between outer ring metal and window edge >= 2
 OUTLAYER ENC T4M2S_OUTER DRC:1 < 2 ABUT < 90 SINGULAR REGION
}
}
if { ([set CHECK_T8V1] == 1) && ([set CHECK_T8M1] == 1) } {
RULECHECK SRCK_3_T8M1 {
@ Space between outer ring metal and window edge >= 2
 OUTLAYER ENC T8M1S_OUTER DRC:1 < 2 ABUT < 90 SINGULAR REGION
}
}
if { ([set CHECK_T8V2] == 1) && ([set CHECK_T8M2] == 1) } {
RULECHECK SRCK_3_T8M2 {
@ Space between outer ring metal and window edge >= 2
 OUTLAYER ENC T8M2S_OUTER DRC:1 < 2 ABUT < 90 SINGULAR REGION
}
}

foreach j $m_j {

RULECHECK SRCK_4_M${j} {
@ Space between outer ring metal and inner ring metal >= 2
 OUTLAYER EXT M${j}S_INNER M${j}S_OUTER < 2 ABUT < 90 SINGULAR REGION
}
}
 
if { ([set CHECK_T2V1] == 1) && ([set CHECK_T2M1] == 1) } {
RULECHECK SRCK_4_T2M1 {
@ Space between outer ring metal and inner ring metal >= 2
 OUTLAYER EXT T2M1S_INNER T2M1S_OUTER < 2 ABUT < 90 SINGULAR REGION
}
}


if { ([set CHECK_T2V2] == 1) && ([set CHECK_T2M2] == 1) } {
RULECHECK SRCK_4_T2M2 {
@ Space between outer ring metal and inner ring metal >= 2
 OUTLAYER EXT T2M2S_INNER T2M2S_OUTER < 2 ABUT < 90 SINGULAR REGION
}
}
if { ([set CHECK_T4V1] == 1) && ([set CHECK_T4M1] == 1) } {
RULECHECK SRCK_4_T4M1 {
@ Space between outer ring metal and inner ring metal >= 2
 OUTLAYER EXT T4M1S_INNER T4M1S_OUTER < 2 ABUT < 90 SINGULAR REGION
}
}
if { ([set CHECK_T4V2] == 1) && ([set CHECK_T4M2] == 1) } {
RULECHECK SRCK_4_T4M2 {
@ Space between outer ring metal and inner ring metal >= 2
 OUTLAYER EXT T4M2S_INNER T4M2S_OUTER < 2 ABUT < 90 SINGULAR REGION
}
}
if { ([set CHECK_T8V1] == 1) && ([set CHECK_T8M1] == 1) } {
RULECHECK SRCK_4_T8M1 {
@ Space between outer ring metal and inner ring metal >= 2
 OUTLAYER EXT T8M1S_INNER T8M1S_OUTER < 2 ABUT < 90 SINGULAR REGION
}
}
if { ([set CHECK_T8V2] == 1) && ([set CHECK_T8M2] == 1) } {
RULECHECK SRCK_4_T8M2 {
@ Space between outer ring metal and inner ring metal >= 2
 OUTLAYER EXT T8M2S_INNER T8M2S_OUTER < 2 ABUT < 90 SINGULAR REGION
}
}

foreach j $m_j {

RULECHECK SRCK_5_M${j} {
@ Metal width of outer ring metal  >= 2
 OUTLAYER INT M${j}S_OUTER < 2 ABUT < 90 SINGULAR REGION
}

} 

if { ([set CHECK_T2V1] == 1) && ([set CHECK_T2M1] == 1) } {
RULECHECK SRCK_5_T2M1 {
@ Metal width of outer ring  >= 2
 OUTLAYER INT  T2M1S_OUTER < 2 ABUT < 90 SINGULAR REGION
} 
}
if { ([set CHECK_T2V2] == 1) && ([set CHECK_T2M2] == 1) } {
RULECHECK SRCK_5_T2M2 {
@ Metal width of outer ring  >= 2
 OUTLAYER INT  T2M2S_OUTER < 2 ABUT < 90 SINGULAR REGION
} 
}
if { ([set CHECK_T4V1] == 1) && ([set CHECK_T4M1] == 1) } {
RULECHECK SRCK_5_T4M1 {
@ Metal width of outer ring  >= 2
 OUTLAYER INT  T4M1S_OUTER < 2 ABUT < 90 SINGULAR REGION
} 
}
if { ([set CHECK_T4V2] == 1) && ([set CHECK_T4M2] == 1) } {
RULECHECK SRCK_5_T4M2 {
@ Metal width of outer ring  >= 2
 OUTLAYER INT  T4M2S_OUTER < 2 ABUT < 90 SINGULAR REGION
} 
}
if { ([set CHECK_T8V1] == 1) && ([set CHECK_T8M1] == 1) } {
RULECHECK SRCK_5_T8M1 {
@ Metal width of outer ring  >= 2
 OUTLAYER INT  T8M1S_OUTER < 2 ABUT < 90 SINGULAR REGION
} 
}
if { ([set CHECK_T8V2] == 1) && ([set CHECK_T8M2] == 1) } {
RULECHECK SRCK_5_T8M2 {
@ Metal width of outer ring  >= 2
 OUTLAYER INT  T8M2S_OUTER < 2 ABUT < 90 SINGULAR REGION
} 
}

foreach j $m_j {

RULECHECK SRCK_6_M${j} {
@ Metal width of inner ring metal  >= 4
 OUTLAYER INT M${j}S_INNER < 4 ABUT < 90 SINGULAR REGION
}

} 

if { ([set CHECK_T2V1] == 1) && ([set CHECK_T2M1] == 1) } {
RULECHECK SRCK_6_T2M1 {
@ Metal width of inner ring  >= 4
 OUTLAYER INT  T2M1S_INNER < 4 ABUT < 90 SINGULAR REGION
}
}
if { ([set CHECK_T2V2] == 1) && ([set CHECK_T2M2] == 1) } {
RULECHECK SRCK_6_T2M2 {
@ Metal width of inner ring  >= 4
 OUTLAYER INT  T2M2S_INNER < 4 ABUT < 90 SINGULAR REGION
}
}
if { ([set CHECK_T4V1] == 1) && ([set CHECK_T4M1] == 1) } {
RULECHECK SRCK_6_T4M1 {
@ Metal width of inner ring  >= 4
 OUTLAYER INT  T4M1S_INNER < 4 ABUT < 90 SINGULAR REGION
}
}
if { ([set CHECK_T4V2] == 1) && ([set CHECK_T4M2] == 1) } {
RULECHECK SRCK_6_T4M2 {
@ Metal width of inner ring  >= 4
 OUTLAYER INT  T4M2S_INNER < 4 ABUT < 90 SINGULAR REGION
}
}
if { ([set CHECK_T8V1] == 1) && ([set CHECK_T8M1] == 1) } {
RULECHECK SRCK_6_T8M1 {
@ Metal width of inner ring  >= 4
 OUTLAYER INT  T8M1S_INNER < 4 ABUT < 90 SINGULAR REGION
}
}
if { ([set CHECK_T8V2] == 1) && ([set CHECK_T8M2] == 1) } {
RULECHECK SRCK_6_T8M2 {
@ Metal width of inner ring  >= 4
 OUTLAYER INT  T8M2S_INNER < 4 ABUT < 90 SINGULAR REGION
}
}

RULECHECK SRCK_7_RDL {
@ RDL Clearance to window edge  >= 4.5
 OUTLAYER ENC  RDLS_OUTER DRC:1 < 4.5 ABUT < 90 SINGULAR REGION
} 

RULECHECK SRCK_8_RDL {
@ RDL width in seal ring  >= 5.5
 OUTLAYER INT RDLS < 5.498 ABUT < 90 SINGULAR REGION
} 


RULECHECK SRCK_9_RV {
@ RV clearance to Window edge >= 6
OUTLAYER  ENC RDLVIAS DRC:1 < 6 ABUT <90 SINGULAR REGION
}

RULECHECK SRCK_10_RV {
@ RV slot width = 3
OUTLAYER INT  RDLVIAS  < 2.97 ABUT <90 SINGULAR REGION
OUTLAYER RDLVIAS WITH WIDTH > 3.03 
}

RULECHECK SRCK_11_COVER {
@ Cover(Passivation2) clearance to Window edge >= 6
OUTLAYER  ENC RDLPA2S DRC:1 < 6 ABUT <90 SINGULAR REGION
}

RULECHECK SRCK_12_COVER {
@ Cover(Passivation2) Slot width = 3
OUTLAYER  INT RDLPA2S < 2.97 ABUT <90 SINGULAR REGION
OUTLAYER  WITH WIDTH RDLPA2S > 3.03
}

RULECHECK SRCK_13a {
@ Fixed CT bar width = 0.09
@ NOTICE: It is a guidelines rule.
  SETLAYER X = INT CTS_SL < 0.089 ABUT<90 SINGULAR REGION
  SETLAYER Y = CTS_SL WITH WIDTH > 0.091
  OUTLAYER (X OR Y) NOT INSIDE NODRC
}

RULECHECK SRCK_13b {
@ Fixed Vn bar width (n=1~7) = 0.09
@ NOTICE: It is a guidelines rule.
foreach via $v_j_layer {
  OUTLAYER (INT ${via}S_SL < 0.089 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
  OUTLAYER (${via}S_SL WITH WIDTH > 0.091) NOT INSIDE NODRC
}
}

if { ($CHECK_T2V1 == 1) || ($CHECK_T2V2 == 1) } {
RULECHECK SRCK_13d {
@ T2Vn(n=1~2) bar width (for 2X option)  = 0.20 
@ NOTICE: It is a guidelines rule.
foreach top_via { T2V1 T2V2 } {
  if { [set CHECK_$top_via] == 1 } {
    OUTLAYER (INT ${top_via}S_SL < 0.199 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
    OUTLAYER (${top_via}S_SL WITH WIDTH > 0.223) NOT INSIDE NODRC
  }
}
}
}

if { ($CHECK_T4V1 == 1) || ($CHECK_T4V2 == 1) || ($CHECK_T8V1 == 1) || ($CHECK_T8V2 == 1) } {
RULECHECK SRCK_13e_13f {
@ Fixed T4Vn(n=1~2) width (for 4X option and T8V2) bar width = 0.36,DRC waive check 0.36um square TVn
foreach top_via { T4V1 T4V2 T8V1 T8V2} {
  if { [set CHECK_$top_via] == 1 } {
    SETLAYER VIA_${top_via} = RECTANGLE ${top_via}S == 0.36 BY == 0.36
    SETLAYER TOP_${top_via} = ${top_via}S NOT VIA_${top_via}      
    OUTLAYER (INT TOP_${top_via} < 0.36-0.005 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
    OUTLAYER (TOP_${top_via} WITH WIDTH > 0.36+0.005) NOT INSIDE NODRC
    
  }
}
}
}

RULECHECK SRCK_14a {
@ Fixed square CT width and length = 0.09
@ NOTICE: It is a guidelines rule.
  OUTLAYER NOT RECTANGLE CTS == 0.09  BY == 0.09
}

RULECHECK SRCK_14b_14c {
@ Fixed Vn width and length (n=1~7) is 0.09
@ NOTICE: It is a guidelines rule.
foreach via $v_j_layer {
  OUTLAYER (NOT RECTANGLE ${via}S  == 0.09 BY == 0.09) NOT INSIDE NODRC
}
}

if { ($CHECK_T2V1 == 1) || ($CHECK_T2V2 == 1) } {
RULECHECK SRCK_14d {
@ Square T2Vn(n=1~2) width and length (for 2X option) = 0.2
@ NOTICE: It is a guidelines rule.
foreach top_via { T2V1 T2V2 } {
  if { [set CHECK_$top_via] == 1 } {
    OUTLAYER (NOT RECTANGLE ${top_via}S == 0.2 BY ==0.2) NOT INSIDE NODRC
  }
}
}
}

if { ($CHECK_T4V1 == 1) || ($CHECK_T4V2 == 1) || ($CHECK_T8V1 == 1) || ($CHECK_T8V2 == 1)} {
RULECHECK SRCK_14e_14f {
@ Fixed T4Vn(n=1~2) width and length (for square 4X option and T8V2) = 0.36
foreach top_via { T4V1 T4V2 T8V1 T8V2 } {
  if { [set CHECK_$top_via] == 1 } {
    OUTLAYER NOT RECTANGLE  ${top_via}S  == 0.36 BY == 0.36
    
  }
}
}
}

RULECHECK SRCK_15a_CT { 
@ Metal enclosure of CT bar >= 0.375
  OUTLAYER (ENC CTS_SL M1S < 0.375 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK SRCK_15b_V1 {
@ Metal enclosure of via bar >= 0.375
  OUTLAYER (ENC V1S_SL M1S < 0.375 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
  OUTLAYER (ENC V1S_SL M2S < 0.375 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK SRCK_15b_15c {
@ Via bar enclosure by Mn (n=2~7) is 0.375/0.5
@ NOTICE: It is a guidelines rule.
for { set j 2 } { $j <= [lindex $v_j end] } { incr j } {
  SETLAYER ENC5_V${j} = V${j}S_SL INTERACT ((ENC V${j}S_SL M${j}S < 0.5 ABUT < 90 SINGULAR REGION) OR (ENC V${j}S_SL M[expr $j+1]S < 0.5 ABUT < 90 SINGULAR REGION))
  OUTLAYER (ENC ENC5_V${j} M${j}S < 0.375 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
  OUTLAYER (ENC ENC5_V${j} M[expr $j +1]S < 0.375 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}
}

RULECHECK SRCK_15d_15e_15f {
@ Min T2M1/T2M2 enclosure of T2V1/T2V2 bar is 0.52
@ Min T4M1/T4M2 enclosure of T4V1/T4V2 bar is 0.44
@ Min T8M1/T8M2 enclosure of T8V1/T8V2 bar is 0.44
@ NOTICE: It is a guidelines rule.
if { ([set CHECK_T2V2] == 1) && ([set CHECK_T2M2] == 1) } {
  OUTLAYER (ENC [lindex $top_v_m_list 0]S_SL [lindex $top_v_m_list 1]S < 0.52 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
if { [llength $top_v_m_list] == 4 } {
  OUTLAYER (ENC [lindex $top_v_m_list 2]S_SL [lindex $top_v_m_list 3]S < 0.52 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}  
}

if { ([set CHECK_T2V2] == 0)} {
  OUTLAYER (ENC [lindex $top_v_m_list 0]S_SL [lindex $top_v_m_list 1]S < 0.44 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
if { [llength $top_v_m_list] == 4 } {
  OUTLAYER (ENC [lindex $top_v_m_list 2]S_SL [lindex $top_v_m_list 3]S < 0.44 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}
}
}

RULECHECK SRCK_16a_CT {
@ Square CT enclosure by M1 in SRINGBLK outer ring covered areas is 0.405
@ NOTICE: It is a guidelines rule.
  OUTLAYER (ENC CTS_SQ M1S_OUTER < 0.405 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK SRCK_16b_v1 {
@ Square via enclosure by M1 in SRINGBLK outer ring is 0.405
@ NOTICE: It is a guidelines rule.
  OUTLAYER (ENC V1S_SQ M1S_OUTER < 0.405 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}


RULECHECK SRCK_16b_16c {
@ Square via enclosure by Mn in SRINGBLK outer ring (n=2~7) is 0.405
@ NOTICE: It is a guidelines rule.
for { set j 2 } { $j <= [lindex $v_j end] } { incr j } {
  OUTLAYER (ENC V${j}S_SQ M${j}S_OUTER < 0.405 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}
}

RULECHECK SRCK_16d_16e_16f {
@ Min T2M1/T2M2 enclosure of T2V1/T2V2 in SRINGBLK outer ring is 0.48
@ Min T4M1/T4M2 enclosure of T4V1/T4V2 in SRINGBLK outer ring is 0.24
@ Min T8M1/T8M2 enclosure of T8V1/T8V2 in SRINGBLK outer ring is 0.24
@ NOTICE: It is a guidelines rule.
if { ([set CHECK_T2V2] == 1) && ([set CHECK_T2M2] == 1) } {
OUTLAYER (ENC [lindex $top_v_m_list 0]S [lindex $top_v_m_list 1]S < 0.48 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC

if { [llength $top_v_m_list] == 4 } {
  OUTLAYER (ENC [lindex $top_v_m_list 0]S [lindex $top_v_m_list 1]S < 0.48 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}
}

if { ([set CHECK_T2V2] == 0)} {
OUTLAYER (ENC [lindex $top_v_m_list 0]S [lindex $top_v_m_list 1]S < 0.24 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
if { [llength $top_v_m_list] == 4 } {
  OUTLAYER (ENC [lindex $top_v_m_list 2]S [lindex $top_v_m_list 3]S < 0.24 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}
}
}

RULECHECK SRCK_17a {
@ Minimum space between square contact and its bar is 0.74
@ NOTICE: It is a guidelines rule.
  OUTLAYER (EXT CTS_SL CTS_SQ < 0.74 ABUT < 90 OPPOSITE REGION) NOT INSIDE NODRC
}


RULECHECK SRCK_17b_17c {
@ Minimum space between square via and its bar is 0.6/0.74
@ NOTICE: It is a guidelines rule.
foreach via $v_j_layer {
  SETLAYER SPACE_074_${via}S_SL = ${via}S_SL INTERACT (EXT ${via}S_SL ${via}S_SQ < 0.74 ABUT < 90 OPPOSITE REGION)
  OUTLAYER (EXT SPACE_074_${via}S_SL ${via}S_SQ < 0.6 ABUT < 90 OPPOSITE REGION) NOT INSIDE NODRC
}
}

RULECHECK SRCK_17d_17e_17f {
@ Minimum space between square TV and its bar is 0.6
@ NOTICE: It is a guidelines rule.
foreach t_v_list_layer $t_v_j {
  OUTLAYER (EXT ${t_v_list_layer}S_SL ${t_v_list_layer}S_SQ < 0.6 ABUT < 90 OPPOSITE REGION) NOT INSIDE NODRC
}
}

RULECHECK SRCK_18a_19a {
@ CT space perpendicular to the direction of seal ring >=0.21
@ CT space along the sealring direction in the same colum >= 0.6
SETLAYER CHECK_CT = CTS OR (EXT CTS_SQ <0.6 OPPOSITE REGION)
OUTLAYER EXT CHECK_CT < 0.21 OPPOSITE REGION
}

RULECHECK SRCK_18b_18c_19b_19c {
@ Vn space perpendicular to the direction of seal ring >=0.21
@ Vn+1 space along the sealring direction in the same colum >= 0.6
foreach via $v_j_layer {
SETLAYER CHECK_${via}S = ${via}S OR (EXT ${via}S_SQ <0.6 OPPOSITE REGION)
OUTLAYER EXT CHECK_${via}S < 0.21 OPPOSITE REGION
}
}

if { ($CHECK_T2V1 == 1) || ($CHECK_T2V2 == 1) } {
RULECHECK SRCK_18d_19d_T2V1 {
@ T2Vn space perpendicular to the direction of seal ring >=0.38
@ T2Vn space along the sealring direction in the same colum >= 0.6
foreach top_via { T2V1 T2V2 } {
  if { [set CHECK_$top_via] == 1 } {
SETLAYER CHECK_${top_via} = ${top_via}S OR (EXT ${top_via}S_SQ <0.6 OPPOSITE REGION)
OUTLAYER EXT CHECK_${top_via} < 0.38 OPPOSITE REGION
}
}
}
}

if { ($CHECK_T4V1 == 1) || ($CHECK_T4V2 == 1) || ($CHECK_T8V1 == 1) || ($CHECK_T8V2 == 1)  } {
RULECHECK SRCK_18e_18f_19e_19f_${top_via} {
@ T4Vn space perpendicular to the direction of seal ring >=0.48
@ T4Vn space along the sealring direction in the same colum >= 0.6
@ T8Vn space perpendicular to the direction of seal ring >=0.48
@ T8Vn space along the sealring direction in the same colum >= 0.6
foreach top_via { T4V1 T4V2 T8V1 T8V2} {
  if { [set CHECK_$top_via] == 1 } {
SETLAYER CHECK_${top_via} = ${top_via}S OR (EXT ${top_via}S_SQ <0.6 OPPOSITE REGION)
OUTLAYER EXT CHECK_${top_via} < 0.48 OPPOSITE REGION
}
}
}
}


VERBATIM {
#IFDEF Metal_Slot_CHECK YES
}
#//========================================
#//  slot - Recommended metal slot rules
#//========================================
GROUP GSL SL_?


RULECHECK SL_W_1_L_1 {
@ Width of metal lot >= 2um
@ Length of metal lot >= 4.5um
foreach j [concat $metal_all ] {
OUTLAYER (NOT RECTANGLE ${j}slot >= 2 BY >= 4.5) NOT INSIDE NODRC
}
}

RULECHECK SL_S_1 {
@ Space of metal lot >= 3um
foreach j [concat $metal_all ] {
OUTLAYER (EXT ${j}slot <3 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}
}

RULECHECK SL_R_1 {
@ The top-metal slot overlap CB is not allowed
foreach j [concat $metal_all ] {
OUTLAYER ${j}slot AND PA
}
}

VERBATIM {
#ENDIF
}

#//======================================
#//  ACT Dummy Pattern check DRC
#//======================================

SETLAYER AADUM_3_3 = RECTANGLE AADUM ==3  BY == 3
SETLAYER AADUM_1_1 = RECTANGLE AADUM ==1  BY == 1
SETLAYER AADUM_0p5_0p5 = RECTANGLE AADUM ==0.467  BY ==0.467

RULECHECK ACTDUM_W_1 {
@ ACTDUM SIZE = 3x3, 1x1, 0.467x0.467
OUTLAYER ((AADUM NOT AADUM_3_3) NOT AADUM_1_1) NOT AADUM_0p5_0p5
}
RULECHECK ACTDUM_S_1 {
@ ACTDUM space if ACTDUM size is 3um*3um >= 2
OUTLAYER EXT  AADUM_3_3 < 2 ABUT <90 SINGULAR REGION
}
RULECHECK ACTDUM_S_2 {
@ ACTDUM space if ACTDUM size is 1um*1um >= 0.6
OUTLAYER EXT  AADUM_1_1 < 0.6 ABUT <90 SINGULAR REGION
}
RULECHECK ACTDUM_S_3 {
@ ACTDUM space if ACTDUM size is 0.467um*0.467um >= 0.28
OUTLAYER EXT  AADUM_0p5_0p5 < 0.28 ABUT <90 SINGULAR REGION
}
RULECHECK ACTDUM_S_4 {
@ Space between ACTDUM and ACT, ACTDUM can not overlap with ACT  >= 1.6
OUTLAYER EXT  AADUM AA < 1.6 ABUT <90 SINGULAR REGION
OUTLAYER AADUM AND AA
}
RULECHECK ACTDUM_S_5 {
@ Space between ACTDUM and Poly, ACTDUM can not overlap with Poly >= 1.6
OUTLAYER EXT  AADUM PO < 1.6 ABUT <90 SINGULAR REGION
OUTLAYER AADUM AND PO
}
RULECHECK ACTDUM_S_6 {
@ Space between ACTDUM and NW1 boundary >= 0.3
OUTLAYER EXT AADUM NW < 0.3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC AADUM NW < 0.3 ABUT < 90 SINGULAR REGION
}
RULECHECK ACTDUM_S_7 {
@ Space between ACTDUM and FUSEALL >= 2
OUTLAYER EXT AADUM FUSEALL < 2 ABUT < 90 SINGULAR REGION
}
RULECHECK ACTDUM_S_8 {
@ Space between ACTDUM and NW1res >= 0.6
OUTLAYER EXT AADUM NW1res < 0.6 ABUT < 90 SINGULAR REGION
}
RULECHECK ACTDUM_S_9 {
@ Space between ACTDUM and LOGO >= 0.1
OUTLAYER EXT AADUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
}
RULECHECK ACTDUM_S_10 {
@ Space between ACTDUM and INDALL >= 2
OUTLAYER EXT AADUM INDALL < 2 ABUT < 90 SINGULAR REGION
}
RULECHECK ACTDUM_S_11 {
@ Space between ACTDUM and Frame boundary >= 0.6
OUTLAYER EXT AADUM CHIPBLK < 0.6 ABUT < 90 SINGULAR REGION
OUTLAYER ENC AADUM CHIPBLK < 0.6 ABUT < 90 SINGULAR REGION
}
RULECHECK ACTDUM_S_12 {
@ Space between ACTDUM and ACTDUMB >= 2
OUTLAYER EXT AADUM AADUMB < 2 ABUT < 90 SINGULAR REGION
}
RULECHECK ACTDUM_S_13 {
@ Space between ACTDUM and DMYBLK >= 2
OUTLAYER EXT AADUM DMYBLK < 2 ABUT < 90 SINGULAR REGION
}
RULECHECK ACTDUM_R_1 {
@ ACTDUM can not overlap with CT
OUTLAYER AADUM AND CT 
}
RULECHECK ACTDUM_R_2 {
@ ACTDUM must be covered by ACTDUMB layer
OUTLAYER AADUM NOT AADUMB 
}

#//======================================
#//  POLY Dummy Pattern check DRC
#//======================================

SETLAYER PODUM_2p4_2p4 = RECTANGLE PODUM == 2.4  BY == 2.4
SETLAYER PODUM_0p92_0p92 = RECTANGLE PODUM == 0.92  BY == 0.92
SETLAYER PODUM_0p38_0p38 = RECTANGLE PODUM == 0.38  BY ==0.38

RULECHECK PODUM_W_1 {
@ PODUM SIZE = 2.4x2.4, 0.92x0.92, 0.38x0.38
OUTLAYER ((PODUM NOT PODUM_2p4_2p4) NOT PODUM_0p92_0p92) NOT PODUM_0p38_0p38
}
RULECHECK PODUM_S_1 {
@ PODUM space if PODUM size is 2.4um*2.4um >= 2.6
OUTLAYER EXT PODUM_2p4_2p4 < 2.6 ABUT <90 SINGULAR REGION
}
RULECHECK PODUM_S_2 {
@ PODUM space if PODUM size is 0.92um*0.92um >= 0.68
OUTLAYER EXT PODUM_0p92_0p92 < 0.68 ABUT <90 SINGULAR REGION
}
RULECHECK PODUM_S_3 {
@ PODUM space if PODUM size is 0.38um*0.38um >= 0.36
OUTLAYER EXT PODUM_0p38_0p38 < 0.36 ABUT <90 SINGULAR REGION
}
RULECHECK PODUM_S_4 {
@ Space between PODUM and ACT, PODUM can not overlap with ACT  >= 0.8
OUTLAYER EXT PODUM AA < 0.8 ABUT <90 SINGULAR REGION
OUTLAYER PODUM AND AA
}
RULECHECK PODUM_S_5 {
@ Space between PODUM and Poly, PODUM can not overlap with Poly >= 0.8
OUTLAYER EXT  PODUM PO < 0.8 ABUT <90 SINGULAR REGION
OUTLAYER PODUM AND PO
}
RULECHECK PODUM_S_6 {
@ Space between PODUM and NW1 boundary >= 0.3
OUTLAYER EXT PODUM NW < 0.3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC PODUM NW < 0.3 ABUT < 90 SINGULAR REGION
}
RULECHECK PODUM_S_7 {
@ Space between PODUM and NW1res >= 0.6
OUTLAYER EXT PODUM NW1res < 0.6 ABUT < 90 SINGULAR REGION
}
RULECHECK PODUM_S_8 {
@ Space between PODUM and LOGO >= 0.1
OUTLAYER EXT PODUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
}
RULECHECK PODUM_S_9 {
@ Space between PODUM and INDALL >= 2
OUTLAYER EXT PODUM INDALL < 2 ABUT < 90 SINGULAR REGION
}
RULECHECK PODUM_S_10 {
@ Space between PODUM and CHIPBLK >= 0.6
OUTLAYER EXT PODUM CHIPBLK < 0.6 ABUT < 90 SINGULAR REGION
OUTLAYER ENC PODUM CHIPBLK < 0.3 ABUT < 90 SINGULAR REGION
}
RULECHECK PODUM_S_11 {
@ Space between PODUM and PODUMB >= 2
OUTLAYER EXT PODUM PODUMB < 2 ABUT < 90 SINGULAR REGION
}
RULECHECK PODUM_S_12 {
@ Space between PODUM and DMYBLK >= 2
OUTLAYER EXT PODUM DMYBLK < 2 ABUT < 90 SINGULAR REGION
}
RULECHECK PODUM_R_1 {
@ PODUM can not overlap with CT
OUTLAYER PODUM AND CT 
}
RULECHECK PODUM_R_2 {
@ PODUM must be covered by PODUMB layer
OUTLAYER PODUM NOT PODUMB 
}


#**********************************************
# Mn: Metal Dummy n (n=1~8) design rules
#**********************************************

set metal_list { M1 M2 M3 M4 M5 M6 M7 M8 }
foreach metal_layer $metal_list {
  set tmp CHECK_$metal_layer
  set tmp_v [set $tmp]

SETLAYER ${metal_layer}DUM_2_2 = RECTANGLE ${metal_layer}DUM == 2  BY == 2
SETLAYER ${metal_layer}DUM_1_1 = RECTANGLE ${metal_layer}DUM == 1  BY == 1
SETLAYER ${metal_layer}DUM_0p22_0p89 = RECTANGLE ${metal_layer}DUM == 0.22  BY == 0.89

RULECHECK ${metal_layer}DUMCK_W_1 {
@ METndm SIZE = 2x2, 1x1, 0.22x0.89
OUTLAYER ((${metal_layer}DUM NOT ${metal_layer}DUM_2_2) NOT ${metal_layer}DUM_1_1) NOT ${metal_layer}DUM_0p22_0p89
}

RULECHECK ${metal_layer}DUMCK_S_1 {
@ METndm space if METndm size is 2um*2um >= 0.8um
OUTLAYER EXT ${metal_layer}DUM_2_2 < 0.8 ABUT <90 SINGULAR REGION
}

RULECHECK ${metal_layer}DUMCK_S_2 {
@ Space between METndm and MET if METndm size is 2um*2um >= 10um
OUTLAYER EXT $metal_layer ${metal_layer}DUM_2_2 < 10 ABUT <90 SINGULAR REGION
}

RULECHECK ${metal_layer}DUMCK_S_3 {
@ METndm space if METndm size is 1um*1um >= 0.3um
OUTLAYER EXT ${metal_layer}DUM_1_1 < 0.3 ABUT <90 SINGULAR REGION
}

RULECHECK ${metal_layer}DUMCK_S_4 {
@ Space between METndm and MET if METndm size is 1um*1um >= 3um
OUTLAYER EXT $metal_layer ${metal_layer}DUM_1_1 < 3 ABUT <90 SINGULAR REGION
}

RULECHECK ${metal_layer}DUMCK_S_5 {
@ METndm space if METndm size is 0.22um*0.89um >= 0.25um
OUTLAYER EXT ${metal_layer}DUM_0p22_0p89 < 0.25 ABUT <90 SINGULAR REGION
}

RULECHECK ${metal_layer}DUMCK_S_6 {
@ Space between METndm and MET if METndm size is 0.22um*0.89um >= 0.3um
OUTLAYER EXT $metal_layer ${metal_layer}DUM_0p22_0p89 < 0.3 ABUT <90 SINGULAR REGION
}

RULECHECK ${metal_layer}DUMCK_S_7 {
@ Space between two (MnDUM or Mn) having run length >=1.5um with one or both M1DUM width >=1.5um is 0.60um
Mn_2c_DUM ${metal_layer}ALL ${metal_layer}DUM 1.5 1.5 0.6
}

RULECHECK ${metal_layer}DUMCK_S_8 {
@ Space between MnDUM and 45 degree METn >= 0.4um
  SETLAYER X = ANGLE $metal_layer == 45
  OUTLAYER (EXT X ${metal_layer}DUM < 0.4 REGION) NOT INSIDE NODRC
}

RULECHECK ${metal_layer}DUMCK_S_9 {
@ Space between MnDUM and FUSEALL(fuse) >= 3um
OUTLAYER EXT ${metal_layer}DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC ${metal_layer}DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK ${metal_layer}DUMCK_S_10 {
@ Space between MnDUM and BMIM(MIM) >= 2um
OUTLAYER EXT ${metal_layer}DUM BMIM < 2 ABUT < 90 SINGULAR REGION
OUTLAYER ENC ${metal_layer}DUM BMIM < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK ${metal_layer}DUMCK_S_11 {
@ Space between MnDUM and LOGO >= 0.1um
OUTLAYER EXT ${metal_layer}DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
OUTLAYER ENC ${metal_layer}DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
}

RULECHECK ${metal_layer}DUMCK_S_12 {
@ Space between MnDUM and INDALL >= 3um
OUTLAYER EXT ${metal_layer}DUM INDALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC ${metal_layer}DUM INDALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK ${metal_layer}DUMCK_S_13 {
@ Space between MnDUM and CHIPBLK(chip edge) >= 2.5um
OUTLAYER EXT ${metal_layer}DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
OUTLAYER ENC ${metal_layer}DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
}

RULECHECK ${metal_layer}DUMCK_S_14 {
@ Space between MnDUM and MnDUMB >= 2um
OUTLAYER EXT ${metal_layer}DUM ${metal_layer}DUMB < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK ${metal_layer}DUMCK_S_15 {
@ Space between MnDUM and DMYBLK >= 2um
OUTLAYER EXT ${metal_layer}DUM DMYBLK < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK ${metal_layer}DUMCK_R_1 {
@ MnDUM must be covered by MnDUMB layer
OUTLAYER ${metal_layer}DUM NOT ${metal_layer}DUMB
}

}

#**********************************************
# Mn: T2Mn Dummy n (n=1~2) design rules
#**********************************************


if {($T2V1_T2M1 == 1) && ($T2V2_T2M2 == 0)} {

SETLAYER T2M1DUM_2_2 = RECTANGLE T2M1DUM == 2  BY == 2
SETLAYER T2M1DUM_1_1 = RECTANGLE T2M1DUM == 1  BY == 1
SETLAYER T2M1DUM_0p6_1p2 = RECTANGLE T2M1DUM == 0.6  BY == 1.2

RULECHECK T2M1DUMCK_W_1 {
@ T2MnDUM SIZE = 2x2, 1x1, 0.6x1.2
OUTLAYER ((T2M1DUM NOT T2M1DUM_2_2) NOT T2M1DUM_1_1) NOT T2M1DUM_0p6_1p2
}

RULECHECK T2M1DUMCK_S_1 {
@ Space between two T2MnDUMs if T2MnDUM size is 2um*2um  >= 0.80um
OUTLAYER ((EXT T2M1DUM_2_2 < 0.80 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T2M1DUMCK_S_2 {
@ Space between T2MnDUMs and T2Mn if T2MnDUM size is 2um*2um  >= 10um
OUTLAYER ((EXT T2M1DUM_2_2 T2M1 < 10 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T2M1DUMCK_S_3 {
@ Space between two T2MnDUMs if T2MnDUM size is 1um*1um  >= 0.40um
OUTLAYER ((EXT T2M1DUM_1_1 < 0.40 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T2M1DUMCK_S_4 {
@ Space between T2MnDUMs and T2Mn if T2MnDUM size is 1um*1um  >= 0.6um
OUTLAYER ((EXT T2M1DUM_1_1 T2M1 < 0.6 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T2M1DUMCK_S_5 {
@ Space between two T2MnDUMs if T2MnDUM size is 0.6um*1.2um  >= 0.40um
OUTLAYER ((EXT T2M1DUM_0p6_1p2 < 0.40 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T2M1DUMCK_S_6 {
@ Space between T2MnDUMs and T2Mn if T2MnDUM size is 0.6um*1.2um  >= 0.6um
OUTLAYER ((EXT T2M1DUM_0p6_1p2 T2M1 < 0.6 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T2M1DUMCK_S_7 {
@ Space between two (T2MnDUM or T2Mn) having run length >=1.5um with one or both T2MnDUM width >=1.5um is 0.60um
Mn_2b_DUM T2M1ALL T2M1DUM 1.5 1.5 0.6
}

RULECHECK T2M1DUMCK_S_8 {
@ Space between T2MnDUM and 45 degree T2Mn >= 0.4um
  SETLAYER X = ANGLE T2M1 == 45
  OUTLAYER (EXT X T2M1DUM < 0.4 REGION) NOT INSIDE NODRC
}

RULECHECK T2M1DUMCK_S_9 {
@ Space between T2MnDUM and FUSEALL(fuse) >= 3um
OUTLAYER EXT T2M1DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T2M1DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK T2M1DUMCK_S_10 {
@ Space between T2MnDUM and BMIM(MIM) >= 2um
OUTLAYER EXT T2M1DUM BMIM < 2 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T2M1DUM BMIM < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T2M1DUMCK_S_11 {
@ Space between T2MnDUM and LOGO >= 0.1um
OUTLAYER EXT T2M1DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T2M1DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
}

RULECHECK T2M1DUMCK_S_12 {
@ Space between T2MnDUM and INDALL >= 3um
OUTLAYER EXT T2M1DUM INDALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T2M1DUM INDALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK T2M1DUMCK_S_13 {
@ Space between T2MnDUM and CHIPBLK(chip edge) >= 2.5um
OUTLAYER EXT T2M1DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T2M1DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
}

RULECHECK T2M1DUMCK_S_14 {
@ Space between T2MnDUM and T2MnDUMB >= 2um
OUTLAYER EXT T2M1DUM T2M1DUMB < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T2M1DUMCK_S_15 {
@ Space between T2MnDUM and DMYBLK >= 2um
OUTLAYER EXT T2M1DUM DMYBLK < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T2M1DUMCK_R_1 {
@ T2MnDUM must be covered by T2MnDUMB layer
OUTLAYER T2M1DUM NOT T2M1DUMB
}

}


if {($T2V1_T2M1 == 1) && ($T2V2_T2M2 == 1)} {

SETLAYER T2M1DUM_2_2 = RECTANGLE T2M1DUM == 2  BY == 2
SETLAYER T2M1DUM_1_1 = RECTANGLE T2M1DUM == 1  BY == 1
SETLAYER T2M1DUM_0p6_1p2 = RECTANGLE T2M1DUM == 0.6  BY == 1.2

SETLAYER T2M2DUM_2_2 = RECTANGLE T2M2DUM == 2  BY == 2
SETLAYER T2M2DUM_1_1 = RECTANGLE T2M2DUM == 1  BY == 1
SETLAYER T2M2DUM_0p6_1p2 = RECTANGLE T2M2DUM == 0.6  BY == 1.2

RULECHECK T2M1DUMCK_W_1 {
@ T2MnDUM SIZE = 2x2, 1x1, 0.6x1.2
OUTLAYER ((T2M1DUM NOT T2M1DUM_2_2) NOT T2M1DUM_1_1) NOT T2M1DUM_0p6_1p2
}

RULECHECK T2M2DUMCK_W_1 {
@ T2MnDUM SIZE = 2x2, 1x1, 0.6x1.2
OUTLAYER ((T2M2DUM NOT T2M2DUM_2_2) NOT T2M2DUM_1_1) NOT T2M2DUM_0p6_1p2
}

RULECHECK T2M1DUMCK_S_1 {
@ Space between two T2MnDUMs if T2MnDUM size is 2um*2um  >= 0.80um
OUTLAYER ((EXT T2M1DUM_2_2 < 0.80 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T2M2DUMCK_S_1 {
@ Space between two T2MnDUMs if T2MnDUM size is 2um*2um  >= 0.80um
OUTLAYER ((EXT T2M2DUM_2_2 < 0.80 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T2M1DUMCK_S_2 {
@ Space between T2MnDUMs and T2Mn if T2MnDUM size is 2um*2um  >= 10um
OUTLAYER ((EXT T2M1DUM_2_2 T2M1 < 10 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T2M2DUMCK_S_2 {
@ Space between T2MnDUMs and T2Mn if T2MnDUM size is 2um*2um  >= 10um
OUTLAYER ((EXT T2M2DUM_2_2 T2M2 < 10 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T2M1DUMCK_S_3 {
@ Space between two T2MnDUMs if T2MnDUM size is 1um*1um  >= 0.40um
OUTLAYER ((EXT T2M1DUM_1_1 < 0.40 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T2M2DUMCK_S_3 {
@ Space between two T2MnDUMs if T2MnDUM size is 1um*1um  >= 0.40um
OUTLAYER ((EXT T2M2DUM_1_1 < 0.40 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T2M1DUMCK_S_4 {
@ Space between T2MnDUMs and T2Mn if T2MnDUM size is 1um*1um  >= 0.6um
OUTLAYER ((EXT T2M1DUM_1_1 T2M1 < 0.6 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T2M2DUMCK_S_4 {
@ Space between T2MnDUMs and T2Mn if T2MnDUM size is 1um*1um  >= 0.6um
OUTLAYER ((EXT T2M2DUM_1_1 T2M2 < 0.6 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T2M1DUMCK_S_5 {
@ Space between two T2MnDUMs if T2MnDUM size is 0.6um*1.2um  >= 0.40um
OUTLAYER ((EXT T2M1DUM_0p6_1p2 < 0.40 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T2M2DUMCK_S_5 {
@ Space between two T2MnDUMs if T2MnDUM size is 0.6um*1.2um  >= 0.40um
OUTLAYER ((EXT T2M2DUM_0p6_1p2 < 0.40 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T2M1DUMCK_S_6 {
@ Space between T2MnDUMs and T2Mn if T2MnDUM size is 0.6um*1.2um  >= 0.6um
OUTLAYER ((EXT T2M1DUM_0p6_1p2 T2M1 < 0.6 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T2M2DUMCK_S_6 {
@ Space between T2MnDUMs and T2Mn if T2MnDUM size is 0.6um*1.2um  >= 0.6um
OUTLAYER ((EXT T2M2DUM_0p6_1p2 T2M2 < 0.6 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T2M1DUMCK_S_7 {
@ Space between two (T2MnDUM or T2Mn) having run length >=1.5um with one or both T2MnDUM width >=1.5um is 0.60um
Mn_2b_DUM T2M1ALL T2M1DUM 1.5 1.5 0.6
}

RULECHECK T2M2DUMCK_S_7 {
@ Space between two (T2MnDUM or T2Mn) having run length >=1.5um with one or both T2MnDUM width >=1.5um is 0.60um
Mn_2b_DUM T2M2ALL T2M2DUM 1.5 1.5 0.6
}

RULECHECK T2M1DUMCK_S_8 {
@ Space between T2MnDUM and 45 degree T2Mn >= 0.4um
  SETLAYER X = ANGLE T2M1 == 45
  OUTLAYER (EXT X T2M1DUM < 0.4 REGION) NOT INSIDE NODRC
}

RULECHECK T2M2DUMCK_S_8 {
@ Space between T2MnDUM and 45 degree T2Mn >= 0.4um
  SETLAYER X = ANGLE T2M2 == 45
  OUTLAYER (EXT X T2M2DUM < 0.4 REGION) NOT INSIDE NODRC
}

RULECHECK T2M1DUMCK_S_9 {
@ Space between T2MnDUM and FUSEALL(fuse) >= 3um
OUTLAYER EXT T2M1DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T2M1DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK T2M2DUMCK_S_9 {
@ Space between T2MnDUM and FUSEALL(fuse) >= 3um
OUTLAYER EXT T2M2DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T2M2DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK T2M1DUMCK_S_10 {
@ Space between T2MnDUM and BMIM(MIM) >= 2um
OUTLAYER EXT T2M1DUM BMIM < 2 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T2M1DUM BMIM < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T2M2DUMCK_S_10 {
@ Space between T2MnDUM and BMIM(MIM) >= 2um
OUTLAYER EXT T2M2DUM BMIM < 2 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T2M2DUM BMIM < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T2M1DUMCK_S_11 {
@ Space between T2MnDUM and LOGO >= 0.1um
OUTLAYER EXT T2M1DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T2M1DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
}

RULECHECK T2M2DUMCK_S_11 {
@ Space between T2MnDUM and LOGO >= 0.1um
OUTLAYER EXT T2M2DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T2M2DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
}

RULECHECK T2M1DUMCK_S_12 {
@ Space between T2MnDUM and INDALL >= 3um
OUTLAYER EXT T2M1DUM INDALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T2M1DUM INDALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK T2M2DUMCK_S_12 {
@ Space between T2MnDUM and INDALL >= 3um
OUTLAYER EXT T2M2DUM INDALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T2M2DUM INDALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK T2M1DUMCK_S_13 {
@ Space between T2MnDUM and CHIPBLK(chip edge) >= 2.5um
OUTLAYER EXT T2M1DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T2M1DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
}

RULECHECK T2M2DUMCK_S_13 {
@ Space between T2MnDUM and CHIPBLK(chip edge) >= 2.5um
OUTLAYER EXT T2M2DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T2M2DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
}

RULECHECK T2M1DUMCK_S_14 {
@ Space between T2MnDUM and T2MnDUMB >= 2um
OUTLAYER EXT T2M1DUM T2M1DUMB < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T2M2DUMCK_S_14 {
@ Space between T2MnDUM and T2MnDUMB >= 2um
OUTLAYER EXT T2M2DUM T2M2DUMB < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T2M1DUMCK_S_15 {
@ Space between T2MnDUM and DMYBLK >= 2um
OUTLAYER EXT T2M1DUM DMYBLK < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T2M2DUMCK_S_15 {
@ Space between T2MnDUM and DMYBLK >= 2um
OUTLAYER EXT T2M2DUM DMYBLK < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T2M1DUMCK_R_1 {
@ T2MnDUM must be covered by T2MnDUMB layer
OUTLAYER T2M1DUM NOT T2M1DUMB
}

RULECHECK T2M2DUMCK_R_1 {
@ T2MnDUM must be covered by T2MnDUMB layer
OUTLAYER T2M2DUM NOT T2M2DUMB
}

}


#**********************************************
# Mn: T4Mn Dummy n (n=1~2) design rules
#**********************************************


if {($T4V1_T4M1 == 1) && ($T4V2_T4M2 == 0)} {

SETLAYER T4M1DUM_2_2 = RECTANGLE T4M1DUM == 2  BY == 2
SETLAYER T4M1DUM_1_1 = RECTANGLE T4M1DUM == 1  BY == 1
SETLAYER T4M1DUM_0p6_1p2 = RECTANGLE T4M1DUM == 0.6  BY == 1.2

RULECHECK T4M1DUMCK_W_1 {
@ T4MnDUM SIZE = 2x2, 1x1, 0.6x1.2
OUTLAYER ((T4M1DUM NOT T4M1DUM_2_2) NOT T4M1DUM_1_1) NOT T4M1DUM_0p6_1p2
}

RULECHECK T4M1DUMCK_S_1 {
@ Space between two T4MnDUMs if T4MnDUM size is 2um*2um  >= 0.80um
OUTLAYER ((EXT T4M1DUM_2_2 < 0.80 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M1DUMCK_S_2 {
@ Space between T4MnDUMs and T4Mn if T4MnDUM size is 2um*2um  >= 10um
OUTLAYER ((EXT T4M1DUM_2_2 T4M1 < 10 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M1DUMCK_S_3 {
@ Space between two T4MnDUMs if T4MnDUM size is 1um*1um  >= 0.40um
OUTLAYER ((EXT T4M1DUM_1_1 < 0.40 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M1DUMCK_S_4 {
@ Space between T4MnDUMs and T4Mn if T4MnDUM size is 1um*1um  >= 0.6um
OUTLAYER ((EXT T4M1DUM_1_1 T4M1 < 0.6 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M1DUMCK_S_5 {
@ Space between two T4MnDUMs if T4MnDUM size is 0.6um*1.2um  >= 0.40um
OUTLAYER ((EXT T4M1DUM_0p6_1p2 < 0.40 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M1DUMCK_S_6 {
@ Space between T4MnDUMs and T4Mn if T4MnDUM size is 0.6um*1.2um  >= 0.6um
OUTLAYER ((EXT T4M1DUM_0p6_1p2 T4M1 < 0.6 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M1DUMCK_S_7 {
@ Space between two (T4MnDUM or T4Mn) having run length >=1.5um with one or both T4MnDUM width >=1.5um is 0.60um
Mn_2b_DUM T4M1ALL T4M1DUM 1.5 1.5 0.6
}

RULECHECK T4M1DUMCK_S_8 {
@ Space between T4MnDUM and 45 degree T4Mn >= 0.4um
  SETLAYER X = ANGLE T4M1 == 45
  OUTLAYER (EXT X T4M1DUM < 0.4 REGION) NOT INSIDE NODRC
}

RULECHECK T4M1DUMCK_S_9 {
@ Space between T4MnDUM and FUSEALL(fuse) >= 3um
OUTLAYER EXT T4M1DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T4M1DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M1DUMCK_S_10 {
@ Space between T4MnDUM and BMIM(MIM) >= 2um
OUTLAYER EXT T4M1DUM BMIM < 2 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T4M1DUM BMIM < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M1DUMCK_S_11 {
@ Space between T4MnDUM and LOGO >= 0.1um
OUTLAYER EXT T4M1DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T4M1DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M1DUMCK_S_12 {
@ Space between T4MnDUM and INDALL >= 3um
OUTLAYER EXT T4M1DUM INDALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T4M1DUM INDALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M1DUMCK_S_13 {
@ Space between T4MnDUM and CHIPBLK(chip edge) >= 2.5um
OUTLAYER EXT T4M1DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T4M1DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M1DUMCK_S_14 {
@ Space between T4MnDUM and T4MnDUMB >= 2um
OUTLAYER EXT T4M1DUM T4M1DUMB < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M1DUMCK_S_15 {
@ Space between T4MnDUM and DMYBLK >= 2um
OUTLAYER EXT T4M1DUM DMYBLK < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M1DUMCK_R_1 {
@ T4MnDUM must be covered by T4MnDUMB layer
OUTLAYER T4M1DUM NOT T4M1DUMB
}

}

if {($T4V1_T4M1 == 0) && ($T4V2_T4M2 == 1)} {

SETLAYER T4M2DUM_2_2 = RECTANGLE T4M2DUM == 2  BY == 2
SETLAYER T4M2DUM_1_1 = RECTANGLE T4M2DUM == 1  BY == 1
SETLAYER T4M2DUM_0p6_1p2 = RECTANGLE T4M2DUM == 0.6  BY == 1.2

RULECHECK T4M2DUMCK_W_1 {
@ T4MnDUM SIZE = 2x2, 1x1, 0.6x1.2
OUTLAYER ((T4M2DUM NOT T4M2DUM_2_2) NOT T4M2DUM_1_1) NOT T4M2DUM_0p6_1p2
}

RULECHECK T4M2DUMCK_S_1 {
@ Space between two T4MnDUMs if T4MnDUM size is 2um*2um  >= 0.80um
OUTLAYER ((EXT T4M2DUM_2_2 < 0.80 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M2DUMCK_S_2 {
@ Space between T4MnDUMs and T4Mn if T4MnDUM size is 2um*2um  >= 10um
OUTLAYER ((EXT T4M2DUM_2_2 T4M2 < 10 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M2DUMCK_S_3 {
@ Space between two T4MnDUMs if T4MnDUM size is 1um*1um  >= 0.40um
OUTLAYER ((EXT T4M2DUM_1_1 < 0.40 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M2DUMCK_S_4 {
@ Space between T4MnDUMs and T4Mn if T4MnDUM size is 1um*1um  >= 0.6um
OUTLAYER ((EXT T4M2DUM_1_1 T4M2 < 0.6 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M2DUMCK_S_5 {
@ Space between two T4MnDUMs if T4MnDUM size is 0.6um*1.2um  >= 0.40um
OUTLAYER ((EXT T4M2DUM_0p6_1p2 < 0.40 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M2DUMCK_S_6 {
@ Space between T4MnDUMs and T4Mn if T4MnDUM size is 0.6um*1.2um  >= 0.6um
OUTLAYER ((EXT T4M2DUM_0p6_1p2 T4M2 < 0.6 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M2DUMCK_S_7 {
@ Space between two (T4MnDUM or T4Mn) having run length >=1.5um with one or both T4MnDUM width >=1.5um is 0.60um
Mn_2b_DUM T4M2ALL T4M2DUM 1.5 1.5 0.6
}

RULECHECK T4M2DUMCK_S_8 {
@ Space between T4MnDUM and 45 degree T4Mn >= 0.4um
  SETLAYER X = ANGLE T4M2 == 45
  OUTLAYER (EXT X T4M2DUM < 0.4 REGION) NOT INSIDE NODRC
}

RULECHECK T4M2DUMCK_S_9 {
@ Space between T4MnDUM and FUSEALL(fuse) >= 3um
OUTLAYER EXT T4M2DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T4M2DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M2DUMCK_S_10 {
@ Space between T4MnDUM and BMIM(MIM) >= 2um
OUTLAYER EXT T4M2DUM BMIM < 2 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T4M2DUM BMIM < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M2DUMCK_S_11 {
@ Space between T4MnDUM and LOGO >= 0.1um
OUTLAYER EXT T4M2DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T4M2DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M2DUMCK_S_12 {
@ Space between T4MnDUM and INDALL >= 3um
OUTLAYER EXT T4M2DUM INDALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T4M2DUM INDALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M2DUMCK_S_13 {
@ Space between T4MnDUM and CHIPBLK(chip edge) >= 2.5um
OUTLAYER EXT T4M2DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T4M2DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M2DUMCK_S_14 {
@ Space between T4MnDUM and T4MnDUMB >= 2um
OUTLAYER EXT T4M2DUM T4M2DUMB < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M2DUMCK_S_15 {
@ Space between T4MnDUM and DMYBLK >= 2um
OUTLAYER EXT T4M2DUM DMYBLK < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M2DUMCK_R_1 {
@ T4MnDUM must be covered by T4MnDUMB layer
OUTLAYER T4M2DUM NOT T4M2DUMB
}

}

if {($T4V1_T4M1 == 1) && ($T4V2_T4M2 == 1)} {

SETLAYER T4M1DUM_2_2 = RECTANGLE T4M1DUM == 2  BY == 2
SETLAYER T4M1DUM_1_1 = RECTANGLE T4M1DUM == 1  BY == 1
SETLAYER T4M1DUM_0p6_1p2 = RECTANGLE T4M1DUM == 0.6  BY == 1.2

SETLAYER T4M2DUM_2_2 = RECTANGLE T4M2DUM == 2  BY == 2
SETLAYER T4M2DUM_1_1 = RECTANGLE T4M2DUM == 1  BY == 1
SETLAYER T4M2DUM_0p6_1p2 = RECTANGLE T4M2DUM == 0.6  BY == 1.2

RULECHECK T4M1DUMCK_W_1 {
@ T4MnDUM SIZE = 2x2, 1x1, 0.6x1.2
OUTLAYER ((T4M1DUM NOT T4M1DUM_2_2) NOT T4M1DUM_1_1) NOT T4M1DUM_0p6_1p2
}

RULECHECK T4M2DUMCK_W_1 {
@ T4MnDUM SIZE = 2x2, 1x1, 0.6x1.2
OUTLAYER ((T4M2DUM NOT T4M2DUM_2_2) NOT T4M2DUM_1_1) NOT T4M2DUM_0p6_1p2
}

RULECHECK T4M1DUMCK_S_1 {
@ Space between two T4MnDUMs if T4MnDUM size is 2um*2um  >= 0.80um
OUTLAYER ((EXT T4M1DUM_2_2 < 0.80 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M2DUMCK_S_1 {
@ Space between two T4MnDUMs if T4MnDUM size is 2um*2um  >= 0.80um
OUTLAYER ((EXT T4M2DUM_2_2 < 0.80 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M1DUMCK_S_2 {
@ Space between T4MnDUMs and T4Mn if T4MnDUM size is 2um*2um  >= 10um
OUTLAYER ((EXT T4M1DUM_2_2 T4M1 < 10 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M2DUMCK_S_2 {
@ Space between T4MnDUMs and T4Mn if T4MnDUM size is 2um*2um  >= 10um
OUTLAYER ((EXT T4M2DUM_2_2 T4M2 < 10 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M1DUMCK_S_3 {
@ Space between two T4MnDUMs if T4MnDUM size is 1um*1um  >= 0.40um
OUTLAYER ((EXT T4M1DUM_1_1 < 0.40 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M2DUMCK_S_3 {
@ Space between two T4MnDUMs if T4MnDUM size is 1um*1um  >= 0.40um
OUTLAYER ((EXT T4M2DUM_1_1 < 0.40 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M1DUMCK_S_4 {
@ Space between T4MnDUMs and T4Mn if T4MnDUM size is 1um*1um  >= 0.6um
OUTLAYER ((EXT T4M1DUM_1_1 T4M1 < 0.6 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M2DUMCK_S_4 {
@ Space between T4MnDUMs and T4Mn if T4MnDUM size is 1um*1um  >= 0.6um
OUTLAYER ((EXT T4M2DUM_1_1 T4M2 < 0.6 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M1DUMCK_S_5 {
@ Space between two T4MnDUMs if T4MnDUM size is 0.6um*1.2um  >= 0.40um
OUTLAYER ((EXT T4M1DUM_0p6_1p2 < 0.40 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M2DUMCK_S_5 {
@ Space between two T4MnDUMs if T4MnDUM size is 0.6um*1.2um  >= 0.40um
OUTLAYER ((EXT T4M2DUM_0p6_1p2 < 0.40 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M1DUMCK_S_6 {
@ Space between T4MnDUMs and T4Mn if T4MnDUM size is 0.6um*1.2um  >= 0.6um
OUTLAYER ((EXT T4M1DUM_0p6_1p2 T4M1 < 0.6 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M2DUMCK_S_6 {
@ Space between T4MnDUMs and T4Mn if T4MnDUM size is 0.6um*1.2um  >= 0.6um
OUTLAYER ((EXT T4M2DUM_0p6_1p2 T4M2 < 0.6 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T4M1DUMCK_S_7 {
@ Space between two (T4MnDUM or T4Mn) having run length >=1.5um with one or both T4MnDUM width >=1.5um is 0.60um
Mn_2b_DUM T4M1ALL T4M1DUM 1.5 1.5 0.6
}

RULECHECK T4M2DUMCK_S_7 {
@ Space between two (T4MnDUM or T4Mn) having run length >=1.5um with one or both T4MnDUM width >=1.5um is 0.60um
Mn_2b_DUM T4M2ALL T4M2DUM 1.5 1.5 0.6
}

RULECHECK T4M1DUMCK_S_8 {
@ Space between T4MnDUM and 45 degree T4Mn >= 0.4um
  SETLAYER X = ANGLE T4M1 == 45
  OUTLAYER (EXT X T4M1DUM < 0.4 REGION) NOT INSIDE NODRC
}

RULECHECK T4M2DUMCK_S_8 {
@ Space between T4MnDUM and 45 degree T4Mn >= 0.4um
  SETLAYER X = ANGLE T4M2 == 45
  OUTLAYER (EXT X T4M2DUM < 0.4 REGION) NOT INSIDE NODRC
}

RULECHECK T4M1DUMCK_S_9 {
@ Space between T4MnDUM and FUSEALL(fuse) >= 3um
OUTLAYER EXT T4M1DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T4M1DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M2DUMCK_S_9 {
@ Space between T4MnDUM and FUSEALL(fuse) >= 3um
OUTLAYER EXT T4M2DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T4M2DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M1DUMCK_S_10 {
@ Space between T4MnDUM and BMIM(MIM) >= 2um
OUTLAYER EXT T4M1DUM BMIM < 2 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T4M1DUM BMIM < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M2DUMCK_S_10 {
@ Space between T4MnDUM and BMIM(MIM) >= 2um
OUTLAYER EXT T4M2DUM BMIM < 2 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T4M2DUM BMIM < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M1DUMCK_S_11 {
@ Space between T4MnDUM and LOGO >= 0.1um
OUTLAYER EXT T4M1DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T4M1DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M2DUMCK_S_11 {
@ Space between T4MnDUM and LOGO >= 0.1um
OUTLAYER EXT T4M2DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T4M2DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M1DUMCK_S_12 {
@ Space between T4MnDUM and INDALL >= 3um
OUTLAYER EXT T4M1DUM INDALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T4M1DUM INDALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M2DUMCK_S_12 {
@ Space between T4MnDUM and INDALL >= 3um
OUTLAYER EXT T4M2DUM INDALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T4M2DUM INDALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M1DUMCK_S_13 {
@ Space between T4MnDUM and CHIPBLK(chip edge) >= 2.5um
OUTLAYER EXT T4M1DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T4M1DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M2DUMCK_S_13 {
@ Space between T4MnDUM and CHIPBLK(chip edge) >= 2.5um
OUTLAYER EXT T4M2DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T4M2DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M1DUMCK_S_14 {
@ Space between T4MnDUM and T4MnDUMB >= 2um
OUTLAYER EXT T4M1DUM T4M1DUMB < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M2DUMCK_S_14 {
@ Space between T4MnDUM and T4MnDUMB >= 2um
OUTLAYER EXT T4M2DUM T4M2DUMB < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M1DUMCK_S_15 {
@ Space between T4MnDUM and DMYBLK >= 2um
OUTLAYER EXT T4M1DUM DMYBLK < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M2DUMCK_S_15 {
@ Space between T4MnDUM and DMYBLK >= 2um
OUTLAYER EXT T4M2DUM DMYBLK < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T4M1DUMCK_R_1 {
@ T4MnDUM must be covered by T4MnDUMB layer
OUTLAYER T4M1DUM NOT T4M1DUMB
}

RULECHECK T4M2DUMCK_R_1 {
@ T4MnDUM must be covered by T4MnDUMB layer
OUTLAYER T4M2DUM NOT T4M2DUMB
}

}

#**********************************************
# Mn: T8Mn Dummy n (n=1~2) design rules
#**********************************************


if {($T8V1_T8M1 == 1) && ($T8V2_T8M2 == 0)} {

SETLAYER T8M1DUM_2p8_2p8 = RECTANGLE T8M1DUM == 2.8  BY == 2.8

RULECHECK T8M1DUMCK_W_1 {
@ T8MnDUM SIZE = 2.8*2.8
OUTLAYER T8M1DUM NOT T8M1DUM_2p8_2p8
}

RULECHECK T8M1DUMCK_S_1 {
@ Space between two T8MnDUMs if T8MnDUM size is 2.8um*2.8um  >= 2.80um
OUTLAYER ((EXT T8M1DUM_2p8_2p8 < 2.80 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T8M1DUMCK_S_2 {
@ Space between T8MnDUMs and T8Mn if T8MnDUM size is 2.8um*2.8um  >= 2.8um
OUTLAYER ((EXT T8M1DUM_2p8_2p8 T8M1 < 2.80 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T8M1DUMCK_S_7 {
@ Space between two (T8MnDUM or T8Mn) having run length >=1.5um with one or both T8MnDUM width >=1.5um is 0.60um
Mn_2b_DUM T8M1ALL T8M1DUM 1.5 1.5 0.6
}

RULECHECK T8M1DUMCK_S_8 {
@ Space between T8MnDUM and 45 degree T8Mn >= 0.4um
  SETLAYER X = ANGLE T8M1 == 45
  OUTLAYER (EXT X T8M1DUM < 0.4 REGION) NOT INSIDE NODRC
}

RULECHECK T8M1DUMCK_S_9 {
@ Space between T8MnDUM and FUSEALL(fuse) >= 3um
OUTLAYER EXT T8M1DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T8M1DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M1DUMCK_S_10 {
@ Space between T8MnDUM and BMIM(MIM) >= 2um
OUTLAYER EXT T8M1DUM BMIM < 2 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T8M1DUM BMIM < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M1DUMCK_S_11 {
@ Space between T8MnDUM and LOGO >= 0.1um
OUTLAYER EXT T8M1DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T8M1DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M1DUMCK_S_12 {
@ Space between T8MnDUM and INDALL >= 3um
OUTLAYER EXT T8M1DUM INDALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T8M1DUM INDALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M1DUMCK_S_13 {
@ Space between T8MnDUM and CHIPBLK(chip edge) >= 2.5um
OUTLAYER EXT T8M1DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T8M1DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M1DUMCK_S_14 {
@ Space between T8MnDUM and T8MnDUMB >= 2um
OUTLAYER EXT T8M1DUM T8M1DUMB < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M1DUMCK_S_15 {
@ Space between T8MnDUM and DMYBLK >= 2um
OUTLAYER EXT T8M1DUM DMYBLK < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M1DUMCK_R_1 {
@ T8MnDUM must be covered by T8MnDUMB layer
OUTLAYER T8M1DUM NOT T8M1DUMB
}

}


if {($T8V1_T8M1 == 0) && ($T8V2_T8M2 == 1)} {

SETLAYER T8M2DUM_2p8_2p8 = RECTANGLE T8M2DUM == 2.8  BY == 2.8

RULECHECK T8M2DUMCK_W_1 {
@ T8MnDUM SIZE = 2.8*2.8
OUTLAYER T8M2DUM NOT T8M2DUM_2p8_2p8
}

RULECHECK T8M2DUMCK_S_1 {
@ Space between two T8MnDUMs if T8MnDUM size is 2.8um*2.8um  >= 2.80um
OUTLAYER ((EXT T8M2DUM_2p8_2p8 < 2.80 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T8M2DUMCK_S_2 {
@ Space between T8MnDUMs and T8Mn if T8MnDUM size is 2.8um*2.8um  >= 2.8um
OUTLAYER ((EXT T8M2DUM_2p8_2p8 T8M2 < 2.80 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T8M2DUMCK_S_7 {
@ Space between two (T8MnDUM or T8Mn) having run length >=1.5um with one or both T8MnDUM width >=1.5um is 0.60um
Mn_2b_DUM T8M2ALL T8M2DUM 1.5 1.5 0.6
}

RULECHECK T8M2DUMCK_S_8 {
@ Space between T8MnDUM and 45 degree T8Mn >= 0.4um
  SETLAYER X = ANGLE T8M2 == 45
  OUTLAYER (EXT X T8M2DUM < 0.4 REGION) NOT INSIDE NODRC
}

RULECHECK T8M2DUMCK_S_9 {
@ Space between T8MnDUM and FUSEALL(fuse) >= 3um
OUTLAYER EXT T8M2DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T8M2DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M2DUMCK_S_10 {
@ Space between T8MnDUM and BMIM(MIM) >= 2um
OUTLAYER EXT T8M2DUM BMIM < 2 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T8M2DUM BMIM < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M2DUMCK_S_11 {
@ Space between T8MnDUM and LOGO >= 0.1um
OUTLAYER EXT T8M2DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T8M2DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M2DUMCK_S_12 {
@ Space between T8MnDUM and INDALL >= 3um
OUTLAYER EXT T8M2DUM INDALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T8M2DUM INDALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M2DUMCK_S_13 {
@ Space between T8MnDUM and CHIPBLK(chip edge) >= 2.5um
OUTLAYER EXT T8M2DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T8M2DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M2DUMCK_S_14 {
@ Space between T8MnDUM and T8MnDUMB >= 2um
OUTLAYER EXT T8M2DUM T8M2DUMB < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M2DUMCK_S_15 {
@ Space between T8MnDUM and DMYBLK >= 2um
OUTLAYER EXT T8M2DUM DMYBLK < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M2DUMCK_R_1 {
@ T8MnDUM must be covered by T8MnDUMB layer
OUTLAYER T8M2DUM NOT T8M2DUMB
}

}

if {($T8V1_T8M1 == 1) && ($T8V2_T8M2 == 1)} {

SETLAYER T8M2DUM_2p8_2p8 = RECTANGLE T8M2DUM == 2.8  BY == 2.8
SETLAYER T8M1DUM_2p8_2p8 = RECTANGLE T8M1DUM == 2.8  BY == 2.8

RULECHECK T8M1DUMCK_W_1 {
@ T8MnDUM SIZE = 2.8*2.8
OUTLAYER T8M1DUM NOT T8M1DUM_2p8_2p8
}

RULECHECK T8M2DUMCK_W_1 {
@ T8MnDUM SIZE = 2.8*2.8
OUTLAYER T8M2DUM NOT T8M2DUM_2p8_2p8
}

RULECHECK T8M1DUMCK_S_1 {
@ Space between two T8MnDUMs if T8MnDUM size is 2.8um*2.8um  >= 2.80um
OUTLAYER ((EXT T8M1DUM_2p8_2p8 < 2.80 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T8M2DUMCK_S_1 {
@ Space between two T8MnDUMs if T8MnDUM size is 2.8um*2.8um  >= 2.80um
OUTLAYER ((EXT T8M2DUM_2p8_2p8 < 2.80 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T8M1DUMCK_S_2 {
@ Space between T8MnDUMs and T8Mn if T8MnDUM size is 2.8um*2.8um  >= 2.8um
OUTLAYER ((EXT T8M1DUM_2p8_2p8 T8M1 < 2.80 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T8M2DUMCK_S_2 {
@ Space between T8MnDUMs and T8Mn if T8MnDUM size is 2.8um*2.8um  >= 2.8um
OUTLAYER ((EXT T8M2DUM_2p8_2p8 T8M2 < 2.80 ABUT<90 SINGULAR REGION) NOT INDALL) NOT INSIDE NODRC
}

RULECHECK T8M1DUMCK_S_7 {
@ Space between two (T8MnDUM or T8Mn) having run length >=1.5um with one or both T8MnDUM width >=1.5um is 0.60um
Mn_2b_DUM T8M1ALL T8M1DUM 1.5 1.5 0.6
}

RULECHECK T8M2DUMCK_S_7 {
@ Space between two (T8MnDUM or T8Mn) having run length >=1.5um with one or both T8MnDUM width >=1.5um is 0.60um
Mn_2b_DUM T8M2ALL T8M2DUM 1.5 1.5 0.6
}

RULECHECK T8M1DUMCK_S_8 {
@ Space between T8MnDUM and 45 degree T8Mn >= 0.4um
  SETLAYER X = ANGLE T8M1 == 45
  OUTLAYER (EXT X T8M1DUM < 0.4 REGION) NOT INSIDE NODRC
}

RULECHECK T8M2DUMCK_S_8 {
@ Space between T8MnDUM and 45 degree T8Mn >= 0.4um
  SETLAYER X = ANGLE T8M2 == 45
  OUTLAYER (EXT X T8M2DUM < 0.4 REGION) NOT INSIDE NODRC
}

RULECHECK T8M1DUMCK_S_9 {
@ Space between T8MnDUM and FUSEALL(fuse) >= 3um
OUTLAYER EXT T8M1DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T8M1DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M2DUMCK_S_9 {
@ Space between T8MnDUM and FUSEALL(fuse) >= 3um
OUTLAYER EXT T8M2DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T8M2DUM FUSEALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M1DUMCK_S_10 {
@ Space between T8MnDUM and BMIM(MIM) >= 2um
OUTLAYER EXT T8M1DUM BMIM < 2 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T8M1DUM BMIM < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M2DUMCK_S_10 {
@ Space between T8MnDUM and BMIM(MIM) >= 2um
OUTLAYER EXT T8M2DUM BMIM < 2 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T8M2DUM BMIM < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M1DUMCK_S_11 {
@ Space between T8MnDUM and LOGO >= 0.1um
OUTLAYER EXT T8M1DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T8M1DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M2DUMCK_S_11 {
@ Space between T8MnDUM and LOGO >= 0.1um
OUTLAYER EXT T8M2DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T8M2DUM LOGO < 0.1 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M1DUMCK_S_12 {
@ Space between T8MnDUM and INDALL >= 3um
OUTLAYER EXT T8M1DUM INDALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T8M1DUM INDALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M2DUMCK_S_12 {
@ Space between T8MnDUM and INDALL >= 3um
OUTLAYER EXT T8M2DUM INDALL < 3 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T8M2DUM INDALL < 3 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M1DUMCK_S_13 {
@ Space between T8MnDUM and CHIPBLK(chip edge) >= 2.5um
OUTLAYER EXT T8M1DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T8M1DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M2DUMCK_S_13 {
@ Space between T8MnDUM and CHIPBLK(chip edge) >= 2.5um
OUTLAYER EXT T8M2DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
OUTLAYER ENC T8M2DUM CHIPBLK < 2.5 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M1DUMCK_S_14 {
@ Space between T8MnDUM and T8MnDUMB >= 2um
OUTLAYER EXT T8M1DUM T8M1DUMB < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M2DUMCK_S_14 {
@ Space between T8MnDUM and T8MnDUMB >= 2um
OUTLAYER EXT T8M2DUM T8M2DUMB < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M1DUMCK_S_15 {
@ Space between T8MnDUM and DMYBLK >= 2um
OUTLAYER EXT T8M1DUM DMYBLK < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M2DUMCK_S_15 {
@ Space between T8MnDUM and DMYBLK >= 2um
OUTLAYER EXT T8M2DUM DMYBLK < 2 ABUT < 90 SINGULAR REGION
}

RULECHECK T8M1DUMCK_R_1 {
@ T8MnDUM must be covered by T8MnDUMB layer
OUTLAYER T8M1DUM NOT T8M1DUMB
}

RULECHECK T8M2DUMCK_R_1 {
@ T8MnDUM must be covered by T8MnDUMB layer
OUTLAYER T8M2DUM NOT T8M2DUMB
}

}

#//==================================
#// ESD design and layout guideline
#//==================================


SETLAYER ESD = ESD1 AND ESDIOE

SETLAYER ENACT = NACT AND ESDIOE
SETLAYER EPACT = PACT AND ESDIOE
SETLAYER ENTAP = ENACT AND NW
SETLAYER EPTAP = EPACT NOT NW

SETLAYER EGATE = (AA AND PO) AND ESDIOE
SETLAYER ENGATE = EGATE AND ENACT
SETLAYER EPGATE = EGATE AND EPACT
SETLAYER EGATEHV = (EGATE NOT DG) AND TG                 //2.5V or 3.3V
SETLAYER EGATEMV = (EGATE AND DG) NOT TG                 //1.8V
SETLAYER EGATELV = EGATE NOT DG                          //1.2V
SETLAYER EGATE_CASCODED = (EGATE AND ESDIOE) AND ESDIOT   //high voltage tolerant I/O using Cascoded 2.5V/3.3V NMOS

SETLAYER EGATE_CASCODED_OVLAP = EGATE_CASCODED CUT ESAB
SETLAYER EGATE_CASCODED_INSID = EGATE_CASCODED INSIDE ESAB

SETLAYER EGATE_W = EGATE COIN EDGE PO
SETLAYER EGATE_L = EGATE COIN EDGE AA

SETLAYER EGATE_POLY = PO ENCLOSE EGATE
SETLAYER ENGATE_POLY = PO ENCLOSE ENGATE
SETLAYER EPGATE_POLY = PO ENCLOSE EPGATE

SETLAYER ECT = CT AND ESDIOE
SETLAYER ESAB = SAB AND ESDIOE
SETLAYER ESAB_HO_RAW = HOLES ESAB INNER EMPTY
SETLAYER ESAB_HO = ESAB_HO_RAW OR EMOS_D
SETLAYER ECT_S = ECT OUTSIDE ESAB_HO
SETLAYER ECT_D = ECT INSIDE ESAB_HO

SETLAYER ENMOS = ENACT ENCLOSE EGATE
SETLAYER EPMOS = EPACT ENCLOSE EGATE
SETLAYER ENMOS_SD = ENMOS NOT EGATE
SETLAYER EPMOS_SD = EPMOS NOT EGATE

SETLAYER ENMOS_S = (ENMOS_SD NOT ESAB) TOUCH EGATE
SETLAYER ENMOS_D = (ENMOS_SD NOT ESAB) NOT TOUCH EGATE
SETLAYER ENMOS_DRAIN = (ENMOS_SD INTERACT ENMOS_D) INTERACT ECT
SETLAYER EPMOS_S = (EPMOS_SD NOT ESAB) TOUCH EGATE
SETLAYER EPMOS_D = (EPMOS_SD NOT ESAB) NOT TOUCH EGATE
SETLAYER EPMOS_DRAIN = (EPMOS_SD INTERACT EPMOS_D) INTERACT ECT
SETLAYER EMOS_D = ENMOS_D OR EPMOS_D
SETLAYER EMOS_S = ENMOS_S OR EPMOS_S


SETLAYER ENGUARDRING = HOLES ENTAP INNER EMPTY
SETLAYER EPGUARDRING = HOLES EPTAP INNER EMPTY
SETLAYER ENGUARDHOLE_2 = (HOLES ENTAP INNER) ENCLOSE EPGUARDRING
SETLAYER EPGUARDHOLE_2 = (HOLES EPTAP INNER) ENCLOSE ENGUARDRING

SETLAYER NESDCLP_NOSAB = (NACT AND ESDIOE) NOT INTERACT SAB
SETLAYER NESDCLP_SAB = (NACT AND ESDIOE) INTERACT SAB
SETLAYER PESDCLP_NOSAB = (PACT AND ESDIOE) NOT INTERACT SAB
SETLAYER PESDCLP_SAB = (PACT AND ESDIOE) INTERACT SAB

SETLAYER ENGATE_NOSAB = GATE AND NESDCLP_NOSAB
SETLAYER ENGATE_SAB = GATE AND NESDCLP_SAB
SETLAYER EPGATE_NOSAB = GATE AND PESDCLP_NOSAB
SETLAYER EPGATE_SAB = GATE AND PESDCLP_SAB
SETLAYER EGATE_NOSAB = ENGATE_NOSAB OR EPGATE_NOSAB
SETLAYER EGATE_SAB = ENGATE_SAB OR EPGATE_SAB

SETLAYER ESD3C_1 = EXPAND EDGE ((EGATE NOT EGATE_CASCODED) INSIDE EDGE AA) INSIDE BY 0.001
SETLAYER ESD3C_2 = EXPAND EDGE ((EGATE_CASCODED NOT INSIDE SAB) INSIDE EDGE AA) INSIDE BY 0.001
SETLAYER ESD3C = ESD3C_1 OR ESD3C_2

SETLAYER ENACT_D = ((ENACT NOT PO) INTERACT PO) INTERACT SAB >= 1
SETLAYER EPACT_D = ((EPACT NOT PO) INTERACT PO) INTERACT SAB >= 1
SETLAYER EACT_D = ENACT_D OR EPACT_D


#LAYER MAP 998 DATATYPE 1234 5432
#LAYER EMPTY1 5432
SETLAYER ENGATE_D_EMPTY = EMPTY1 OR (ESDIOE AND ENMOS_DRAIN)
SETLAYER EPGATE_D_EMPTY = EMPTY1 OR (ESDIOE AND EPMOS_DRAIN)
SETLAYER ESD3C_EMPTY    = EMPTY1 OR ESD3C
SETLAYER ECT_EMPTY      = EMPTY1 OR ECT

#CONNECT EGATE_POLY_EMPTY ESD3C_EMPTY
#CONNECT EGATE_POLY_EMPTY EM1_EMPTY BY ECT_EMPTY
CONNECT ENGATE_D_EMPTY ESD3C_EMPTY
CONNECT EPGATE_D_EMPTY ESD3C_EMPTY
CONNECT ENGATE_D_EMPTY EM1i_EMPTY BY ECT_EMPTY
CONNECT EPGATE_D_EMPTY EM1i_EMPTY BY ECT_EMPTY 

#Below connection is only for ESD_3_G; Both poly connected by PO and M1 are considered as "Finger"
foreach metal_via $v_m_list_for_connect {
  SETLAYER E${metal_via}_EMPTY = EMPTY1 OR $metal_via
}

for { set i 0 } { $i < [expr [llength $v_m_list_for_connect] -2] } { incr i 2 } {
  CONNECT E[lindex $v_m_list_for_connect $i]_EMPTY E[lindex $v_m_list_for_connect [expr $i +2]]_EMPTY BY E[lindex $v_m_list_for_connect [expr $i +1]]_EMPTY
}

SETLAYER EPA_EMPTY     = EMPTY1 OR CBi
SETLAYER ERDL_EMPTY    = EMPTY1 OR RDLi
SETLAYER ERDLVIA_EMPTY = EMPTY1 OR RV
SETLAYER EALPA_EMPTY   = EMPTY1 OR ALPAi
SETLAYER EMD_EMPTY     = EMPTY1 OR MDi
SETLAYER ERDLPA2_EMPTY = EMPTY1 OR COVER
if { [string equal $T4V2_T4M2 1] == 1 } {
CONNECT ET4M2i_EMPTY EPA_EMPTY
CONNECT ET4M2i_EMPTY ERDL_EMPTY BY ERDLVIA_EMPTY
}
if { [string equal $T2V2_T2M2 1] == 1 } {
CONNECT ET2M2i_EMPTY EPA_EMPTY
CONNECT ET2M2i_EMPTY ERDL_EMPTY BY ERDLVIA_EMPTY
}
if { [string equal $T8V2_T8M2 1] == 1 } {
CONNECT ET8M2i_EMPTY EPA_EMPTY
CONNECT ET8M2i_EMPTY ERDL_EMPTY BY ERDLVIA_EMPTY
}
if { [string equal $T4V1_T4M1 1] == 1 && [string equal $top_metal 1] == 1  } {
CONNECT ET4M1i_EMPTY EPA_EMPTY
CONNECT ET4M1i_EMPTY ERDL_EMPTY BY ERDLVIA_EMPTY
}
if { [string equal $T2V1_T2M1 1] == 1 && [string equal $top_metal 1] == 1} {
CONNECT ET2M1i_EMPTY EPA_EMPTY
CONNECT ET2M1i_EMPTY ERDL_EMPTY BY ERDLVIA_EMPTY
}
if { [string equal $T8V1_T8M1 1] == 1 && [string equal $top_metal 1] == 1} {
CONNECT ET8M1i_EMPTY EPA_EMPTY
CONNECT ET8M1i_EMPTY ERDL_EMPTY BY ERDLVIA_EMPTY
}
CONNECT ERDL_EMPTY ERDLPA2_EMPTY
CONNECT EPA_EMPTY EALPA_EMPTY
CONNECT ERDL_EMPTY EALPA_EMPTY
CONNECT EALPA_EMPTY EMD_EMPTY


VERBATIM {
#IFDEF ESD_CHECK YES
}

RULECHECK ESDN_1_SEDP_1 {
@ Minimum ACT extnsion of CT on SOURCE >= 0.15
OUTLAYER (ENC ECT_S EMOS_S < 0.15 ABUT < 90 SINGULAR REGION) NOT INSIDE EDGE NODRC
}

RULECHECK ESDN_2_ESDP_2 {
@ Minimum CT to Poly space on SOURCE >= 0.15
OUTLAYER (EXT ECT_S EGATE < 0.15 ABUT < 90 SINGULAR REGION) NOT INSIDE EDGE NODRC
}
RULECHECK ESDN_4_ESDP_4 {
@ Minimum SAB overlap Poly on Drain >= 0.05
OUTLAYER (INTERNAL ESAB EGATE < 0.05 ABUT < 90 SINGULAR REGION) NOT INSIDE NODRC
}
RULECHECK ESDN_5_ESDP_5 {
@ Minimum SAB to Poly on Drain space >= 1.29
 OUTLAYER (EXT ESAB_HO_RAW EGATE < 1.29 OPPOSITE REGION) NOT INSIDE EDGE NODRC
}
RULECHECK ESDN_6_ESDP_6 {
@ Minimum SAB to CT on Drain space >= 0.21
 OUTLAYER (ENC ECT_D ESAB_HO_RAW  < 0.21 ABUT <90 SINGULAR REGION) NOT INSIDE EDGE NODRC
}

RULECHECK ESDN_7_ESDP_7 {
@ Minimum SAB to ACT space >= 0.21
 OUTLAYER (ENC ENMOS_DRAIN (ESAB OR ESAB_HO_RAW)  < 0.21 ABUT <90 SINGULAR REGION) NOT INSIDE EDGE NODRC
 OUTLAYER (ENC EPMOS_DRAIN (ESAB OR ESAB_HO_RAW)  < 0.21 ABUT <90 SINGULAR REGION) NOT INSIDE EDGE NODRC
}
RULECHECK ESDN_8_ESDP_8 {
@ Minimum SAB overlap ACT >= 1
 OUTLAYER (ENC ESAB_HO_RAW ENMOS_DRAIN < 1 ABUT <90 SINGULAR REGION) NOT INSIDE EDGE NODRC
 OUTLAYER (ENC ESAB_HO_RAW EPMOS_DRAIN < 1 ABUT <90 SINGULAR REGION) NOT INSIDE EDGE NODRC
}
RULECHECK ESDN_9 {
@ Minimum ESD implant to Poly space >= 0.4
 OUTLAYER (EXT ESD1 EGATE < 0.4 OPPOSITE REGION) NOT INSIDE EDGE NODRC
}

RULECHECK ESDN_10 {
@ Minimum ESD implant to ACT space >= 0.4
 OUTLAYER (ENC ESD1 ENMOS_DRAIN < 0.4 ABUT <90 SINGULAR REGION) NOT INSIDE EDGE NODRC
}
RULECHECK ESDN_11 {
@ ESD implant can't overlap Poly
 OUTLAYER (ESD1 AND EGATE_POLY) NOT INSIDE EDGE NODRC
}

RULECHECK ESDN_12 {
@ Unit finger width (F) of NMOS for ESD protection device >= 30um
@ <= 40um
 OUTLAYER (LENGTH (EGATE_W INSIDE EDGE ENMOS) < 30) NOT INSIDE EDGE NODRC
 OUTLAYER (LENGTH (EGATE_W INSIDE EDGE ENMOS) > 40) NOT INSIDE EDGE NODRC
}
RULECHECK ESDP_9 {
@ Unit finger width (F) of PMOS for ESD protection device >= 30um
@ <= 40um
 OUTLAYER (LENGTH (EGATE_W INSIDE EDGE EPMOS) < 30) NOT INSIDE EDGE NODRC
 OUTLAYER (LENGTH (EGATE_W INSIDE EDGE EPMOS) > 40) NOT INSIDE EDGE NODRC
}

VERBATIM {
#IFDEF OPEN_RECOMMENDED_ON YES
}
RULECHECK ESDN_13_R {
@ Total channel width of ESD NMOS. The total channel width is calculated by the ESD MOS in the same Drain connection. The connectivity can be formed by all metal, via, ALPA, PA and MD but not broken by resistors. SAB is used for drain recognition in DRC runset
@ Channel width (W) of NMOS for ESD protection device (Channel width = Finger width x Finger No.) >= 150um
   SETLAYER X = NET AREA RATIO ENGATE_D_EMPTY ESD3C_EMPTY \[AREA(ESD3C_EMPTY)/0.001\] < 150
   OUTLAYER ((X INTERACT ENGATE) NOT INTERACT EGATE_NOSAB) NOT INSIDE NODRC
}

RULECHECK ESDP_10_R {
@ Total channel width of ESD PMOS. The total channel width is calculated by the ESD MOS in the same Drain connection. The connectivity can be formed by all metal, via, ALPA, PA and MD but not broken by resistors. SAB is used for drain recognition in DRC runset
@ Channel width (W) of PMOS for ESD protection device (Channel width = Finger width x Finger No.) >= 300um
   SETLAYER X = NET AREA RATIO EPGATE_D_EMPTY ESD3C_EMPTY \[AREA(ESD3C_EMPTY)/0.001\] < 300
   OUTLAYER ((X INTERACT EPGATE) NOT INTERACT EGATE_NOSAB) NOT INSIDE NODRC
}

VERBATIM {
#ENDIF
}

VERBATIM {
#IFDEF IO 1833
}
RULECHECK ESDN_3 {
@ Channel length of 3.3V I/O NMOS for protection device. >= 0.5um
 SETLAYER X = (EGATEHV AND ENGATE) COIN EDGE EGATE_L
 OUTLAYER (LENGTH X < 0.5) NOT INSIDE EDGE NODRC
}
RULECHECK ESDP_3 {
@ Channel length of 3.3V I/O PMOS for protection device. >= 0.4um, <=0.5 
 SETLAYER X = (EGATEHV AND EPGATE) COIN EDGE EGATE_L
 SETLAYER GOOD =  (LENGTH X >= 0.4 <= 0.5) NOT INSIDE EDGE NODRC
 OUTLAYER ((EGATEHV AND EPGATE) NOT WITH EDGE GOOD) NOT INSIDE EDGE NODRC
}
VERBATIM {
#ENDIF
}

VERBATIM { 
#IFDEF IO 1825 
}
RULECHECK ESDN_3 {
@ Channel length of 3.3V I/O NMOS for protection device. >= 0.5um
 SETLAYER X = (EGATEHV AND ENGATE) COIN EDGE EGATE_L
 OUTLAYER (LENGTH X < 0.5) NOT INSIDE EDGE NODRC
}
RULECHECK ESDP_3 {
@ Channel length of 3.3V I/O PMOS for protection device. >= 0.4um, <=0.5 
 SETLAYER X = (EGATEHV AND EPGATE) COIN EDGE EGATE_L
 SETLAYER GOOD =  (LENGTH X >= 0.4 <= 0.5) NOT INSIDE EDGE NODRC
 OUTLAYER ((EGATEHV AND EPGATE) NOT WITH EDGE GOOD) NOT INSIDE EDGE NODRC
}
VERBATIM {
#ENDIF
}


VERBATIM {
#ENDIF
}



#//============================
#//  ESD1 implant layer rules
#//============================

RULECHECK ESD_W_1 {
@ ESD1 width >= 0.47um

OUTLAYER (INT ESD1 < 0.47 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK ESD_S_1 {
@ Space between two ESD1s. Merge if space is less than this value. >= 0.47um
OUTLAYER (EXT ESD1 < 0.47 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK ESD_A_1 {
@ ESD1 area >= 0.6um2 
OUTLAYER (AREA ESD1 < 0.6) NOT INSIDE NODRC
}

RULECHECK ESD_A_2 {
@ ESD1 enclosed area >= 0.6um2
OUTLAYER (AREA ((HOLES ESD1 INNER) NOT ESD1) < 0.6) NOT INSIDE NODRC
}

VERBATIM {
#IFDEF LATCH_UP_CHECK YES
}

#//========================================
#//  Latch-Up Prevention Layout Guidelines
#//========================================

SETLAYER POWER_PAD = PVSS OR PVDD 
SETLAYER ALL_RES =  (AA ENCLOSE (AA_resistor OR NW_resistor)) OR (PO ENCLOSE PO_resistor) 

SETLAYER all_pad_vdd_M1 = WITH TEXT M1 ?VDD? MET1text
SETLAYER all_pad_vss_M1 = WITH TEXT M1 ?VSS? MET1text
SETLAYER all_pad_vcc_M1 = WITH TEXT M1 ?VCC? MET1text
SETLAYER all_pad_gnd_M1 = WITH TEXT M1 ?GND? MET1text
SETLAYER all_pad_vdd_M2 = WITH TEXT M2 ?VDD? MET2text
SETLAYER all_pad_vss_M2 = WITH TEXT M2 ?VSS? MET2text
SETLAYER all_pad_vcc_M2 = WITH TEXT M2 ?VCC? MET2text
SETLAYER all_pad_gnd_M2 = WITH TEXT M2 ?GND? MET2text
SETLAYER all_pad_vdd_M3 = WITH TEXT M3 ?VDD? MET3text
SETLAYER all_pad_vss_M3 = WITH TEXT M3 ?VSS? MET3text
SETLAYER all_pad_vcc_M3 = WITH TEXT M3 ?VCC? MET3text
SETLAYER all_pad_gnd_M3 = WITH TEXT M3 ?GND? MET3text
SETLAYER all_pad_vdd_M4 = WITH TEXT M4 ?VDD? MET4text
SETLAYER all_pad_vss_M4 = WITH TEXT M4 ?VSS? MET4text
SETLAYER all_pad_vcc_M4 = WITH TEXT M4 ?VCC? MET4text
SETLAYER all_pad_gnd_M4 = WITH TEXT M4 ?GND? MET4text
SETLAYER all_pad_vdd_M5 = WITH TEXT M5 ?VDD? MET5text
SETLAYER all_pad_vss_M5 = WITH TEXT M5 ?VSS? MET5text
SETLAYER all_pad_vcc_M5 = WITH TEXT M5 ?VCC? MET5text
SETLAYER all_pad_gnd_M5 = WITH TEXT M5 ?GND? MET5text
SETLAYER all_pad_vdd_M6 = WITH TEXT M6 ?VDD? MET6text
SETLAYER all_pad_vss_M6 = WITH TEXT M6 ?VSS? MET6text
SETLAYER all_pad_vcc_M6 = WITH TEXT M6 ?VCC? MET6text
SETLAYER all_pad_gnd_M6 = WITH TEXT M6 ?GND? MET6text
SETLAYER all_pad_vdd_M7 = WITH TEXT M7 ?VDD? MET7text
SETLAYER all_pad_vss_M7 = WITH TEXT M7 ?VSS? MET7text
SETLAYER all_pad_vcc_M7 = WITH TEXT M7 ?VCC? MET7text
SETLAYER all_pad_gnd_M7 = WITH TEXT M7 ?GND? MET7text
SETLAYER all_pad_vdd_M8 = WITH TEXT M8 ?VDD? MET8text
SETLAYER all_pad_vss_M8 = WITH TEXT M8 ?VSS? MET8text
SETLAYER all_pad_vcc_M8 = WITH TEXT M8 ?VCC? MET8text
SETLAYER all_pad_gnd_M8 = WITH TEXT M8 ?GND? MET8text
SETLAYER all_pad_vdd_T4M1 = WITH TEXT T4M1 ?VDD? T4M1text
SETLAYER all_pad_vss_T4M1 = WITH TEXT T4M1 ?VSS? T4M1text
SETLAYER all_pad_vcc_T4M1 = WITH TEXT T4M1 ?VCC? T4M1text
SETLAYER all_pad_gnd_T4M1 = WITH TEXT T4M1 ?GND? T4M1text
SETLAYER all_pad_vdd_T4M2 = WITH TEXT T4M2 ?VDD? T4M2text
SETLAYER all_pad_vss_T4M2 = WITH TEXT T4M2 ?VSS? T4M2text
SETLAYER all_pad_vcc_T4M2 = WITH TEXT T4M2 ?VCC? T4M2text
SETLAYER all_pad_gnd_T4M2 = WITH TEXT T4M2 ?GND? T4M2text
SETLAYER all_pad_vdd_T2M1 = WITH TEXT T2M1 ?VDD? T2M1text
SETLAYER all_pad_vss_T2M1 = WITH TEXT T2M1 ?VSS? T2M1text
SETLAYER all_pad_vcc_T2M1 = WITH TEXT T2M1 ?VCC? T2M1text
SETLAYER all_pad_gnd_T2M1 = WITH TEXT T2M1 ?GND? T2M1text
SETLAYER all_pad_vdd_T2M2 = WITH TEXT T2M2 ?VDD? T2M2text
SETLAYER all_pad_vss_T2M2 = WITH TEXT T2M2 ?VSS? T2M2text
SETLAYER all_pad_vcc_T2M2 = WITH TEXT T2M2 ?VCC? T2M2text
SETLAYER all_pad_gnd_T2M2 = WITH TEXT T2M2 ?GND? T2M2text
SETLAYER all_pad_vdd_T8M1 = WITH TEXT T8M1 ?VDD? T8M1text
SETLAYER all_pad_vss_T8M1 = WITH TEXT T8M1 ?VSS? T8M1text
SETLAYER all_pad_vcc_T8M1 = WITH TEXT T8M1 ?VCC? T8M1text
SETLAYER all_pad_gnd_T8M1 = WITH TEXT T8M1 ?GND? T8M1text
SETLAYER all_pad_vdd_T8M2 = WITH TEXT T8M2 ?VDD? T8M2text
SETLAYER all_pad_vss_T8M2 = WITH TEXT T8M2 ?VSS? T8M2text
SETLAYER all_pad_vcc_T8M2 = WITH TEXT T8M2 ?VCC? T8M2text
SETLAYER all_pad_gnd_T8M2 = WITH TEXT T8M2 ?GND? T8M2text
SETLAYER all_pad_vdd_PA = WITH TEXT PA ?VDD? CBtext
SETLAYER all_pad_vss_PA = WITH TEXT PA ?VSS? CBtext
SETLAYER all_pad_vcc_PA = WITH TEXT PA ?VCC? CBtext
SETLAYER all_pad_gnd_PA = WITH TEXT PA ?GND? CBtext
SETLAYER all_pad_vdd_ALPA = WITH TEXT ALPA ?VDD? ALPADtext
SETLAYER all_pad_vss_ALPA = WITH TEXT ALPA ?VSS? ALPADtext
SETLAYER all_pad_vcc_ALPA = WITH TEXT ALPA ?VCC? ALPADtext
SETLAYER all_pad_gnd_ALPA = WITH TEXT ALPA ?GND? ALPADtext

SETLAYER all_pad_TXT_M1 = OR all_pad_vdd_M1 all_pad_vss_M1 all_pad_vcc_M1 all_pad_gnd_M1
SETLAYER all_pad_TXT_M2 = OR all_pad_vdd_M2 all_pad_vss_M2 all_pad_vcc_M2 all_pad_gnd_M2
SETLAYER all_pad_TXT_M3 = OR all_pad_vdd_M3 all_pad_vss_M3 all_pad_vcc_M3 all_pad_gnd_M3
SETLAYER all_pad_TXT_M4 = OR all_pad_vdd_M4 all_pad_vss_M4 all_pad_vcc_M4 all_pad_gnd_M4
SETLAYER all_pad_TXT_M5 = OR all_pad_vdd_M5 all_pad_vss_M5 all_pad_vcc_M5 all_pad_gnd_M5
SETLAYER all_pad_TXT_M6 = OR all_pad_vdd_M6 all_pad_vss_M6 all_pad_vcc_M6 all_pad_gnd_M6
SETLAYER all_pad_TXT_M7 = OR all_pad_vdd_M7 all_pad_vss_M7 all_pad_vcc_M7 all_pad_gnd_M7
SETLAYER all_pad_TXT_M8 = OR all_pad_vdd_M8 all_pad_vss_M8 all_pad_vcc_M8 all_pad_gnd_M8
SETLAYER all_pad_TXT_T4M1 = OR all_pad_vdd_T4M1 all_pad_vss_T4M1 all_pad_vcc_T4M1 all_pad_gnd_T4M1
SETLAYER all_pad_TXT_T4M2 = OR all_pad_vdd_T4M2 all_pad_vss_T4M2 all_pad_vcc_T4M2 all_pad_gnd_T4M2
SETLAYER all_pad_TXT_T2M1 = OR all_pad_vdd_T2M1 all_pad_vss_T2M1 all_pad_vcc_T2M1 all_pad_gnd_T2M1
SETLAYER all_pad_TXT_T2M2 = OR all_pad_vdd_T2M2 all_pad_vss_T2M2 all_pad_vcc_T2M2 all_pad_gnd_T2M2
SETLAYER all_pad_TXT_T8M1 = OR all_pad_vdd_T8M1 all_pad_vss_T8M1 all_pad_vcc_T8M1 all_pad_gnd_T8M1
SETLAYER all_pad_TXT_T8M2 = OR all_pad_vdd_T8M2 all_pad_vss_T8M2 all_pad_vcc_T8M2 all_pad_gnd_T8M2
SETLAYER all_pad_TXT_PA = OR all_pad_vdd_PA all_pad_vss_PA all_pad_vcc_PA all_pad_gnd_PA
SETLAYER all_pad_TXT_ALPA = OR all_pad_vdd_ALPA all_pad_vss_ALPA all_pad_vcc_ALPA all_pad_gnd_ALPA

SETLAYER all_pad_TXT = OR all_pad_TXT_M1 all_pad_TXT_M2 all_pad_TXT_M3 all_pad_TXT_M4 all_pad_TXT_M5 all_pad_TXT_M6 all_pad_TXT_M7 all_pad_TXT_M8 all_pad_TXT_T4M1 all_pad_TXT_T4M2 all_pad_TXT_T2M1 all_pad_TXT_T2M2 all_pad_TXT_T8M1 all_pad_TXT_T8M2 all_pad_TXT_PA all_pad_TXT_ALPA

SETLAYER all_pad_TXT1_PA = STAMP all_pad_TXT_PA BY PA_1
SETLAYER all_pad_TXT1_ALPA = STAMP all_pad_TXT_ALPA BY ALPA_1
SETLAYER power_pad_TXT_PA = PA_1 INTERACT (NET AREA RATIO PA_1 all_pad_TXT1_PA > 0)
SETLAYER power_pad_TXT_ALPA = ALPA_1 INTERACT (NET AREA RATIO ALPA_1 all_pad_TXT1_ALPA > 0)
SETLAYER NAA_POWER_PAD_PA = NET AREA RATIO NAA_PAD power_pad_TXT_PA > 0
SETLAYER PAA_POWER_PAD_PA = NET AREA RATIO PAA_PAD power_pad_TXT_PA > 0
SETLAYER NAA_POWER_PAD_ALPA = NET AREA RATIO NAA_PAD power_pad_TXT_ALPA > 0
SETLAYER PAA_POWER_PAD_ALPA = NET AREA RATIO PAA_PAD power_pad_TXT_ALPA > 0
VERBATIM {
POWER_PAD2 = STAMP POWER_PAD BY MD_1
POWER_PAD3 = MD_1 INTERACT (NET AREA RATIO MD_1 POWER_PAD2 > 0)
MD_IO_PAD = MD_1 NOT INTERACT POWER_PAD3
}

SETLAYER NACT_0   = (SDN AND AA) NOT PO  
SETLAYER PACT_0   = (SDP AND AA) NOT PO  

SETLAYER CT_1     = EMPTY5 OR CT
SETLAYER MD_1     = EMPTY5 OR MD 
SETLAYER RDL_1    = EMPTY5 OR RDL
SETLAYER RDLVIA_1 = EMPTY5 OR RV
SETLAYER RDLPA2_1 = EMPTY5 OR COVER

VERBATIM {
#IFDEF DEFINE_PAD_BY_TEXT 1
}
SETLAYER  ALPA_1 = EMPTY5 OR ALPA 
SETLAYER  PA_1   = EMPTY5 OR PA

SETLAYER M1i_EMPTY5 = EMPTY5 OR M1i 
SETLAYER all_pad_TXT1_M1 = STAMP all_pad_TXT_M1 BY M1i_EMPTY5
SETLAYER power_pad_TXT_M1 = M1i_EMPTY5 INTERACT (NET AREA RATIO M1i_EMPTY5 all_pad_TXT1_M1 > 0)
SETLAYER NAA_POWER_PAD_M1 = NET AREA RATIO NAA_PAD power_pad_TXT_M1 > 0
SETLAYER PAA_POWER_PAD_M1 = NET AREA RATIO PAA_PAD power_pad_TXT_M1 > 0

set metal_list { M2 M3 M4 M5 M6 M7 M8 }
foreach metal_layer $metal_list {
  set tmp CHECK_$metal_layer
  set tmp_v [set $tmp]

  if { $tmp_v == 1 } {
SETLAYER ${metal_layer}i_EMPTY5 = EMPTY5 OR ${metal_layer}i
SETLAYER all_pad_TXT1_${metal_layer} = STAMP all_pad_TXT_${metal_layer} BY ${metal_layer}i_EMPTY5
SETLAYER power_pad_TXT_${metal_layer} = ${metal_layer}i_EMPTY5 INTERACT (NET AREA RATIO ${metal_layer}i_EMPTY5 all_pad_TXT1_${metal_layer} > 0)

SETLAYER NAA_POWER_PAD_${metal_layer} = NET AREA RATIO NAA_PAD power_pad_TXT_${metal_layer} > 0
  SETLAYER PAA_POWER_PAD_${metal_layer} = NET AREA RATIO PAA_PAD power_pad_TXT_${metal_layer} > 0 
  lappend list1 NAA_POWER_PAD_${metal_layer}
  lappend list2 PAA_POWER_PAD_${metal_layer}
}
}

SETLAYER V1_EMPTY5 = EMPTY5 OR V1
set via_list { V2 V3 V4 V5 V6 V7 }
foreach via_layer $via_list {
  set tmp CHECK_$via_layer
  set tmp_v [set $tmp]

  if { $tmp_v == 1 } {
SETLAYER ${via_layer}_EMPTY5 = EMPTY5 OR ${via_layer}

}
}

if { ($T4V1_T4M1 == 1) && ($T4V2_T4M2 == 1) && ($top_metal == 2) } {
SETLAYER T4M1i_EMPTY5 = EMPTY5 OR T4M1i 
SETLAYER T4M2i_EMPTY5 = EMPTY5 OR T4M2i
SETLAYER T4V1i_EMPTY5 = EMPTY5 OR T4V1i 
SETLAYER T4V2i_EMPTY5 = EMPTY5 OR T4V2i 

SETLAYER all_pad_TXT1_T4M1 = STAMP all_pad_TXT_T4M1 BY T4M1i_EMPTY5
SETLAYER all_pad_TXT1_T4M2 = STAMP all_pad_TXT_T4M2 BY T4M2i_EMPTY5
SETLAYER power_pad_TXT_T4M1 = T4M1i_EMPTY5 INTERACT (NET AREA RATIO T4M1i_EMPTY5 all_pad_TXT1_T4M1 > 0)
SETLAYER power_pad_TXT_T4M2 = T4M2i_EMPTY5 INTERACT (NET AREA RATIO T4M2i_EMPTY5 all_pad_TXT1_T4M2 > 0)
SETLAYER NAA_POWER_PAD_T4M1 = NET AREA RATIO NAA_PAD power_pad_TXT_T4M1 > 0
SETLAYER PAA_POWER_PAD_T4M1 = NET AREA RATIO PAA_PAD power_pad_TXT_T4M1 > 0
SETLAYER NAA_POWER_PAD_T4M2 = NET AREA RATIO NAA_PAD power_pad_TXT_T4M2 > 0
SETLAYER PAA_POWER_PAD_T4M2 = NET AREA RATIO PAA_PAD power_pad_TXT_T4M2 > 0
lappend list1 {NAA_POWER_PAD_T4M1 }
lappend list1 {NAA_POWER_PAD_T4M2}
lappend list2 {PAA_POWER_PAD_T4M1}
lappend list2 {PAA_POWER_PAD_T4M2}
}

if { ($T4V1_T4M1 == 1) && ($T8V2_T8M2 == 1) && ($top_metal == 2) } {
SETLAYER T4M1i_EMPTY5 = EMPTY5 OR T4M1i
SETLAYER T8M2i_EMPTY5 = EMPTY5 OR T8M2i 
SETLAYER T4V1i_EMPTY5 = EMPTY5 OR T4V1i 
SETLAYER T8V2i_EMPTY5 = EMPTY5 OR T8V2i 
SETLAYER all_pad_TXT1_T4M1 = STAMP all_pad_TXT_T4M1 BY T4M1i_EMPTY5
SETLAYER all_pad_TXT1_T8M2 = STAMP all_pad_TXT_T8M2 BY T8M2i_EMPTY5
SETLAYER power_pad_TXT_T4M1 = T4M1i_EMPTY5 INTERACT (NET AREA RATIO T4M1i_EMPTY5 all_pad_TXT1_T4M1 > 0)
SETLAYER power_pad_TXT_T8M2 = T8M2i_EMPTY5 INTERACT (NET AREA RATIO T8M2i_EMPTY5 all_pad_TXT1_T8M2 > 0)
SETLAYER NAA_POWER_PAD_T4M1 = NET AREA RATIO NAA_PAD power_pad_TXT_T4M1 > 0
SETLAYER PAA_POWER_PAD_T4M1 = NET AREA RATIO PAA_PAD power_pad_TXT_T4M1 > 0
SETLAYER NAA_POWER_PAD_T8M2 = NET AREA RATIO NAA_PAD power_pad_TXT_T8M2 > 0
SETLAYER PAA_POWER_PAD_T8M2 = NET AREA RATIO PAA_PAD power_pad_TXT_T8M2 > 0
lappend list1 {NAA_POWER_PAD_T4M1}
lappend list1 {NAA_POWER_PAD_T8M2}
lappend list2 {PAA_POWER_PAD_T4M1}
lappend list2 {PAA_POWER_PAD_T8M2}
}

if { ($T8V1_T8M1 == 1) && ($top_metal == 2) } {
SETLAYER T8M1i_EMPTY5 = EMPTY5 OR T8M1i 
SETLAYER T8M2i_EMPTY5 = EMPTY5 OR T8M2i
SETLAYER T8V1i_EMPTY5 = EMPTY5 OR T8V1i 
SETLAYER T8V2i_EMPTY5 = EMPTY5 OR T8V2i 

SETLAYER all_pad_TXT1_T8M1 = STAMP all_pad_TXT_T8M1 BY T8M1i_EMPTY5
SETLAYER all_pad_TXT1_T8M2 = STAMP all_pad_TXT_T8M2 BY T8M2i_EMPTY5
SETLAYER power_pad_TXT_T8M1 = T8M1i_EMPTY5 INTERACT (NET AREA RATIO T8M1i_EMPTY5 all_pad_TXT1_T8M1 > 0)
SETLAYER power_pad_TXT_T8M2 = T8M2i_EMPTY5 INTERACT (NET AREA RATIO T8M2i_EMPTY5 all_pad_TXT1_T8M2 > 0)
SETLAYER NAA_POWER_PAD_T8M1 = NET AREA RATIO NAA_PAD power_pad_TXT_T8M1 > 0
SETLAYER PAA_POWER_PAD_T8M1 = NET AREA RATIO PAA_PAD power_pad_TXT_T8M1 > 0
SETLAYER NAA_POWER_PAD_T8M2 = NET AREA RATIO NAA_PAD power_pad_TXT_T8M2 > 0
SETLAYER PAA_POWER_PAD_T8M2 = NET AREA RATIO PAA_PAD power_pad_TXT_T8M2 > 0
lappend list1 {NAA_POWER_PAD_T8M1 }
lappend list1 {NAA_POWER_PAD_T8M2}
lappend list2 {PAA_POWER_PAD_T8M1}
lappend list2 {PAA_POWER_PAD_T8M2}
}

if { ($T2V1_T2M1 == 1) && ($T2V2_T2M2 == 1) && ($top_metal == 2) } {
SETLAYER T2M1i_EMPTY5 = EMPTY5 OR T2M1i 
SETLAYER T2M2i_EMPTY5 = EMPTY5 OR T2M2i 
SETLAYER T2V1i_EMPTY5 = EMPTY5 OR T2V1i 
SETLAYER T2V2i_EMPTY5 = EMPTY5 OR T2V2i 
SETLAYER all_pad_TXT1_T2M1 = STAMP all_pad_TXT_T2M1 BY T2M1i_EMPTY5
SETLAYER all_pad_TXT1_T2M2 = STAMP all_pad_TXT_T2M2 BY T2M2i_EMPTY5
SETLAYER power_pad_TXT_T2M1 = T2M1i_EMPTY5 INTERACT (NET AREA RATIO T2M1i_EMPTY5 all_pad_TXT1_T2M1 > 0)
SETLAYER power_pad_TXT_T2M2 = T2M2i_EMPTY5 INTERACT (NET AREA RATIO T2M2i_EMPTY5 all_pad_TXT1_T2M2 > 0)
SETLAYER NAA_POWER_PAD_T2M1 = NET AREA RATIO NAA_PAD power_pad_TXT_T2M1 > 0
SETLAYER PAA_POWER_PAD_T2M1 = NET AREA RATIO PAA_PAD power_pad_TXT_T2M1 > 0
SETLAYER NAA_POWER_PAD_T2M2 = NET AREA RATIO NAA_PAD power_pad_TXT_T2M2 > 0
SETLAYER PAA_POWER_PAD_T2M2 = NET AREA RATIO PAA_PAD power_pad_TXT_T2M2 > 0
lappend list1 {NAA_POWER_PAD_T2M1}
lappend list1 {NAA_POWER_PAD_T2M2}
lappend list2 {PAA_POWER_PAD_T2M1}
lappend list2 {PAA_POWER_PAD_T2M2}

}

if { ($T2V1_T2M1 == 1) && ($T4V2_T4M2 == 1) && ($top_metal == 2) } {
SETLAYER T2M1i_EMPTY5 = EMPTY5 OR T2M1i
SETLAYER T4M2i_EMPTY5 = EMPTY5 OR T4M2i 
SETLAYER T2V1i_EMPTY5 = EMPTY5 OR T2V1i 
SETLAYER T4V2i_EMPTY5 = EMPTY5 OR T4V2i 
SETLAYER all_pad_TXT1_T2M1 = STAMP all_pad_TXT_T2M1 BY T2M1i_EMPTY5
SETLAYER all_pad_TXT1_T4M2 = STAMP all_pad_TXT_T4M2 BY T4M2i_EMPTY5
SETLAYER power_pad_TXT_T2M1 = T2M1i_EMPTY5 INTERACT (NET AREA RATIO T2M1i_EMPTY5 all_pad_TXT1_T2M1 > 0)
SETLAYER power_pad_TXT_T4M2 = T4M2i_EMPTY5 INTERACT (NET AREA RATIO T4M2i_EMPTY5 all_pad_TXT1_T4M2 > 0)
SETLAYER NAA_POWER_PAD_T2M1 = NET AREA RATIO NAA_PAD power_pad_TXT_T2M1 > 0
SETLAYER PAA_POWER_PAD_T2M1 = NET AREA RATIO PAA_PAD power_pad_TXT_T2M1 > 0
SETLAYER NAA_POWER_PAD_T4M2 = NET AREA RATIO NAA_PAD power_pad_TXT_T4M2 > 0
SETLAYER PAA_POWER_PAD_T4M2 = NET AREA RATIO PAA_PAD power_pad_TXT_T4M2 > 0
lappend list1 {NAA_POWER_PAD_T2M1}
lappend list1 {NAA_POWER_PAD_T4M2}
lappend list2 {PAA_POWER_PAD_T2M1}
lappend list2 {PAA_POWER_PAD_T4M2}
}

if { ($T2V1_T2M1 == 1) && ($T8V2_T8M2 == 1) && ($top_metal == 2) } {
SETLAYER T2M1i_EMPTY5 = EMPTY5 OR T2M1i
SETLAYER T8M2i_EMPTY5 = EMPTY5 OR T8M2i 
SETLAYER T2V1i_EMPTY5 = EMPTY5 OR T2V1i 
SETLAYER T8V2i_EMPTY5 = EMPTY5 OR T8V2i 
SETLAYER all_pad_TXT1_T2M1 = STAMP all_pad_TXT_T2M1 BY T2M1i_EMPTY5
SETLAYER all_pad_TXT1_T8M2 = STAMP all_pad_TXT_T8M2 BY T8M2i_EMPTY5
SETLAYER power_pad_TXT_T2M1 = T2M1i_EMPTY5 INTERACT (NET AREA RATIO T2M1i_EMPTY5 all_pad_TXT1_T2M1 > 0)
SETLAYER power_pad_TXT_T8M2 = T8M2i_EMPTY5 INTERACT (NET AREA RATIO T8M2i_EMPTY5 all_pad_TXT1_T8M2 > 0)
SETLAYER NAA_POWER_PAD_T2M1 = NET AREA RATIO NAA_PAD power_pad_TXT_T2M1 > 0
SETLAYER PAA_POWER_PAD_T2M1 = NET AREA RATIO PAA_PAD power_pad_TXT_T2M1 > 0
SETLAYER NAA_POWER_PAD_T8M2 = NET AREA RATIO NAA_PAD power_pad_TXT_T8M2 > 0
SETLAYER PAA_POWER_PAD_T8M2 = NET AREA RATIO PAA_PAD power_pad_TXT_T8M2 > 0
lappend list1 {NAA_POWER_PAD_T2M1}
lappend list1 {NAA_POWER_PAD_T8M2}
lappend list2 {PAA_POWER_PAD_T2M1}
lappend list2 {PAA_POWER_PAD_T8M2}
}

if { ($T4V1_T4M1 == 1)  && ($top_metal == 1) } {
SETLAYER T4M1i_EMPTY5 = EMPTY5 OR T4M1i 
SETLAYER T4V1i_EMPTY5 = EMPTY5 OR T4V1i 

SETLAYER all_pad_TXT1_T4M1 = STAMP all_pad_TXT_T4M1 BY T4M1i_EMPTY5
SETLAYER power_pad_TXT_T4M1 = T4M1i_EMPTY5 INTERACT (NET AREA RATIO T4M1i_EMPTY5 all_pad_TXT1_T4M1 > 0)
SETLAYER NAA_POWER_PAD_T4M1 = NET AREA RATIO NAA_PAD power_pad_TXT_T4M1 > 0
SETLAYER PAA_POWER_PAD_T4M1 = NET AREA RATIO PAA_PAD power_pad_TXT_T4M1 > 0
lappend list1 {NAA_POWER_PAD_T4M1}
lappend list2 {PAA_POWER_PAD_T4M1}
}


if { ($T2V1_T2M1 == 1)  && ($top_metal == 1) } {
SETLAYER T2M1i_EMPTY5 = EMPTY5 OR T2M1i 
SETLAYER T2V1i_EMPTY5 = EMPTY5 OR T2V1i
SETLAYER all_pad_TXT1_T2M1 = STAMP all_pad_TXT_T2M1 BY T2M1i_EMPTY5
SETLAYER power_pad_TXT_T2M1 = T2M1i_EMPTY5 INTERACT (NET AREA RATIO T2M1i_EMPTY5 all_pad_TXT1_T2M1 > 0) 
SETLAYER NAA_POWER_PAD_T2M1 = NET AREA RATIO NAA_PAD power_pad_TXT_T2M1 > 0
SETLAYER PAA_POWER_PAD_T2M1 = NET AREA RATIO PAA_PAD power_pad_TXT_T2M1 > 0
lappend list1 {NAA_POWER_PAD_T2M1}
lappend list2 {PAA_POWER_PAD_T2M1}
}
if { ($T8V1_T8M1 == 1)  && ($top_metal == 1) } {
SETLAYER T8M1i_EMPTY5 = EMPTY5 OR T8M1i 
SETLAYER T8V1i_EMPTY5 = EMPTY5 OR T8V1i
SETLAYER all_pad_TXT1_T8M1 = STAMP all_pad_TXT_T8M1 BY T8M1i_EMPTY5
SETLAYER power_pad_TXT_T8M1 = T8M1i_EMPTY5 INTERACT (NET AREA RATIO T8M1i_EMPTY5 all_pad_TXT1_T8M1 > 0) 
SETLAYER NAA_POWER_PAD_T8M1 = NET AREA RATIO NAA_PAD power_pad_TXT_T8M1 > 0
SETLAYER PAA_POWER_PAD_T8M1 = NET AREA RATIO PAA_PAD power_pad_TXT_T8M1 > 0
lappend list1 {NAA_POWER_PAD_T8M1}
lappend list2 {PAA_POWER_PAD_T8M1}
}

SETLAYER NAA_POWER_PAD_all_0 = OR NAA_POWER_PAD_M1 NAA_POWER_PAD_PA NAA_POWER_PAD_ALPA
SETLAYER PAA_POWER_PAD_all_0 = OR PAA_POWER_PAD_M1 PAA_POWER_PAD_PA PAA_POWER_PAD_ALPA
for { set i 0 } { $i < [ llength $list1 ] } { incr i } {
SETLAYER NAA_POWER_PAD_all_[ expr $i + 1 ] = NAA_POWER_PAD_all_$i OR [ lindex $list1 $i ]
}
VERBATIM "  "
for { set i 0 } { $i < [ llength $list2 ] } { incr i } {
SETLAYER PAA_POWER_PAD_all_[ expr $i + 1 ] = PAA_POWER_PAD_all_$i OR [ lindex $list2 $i ]
}



SETLAYER NAA_IO_PAD = NAA_PAD NOT INTERACT NAA_POWER_PAD_all_${i}
SETLAYER PAA_IO_PAD = PAA_PAD NOT INTERACT PAA_POWER_PAD_all_${i}
SETLAYER NMOS_IO_PAD = NMOS_PAD INTERACT NAA_IO_PAD
SETLAYER PMOS_IO_PAD = PMOS_PAD INTERACT PAA_IO_PAD

VERBATIM {
#ENDIF
}

VERBATIM {
#IFDEF DEFINE_PAD_BY_TEXT 0
}
SETLAYER  ALPA_1 = EMPTY5 OR ALPAi
SETLAYER  PA_1   = EMPTY5 OR CBi
foreach metal_via $v_m_list_for_connect {
  SETLAYER  ${metal_via}_EMPTY5 = EMPTY5 OR ${metal_via}
}

VERBATIM {
NAA_IO_PAD = NET AREA RATIO NACT_1 MD_IO_PAD > 0
PAA_IO_PAD = NET AREA RATIO PACT_1 MD_IO_PAD > 0
NMOS_IO_PAD = NMOS1 INTERACT NAA_IO_PAD
PMOS_IO_PAD = PMOS1 INTERACT PAA_IO_PAD
}

VERBATIM {
#ENDIF
}


VERBATIM {
#IFDEF CONNECT_ALL_RESISTOR 0
}
SETLAYER  NACT_1 = EMPTY5 OR (NACT_0 NOT (AA_resistor OR NW_resistor)) 
SETLAYER  PACT_1 = EMPTY5 OR (PACT_0 NOT (AA_resistor OR NW_resistor)) 
SETLAYER  PO_1  =  EMPTY5 OR (PO_raw NOT PO_resistor)
VERBATIM {
#ENDIF
}


VERBATIM {
#IFDEF CONNECT_ALL_RESISTOR 1
}
SETLAYER  NACT_1 = EMPTY5 OR NACT_0  
SETLAYER  PACT_1 = EMPTY5 OR PACT_0  
SETLAYER  PO_1   = EMPTY5 OR PO_raw 



VERBATIM {
#ENDIF
}

for { set i 0 } { $i < [expr [llength $v_m_list_for_connect] -2] } { incr i 2 } {
  CONNECT [lindex $v_m_list_for_connect $i]_EMPTY5 [lindex $v_m_list_for_connect [expr $i +2]]_EMPTY5 BY \
          [lindex $v_m_list_for_connect [expr $i +1]]_EMPTY5
}

CONNECT M1i_EMPTY5 PO_1 NACT_1 PACT_1  BY CT_1

if { [string equal $T4V2_T4M2 1] == 1} {
CONNECT T4M2i_EMPTY5 PA_1
CONNECT T4M2i_EMPTY5 RDL_1 BY RDLVIA_1
}
if { [string equal $T2V2_T2M2 1] == 1 } {
CONNECT T2M2i_EMPTY5 PA_1
CONNECT T2M2i_EMPTY5 RDL_1 BY RDLVIA_1
}
if { [string equal $T8V2_T8M2 1] == 1 } {
CONNECT T8M2i_EMPTY5 PA_1
CONNECT T8M2i_EMPTY5 RDL_1 BY RDLVIA_1
}
if { [string equal $T4V1_T4M1 1] == 1 && [string equal $top_metal 1] == 1} {
CONNECT T4M1i_EMPTY5 PA_1
CONNECT T4M1i_EMPTY5 RDL_1 BY RDLVIA_1
}
if { [string equal $T2V1_T2M1 1] == 1 && [string equal $top_metal 1] == 1} {
CONNECT T2M1i_EMPTY5 PA_1
CONNECT T2M1i_EMPTY5 RDL_1 BY RDLVIA_1
}
if { [string equal $T8V1_T8M1 1] == 1 && [string equal $top_metal 1] == 1} {
CONNECT T8M1i_EMPTY5 PA_1
CONNECT T8M1i_EMPTY5 RDL_1 BY RDLVIA_1
}
CONNECT RDL_1 RDLPA2_1
CONNECT PA_1 ALPA_1
CONNECT RDL_1 ALPA_1
CONNECT ALPA_1 MD_1

SETLAYER NMOS_PAD = NMOS INTERACT (NET AREA RATIO NACT_1  MD_IO_PAD > 0) 
SETLAYER PMOS_PAD = PMOS INTERACT (NET AREA RATIO PACT_1  MD_IO_PAD > 0) 


SETLAYER NAA_PAD = NET AREA RATIO NACT_1  MD_IO_PAD > 0 
SETLAYER PAA_PAD = NET AREA RATIO PACT_1  MD_IO_PAD > 0 

SETLAYER PMOS1 = PACT ENCLOSE GATE
SETLAYER NMOS1 = NACT ENCLOSE GATE
SETLAYER NGUARDRING = HOLES NTAP INNER
SETLAYER PGUARDRING = HOLES PTAP INNER
SETLAYER NGUARDHOLE_2 = (HOLES NTAP INNER) ENCLOSE PGUARDRING
SETLAYER PGUARDHOLE_2 = (HOLES PTAP INNER) ENCLOSE NGUARDRING

SETLAYER GATEHV = GATE AND TG 
SETLAYER NGATEHV = NGATE AND TG
SETLAYER PGATEHV = PGATE AND TG
SETLAYER GATEMV = GATE AND DG                          //1.8V or 1.5V
SETLAYER GATELV = GATE NOT INSIDE (DG OR TG)
   
RULECHECK LU_R_2 {
@ Guard ring should be used to surround ACT injector or a group of ACT injectors which are connected to an I/O pad
@ N+ injector must be surrounded by a P+ guard-ring
@ P+ injector must be surrounded by a N+ guard-ring
@ NW/PW pickups rings can be used as guard rings. DRC check the nearest guard-ring which surrounds AA injector or a group of AA injector
 OUTLAYER (((NAA_IO_PAD TOUCH PO) NOT PGUARDRING) NOT INSIDE (LATCHUP OR SRINGBLK)) NOT INSIDE NODRC
 OUTLAYER (((PAA_IO_PAD TOUCH PO) NOT NGUARDRING) NOT INSIDE (LATCHUP OR SRINGBLK)) NOT INSIDE NODRC
}
		
RULECHECK LU_W_1 {
@ Guard-ring width for ACT injector connected to an I/O pad
@ Guard-ring definition please refers to LU.1. >= 0.12um
OUTLAYER (INT ((DONUT NTAP) TOUCH ((HOLES NTAP INNER) ENCLOSE PAA_IO_PAD)) < 0.12 ABUT<90 SINGULAR REGION) NOT INSIDE (OR SRINGBLK LATCHUP NODRC)
OUTLAYER (INT ((DONUT PTAP) TOUCH ((HOLES PTAP INNER) ENCLOSE NAA_IO_PAD)) < 0.12 ABUT<90 SINGULAR REGION) NOT INSIDE (OR SRINGBLK LATCHUP NODRC)
}

VERBATIM {
#IFDEF LU_3_CHECK FAST
}
RULECHECK LU_S_1a {
@ For 0.9/1.2V core N/PMOS ACT connected to an I/O pad
@ Spacing between NMOS and PMOS >= 2.0um
 SETLAYER  X = (NMOS_IO_PAD ENCLOSE GATELV) NOT SRINGBLK
 SETLAYER  Y = (PMOS_IO_PAD ENCLOSE GATELV) NOT SRINGBLK
 SETLAYER  M = (NMOS ENCLOSE GATELV) NOT SRINGBLK
 SETLAYER  N = (PMOS ENCLOSE GATELV) NOT SRINGBLK
 SETLAYER  Z1 = SIZE X BY 1.036 BEVEL 3
 SETLAYER  Z2 = SIZE N BY 1.036 BEVEL 3
 OUTLAYER  (Z1 AND Z2) NOT INSIDE (OR LATCHUP NODRC)   
 SETLAYER   Z3 = SIZE M BY 1.036 BEVEL 3
 SETLAYER   Z4 = SIZE Y BY 1.036 BEVEL 3
 OUTLAYER  (Z3 AND Z4) NOT INSIDE (OR LATCHUP NODRC)
}			
RULECHECK LU_S_1b {
@ LU.3a-LU.3d define minimum space (S1) between NMOS and PMOS with either one of NMOS or PMOS ACT connected to I/O pad. (Fig.1).
@ For 1.8V N/PMOS ACT connected to an I/O pad
@ Spacing between 1.8V NMOS and 1.8V PMOS and Spacing between 1.8V PMOS and 1.8V/Core NMOS. >= 2.3um
 SETLAYER X = NMOS_IO_PAD ENCLOSE GATEMV
 SETLAYER Y = PMOS_IO_PAD ENCLOSE GATEMV
 SETLAYER M = NMOS ENCLOSE (GATELV OR GATEMV)
 SETLAYER N = PMOS ENCLOSE (GATELV OR GATEMV)
  SETLAYER Z1 = SIZE X BY 1.191 BEVEL 3
  SETLAYER Z2 = SIZE N BY 1.191 BEVEL 3
  OUTLAYER ((Z1 AND Z2) NOT SRINGBLK) NOT INSIDE (OR LATCHUP NODRC)
  SETLAYER Z3 = SIZE M BY 1.191 BEVEL 3
  SETLAYER Z4 = SIZE Y BY 1.191 BEVEL 3
  OUTLAYER ((Z3 AND Z4) NOT SRINGBLK) NOT INSIDE (OR LATCHUP NODRC)
}

RULECHECK LU_S_1c {
@ LU.3a-LU.3d define minimum space (S1) between NMOS and PMOS with either one of NMOS or PMOS ACT connected to I/O pad. (Fig.1).
@ For 2.5V N/PMOS ACT connected to an I/O pad
@ Spacing between 2.5V NMOS and 2.5V PMOS and Spacing between 2.5V PMOS and 2.5V/Core NMOS. >= 3.2um
 SETLAYER X = NMOS_IO_PAD ENCLOSE GATEHV
 SETLAYER Y = PMOS_IO_PAD ENCLOSE GATEHV
 SETLAYER M = NMOS ENCLOSE (GATELV OR GATEHV )
 SETLAYER N = PMOS ENCLOSE (GATELV OR GATEHV)
 SETLAYER Z1 = SIZE X BY 1.657 BEVEL 3
 SETLAYER Z2 = SIZE N BY 1.657 BEVEL 3
 OUTLAYER ((Z1 AND Z2) NOT SRINGBLK) NOT INSIDE (OR LATCHUP NODRC)
 SETLAYER Z3 = SIZE M BY 1.657 BEVEL 3
 SETLAYER Z4 = SIZE Y BY 1.657 BEVEL 3
 OUTLAYER  ((Z3 AND Z4) NOT SRINGBLK) NOT INSIDE (OR LATCHUP NODRC)
}

RULECHECK LU_S_1d {
@ For 3.3 V N/PMOS (or 2.5V overdrive 3.3V) ACT connected to an I/O pad
@ Spacing between 3.3V NMOS and 3.3V/0.9V/1.2V PMOS and
@ Spacing between 3.3V PMOS and 3.3V/0.9V/1.2V NMOS. >= 5um
 SETLAYER X = NMOS_IO_PAD ENCLOSE (GATEHV AND OD)
 SETLAYER Y = PMOS_IO_PAD ENCLOSE (GATEHV AND OD)
 SETLAYER M = NMOS ENCLOSE (GATELV OR (GATEHV AND OD))
 SETLAYER N = PMOS ENCLOSE (GATELV OR (GATEHV AND OD))
 #OUTLAYER ((EXT X N < 5 ABUT<90 SINGULAR REGION) NOT SRINGBLK) NOT INSIDE NODRC
 #OUTLAYER ((EXT Y M < 5 ABUT<90 SINGULAR REGION) NOT SRINGBLK) NOT INSIDE NODRC
 SETLAYER  Z1 = SIZE X BY 2.589 BEVEL 3
 SETLAYER  Z2 = SIZE N BY 2.589 BEVEL 3
 OUTLAYER  ((Z1 AND Z2) NOT SRINGBLK) NOT INSIDE (OR LATCHUP NODRC)
 SETLAYER  Z3 = SIZE M BY 2.589 BEVEL 3
 SETLAYER  Z4 = SIZE Y BY 2.589 BEVEL 3
 OUTLAYER  ((Z3 AND Z4) NOT SRINGBLK) NOT INSIDE (OR LATCHUP NODRC)
}
 
VERBATIM {
#ENDIF
}

VERBATIM {
#IFDEF LU_3_CHECK ACCURATE
}
RULECHECK LU_S_1a {
@ LU.3a-LU.3d define minimum space (S1) between NMOS and PMOS with either one of NMOS or PMOS ACT connected to I/O pad. (Fig.1).
@ For core N/PMOS connected to an I/O pad
@ Spacing between NMOS and PMOS. >= 2um
 SETLAYER X = NMOS_IO_PAD ENCLOSE GATELV
 SETLAYER Y = PMOS_IO_PAD ENCLOSE GATELV
 SETLAYER M = NMOS ENCLOSE GATELV
 SETLAYER N = PMOS ENCLOSE GATELV
 OUTLAYER ((EXT X N < 2 ABUT<90 SINGULAR REGION) NOT SRINGBLK) NOT INSIDE (OR LATCHUP NODRC)
 OUTLAYER ((EXT M Y < 2 ABUT<90 SINGULAR REGION) NOT SRINGBLK) NOT INSIDE (OR LATCHUP NODRC)
}

RULECHECK LU_S_1b {
@ LU.3a-LU.3d define minimum space (S1) between NMOS and PMOS with either one of NMOS or PMOS ACT connected to I/O pad. (Fig.1).
@ For 1.8V N/PMOS ACT connected to an I/O pad
@ Spacing between 1.8V NMOS and 1.8V/Core PMOS and Spacing between 1.8V PMOS and 1.8V/Core NMOS. >= 2.3um
 SETLAYER X = NMOS_IO_PAD ENCLOSE GATEMV
 SETLAYER Y = PMOS_IO_PAD ENCLOSE GATEMV
 SETLAYER M = NMOS ENCLOSE (GATELV OR GATEMV)
 SETLAYER N = PMOS ENCLOSE (GATELV OR GATEMV)
 OUTLAYER ((EXT M Y < 2.3 ABUT<90 SINGULAR REGION) NOT SRINGBLK ) NOT INSIDE (OR LATCHUP NODRC)
 OUTLAYER ((EXT X N < 2.3 ABUT<90 SINGULAR REGION) NOT SRINGBLK ) NOT INSIDE (OR LATCHUP NODRC)
}

RULECHECK LU_S_1c {
@ LU.3a-LU.3d define minimum space (S1) between NMOS and PMOS with either one of NMOS or PMOS ACT connected to I/O pad. (Fig.1).
@ For 2.5V N/PMOS ACT connected to an I/O pad
@ Spacing between 2.5V NMOS and 2.5V/Core PMOS and Spacing between 2.5V PMOS and 2.5V/Core NMOS. >= 3.2um
 SETLAYER X = NMOS_IO_PAD ENCLOSE GATEHV
 SETLAYER Y = PMOS_IO_PAD ENCLOSE GATEHV
 SETLAYER M = NMOS ENCLOSE (GATELV OR GATEHV )
 SETLAYER N = PMOS ENCLOSE (GATELV OR GATEHV)
 OUTLAYER ((EXT M Y < 3.2 ABUT<90 SINGULAR REGION) NOT SRINGBLK) NOT INSIDE (OR LATCHUP NODRC)
 OUTLAYER ((EXT X N < 3.2 ABUT<90 SINGULAR REGION) NOT SRINGBLK) NOT INSIDE (OR LATCHUP NODRC)
}

RULECHECK LU_S_1d {
@ LU.3a-LU.3d define minimum space (S1) between NMOS and PMOS with either one of NMOS or PMOS ACT connected to I/O pad. (Fig.1).
@ For 3.3 V N/PMOS ACT (2.5V overdrive) connected to an I/O pad
@ Spacing between 3.3V NMOS and 3.3V/Core PMOS and Spacing between 3.3V PMOS and 3.3V/Core NMOS >= 5.0um.
 SETLAYER X = NMOS_IO_PAD ENCLOSE (GATEHV AND OD)
 SETLAYER Y = PMOS_IO_PAD ENCLOSE (GATEHV AND OD)
 SETLAYER M = NMOS ENCLOSE (GATELV OR (GATEHV AND OD))
 SETLAYER N = PMOS ENCLOSE (GATELV OR (GATEHV AND OD))
 OUTLAYER ((EXT X N < 5 ABUT<90 SINGULAR REGION) NOT SRINGBLK) NOT INSIDE (OR LATCHUP NODRC)
 OUTLAYER ((EXT Y M < 5 ABUT<90 SINGULAR REGION) NOT SRINGBLK) NOT INSIDE (OR LATCHUP NODRC)

}

VERBATIM {
#ENDIF
}
RULECHECK LU_S_2_NTAP {
@ Space (S2) from any point within the Source/Drain region to the nearest pickup ACT region inside the same well for I/O and internal circuits. (Fig.2). 
@ For native device, DRC check the pickup ACT inside the PSUB butted PW area, and PW is still treated as connection by substrate even one NW ring inserted. <= 35um
 SETLAYER NW_MINUS_NTAP_0 = SIZE NTAP BY 5 INSIDE OF NW STEP 0.38 BEVEL 4
 SETLAYER MAYBE_BAD_b = NW NOT NW_MINUS_NTAP_0
 SETLAYER NW_FILTER = NW INTERACT MAYBE_BAD_b
 SETLAYER NW_MINUS_NTAP_1 = NW_MINUS_NTAP_0 AND NW_FILTER
 SETLAYER NW_MINUS_NTAP = SIZE NW_MINUS_NTAP_1 BY 30 INSIDE OF NW_FILTER STEP 0.38 BEVEL 4
 SETLAYER X = PMOS1 AND NW_FILTER
 OUTLAYER ((OUTSIDE EDGE X NW_MINUS_NTAP) NOT INSIDE EDGE SRINGBLK) NOT INSIDE EDGE NODRC
}

RULECHECK LU_S_2_PTAP {
@ Space (S2) from any point within the Source/Drain region to the nearest pickup ACT region inside the same well for I/O and internal circuits.(Fig. 7.3.14-2) 
@ For native device, DRC check the pickup ACT inside the PSUB butted PW area, and PW is still treated as connection by substrate even one NW ring inserted. <= 35um
SETLAYER PW_MINUS_PTAP_0 = SIZE PTAP BY 5 INSIDE OF PW STEP 0.38 BEVEL 4
 SETLAYER MAYBE_BAD_b = PW NOT PW_MINUS_PTAP_0
 SETLAYER PW_FILTER = PW INTERACT MAYBE_BAD_b
 SETLAYER PW_MINUS_PTAP_1 = PW_MINUS_PTAP_0 AND PW_FILTER
 SETLAYER PW_MINUS_PTAP = SIZE PW_MINUS_PTAP_1 BY 30 INSIDE OF PW_FILTER STEP 0.38 BEVEL 4
 SETLAYER X = NMOS1 AND PW_FILTER
 OUTLAYER ((OUTSIDE EDGE X PW_MINUS_PTAP) NOT INSIDE EDGE SRINGBLK) NOT INSIDE EDGE NODRC

 SETLAYER SIZE_REGION = OR PW PSUB NW
 SETLAYER SIZE_PTAP_NOT_DNW = PTAP NOT (DNW NOT INTERACT PSUB) 
 SETLAYER PW_SIZE_a = SIZE SIZE_PTAP_NOT_DNW BY 5 INSIDE OF SIZE_REGION STEP 0.38 BEVEL 4
 SETLAYER MAYBE_BAD_PSUB_a = SIZE_REGION NOT PW_SIZE_a
 SETLAYER PW_FILTER_PSUB_a = SIZE_REGION INTERACT MAYBE_BAD_PSUB_a
 SETLAYER PW_MINUS_PTAP_PSUB_a = PW_SIZE_a AND PW_FILTER_PSUB_a
 SETLAYER PW_SIZE_1 = SIZE PW_MINUS_PTAP_PSUB_a BY 30 INSIDE OF PW_FILTER_PSUB_a STEP 0.38 BEVEL 4
 SETLAYER NMOS_PSUB_a = ((NMOS1 AND PSUB) NOT INTERACT DNW) AND PW_FILTER_PSUB_a
 OUTLAYER ((OUTSIDE EDGE NMOS_PSUB_a PW_SIZE_1) NOT INSIDE EDGE SRINGBLK) NOT INSIDE EDGE NODRC

 SETLAYER SIZE_PTAP_AND_DNW = (PTAP AND (PW INTERACT PSUB)) INTERACT DNW 
 SETLAYER PW_SIZE_b = SIZE SIZE_PTAP_AND_DNW BY 5 INSIDE OF SIZE_REGION STEP 0.38 BEVEL 4
 SETLAYER MAYBE_BAD_PSUB_b = SIZE_REGION NOT PW_SIZE_b
 SETLAYER PW_FILTER_PSUB_b = SIZE_REGION INTERACT MAYBE_BAD_PSUB_b
 SETLAYER PW_MINUS_PTAP_PSUB_b = PW_SIZE_b AND PW_FILTER_PSUB_b
 SETLAYER PW_SIZE_2 = SIZE PW_MINUS_PTAP_PSUB_b BY 30 INSIDE OF PW_FILTER_PSUB_b STEP 0.38 BEVEL 4
 SETLAYER NMOS_PSUB_b = ((NMOS1 AND PSUB) INTERACT DNW) AND PW_FILTER_PSUB_b
 OUTLAYER ((OUTSIDE EDGE NMOS_PSUB_b PW_SIZE_2) NOT INSIDE EDGE SRINGBLK) NOT INSIDE EDGE NODRC

}
VERBATIM {
#ENDIF
}


VERBATIM {
#IFDEF MOM_CHECK YES
}
#//===================================================
#//  MOM design rules
#//===================================================
GROUP GMOM MOM_?

RULECHECK MOM_R_1 {
@ It is not allowed:
@ 1) V1 in M1MOM
@ 2) Vn/Vn-1 in MOMMKn (n = 2~8), whereVn-1 is the via underneath Mn, and Vn is the via above Mn. Vn can be inter-via or T4V1/T2V1 or T4V2/T2V2
for {set i 1} { $i < [expr [llength $v_j] +1 ] } {incr i 1} {
OUTLAYER (V${i} AND M${i}MOM) NOT INSIDE NODRC
OUTLAYER (V${i} AND M[expr ${i} +1]MOM) NOT INSIDE NODRC
set top_inner_mk M[expr ${i} +1]MOM
}
set topvia [lindex $top_v_m_list 0]
OUTLAYER ($topvia AND $top_inner_mk) NOT INSIDE NODRC
}

RULECHECK MOM_S_1 {
@ The space between (Mn AND MOMMKn AND MOMLVS1) and Vn/Vn-1 (n = 1~8) outside of MOMLVS1, whereVn-1 is the via underneath Mn, and Vn is the via above Mn. Vn can be inter-via or T4V1 or T4V2. >= 0.11um
for {set i 1} { $i < [expr [llength $v_j] +1 ] } {incr i 1} {
OUTLAYER (EXT (V${i} OUTSIDE MOMLVS1) ((M${i} AND M${i}MOM) AND MOMLVS1) < 0.11 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
OUTLAYER (EXT (V${i} OUTSIDE MOMLVS1) ((M[expr ${i} +1] AND M[expr ${i} +1]MOM) AND MOMLVS1) < 0.11 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
set top_inner_mk M[expr ${i} +1]MOM
set top_inner_metal M[expr ${i} +1]
}
set topvia [lindex $top_v_m_list 0]
OUTLAYER (EXT ($topvia OUTSIDE MOMLVS1) (($top_inner_metal AND $top_inner_mk) AND MOMLVS1) < 0.11 ABUT<90 SINGULAR REGION) NOT INSIDE NODRC
}

RULECHECK MOM_R_2 {
@ MOMLVS1 and MOMMKn layers are must for MOM device. DRC checking is based on the label text by MOMLVS1 layer. Possible label texts and related MOMMKn follow the Table-1. DRC need flag the stacked MOM structure

set MOMMK_list { M1MOM, M2MOM, M3MOM, M4MOM, M5MOM, M6MOM, M7MOM, M8MOM }
set momcap_list { 12 13 14 15 16 17 18 23 24 25 26 27 28 34 35 36 37 38 45 46 47 48 56 57 58 67 68 78 }

foreach k $momcap_list {
SETLAYER  M1MOM_${k} = M1MOM INTERACT (MOMLVS1 WITH TEXT \"momcap${k}\" MOMLVS1)
SETLAYER  M2MOM_${k} = M2MOM INTERACT (MOMLVS1 WITH TEXT \"momcap${k}\" MOMLVS1)
SETLAYER  M3MOM_${k} = M3MOM INTERACT (MOMLVS1 WITH TEXT \"momcap${k}\" MOMLVS1)
SETLAYER  M4MOM_${k} = M4MOM INTERACT (MOMLVS1 WITH TEXT \"momcap${k}\" MOMLVS1)
SETLAYER  M5MOM_${k} = M5MOM INTERACT (MOMLVS1 WITH TEXT \"momcap${k}\" MOMLVS1)
SETLAYER  M6MOM_${k} = M6MOM INTERACT (MOMLVS1 WITH TEXT \"momcap${k}\" MOMLVS1)
SETLAYER  M7MOM_${k} = M7MOM INTERACT (MOMLVS1 WITH TEXT \"momcap${k}\" MOMLVS1)
SETLAYER  M8MOM_${k} = M8MOM INTERACT (MOMLVS1 WITH TEXT \"momcap${k}\" MOMLVS1)
}

foreach k $momcap_list {
SETLAYER  M1MOM_${k}_no = M1MOM INTERACT (MOMLVS1 NOT WITH TEXT \"momcap${k}\" MOMLVS1)
SETLAYER  M2MOM_${k}_no = M2MOM INTERACT (MOMLVS1 NOT WITH TEXT \"momcap${k}\" MOMLVS1)
SETLAYER  M3MOM_${k}_no = M3MOM INTERACT (MOMLVS1 NOT WITH TEXT \"momcap${k}\" MOMLVS1)
SETLAYER  M4MOM_${k}_no = M4MOM INTERACT (MOMLVS1 NOT WITH TEXT \"momcap${k}\" MOMLVS1)
SETLAYER  M5MOM_${k}_no = M5MOM INTERACT (MOMLVS1 NOT WITH TEXT \"momcap${k}\" MOMLVS1)
SETLAYER  M6MOM_${k}_no = M6MOM INTERACT (MOMLVS1 NOT WITH TEXT \"momcap${k}\" MOMLVS1)
SETLAYER  M7MOM_${k}_no = M7MOM INTERACT (MOMLVS1 NOT WITH TEXT \"momcap${k}\" MOMLVS1)
SETLAYER  M8MOM_${k}_no = M8MOM INTERACT (MOMLVS1 NOT WITH TEXT \"momcap${k}\" MOMLVS1)
}

foreach k $momcap_list {
SETLAYER  MOMLVS1_${k} = MOMLVS1 WITH TEXT \"momcap${k}\" MOMLVS1
SETLAYER  MOMLVS1_${k}_no = MOMLVS1 NOT WITH TEXT \"momcap${k}\" MOMLVS1
}

########## can't be marked with M1MOM
  set momcap_list1 [lrange $momcap_list 7 end]
#RULECHECK T1 {
foreach k $momcap_list1 {
OUTLAYER  (M1MOM AND M1MOM_${k}) NOT SRINGBLK
}
#}

########## can't be marked with M2MOM
  set momcap_list2 [lrange $momcap_list 13 end]
#RULECHECK T2 {
foreach k $momcap_list2 {
OUTLAYER  (M2MOM AND M2MOM_${k}) NOT SRINGBLK
}
#}

########## can't be marked with M3MOM
  set momcap_list3 [lrange $momcap_list 18 end]
#RULECHECK T3 {
OUTLAYER  (M3MOM AND M3MOM_12) NOT SRINGBLK
foreach k $momcap_list3 {
OUTLAYER  (M3MOM AND M3MOM_${k}) NOT SRINGBLK
}
#}

########## can't be marked with M4MOM
set momcap_list4 [lrange $momcap_list 22 end]
#RULECHECK T4 {
OUTLAYER  (M4MOM AND M4MOM_12) NOT SRINGBLK 
OUTLAYER  (M4MOM AND M4MOM_13) NOT SRINGBLK 
OUTLAYER  (M4MOM AND M4MOM_23) NOT SRINGBLK 
foreach k $momcap_list4 {
OUTLAYER  (M4MOM AND M4MOM_${k}) NOT SRINGBLK
}
#}

########## can't be marked with M5MOM
set momcap_list5 [lrange $momcap_list 25 end]
#RULECHECK T5 {
OUTLAYER  (M5MOM AND M5MOM_12) NOT SRINGBLK 
OUTLAYER  (M5MOM AND M5MOM_13) NOT SRINGBLK 
OUTLAYER  (M5MOM AND M5MOM_14) NOT SRINGBLK 
OUTLAYER  (M5MOM AND M5MOM_23) NOT SRINGBLK 
OUTLAYER  (M5MOM AND M5MOM_24) NOT SRINGBLK 
OUTLAYER  (M5MOM AND M5MOM_34) NOT SRINGBLK 
foreach k $momcap_list5 {
OUTLAYER  (M5MOM AND M5MOM_${k}) NOT SRINGBLK
}
#}

########## can't be marked with M6MOM
set momcap_list6 { 12 13 14 15 23 24 25 34 35 45 78 }
#RULECHECK T6 {
foreach k $momcap_list6 {
OUTLAYER  (M6MOM AND M6MOM_${k}) NOT SRINGBLK
}
#}

########## can't be marked with M7MOM
set momcap_list7 { 12 13 14 15 16 23 24 25 26 34 35 36 45 46 56 }
#RULECHECK T7 {
foreach k $momcap_list7 {
OUTLAYER  (M7MOM AND M7MOM_${k}) NOT SRINGBLK
}
#}

########## can't be marked with M8MOM
set momcap_list8 { 12 13 14 15 16 17 23 24 25 26 27 34 35 36 37 45 46 47 56 57 67 }
#RULECHECK T8 {
foreach k $momcap_list8 {
OUTLAYER  (M8MOM AND M8MOM_${k}) NOT SRINGBLK
}
#}
#############################################################################################


########## should be but not be marked with M1MOM
#RULECHECK Y12 {
SETLAYER  X12 = (MOMLVS1_12 INTERACT M1MOM) INTERACT M2MOM
OUTLAYER  (MOMLVS1_12 NOT X12) NOT SRINGBLK
#}

#RULECHECK Y13 {
SETLAYER  X13 = ((MOMLVS1_13 INTERACT M1MOM) INTERACT M2MOM) INTERACT M3MOM
OUTLAYER  (MOMLVS1_13 NOT X13) NOT SRINGBLK
#}

#RULECHECK Y14 {
SETLAYER  X14 = (((MOMLVS1_14 INTERACT M1MOM) INTERACT M2MOM) INTERACT M3MOM) INTERACT M4MOM
OUTLAYER  (MOMLVS1_14 NOT X14) NOT SRINGBLK
#}

#RULECHECK Y15 {
SETLAYER  X15 = ((((MOMLVS1_15 INTERACT M1MOM) INTERACT M2MOM) INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM
OUTLAYER  (MOMLVS1_15 NOT X15) NOT SRINGBLK
#}

#RULECHECK Y16 {
SETLAYER  X16 = (((((MOMLVS1_16 INTERACT M1MOM) INTERACT M2MOM) INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM
OUTLAYER  (MOMLVS1_16 NOT X16) NOT SRINGBLK
#}

#RULECHECK Y17 {
SETLAYER  X17 = ((((((MOMLVS1_17 INTERACT M1MOM) INTERACT M2MOM) INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM) INTERACT M7MOM
OUTLAYER  (MOMLVS1_17 NOT X17) NOT SRINGBLK
#}

#RULECHECK Y18 {
SETLAYER  X18 = (((((((MOMLVS1_18 INTERACT M1MOM) INTERACT M2MOM) INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM) INTERACT M7MOM) INTERACT M8MOM
OUTLAYER  (MOMLVS1_18 NOT X18) NOT SRINGBLK
#}

#RULECHECK Y23 {
SETLAYER  X23 = (MOMLVS1_23 INTERACT M2MOM) INTERACT M3MOM 
OUTLAYER  (MOMLVS1_23 NOT X23) NOT SRINGBLK
#}

#RULECHECK Y24 {
SETLAYER  X24 = ((MOMLVS1_24 INTERACT M2MOM) INTERACT M3MOM) INTERACT M4MOM
OUTLAYER  (MOMLVS1_24 NOT X24) NOT SRINGBLK
#}

#RULECHECK Y25 {
SETLAYER  X25 = (((MOMLVS1_25 INTERACT M2MOM) INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM
OUTLAYER  (MOMLVS1_25 NOT X25) NOT SRINGBLK
#}

#RULECHECK Y26 {
SETLAYER  X26 = ((((MOMLVS1_26 INTERACT M2MOM) INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM
OUTLAYER  (MOMLVS1_26 NOT X26) NOT SRINGBLK
#}

#RULECHECK Y27 {
SETLAYER  X27 = (((((MOMLVS1_27 INTERACT M2MOM) INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM) INTERACT M7MOM
OUTLAYER  (MOMLVS1_27 NOT X27) NOT SRINGBLK
#}

#RULECHECK Y28 {
SETLAYER  X28 = ((((((MOMLVS1_28 INTERACT M2MOM) INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM) INTERACT M7MOM) INTERACT M8MOM
OUTLAYER  (MOMLVS1_28 NOT X28) NOT SRINGBLK
#}

#RULECHECK Y34 {
SETLAYER  X34 = (MOMLVS1_34 INTERACT M3MOM) INTERACT M4MOM
OUTLAYER  (MOMLVS1_34 NOT X34) NOT SRINGBLK
#}

#RULECHECK Y35 {
SETLAYER  X35 = ((MOMLVS1_35 INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM
OUTLAYER  (MOMLVS1_35 NOT X35) NOT SRINGBLK
#}

#RULECHECK Y36 {
SETLAYER  X36 = (((MOMLVS1_36 INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM
OUTLAYER  (MOMLVS1_36 NOT X36) NOT SRINGBLK
#}

#RULECHECK Y37 {
SETLAYER  X37 = ((((MOMLVS1_37 INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM) INTERACT M7MOM
OUTLAYER  (MOMLVS1_37 NOT X37) NOT SRINGBLK
#}

#RULECHECK Y38 {
SETLAYER  X38 = (((((MOMLVS1_38 INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM) INTERACT M7MOM) INTERACT M8MOM
OUTLAYER  (MOMLVS1_38 NOT X38) NOT SRINGBLK
#}

#RULECHECK Y45 {
SETLAYER  X45 = (MOMLVS1_45 INTERACT M4MOM) INTERACT M5MOM
OUTLAYER  (MOMLVS1_45 NOT X45) NOT SRINGBLK
#}

#RULECHECK Y46 {
SETLAYER  X46 = ((MOMLVS1_46 INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM
OUTLAYER  (MOMLVS1_46 NOT X46) NOT SRINGBLK
#}

#RULECHECK Y47 {
SETLAYER  X47 = (((MOMLVS1_47 INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM) INTERACT M7MOM
OUTLAYER  (MOMLVS1_47 NOT X47) NOT SRINGBLK
#}

#RULECHECK Y48 {
SETLAYER  X48 = ((((MOMLVS1_48 INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM) INTERACT M7MOM) INTERACT M8MOM
OUTLAYER  (MOMLVS1_48 NOT X48) NOT SRINGBLK
#}

#RULECHECK Y56 {
SETLAYER  X56 = (MOMLVS1_56 INTERACT M5MOM) INTERACT M6MOM
OUTLAYER  (MOMLVS1_56 NOT X56) NOT SRINGBLK
#}

#RULECHECK Y57 {
SETLAYER  X57 = ((MOMLVS1_57 INTERACT M5MOM) INTERACT M6MOM) INTERACT M7MOM
OUTLAYER  (MOMLVS1_57 NOT X57) NOT SRINGBLK
#}

#RULECHECK Y58 {
SETLAYER  X58 = (((MOMLVS1_58 INTERACT M5MOM) INTERACT M6MOM) INTERACT M7MOM) INTERACT M8MOM
OUTLAYER  (MOMLVS1_58 NOT X58) NOT SRINGBLK
#}

#RULECHECK Y67 {
SETLAYER  X67 = (MOMLVS1_67 INTERACT M6MOM) INTERACT M7MOM
OUTLAYER  (MOMLVS1_67 NOT X67) NOT SRINGBLK
#}

#RULECHECK Y68 {
SETLAYER  X68 = ((MOMLVS1_68 INTERACT M6MOM) INTERACT M7MOM) INTERACT M8MOM
OUTLAYER  (MOMLVS1_68 NOT X68) NOT SRINGBLK
#}

#RULECHECK Y78 {
SETLAYER  X78 = (MOMLVS1_78 INTERACT M7MOM) INTERACT M8MOM
OUTLAYER  (MOMLVS1_78 NOT X78) NOT SRINGBLK
#}

######################################################################################

#########MOMLVS1 not with correspond text

SETLAYER  Z12 = ((MOMLVS1 INTERACT M1MOM) INTERACT M2MOM) NOT INTERACT (OR M3MOM M4MOM M5MOM M6MOM M7MOM M8MOM)
OUTLAYER  (Z12 NOT WITH TEXT \"momcap12\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z13 = (((MOMLVS1 INTERACT M1MOM) INTERACT M2MOM) INTERACT M3MOM) NOT INTERACT (OR M4MOM M5MOM M6MOM M7MOM M8MOM)
OUTLAYER  (Z13 NOT WITH TEXT \"momcap13\" MOMLVS1) NOT SRINGBLK 

SETLAYER  Z14 = ((((MOMLVS1 INTERACT M1MOM) INTERACT M2MOM) INTERACT M3MOM) INTERACT M4MOM) NOT INTERACT (OR M5MOM M6MOM M7MOM M8MOM)
OUTLAYER  (Z14 NOT WITH TEXT \"momcap14\" MOMLVS1) NOT SRINGBLK 

SETLAYER  Z15 = (((((MOMLVS1 INTERACT M1MOM) INTERACT M2MOM) INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM) NOT INTERACT (OR M6MOM M7MOM M8MOM)
OUTLAYER  (Z15 NOT WITH TEXT \"momcap15\" MOMLVS1) NOT SRINGBLK  

SETLAYER  Z16 = ((((((MOMLVS1 INTERACT M1MOM) INTERACT M2MOM) INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM) NOT INTERACT (OR M7MOM M8MOM)
OUTLAYER  (Z16 NOT WITH TEXT \"momcap16\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z17 = (((((((MOMLVS1 INTERACT M1MOM) INTERACT M2MOM) INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM) INTERACT M7MOM) NOT INTERACT M8MOM
OUTLAYER  (Z17 NOT WITH TEXT \"momcap17\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z18 = (((((((MOMLVS1 INTERACT M1MOM) INTERACT M2MOM) INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM) INTERACT M7MOM) INTERACT M8MOM
OUTLAYER  (Z18 NOT WITH TEXT \"momcap18\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z23 = ((MOMLVS1 INTERACT M2MOM) INTERACT M3MOM) NOT INTERACT (OR M1MOM M4MOM M5MOM M6MOM M7MOM M8MOM)
OUTLAYER  (Z23 NOT WITH TEXT \"momcap23\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z24 = (((MOMLVS1 INTERACT M2MOM) INTERACT M3MOM) INTERACT M4MOM) NOT INTERACT (OR M1MOM M5MOM M6MOM M7MOM M8MOM)
OUTLAYER  (Z24 NOT WITH TEXT \"momcap24\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z25 = ((((MOMLVS1 INTERACT M2MOM) INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM) NOT INTERACT (OR M1MOM M6MOM M7MOM M8MOM)
OUTLAYER  (Z25 NOT WITH TEXT \"momcap25\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z26 = (((((MOMLVS1 INTERACT M2MOM) INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM) NOT INTERACT (OR M1MOM M7MOM M8MOM)
OUTLAYER  (Z26 NOT WITH TEXT \"momcap26\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z27 = ((((((MOMLVS1 INTERACT M2MOM) INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM) INTERACT M7MOM) NOT INTERACT (OR M1MOM M8MOM)
OUTLAYER  (Z27 NOT WITH TEXT \"momcap27\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z28 = (((((((MOMLVS1 INTERACT M2MOM) INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM) INTERACT M7MOM) INTERACT M8MOM) NOT INTERACT M1MOM
OUTLAYER  (Z28 NOT WITH TEXT \"momcap28\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z34 = ((MOMLVS1 INTERACT M3MOM) INTERACT M4MOM) NOT INTERACT (OR M1MOM M2MOM M5MOM M6MOM M7MOM M8MOM)
OUTLAYER  (Z34 NOT WITH TEXT \"momcap34\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z35 = (((MOMLVS1 INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM) NOT INTERACT (OR M1MOM M2MOM M6MOM M7MOM M8MOM)
OUTLAYER  (Z35 NOT WITH TEXT \"momcap35\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z36 = ((((MOMLVS1 INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM) NOT INTERACT (OR M1MOM M2MOM M7MOM M8MOM)
OUTLAYER  (Z36 NOT WITH TEXT \"momcap36\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z37 = (((((MOMLVS1 INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM) INTERACT M7MOM) NOT INTERACT (OR M1MOM M2MOM M8MOM)
OUTLAYER  (Z37 NOT WITH TEXT \"momcap37\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z38 = ((((((MOMLVS1 INTERACT M3MOM) INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM) INTERACT M7MOM) INTERACT M8MOM) NOT INTERACT (OR M1MOM M2MOM)
OUTLAYER  (Z38 NOT WITH TEXT \"momcap38\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z45 = ((MOMLVS1 INTERACT M4MOM) INTERACT M5MOM) NOT INTERACT (OR M1MOM M2MOM M3MOM M6MOM M7MOM M8MOM)
OUTLAYER  (Z45 NOT WITH TEXT \"momcap45\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z46 = (((MOMLVS1 INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM) NOT INTERACT (OR M1MOM M2MOM M3MOM M7MOM M8MOM)
OUTLAYER  (Z46 NOT WITH TEXT \"momcap46\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z47 = ((((MOMLVS1 INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM) INTERACT M7MOM) NOT INTERACT (OR M1MOM M2MOM M3MOM M8MOM)
OUTLAYER  (Z47 NOT WITH TEXT \"momcap47\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z48 = (((((MOMLVS1 INTERACT M4MOM) INTERACT M5MOM) INTERACT M6MOM) INTERACT M7MOM) INTERACT M8MOM) NOT INTERACT (OR M1MOM M2MOM M3MOM)
OUTLAYER  (Z48 NOT WITH TEXT \"momcap48\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z56 = ((MOMLVS1 INTERACT M5MOM) INTERACT M6MOM) NOT INTERACT (OR M1MOM M2MOM M3MOM M4MOM M7MOM M8MOM)
OUTLAYER  (Z56 NOT WITH TEXT \"momcap56\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z57 = (((MOMLVS1 INTERACT M5MOM) INTERACT M6MOM) INTERACT M7MOM) NOT INTERACT (OR M1MOM M2MOM M3MOM M4MOM M8MOM)
OUTLAYER  (Z57 NOT WITH TEXT \"momcap57\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z58 = ((((MOMLVS1 INTERACT M5MOM) INTERACT M6MOM) INTERACT M7MOM) INTERACT M8MOM) NOT INTERACT (OR M1MOM M2MOM M3MOM M4MOM)
OUTLAYER  (Z58 NOT WITH TEXT \"momcap58\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z67 = ((MOMLVS1 INTERACT M6MOM) INTERACT M7MOM) NOT INTERACT (OR M1MOM M2MOM M3MOM M4MOM M5MOM M8MOM)
OUTLAYER  (Z67 NOT WITH TEXT \"momcap67\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z68 = (((MOMLVS1 INTERACT M6MOM) INTERACT M7MOM) INTERACT M8MOM) NOT INTERACT (OR M1MOM M2MOM M3MOM M4MOM M5MOM)
OUTLAYER  (Z68 NOT WITH TEXT \"momcap68\" MOMLVS1) NOT SRINGBLK

SETLAYER  Z78 = ((MOMLVS1 INTERACT M7MOM) INTERACT M8MOM) NOT INTERACT (OR M1MOM M2MOM M3MOM M4MOM M5MOM M6MOM)
OUTLAYER  (Z78 NOT WITH TEXT \"momcap78\" MOMLVS1) NOT SRINGBLK
}

VERBATIM {
#ENDIF
}





