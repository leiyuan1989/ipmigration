// *******************************************************************************
// * Calibre DRC COMMAND FILE - CLM25S_4M.211a ( 01/20/2014) *
// * FOR TSMC 0.25UM CMOS LOGIC/MS 1P4M PROCESS (CL025G/E, CM025G, CR025G) *
// * (DRC COMMAND FILE DOCUMENT: T-025-LO-DR-001-C1 Rev 2.11a) *
// * (DESIGN RULE DOCUMENT: T-025-LO-DR-001 Rev. 2.11) *
// *******************************************************************************


//************************************************************************************
//* TSMC developed this deck using Mentor Graphics proprietary SVRF and TVF formats.
//* The deck is to be used only in Calibre tools.
//************************************************************************************
// DISCLAIMER
//
// The information contained herein is provided by TSMC on an "AS IS" basis
// without any warranty, and TSMC has no obligation to support or otherwise
// maintain the information. TSMC disclaims any representation that the
// information does not infringe any intellectual property rights or proprietary
// rights of any third parties. There are no other warranties given by TSMC,
// whether express, implied or statutory, including, without limitation, implied
// warranties of merchantability and fitness for a particular purpose.
//
// STATEMENT OF USE
//
// This information contains confidential and proprietary information of TSMC.
// No part of this information may be reproduced, transmitted, transcribed,
// stored in a retrieval system, or translated into any human or computer
// language, in any form or by any means, electronic, mechanical, magnetic,
// optical, chemical, manual, or otherwise, without the prior written permission
// of TSMC. This information was prepared for informational purpose and is for
// use by TSMC's customers only. TSMC reserves the right to make changes in the
// information at any time and without notice.
//
//-----------------------------------------------------------------------------------
//
// NOTICE: (Read Me First!)
//
// 1. If the input GDS file does not include all the layers in the
// INPUT LAYER BLOCK, for example, they are generated by logic
// operations, please make sure the consistence with original
// layer definition.
// 2. The runset is tested and developed on Calibre v2010.4_26.16 (Dec. 2010),
// please use this or newer TSMC qualified version of Calibre to execute this runset.
//-----------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------
//
// REVISION:
//
// 2.15 08/25/00 tpwang Changed for T-025-LO-DR-001 Ver.2.2;
// Add Guidance for Latch-Up/IO design, Dummy Pad and Power Line
// rules; Modify ESD.S.2, ESD.c.1, ESD.C.4, AMS.1.xx, and wide
// metal check; Rename input layer from "xxI" to "xxi"
//
// 2.16 12/15/00 Kevin Liu Revise checked: LAT.3P, LAT.3N
// 2.17 01/04/01 Kevin Liu Revise checked: LAT.3P, LAT.3N, ESD.O.1, PO.R.2, OD.C.1
// OD2.E.2
// 2.18 03/14/01 Kevin Liu Remove safety check
// Revise checked: OD2.E.2 typo
//-------------------------------------------------------------------------------------
// 2.3a 06/06/2001 Kevin Liu
// 1) Remove all layers V-Notches check
// 2) Remove Fuse rule
// 3) Rule change NP.E.4/PP.E.4
// 4) LAT.3P/LAT.3N new methodology
// 5) Passivation rules
// 2.3b 06/11/2001 Kevin Liu
// 1) Remove Bond Pad checks
// 2.3c 08/08/2001 Kevin Liu & Daniel Yan
// 1) Adding Layer FWI(235) LWI(63 Datetype 2) PMDMY(236)
// 2) Revise derived layer RNGX = PMDMY NOT (CB OR FWI OR LWI)
// 3) Latchup: add data filtering mechanism to avoid long run time and core dump.
// 4) Fix ADP.W.3 error: width 80um is a good pattern
// 5) Remove option INSIDE OF EXTENT in density rule PO.R.3 and Mx.R.1
// 6) Assign all metal and via layers.
//
// 2.3d 11/29/2002 G.S.Chang
// 1) Revised LAT.2 to consider all the active area.
// 2) Enhanced PP.E.1 for rules PP.E.1,2/NP.E.1,2 to highlight the butted edge of IMP with OD.
// 3) Consider dummy metal and slot in metal density and slot rules.
// 4) Add chip-corner and metal slot rules for RDL layers (MD, VIAD)
// 5) Revise Mx.S.2, employ OPPOSITE metrics to the spacing check of the small metal
//
// 2.4a 06/03/2003 Yating Chuang
// 1) Revise PO.R.2, fix false error from sizing step.
// 2) Revise PO.I.1, PP and NP overlap is not allow.
// 3) Revise NWR.O.1, remove inside NWELL. Add check overlap of RPO to NP.
// 4) Add NWR.E.3, consider extension of NP beyond NPOD in NW resistor under STI.
// 5) Relax butted edges between active and pickup for OD2.E.1.
// 6) Enhanced all ESD rules with recognizations of ESD devices by dummy layers
// instead of the pad connection.
// 7) Revise CO/VIA.W.1: add option ORTHOGONAL ONLY.
// 8) Revise Mx.S.2 with more exactly edge checking.
// 9) Change layer name : change N_ACT to NPOD(N+imp OD),N_ACT_PW
// to NACT(N+imp active),same as P_ACT(PPOD) and P_ACT_NW(PACT).
// 10) Modified the definition of RDL pad area for metal slot exclusion.
//
// 2.4b 07/13/2004 C.T.Yao, Yating Chuang
// 1) Add option "OPPOSITE" in PP.C.2/NP.C.2.
// 2) Add OD.R.1.WARN to check OD without implant.
// 3) Modify the checking methodology of the rule Mx.S.2 for checking exactly.
// 4) Add ADP.R.0D, CO/VIA1/VIA3 and VIA2/VIA4/VIAD should not overlap in power line structure.
// 5) Add ADP.E.3, min. extension of OD over CO.
// 6) Remove false errors in ESD.5a and ESD.5c.
// 7) Add RLPP.WARN to check RLPPDMY interact OD.
// 8) Replace OVERLAP, INSIDE ALSO, OUTSIDE ALSO options with AND, NOT, CUT, INSIDE EDGE operations.
//
// 2.4c.pre 11/29/2004 C.T.Yao
// 1) Add ESD.C.5, check overlap of ESD and PPOD.
// 2) Add ESD.5d, check wrong RPO pattern.
// 3) Create switch CHECK_SRAM_EXCL to check M2 and upward layers inside layer EXCL also.
// 4) Create switch CHECK_ALL to check all layers inside layer EXCL also.
//
// 2.5a_pre 03/28/06 Y.M. Zhang
// 1) Add NP.R.1 and PP.R.1
// 2) Modify RPO.C.4, RPO.C.5
// 3) Add A.R.11
//
// 2.5a1 03/30/06 Y.M. Zhang
// 1) Modify NP.R.1 and PP.R.1 to fix false errors
// 2) Remove OD.R.WARN.
// 3) Modify PO.I.1 to fix false errors
// 2.5b 05/19/06 Y.M. Zhang
// 1) Add layer DNW
// 2.5c 06/26/06 Y.M. Zhang
// 1) Add layer DPO and layer DOD
// 2) Add DPO.R.warn and DOD.R.warn
// 3) Modify PO.R.3.Logic , Change POLYi to ALL_POLY
// 4) Add MD and VIAD rules follow MT and VIAT.
// 2.5d 03/20/07 Y.M. Zhang
// 1) Modify metal slot code with design rule
// 2) Modify PO.I.1 to fix false errors.(select po interact co)
// 2.5e 07/20/07 Y.M. Zhang
// 1) Modify PP.C.2,PP.E.2,NP.C.2,NP.E.2,PO.R.2
// 2) Modify Rules comment to align design rule.
// 3) Change AM.W.1 to AM.W.3 to align design rule
// 2.5f 01/29/08 M.Feng, Y.M. Zhang
// 1) Add layers PPI,LOGO,REST
// 2) Change the definition of the OD&POLY resistior according the REST
// 3) Add the CTM2 & CTM3, and modify the connectivity of the metal
// 4) Change the writing of the wide metal space
// 5) Change the writing of the ESD.C.2
// 6) Change the definition of the M1 & VIA1
// 7) Change the writing of the MD density rule
//-----------------------------------------------------------------------------------
// 2.6a 09/15/2009 S.Q. Zhang
//
// Merge the following design rules into T-025-LO-DR-001.
// 1) C025 logic 2.5V/5V design rule (T-025-LO-DR-002)
// 2) C025 logic 2.5V design rule (T-025-LO-DR-004)
// 3) C025 logic 2.5V/3.3V design rule (T-025-LO-DR-005)
// 4) C025 mixed signal 2.5V/5V design rule (T-025-MM-DR-001)
// 5) C025 mixed signal 2.5V/3.3V design rule (T-025-MM-DR-002)
//
// 1) Newly added rules: NWR.R.2,NWR.R.3,NWR.R.4,NWR.R.5,M1.E.3R,VIAX.E.3R,MX.E.3R,
// logo rules, a new structure for ESD device, RLPP.WARN,
// DNW.S.2 for MM process, 2VN rules and 3VN.C.5 for CE025
// Add MD/VIAD rules for CE025 process.
// 2) Removed rules: AM.W.3, OD.W.1a/NT_N.W.3 for 5V process,
// RPO.C.9/PO.S.2/ for MM process, MD/VIAD rule check for UTM,
// ESD implent rules for single gate oxide 2.5V process
// 3) Rule name changed: N2V.X.X-->2VN.X.X, N3V.X.X-->3VN.X.X, N5V.X.X-->5VN.X.X,
// NT_N.I.X-->NT_N.R.X, CTM.I.X-->CTM.R.X, DNW.I.X-->DNW.R.X,
// M5.X.X-->Mn.X.X, M5T.X.X-->UTM.X.X, PO.S.3.Logic-->PO.S.3,
// PO.R.3.Logic-->PO.R.3, RPO.C.5.Logic-->RPO.C.5,
// PO.W.1A_PO.W.2B_PO.W.3-->PO.W.1_PO.W.2_PO.W.3,PO.W.1A1-->PO.W.1a/b,
// PO.R.3.Logic-->PO.R.3, PO.S.3.Logic-->PO.S.3,PO.W.2B1-->PO.W.2a/b,
// 4) Change rule description: NW.W.1,PP.E.4/NP.E.4 for LO process,RPO.C.3,CO.W.1,
// VIAX.W.1, NT_N.R.5/ CTM.S.4/ CTM.S.5 for MM process,
// NWR.R.1 for single gate oxide 2.5V process
// 5) Rule value changed: ESD.9 is changed to ESD.11 (from 0.8 to 0.75 for 5v process),
// LAT.3( from 15 to 20 for single gate oxide 2.5V process)
//
// 2.6b 01/25/2010 Y. Li
// 1) Change the writing of NP.E.4 to fix false errors
// 2) Change rule comments of NP.E.4 and NP.E.4_MM to align with design rule
// 3) Add a new switch "#DEFINE 2.5V" and change usage of "#DEFINE 2.5V_3.3V"
// and "DEFINE 2.5V_5V" accordingly.
// 4) Divide the waring rule "WARN.VOLTAGE_1" into three waring rules WARN.VOLTAGE_1a/b/c
// according to the switch change.
//
// 2.7a 09/10/2010 R.H. Zhang
// 1) Add CM025 2.5V/5V GPIIA technology into T-025-LO-DR-001, and the switch "#DEFINE GPIIA" for it.
// 2) Add new switch "#DEFINE THICK_30K" and UTM30K rules chapter for 30KA top metal thickness option.
// 3) Modify switch "#DEFINE THICK_TOP_METAL" to "#DEFINE THICK_15K" and rename UTM.X.X rules to UTM15K.X.X.
// 4) Add and modify warning rules for GPIIA process.
// 5) Add new rules: RES.1, VIAn.S.3~5, LPP.R.3, NT_N.W.3b, PO.W.10, VTMN.W.2b, VTMP.W.2b, UTM30K rules chapter and BJT recommendation rules chapter.
// 6) Modify rule writing: PP.E.2, PO.W.6, CTM.R.7.
// 7) Modify rule name: NT_N.W.3 to NT_N.W.3a.
// 8) Copy rule chapter: VTMN, VTMP, VTDN, VTDP. (i.e. VTMN.X.X to VTMN.X.Xa) for GPIIA process.
//
// 2.8a 01/30/2011 R.H. Zhang
// 1) Add rule PO.W.6b, UTM15K.W.1b and UTM15K.S.1b for GPIIA process.
// 2) change rule name: PO.W.6-->PO.W.6a, UTM15K.W.1-->UTM15K.W.1a and UTM15K.S.1-->UTM15K.S.1a for GPIIA process.
// 3) add warning rule: WARN.GPIIA_1d for GPIIA process to forbid PIP option.
//
// 2.9a 04/30/2012 J.Y. Zou
// 1) Add rule VIAx.E.4, RES.2, RES.3, RES.4, RES.5, UTM30K.W.2, DRM.R.1
// 2) Remove rule RES.1
//
// 2.10a 01/18/2013 L.Huang
// 1) Add rules: RES.HRI.1, RES.HRI.7, RES.HRI.8, RES.HRI.10, RES.HRI.11, RES.HRI.13
// 2) Remove rules: UTM30K.W.2
// 3) Modify rules VIAn.W.1, VIAD.W.1 to waive BondPad region
// 4) Modify CTM.R.6 to only check RF-2T MIM
//
// 2.11a 01/20/2014 Franky Chen
// 1) Add rules: CO.R.3, CB.W.1, AN.R.39, AN.R.40
// 2) Waive rules in sealring region: PP.E.1, PP.E.2, NP.E.1, RPO.E.1, RPO.C.4
//-----------------------------------------------------------------------------------
//
// CURRENT STATUS
//
// RULES NOT IMPLEMENTED:
//
// The following rules are not coded in this rule file:
//
// rule description/explanation/alternate file
// ------------------------ ----------------------------------------------------
// Part I recommendations Not coded (page 3 of spec.)
//
// Antenna rules Please refer to antenna DRC deck.
//
// Seal ring rules not coded.
//
// Latch up Guideline Only 2 & 3 implemented.
//
// IO ESD Protection Only 5, 6, 9, 11, 23, 24, 25, 26, 27, 32 implemented.
// Guideline
//
// PO/OD resistor guidelines not coded
/////////////////////////////////////////////////////////////////////////////////

//************************************************************
// Dummy layer descriptions
// ************************************************************
//
// 1) HOTWL- Hot N-Well
// N-Well not connected to the most positive
// voltage Vdd is defined as Hot N-Well. It
// must follow different width and space rules
// from the N-Well connected to Vdd (Cold N-
// Well). Use "HOTWL" layer to exactly cover
// the Hot N-Well area for correct N-Well DRC.
//
// 2) EXCL - unDRC area
// If there's any area with different rules
// and not to be checked in this run, use the
// "EXCL" layer to exactly cover the area to
// be excluded.
//
// 3) SDI - I/O ESD Protection Circuit
// For I/O guidance rule checking, use "SDi"
// layer to designate the ESD area to checked.
// The whole ESD devices should be covered by
// "SDI".
//
// 4) RWDMY- NWell Resistor
// The N-Well region covered by both RWDMY and
// RPO is the NW within OD resistor.
// The N-Well region covered by only RWDMY is
// the NW under STI resistor.
// 5) DRCDMY- TSMC reserved layer
// DRCDMY2 For internal usage of TSMC, please don't use
// this layer.
//
// 6) DPDMY - Dummy Pad area
// For chip corner dummy pad, use "DPDMY" layer to
// exactly cover dummy pad area.
//
// 7) PLDMY - Power Line
// For chip corner power line, use "PLDMY" layer to
// cover whole power line area.
//
// 8) PLMIi - Fuse structure dummy layer
// Use "PLMIi" layer to cover fuse window and
// protection ring structure
// 9) WBDMY - dummy layer to cover the CUP pad
//
////////////////////////////////////////////////////////////
// CORRECT USAGE:
////////////////////////////////////////////////////////////
//
// * To correctly use this DRC deck, the following settings are very important in
// this DRC command file:
//
// (0) Calibre v2010.4_26.16 (Dec. 2010) is used to develop and QA this command file.
// Please execute the DRC with this or newer TSMC qualified version of Calibre.
//
//************************************************************************************
// This drc deck can be used to do check for C025 process as below:
//
// 1) C025 logic 2.5V/3.3V process (CL025G)
// 2) C025 logic 2.5V/5V process (CL025G)
// 3) C025 logic 2.5V process (CL025G)
// 4) C025 logic 2.5V/3.3V process (CL025E)
// 5) C025 mixed signal 2.5V/5V process (CM025G)
// 6) C025 mixed signal 2.5V/3.3V process (CM025G/CR025G)
//
// Note: The default of this DRC command file is for 0.25um logic 2.5V/3.3V(general purpose) design rule
// you can turn on/off relted switch correctly if other process are used,.
//
//
// Note: CM025 2.5V/5V provide GP (general purpose) and GPIIA (general purpose II analog) process.
// If you use GPIIA process, you should turn on the switch "#DEFINE GPIIA".
//
//
//**************************************************************************************************
//
// There are some MUST switchs and OPTIONAL switchs in this drc deck. You must keep
// MUST switch turn on or trun off correctly. Otherwise, you could not check drc correctly.
// As to OPTIONAL switch, you can turn on/off according to you requirement.
// The default of this DRC command file is for 0.25um logic 2.5V/3.3V(general purpose) design rule
//
// MUST switch:
//
// #DEFINE 2.5V_3.3V // turn on only for 2.5V core device and 3.3V I/O device process, otherwise please turn off it.
// //#DEFINE 2.5V_5V // turn on only for 2.5V core device and 5.0V I/O device process, otherwise please turn off it.
// //#DEFINE 2.5V // turn on only for single gate oxide of 2.5V core device process, otherwise please turn off it.
//
// //#DEFINE MIX_MODE // turn on only when you use Mixed-Singal process, otherwise please turn off it
// //#DEFINE GPIIA // turn on only when you use CM025 2.5V/5V GPIIA process, otherwise please turn off it
// //#DEFINE THICK_15K // turn on only when 15KA Thick Top Metal is used. otherwise please turn off it
// //#DEFINE THICK_30K // turn on only when 30KA Thick Top Metal is used. otherwise please turn off it
//
// *** please be noticed that if "THICK_15K" or "THICK_30K" is turned on, you must turn on "MIX_MODE" at the same time. ***
// *** And 30K Thick Top Metal is only offered in GPIIA process, this means "GPIIA" must be turned on when "THICK_30K" is turned on.***
// *** At last, you must turn off "THICK_15K" and "THICK_30K" when you use logic process. ***
//
// OPTIONAL switch:
//
// //#DEFINE CHECK_SRAM_EXCL // turn on when M2 and upward layers in SRAM region covered by EXCL are checked.
// #DEFINE CHECK_DUMMY_ODPO // turn off when Dummy OD&PO are not checked.
// //#DEFINE RECOMMEND // turn on when Recommended rules are checked.
// //#DEFINE CHECK_ALRDL // turn on when MD&VIAD rules are checked
//
//********************************************************************************************************************
//
// (1) Variable for voltage(gate oxide) select:
// By default, dual gate oxide for 2.5V core device and 3.3V I/O device process is selected as follow:
//
// #DEFINE 2.5V_3.3V
// //#DEFINE 2.5V_5V
// //#DEFINE 2.5V
//
// if you use dual gate oxide for 2.5V core device and 5V I/O device process, pls selecte the option as follow:
//
// //#DEFINE 2.5V_3.3V
// #DEFINE 2.5V_5V
// //#DEFINE 2.5V
//
// if you use single gate oxide for 2.5V core device process, pls selecte the option as follow:
//
// //#DEFINE 2.5V_3.3V
// //#DEFINE 2.5V_5V
// #DEFINE 2.5V
//
// (2) Variable for Mixed-Signal circuit design:
//
// By default, this DRC deck is used for LOGIC design, if you use Mixed-Signal design,
// Please remove // for the option of "#DEFINE MIX_MODE" as follow:
//
// #DEFINE MIX_MODE
//
// (3) Variable for CM025 2.5V/5V GPIIA process :
//
// By default, this DRC deck is not for GPIIA process, if you use CM025 2.5V/5V GPIIA process,
// Please remove // for the option of "#DEFINE GPIIA" as follow:
//
// #DEFINE GPIIA
//
// Please be noticed that GPIIA process if only offered in CM025 2.5V/5V
// This means you must turn on #DEFINE MIX_MODE and #DEFINE 2.5V_5V when you turn on #DEFINE GPIIA.
//
// (4) Variable for check Thick metal
//
// By default, we do not check the ultra thick top metal. If customer uses 15KA thick top metal,
// please remove "//" in front of "#DEFINE THICK_15K" and add "//" in front of "#DEFINE THICK_30K" as following:
//
// #DEFINE THICK_15K
// //#DEFINE THICK_30K
//
// If customer uses 30KA thick top metal, please remove "//" in front of "#DEFINE THICK_30K" and
// add "//" in front of "#DEFINE THICK_15K" to switch the options.
//
// //#DEFINE THICK_15K
// #DEFINE THICK_30K
//
// Please be noticed that THICK_30K is only used in GPIIA process. This means you must turned on GPIIA when turn on THICK_30K.
//
// (5) variable for check SRAM inside layer EXCL:
//
// By default, we exclude DRC check inside SRAM region covered by exclude layer "EXCL(55)".
// However, customers could enable this option to check M2 and upward layers inside EXCL
// in order to check logic rules inside SRAM.
// Please notice that turn on this option will also disable the waiving function of EXCL,
// and the region covered by EXCL will be examined with M2 and upward layers' rules.
// Please un-comment the line below to enable this function:
//
// #DEFINE CHECK_SRAM_EXCL
//
// (6) Variable for dummy OD&PO rule checking:
//
// By default, dummy OD&PO are checked by rules in this deck. But some unnecessary rule
// checks may induce false alarm. If dummy OD&PO are not required to check, please
// add "//" in front of "#DEFINE CHECK_DUMMY_ODPO" to disable this option:
//
// //#DEFINE CHECK_DUMMY_ODPO
//
// (7) Variable for RECOMMEND rule checking:
//
// By default, recommend rules are not checked in this deck. If recommend rules needed to
// be checked, pls remove the "//" in front of "#DEFINE RECOMMEND" to enable this option.
//
// #DEFINE RECOMMEND
//
// (8) Variable for MD&VIAD rule checking:
//
// By default, MD&VIAD rules are checked in this deck. If MD&VIAD rules are not required
// to check, please add // to disable this option:
//
// //#DEFINE CHECK_ALRDL
//
////////////////////////////////////////////////////////////
//******************
// OPTION SETUP
//******************
//#DEFINE 2.5V_3.3V // turn on only when 2.5V core device and 3.3V I/O device used, othersize,turn off it.
//#DEFINE 2.5V_5V // turn on only when 2.5V core device and 5.0V I/O device used, othersize,turn off it.
#DEFINE 2.5V // turn on only for single gate oxide of 2.5V core device process, otherwise, turn off it.
//#DEFINE CHECK_SRAM_EXCL // turn on the switch when check M2 and upward layers in SRAM
// region covered by EXCL, othersize, turn off it.
//#DEFINE MIX_MODE // turn on only when you use Mixed-Singal process. otherwise please turn off it.
//#DEFINE GPIIA // turn on only when you use CM025 2.5V/5V GPIIA process. otherwise please turn off it.
//#DEFINE THICK_15K // turn on the switch when 15KA ultra thick top metal used, othersize, turn off it.
//#DEFINE THICK_30K // turn on the switch when 30KA ultra thick top metal used, othersize, turn off it.
#DEFINE CHECK_DUMMY_ODPO // turn on the switch when dummy OD&PO are required to check, othersize, turn off it.
#DEFINE CHECK_ALRDL // turn on only when you want check MD&VIAD rules. otherwise please turn off it.
//#DEFINE RECOMMEND // turn on only when you want check RECOMMEND rules. otherwise please turn off it.




//
// ENVIRONMENT SETUP
//------------------
PRECISION 1000
RESOLUTION 10 // layout grid size 0.01um

LAYOUT SYSTEM GDSII
LAYOUT PATH    "/project/d2da1/user/chois/gdsii/d2da1/d2da1_ioesd.gds"
//cksum: 964588088
LAYOUT PRIMARY    "d2da1_ioesd"

//////////////////////////////////////////////////////////////////////////////////
////////////////    SOLOMON SYSTECH LIMITED INTERNAL USE ONLY    /////////////////
//////////////////////////////////////////////////////////////////////////////////
//                                                                            	//
//==============================================================================//
// SSL Proprietary Data                                                       	//
// Project       : d2da1(d2da1)
// Author        : chois
// Last modified : Mar 24, 2014
//===================================================================================//
// Version : 5.0 (Mar 24, 2014)
// Revision History : initial release
//====================================================================================//
// Version : 4.0 (Mar 24, 2014)
// Revision History : initial release
//====================================================================================//
// Version : 3.0 (Mar 13, 2014)
// Revision History : initial release
//====================================================================================//
// Version : 2.0 (Feb 26, 2014)
// Revision History : initial release
//====================================================================================//
// Version : 1.0 (Feb 26, 2014)
// Revision History : initial release
//====================================================================================//

// --------------------------------------------
// 	DRC include file definition
// --------------------------------------------

//Input a include file to define VARIABLE POWER_6V_NAME for UMC 6V devices checking.
//VARIABLE 	POWER_6V_NAME 			// 6V power for UMC 0.13um +-16V

// -------------------------------------------------------------------------------
// End of DRC include file definition


// --------------------------------------------
// 	LVS include file definition
// --------------------------------------------

//You must add a text file which contain the variable <GPSUB_NAME> and <ISODNW_NAME> 
//for the item <include file path> to check the connectivity of Global P-substrate
//and ISO-DNW. Otherwise, you will miss the checking of those connection
VARIABLE 	GROUND_NEG_POWER	"VSS" 			// GROUND_NEG  power
VARIABLE 	ESD_POWER 	"VDD" "VSS" 			// ESD power
VARIABLE 	LU_POWER 	"VDD" "VSS" 			// LU  power
VARIABLE 	ERC_POWER 	"VDD" "VSS" 			// ERC power
VARIABLE 	GPSUB_POWER 	"VSS" 			// P-Sub  power
VARIABLE 	ISODNW_POWER 	"VSS" 			// ISODNW power
// -------------------------------------------------------------------------------
// End of LVS include file definition


// --------------------------------------------
// 	Extra Latch-up include file definition
// --------------------------------------------
//VARIABLE 	POS3D6V_NAME 			// 3.6V  Voltage definition for UMC 0.28um process
//VARIABLE 	POS13D5V_NAME 			// 13.5V Voltage definition for UMC 0.28um process
//VARIABLE 	POS5V_NAME 			// 5V  Voltage definition for UMC 0.5um process
//VARIABLE 	POS33V_NAME 			// 33V Voltage definition for UMC 0.5um process
//VARIABLE 	POS40V_NAME 			// 40V  Voltage definition for SMIC 0.16um +-20V process/ UMC 0.35um 40V process
//VARIABLE 	POS20V_NAME 			// 20V  Voltage definition for SMIC 0.16um +-20V process/ UMC 0.35um 40V process
//VARIABLE 	POS3D3V_NAME 			// 3.3V Voltage definition for SMIC 0.16um +-20V process/ UMC 0.35um 40V process
//VARIABLE 	NEG20V_NAME 			// -20V Voltage definition for SMIC 0.16um +-20V process
//VARIABLE 	POS6V_NAME 			// 6V   Voltage definition for SMIC 0.16um +-20V process
//VARIABLE 	POS4D4V_NAME 			// 4.4V Voltage definition for SMIC 0.16um +-20V process
//VARIABLE 	POS1D8V_NAME 			// 1.8V Voltage definition for SMIC 0.16um +-20V process
// -------------------------------------------------------------------------------
// End of Extra Latch-up include file definition


// --------------------------------------------
// 	Power Via Check include file definition
// --------------------------------------------
//VARIABLE	POWER_NAME1	""		// 
//VARIABLE	POWER_NAME2	""		// 
//VARIABLE	POWER_NAME3	""		// 
//VARIABLE	POWER_NAME4	""		// 
//VARIABLE	POWER_NAME5	""		// 
//VARIABLE	POWER_NAME6	""		// 
//VARIABLE	POWER_NAME7	""		// 
//VARIABLE	POWER_NAME8	""		// 
//VARIABLE	POWER_NAME9	""		// 
//VARIABLE	POWER_NAME10	""		// 
//VARIABLE	POWER_NAME11	""		// 
//VARIABLE	POWER_NAME12	""		// 
//VARIABLE	POWER_NAME13	""		// 
//VARIABLE	POWER_NAME14	""		// 
//VARIABLE	POWER_NAME15	""		// 
//VARIABLE	POWER_NAME16	""		// 
//VARIABLE	POWER_NAME17	""		// 
//VARIABLE	POWER_NAME18	""		// 
//VARIABLE	POWER_NAME19	""		// 
//VARIABLE	POWER_NAME20	""		// 
//VARIABLE	POWER_NAME21	""		// 
//VARIABLE	POWER_NAME22	""		// 
//VARIABLE	POWER_NAME23	""		// 
//VARIABLE	POWER_NAME24	""		// 
//VARIABLE	POWER_NAME25	""		// 
//VARIABLE	POWER_NAME26	""		// 
//VARIABLE	POWER_NAME27	""		// 
//VARIABLE	POWER_NAME28	""		// 
//VARIABLE	POWER_NAME29	""		// 
//VARIABLE	POWER_NAME30	""		// 
//VARIABLE	POWER_NAME31	""		// 
//VARIABLE	POWER_NAME32	""		// 
//VARIABLE	POWER_NAME33	""		// 
//VARIABLE	POWER_NAME34	""		// 
//VARIABLE	POWER_NAME35	""		// 
//VARIABLE	POWER_NAME36	""		// 
//VARIABLE	POWER_NAME37	""		// 
//VARIABLE	POWER_NAME38	""		// 
//VARIABLE	POWER_NAME39	""		// 
//VARIABLE	POWER_NAME40	""		// 
//VARIABLE	POWER_NAME41	""		// 
//VARIABLE	POWER_NAME42	""		// 
//VARIABLE	POWER_NAME43	""		// 
//VARIABLE	POWER_NAME44	""		// 
//VARIABLE	POWER_NAME45	""		// 
//VARIABLE	POWER_NAME46	""		// 
//VARIABLE	POWER_NAME47	""		// 
//VARIABLE	POWER_NAME48	""		// 
//VARIABLE	POWER_NAME49	""		// 
//VARIABLE	POWER_NAME50	""		// 
// --------------------------------------------
//      Gold bump PAD Variables
// --------------------------------------------
// --------------------------------------------
//      PAD Variables
// --------------------------------------------
VARIABLE VAL_PAD_METW	5			// Minimum width of metal connect to PAD
// --------------------------------------------
//      Wire bond PAD Variables
// --------------------------------------------
VARIABLE VAL_PAD_WIREBOND_3	66			// Min. width of SSL Layer 9 (wire bond)
VARIABLE VAL_PAD_WIREBOND_4	2			// Min. extension from Top Metal to SSL Layer 9 (wire bond)
VARIABLE VAL_PAD_WIREBOND_5	80			// Min. PAD pitch of SSL Layer 9 (wire bond)
VARIABLE VAL_PAD_WIREBOND_6	0.64			// Min. Spacing from Pad Via to SSL Layer 9 (wire bond)
VARIABLE VAL_PAD_WIREBOND_7	2.64			// Min. extension from Pad Via to PAD Metal for wire bond
// --------------------------------------------
//      IFDEF definition
// --------------------------------------------

//Input a #DEFINE definition to define/ not define related DRC checking:

#DEFINE         TSMC	 	// To define foundry				(CSM/FUJITSU/GSMC/HHNEC/MAGNACHIP/MAXCHIP/POWERCHIP/SMIC/SSL/UMC/TSMC)
#DEFINE         L250_BCD		// To define technology				(L90/L110/L130/L135/L150/L160/L162/L180/L200/L250/L250_BCD/L280/L300/L350/L500/L600/L800/L1000)
#DEFINE         1P		// To define how many poly 			(1P/2P/3P)
#DEFINE         4M		// To define how many metal 			(2M/3M/4M/5M/6M/7M/8M/9M/10M)
#DEFINE         NO_AL		// To define use AL metal or not
#DEFINE         MIM_3M_4M	// To define MIM Metal option			(MIM_1M_2M/MIM_2M_3M/MIM_3M_4M/MIM_2M_5M//MIM_5M_6M/MIM_6M_7M/MIM_7M_8M/MIM_8M_9M/MIM_9M_10M)
#DEFINE         OptionC		// To define which type of P-sub generation	(OptionA/OptionB/OptionC)
#DEFINE         SEN_OPTION_A		// To define which type of sensitive signal check	(SEN_OPTION_A/SEN_OPTION_B/SEN_OPTION_C)
#DEFINE 		NON_GOLD_BUMP		// To define gold bump project
#DEFINE 		WIRE_BOND		// To define wire bond project
#DEFINE 		NO_SYSESD		// To define System ESD apply
#DEFINE 		NOT_10K		// To define System ESD requirement 10K
#DEFINE 		NOT_15K		// To define System ESD requirement 15K
#DEFINE 		WITH_IP		// To define this project contain IP
#DEFINE 		CONN_GPSUB_MET		// If CONN_GPSUB_MET, then psub connect to it, otherwise connect to sealring

//autoGen_v1.53





// top level run


DRC RESULTS DATABASE    "/localtmp/calibre/chois/d2da1/d2da1/d2da1_ioesd/logic_foundry/DRC_RES.db" 
DRC SUMMARY REPORT    "/localtmp/calibre/chois/d2da1/d2da1/d2da1_ioesd/logic_foundry/calibre_drc.sum" HIER
DRC CHECK TEXT ALL
DRC MAXIMUM RESULTS ALL

FLAG OFFGRID YES // For layout grid check. default grid value is resolution size
FLAG ACUTE YES
FLAG SKEW YES
FLAG NONSIMPLE YES

LAYOUT PROCESS BOX RECORD YES


VARIABLE NW_W_1 1.2
VARIABLE NW_W_2 3.0
VARIABLE NW_S_1 2.0
VARIABLE NW_S_2 0.6
VARIABLE OD_W_1_2 0.3
VARIABLE OD_W_3 0.5
VARIABLE OD_S_1 0.4
VARIABLE OD_C_1 0.15
VARIABLE OD_C_2_3 0.6
VARIABLE OD_E_2 0.6
VARIABLE OD_C_4 0.6
VARIABLE OD_C_5 0.15
VARIABLE RPO_W_1 0.6
VARIABLE RPO_S_1 0.6
VARIABLE RPO_C_1 0.3
VARIABLE RPO_C_2 0.3
VARIABLE RPO_C_3 0.3
VARIABLE RPO_C_4 0.3
VARIABLE RPO_E_1 0.3
VARIABLE RPO_C_5 0.3
VARIABLE RPO_A_1 2.0
VARIABLE RPO_O_1 0.3
VARIABLE RPO_C_6 0.3
VARIABLE PO_W_1_2_3 0.24
VARIABLE PO_W_1a 0.50
VARIABLE PO_W_2a 0.50
VARIABLE PO_S_1 0.40
VARIABLE PO_S_2 0.36
VARIABLE PO_C_1 0.14
VARIABLE PO_C_2 0.40

VARIABLE PO_O_1 0.30
VARIABLE PO_W_4 0.60
VARIABLE PO_W_5 0.60
VARIABLE PO_L_1 1.0
VARIABLE PO_L_2 1.0
VARIABLE PO_S_4 0.56
VARIABLE PO_S_5 0.56
VARIABLE PO_W_7 1.20
VARIABLE PO_W_8 1.20
VARIABLE PO_W_9 2.00
VARIABLE PP_W_1 0.44
VARIABLE PP_S_1 0.44
VARIABLE PP_C_1 0.26
VARIABLE PP_C_2 0.14
VARIABLE PP_C_3 0.32
VARIABLE PP_C_4 0.32
VARIABLE PP_O_1 0.32
VARIABLE PP_E_1 0.26
VARIABLE PP_E_2 0.04
VARIABLE PP_E_4 0.26
VARIABLE RES_2_W 2.0
VARIABLE RES_2_Nsq 5.0
VARIABLE RES_4_W 2.0
VARIABLE RES_4_Nsq 5.0
VARIABLE RES_HRI_7 0.26
VARIABLE RES_HRI_13a 0.3
VARIABLE RES_HRI_13b 0.3
VARIABLE RES_HRI_13c 0.3
VARIABLE VIA2_E_4 0.09
VARIABLE VIA3_E_4 0.09
VARIABLE VIA4_E_4 0.09
VARIABLE NT_N_W_3b 1.6
VARIABLE VTMN_W_2b 0.8
VARIABLE VTMP_W_2b 0.8
VARIABLE BJT_O_1 0.3
VARIABLE BJT_E_1 0.3
VARIABLE BJT_R_3R 3.0
VARIABLE BJT_R_4R 3.0
VARIABLE BJT_R_5R 2.0
VARIABLE BJT_R_6R 2.0
VARIABLE RES_1R_W 2.0
VARIABLE RES_1R_NSQ 5.0
VARIABLE PO_W_6_NSQ 5.0
VARIABLE PO_W_10_W 2.0
VARIABLE PO_W_10_NSQ 5.0







// DRAWN LAYER DEFINITIONS
LAYER NWELLi 2 // nwell technology
LAYER DIFFi 3 // active areas
LAYER PDIFFi 11 // active areas
LAYER NDIFFi 12 // active areas
LAYER OD2i 4 // define thick gate oxides
LAYER POLYi 13 // polysilicon gates, interconnect
LAYER N2Vi 61 // 2.5V LDD implant
LAYER N3Vi 5 // 3.3V LDD implant
LAYER N5Vi 6 // 5V LDD implant
LAYER PPi 7 // P+ S/D imlant
LAYER NPi 8 // N+ S/D imlant
LAYER COi 15 // Define connect for M1 to S/D and Gate
LAYER M1i 16 // First Metal layer
LAYER VIA1i 17 // Define connect for M2 to M1
LAYER M2i 18 // Second Metal layer
LAYER VIA2i 27 // Define connect for M3 to M2
LAYER M3i 28 // Third Metal layer
LAYER VIA3i 29 // Define connect for M4 to M3
LAYER M4i 31 // Fourth Metal layer
LAYER VIADi 167 // VIAD Connection of MD and MT for RDL
LAYER MDi 168 // MD For RDL interconnection
LAYER CBi 19 // Passivation opening for Bond Pad
LAYER CB2i 1691 // Passivation-2 opening for Bond Pad
LAYER MAP 169 DATATYPE 1 1691
LAYER CBDi 169 // CBD For solder Bump and RDL layer
LAYER UBMi 170 // UBM For solder Bump and RDL layer
LAYER PPIi 189 // Post passivation RDL layer
LAYER ESDi 30 // ESD implant layer
LAYER RPOi 34 // Silicided Block Layer
LAYER LOGO 200
//
// Dummy Layers
//

LAYER HTWL 51 // Hot N-Well
LAYER RWDMY 52 // Nwell resistor dummy layer
LAYER EXCLi 55 // Exclude layer
LAYER DPDMY 65 // DPDUMMY (Dummy Pad)
LAYER PLDMY 66 // PLDUMMY (Power Line)
LAYER DRCDMY 60 // DRC waiver (TSMC reserved layer)
LAYER DRCDMY2 130 // TSMC internal used dummy layer
LAYER PLMIi 89 // polymide ( if drawn )
LAYER SDI 58 // IO ESD region dummy layer
LAYER FWI 235 // Fuse window when x, (x+1) = 3
LAYER PMDMY 236 // dummy layer to cover fuse window and protection ring structure
LAYER VARDMY 138 // dummy layer to cover varactor device
LAYER WBDMY 183 // dummy layer to cover the CUP pad

LAYER BJTDMY 49
LAYER DIODMY 37 56

LAYER DPO 364 // dummy POLY layer
LAYER MAP 13 DATATYPE 1 364
LAYER DOD 365 // dummy OD layer
LAYER MAP 3 DATATYPE 1 365
LAYER ODBLK 1350 // DOD blocking for insertion
LAYER MAP 150 DATATYPE 20 1350
LAYER POBLK 1351 // DPO blocking for insertion
LAYER MAP 150 DATATYPE 21 1351

// LWI layer
LAYER LWI 363 // L target window for bump process
LAYER MAP 63 DATATYPE 2 363
LAYER CTMDMY 131 // Cover metal as a capacitor bottom plate
LAYER REST 54 // Poly/OD resistor dummy layer
LAYER HR400DMY 541
LAYER MAP 54 DATATYPE 1 541
LAYER HR1KDMY 542
LAYER MAP 54 DATATYPE 2 542
LAYER HR3KDMY 543
LAYER MAP 54 DATATYPE 3 543
LAYER RLDMY 133 // low Poly resistor dummy layer
LAYER RHDMY 132 // high Poly resistor dummy layer
LAYER RLPPDMY 134 // LPP high Poly resistor dummy layer
LAYER VTMPi 23 // blocking region of PMOS VT implantation
LAYER VTMNi 24 // blocking region of NMOS VT implantation
LAYER VTDPi 25 // VTD_P implantation
LAYER VTDNi 26 // VTD_N implantation
LAYER NTNi 129 // Native NMOS blocked implantation
LAYER CTPi 14 // capacitor top poly-Si
LAYER BPIi 20 // capacitor bottom plate implantation.
LAYER LPPi 48 // lightly P+ Po1 implantation.
LAYER INDDMY 139 // dummy layer to define inductor region
LAYER DNWi 82 // deep NWELL
LAYER MAP 182 DATATYPE 11 18211
LAYER MATCHING 18211
LAYER RFDUMMY 158 // dummy layer to define RF device
//
// Capacitor Top Metal Layers
//
LAYER CTMi 67
LAYER MAP 67 DATATYPE 1 256
LAYER CTM1i 256 // Capacitor Top Metal-1
LAYER MAP 67 DATATYPE 2 257
LAYER CTM2i 257 // Capacitor Top Metal-2
LAYER MAP 67 DATATYPE 3 258
LAYER CTM3i 258 // Capacitor Top Metal-3
LAYER MAP 67 DATATYPE 4 259
LAYER CTM4i 259 // Capacitor Top Metal-4
//
// Dummy Metal layers & Metal SLot layers
//
LAYER M1DMY 316
LAYER MAP 16 DATATYPE 1 316 //Mapping (16:1) to 316 for M1DMY
LAYER M1SLOTi 321 // Metal1 slot (if drawn)
LAYER MAP 16 DATATYPE 2 321 //Mapping (16:2) to 321 for M1SLOTi
LAYER M2DMY 318
LAYER MAP 18 DATATYPE 1 318 //Mapping (18:1) to 318 for M2DMY
LAYER M2SLOTi 322 // Metal2 slot (if drawn)
LAYER MAP 18 DATATYPE 2 322 //Mapping (18:2) to 322 for M2SLOTi
LAYER M3DMY 328
LAYER MAP 28 DATATYPE 1 328 //Mapping (28:1) to 328 for M3DMY
LAYER M3SLOTi 323 // Metal3 slot (if drawn)
LAYER MAP 28 DATATYPE 2 323 //Mapping (28:2) to 323 for M3SLOTi
LAYER M4DMY 331
LAYER MAP 31 DATATYPE 1 331 //Mapping (31:1) to 331 for M4DMY
LAYER M4SLOTi 324 // Metal4 slot (if drawn)
LAYER MAP 31 DATATYPE 2 324 //Mapping (31:2) to 324 for M4SLOTi
LAYER MDDMY 344 // Dummy MD
LAYER MAP 168 DATATYPE 1 344 // Mapping (168;1) to 344 for MDDMY
LAYER MDSLOTi 343 // MD slot (if drawn)
LAYER MAP 168 DATATYPE 2 343 // Mapping (168;2) to 343 for MDSLOTi

LAYOUT TOP LAYER M1i VIA1i M1SLOTi M1DMY
LAYOUT TOP LAYER M2i VIA2i M2SLOTi M2DMY
LAYOUT TOP LAYER M3i VIA3i M3SLOTi M3DMY
LAYOUT TOP LAYER MDi VIADi MDSLOTi MDDMY M4i M4SLOTi CBi
M1x = ( M1i OR M1DMY ) NOT M1SLOTi
M2x = ( M2i OR M2DMY ) NOT M2SLOTi
M3x = ( M3i OR M3DMY ) NOT M3SLOTi
M4x = ( M4i OR M4DMY ) NOT M4SLOTi
MDx = ( MDi OR MDDMY ) NOT MDSLOTi
/////////////////////////////////////////////////////////////////////////////////

// GLOBAL DERIVED LAYERS FOR RULE CHECKS
//--------------------------------------
CHIP = EXTENT
CHIPx = MERGE CHIP
BULK = SIZE CHIP BY 1.0

EXCL = EXCLi NOT LOGO
#IFDEF CHECK_SRAM_EXCL
EXCL_S = CHIP NOT BULK // an empty layer to disable the usage of EXCL
#ELSE
EXCL_S = COPY EXCL // EXCL_S = EXCL
#ENDIF

PWELLi = BULK NOT NWELLi

PWELL =PWELLi NOT INSIDE EXCL

NWELL = NWELLi NOT INSIDE EXCL
OD2 = OD2i NOT EXCL
N2V = N2Vi NOT EXCL
N3V = N3Vi NOT EXCL
N5V = N5Vi NOT EXCL
PP = PPi NOT INSIDE EXCL
NP = NPi NOT INSIDE EXCL
CO = COi NOT EXCL
M1 = M1x NOT INSIDE EXCL
VIA1 = VIA1i NOT INSIDE EXCL
M2 = M2x NOT INSIDE EXCL_S
VIA2 = VIA2i NOT INSIDE EXCL_S
M3 = M3x NOT INSIDE EXCL_S
VIA3 = VIA3i NOT INSIDE EXCL_S
M4 = M4x NOT INSIDE EXCL_S
VIAD = VIADi NOT INSIDE EXCL_S
MD = MDx NOT INSIDE EXCL_S
ESD = ESDi NOT EXCL_S
RPO = RPOi NOT EXCL
CB = CBi NOT EXCL_S
PLMI = PLMIi NOT EXCL_S
FW = FWI NOT EXCL_S
LW = LWI NOT EXCL_S

ODi = (DIFFi OR PDIFFi) OR NDIFFi
NRODi = ( ODi NOT RPOi ) NOT REST
NPODi = NPi AND NRODi
PPODi = PPi AND NRODi
NONWRi = NWELLi NOT INTERACT RWDMY
NTAPi = NPODi AND NONWRi
PTAPi = PPODi NOT NWELLi
PACTi = PPODi AND NONWRi
NACTi = NPODi NOT NWELLi
PSDi = PACTi NOT POLYi
NSDi = NACTi NOT POLYi

PORES_DMY = ((REST OR RLDMY ) OR RHDMY ) OR RLPPDMY
ILP1i = (POLYi NOT RPOi ) NOT PORES_DMY

CHIP_CORE = SIZE CHIP BY -10
PADH = HOLES CB
SCORE = CHIP_CORE INSIDE PADH
SR_CHIP = CHIP INTERACT SCORE
SR = SR_CHIP NOT (SIZE SR_CHIP BY -10)
SR_CB = CB AND SR
SR_CO = CO AND SR
SR_V1 = VIA1 AND SR
SR_V2 = VIA2 AND SR
SR_V3 = VIA3 AND SR
SR_VD = VIAD AND SR

#IFDEF CHECK_DUMMY_ODPO
OD = (ODi OR DOD) NOT EXCL
POLY = (POLYi OR DPO) NOT EXCL
#ELSE
OD = ODi NOT EXCL
POLY = POLYi NOT EXCL
#ENDIF

DNW = DNWi NOT INSIDE EXCL
NTN = NTNi NOT EXCL
CTP = CTPi NOT EXCL
BPI = BPIi NOT EXCL
LPP = LPPi NOT EXCL
VTMP = VTMPi NOT EXCL
VTMN = VTMNi NOT EXCL
VTDP = VTDPi NOT EXCL
VTDN = VTDNi NOT EXCL

CTM2 = CTM2i NOT EXCL_S
CTM3 = CTM3i NOT EXCL_S
CTM4 = CTM4i NOT EXCL_S

RNWEL = NWELL CUT RWDMY // NWELL resistor (UNDER OD & STI)
HOT_NWELL = (NWELL AND HTWL) OR RNWEL // Derive hot NWELL
COLD_NWELL = NWELL NOT HOT_NWELL // Derive cold NWELL

RWi = PWELLi INSIDE DNWi
RW = PWELL INSIDE DNW

ALL_OD = ODi OR DOD
ALL_POLY = POLYi OR DPO
POLY_ISO = POLY NOT OD
ILP1 = POLY_ISO NOT RPO

CO_DIFF = CO OUTSIDE POLY_ISO
CO_POLY = CO NOT OUTSIDE POLY_ISO

NWRES = RNWEL INTERACT RPO // NWELL resistor (UNDER OD)
NONWR = NWELL NOT INTERACT RWDMY // NWEL exclude resistor area
ODWR = OD INTERACT NWRES // OD area of NW resistor
NPWR = NP INTERACT NWRES // N+ implant on NW resistor terminals
COWR = CO_DIFF INTERACT NWRES // Contact on NW resistor terminals
RHWR = ODWR NOT RPO // Non-Silicided area of NW resistor

NPOD = NP AND OD
PPOD = PP AND OD

OD_PW = OD OUTSIDE NONWR // split up od into two well regions
OD_NW = OD NOT OUTSIDE NONWR // check to see about diff crossing nwell edge!!
NTAP = NPOD AND NONWR
NACT = NPOD NOT NWELL // remove nact in nwres

PTAP = PPOD NOT NWELL
PACT = PPOD AND NWELL
DACT = NACT OR PACT

PP_BEDGE = PP INSIDE EDGE OD // PP edge to form/abut butted tap
NP_BEDGE = NP INSIDE EDGE OD // NP edge to form/abut butted tap
BUTT_PTAP = PTAP TOUCH NACT
NONB_PTAP = PTAP NOT TOUCH NACT
BUTT_NTAP = NTAP TOUCH PACT
NONB_NTAP = NTAP NOT TOUCH PACT

PGATE = POLY AND PACT
NGATE = POLY AND NACT
GATE = POLY AND OD
ALL_GATE = PGATE OR NGATE

GATE_W = POLY INSIDE EDGE OD
GATE_L = OD INSIDE EDGE POLY
PGATE_W = PGATE COIN INSIDE EDGE GATE_W
NGATE_W = NGATE COIN INSIDE EDGE GATE_W

PMOS = ( PPOD INTERACT ALL_GATE ) INTERACT COi
// INTERACT COi to filter out filler cell
NMOS = ( NPOD INTERACT ALL_GATE ) INTERACT COi
// INTERACT COi to filter out filler cell
PASD = PMOS NOT ALL_GATE // all P+ s/d
NASD = NMOS NOT ALL_GATE // all N+ s/d
EPSD = SDI AND PASD // esd P+ s/d
ENSD = SDI AND NASD // esd N+ s/d
EPMOS = SDI AND PMOS
ENMOS = SDI AND NMOS

EXGATE_NP = SIZE ((SIZE NGATE BY 0.02) AND OD) BY 0.3
EXGATE_PP = SIZE ((SIZE PGATE BY 0.02) AND OD) BY 0.3
2V_ACTIVE = OD AND N2V
N2V_EDGE = N2V INSIDE EDGE OD

3V_ACTIVE = OD AND N3V
N3V_EDGE = N3V INSIDE EDGE OD
5V_ACTIVE = OD AND N5V
N5V_EDGE = N5V INSIDE EDGE OD

HVN_GOX = NPOD AND OD2
HVP_GOX = PPOD AND OD2
HV_NGATE_W = GATE_W INSIDE EDGE HVN_GOX
LV_NGATE_W = GATE_W NOT INSIDE EDGE HVN_GOX
HV_PGATE_W = GATE_W INSIDE EDGE HVP_GOX
LV_PGATE_W = GATE_W NOT INSIDE EDGE HVP_GOX
RPO_NOT_SDI = RPO NOT SDI
PORES = POLY_ISO AND RPO_NOT_SDI // non-silicided poly resistor
FOD = (OD OUTSIDE RWDMY) OUTSIDE ALL_GATE
ODRES = ( FOD AND RPO_NOT_SDI ) NOT BJTDMY // OD resistor region

IMP = PP OR NP

FUSE_LTARGET_WINDOW = (CB OR FW) OR LW
RNGX = PMDMY NOT FUSE_LTARGET_WINDOW
//FUSE = CB AND PLMI
//RNGX = PLMI NOT FUSE



BUTLP = LPP TOUCH NACT
NP_OVP_LPP = NP AND LPP



/////////////////
//Define BJT
/////////////////
NPN_BJT = ( NPOD INTERACT RPO ) AND BJTDMY
PNP_BJT = ( PPOD INTERACT RPO ) AND BJTDMY
BJT_E = NPN_BJT OR PNP_BJT
BJT_RPO = RPO INTERACT BJT_E



//*************************************************************************************
//
// warning messages to check whether some switchs are used corretly or not.
//
//*************************************************************************************
//======================================================================================
// 1. Process selection warning.
//======================================================================================
#IFNDEF MIX_MODE
WARN.PROCESS_1 { @ MIX_MODE switch should be turned on for Mixed Singal/RF process

PIP = (LPPi OR BPIi) OR CTPi
VT_L = (((VTMPi OR VTMNi) OR VTDPi) OR VTDNi) OR NTNi
MM_LAYERS = ((( CTMDMY OR INDDMY ) OR DNWi ) OR PIP) OR VT_L
CHIP INTERACT MM_LAYERS
}
#ENDIF

//======================================================================================
// 2. Voltage selection warning.
//======================================================================================

#IFDEF 2.5V
#IFDEF 2.5V_3.3V
WARN.VOLTAGE_1a { @ Only one HIGH_VOLTAGE can be specified every time.
COPY CHIP
}
#ENDIF
#ENDIF
#IFDEF 2.5V
#IFDEF 2.5V_5V
WARN.VOLTAGE_1b { @ Only one HIGH_VOLTAGE can be specified every time.
COPY CHIP
}
#ENDIF
#ENDIF
#IFDEF 2.5V_3.3V
#IFDEF 2.5V_5V
WARN.VOLTAGE_1c { @ Only one HIGH_VOLTAGE can be specified every time.
COPY CHIP
}
#ENDIF
#ENDIF


#IFDEF 2.5V
WARN.VOLTAGE_2 { @OD2/N3V/N5V/N2V could not used for 2.5v process
HV_LAYERS = ((OD2 OR N3V) OR N5V) OR N2V
CHIP INTERACT HV_LAYERS
}
#ENDIF


#IFDEF MIX_MODE
#IFDEF 2.5V
WARN.VOLTAGE_3 { @ mix-mode process not provide 2.5v single gate oxide.
COPY CHIP
}
#ENDIF
#ENDIF



//======================================================================================
// 3. Thick top metal selection warning
//======================================================================================
#IFNDEF MIX_MODE
#IFDEF THICK_15K
WARN.THICK_1 { @ UTM 15K only provide for MM/RF process,
@ Other processes are not provided in this design rule.
COPY CHIP
}
#ENDIF
#ENDIF
#IFNDEF GPIIA
#IFDEF THICK_30K
WARN.THICK_2 { @ UTM 30K only provide for CM025 2.5V/5V GPIIA process,
@ Other processes are not provided in this design rule.
COPY CHIP
}
#ENDIF
#ENDIF

#IFDEF THICK_15K
#IFDEF THICK_30K
WARN.THICK_3 { @ Only one kind of top metal thickness is allowed on one chip.
COPY CHIP
}
#ENDIF
#ENDIF


//======================================================================================
// 4. VTMN/VTMP/VTDN/VTDP warning
//======================================================================================
#IFDEF MIX_MODE
#IFNDEF GPIIA
#IFNDEF 2.5V_3.3V
WARN.IMP_1 { @ VTMN/VTMP/VTDN/VTDP only provide for MM/RF 2.5V_3.3V process and CM025 2.5V/5V GPIIA process,
@ Other processes are not provided in this design rule.
VT_IMP = ((VTMPi OR VTMNi) OR VTDPi) OR VTDNi
CHIP INTERACT VT_IMP
}
#ENDIF
#ENDIF
#ENDIF
//======================================================================================
// 5. ESD warning
//======================================================================================
#IFDEF 2.5V
WARN.ESD_1 { @ ESD can not be used for 2.5v single gate oxide process.
CHIP INTERACT ESDi
}
#ENDIF

//======================================================================================
// 6. GPIIA process warning
//======================================================================================
#IFDEF GPIIA
#IFNDEF 2.5V_5V
WARN.GPIIA_1a { @ GPIIA process is only provided in CM025 2.5V/5V, please set the right voltage switch.
COPY CHIP
}
#ENDIF
#IFNDEF MIX_MODE
WARN.GPIIA_1b { @ GPIIA process is only provided in CM025 2.5V/5V, please turn on MIX_MODE.
COPY CHIP
}
#ENDIF
WARN.GPIIA_1d { @ PiP is not allowed in GPIIA process
CHIP INTERACT CTP
CHIP INTERACT BPI
}
#ENDIF
#IFNDEF GPIIA
WARN.GPIIA_1c { @ HRI 1K and 3K resistor is only allowed in CM025 2.5V/5V GPIIA process,please check your design.
CHIP INTERACT ( HR1KDMY OR HR3KDMY )
}
#ENDIF

RLPP.WARN { @ RLPPDMY overlap OD is not allowed
RLPPDMY AND OD
}


// NWELL CHECKS
//=============
CONNECT NTAPi NWELLi
CONNECT NTAPi DNWi
CONNECT PTAPi RWi
CONNECT PTAPi PWELLi
CONNECT NTAPi PSDi
CONNECT PTAPi NSDi
POLY_CONT = COi AND ( POLYi NOT CTPi)
CONNECT M1x ILP1i BY POLY_CONT
CONNECT M1x NTAPi PTAPi PSDi NSDi BY COi


CONNECT M1x M2x BY VIA1i
//Exclude the via upon CTM region
VIA2t = VIA2i NOT INTERACT CTM2i
VIA2c = VIA2i AND CTM2i
CONNECT M2x M3x BY VIA2t
CONNECT M3x CTM2i BY VIA2c
//Exclude the via upon CTM region
VIA3t = VIA3i NOT INTERACT CTM3i
VIA3c = VIA3i AND CTM3i
CONNECT M3x M4x BY VIA3t
CONNECT M4x CTM3i BY VIA3c
CONNECT M4x MDx BY VIADi

NW.W.1 { @ Minimum NWELL width >= 1.20um
INT NWELL < 1.20 ABUT < 90 SINGULAR REGION
}
NW.W.2 { @ Minimum hot NWELL width >= ^NW_W_2 um
INT HOT_NWELL < NW_W_2 ABUT < 90 SINGULAR REGION
}

// using HTWL mark layer and connectivity for nwell spacing
NW.S.1 { @ Minimum different potential NWELL space >= ^NW_S_1 um
NWEL_NODAL = STAMP NWELL BY NWELLi
EXT NWEL_NODAL < NW_S_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
EXT RNWEL < NW_S_1 SINGULAR REGION ABUT < 90 // NWELL as resistor
EXT RNWEL NWELL < NW_S_1 ABUT < 90 SINGULAR REGION
}
NW.S.2 { @ Minimum same potential NWELL space >= ^NW_S_2 um
EXT NWELL < NW_S_2 SINGULAR REGION ABUT < 90
}




// NWELL (within OD) RESISTOR CHECKS
//====================================

NWR.E.1 {@ Minimum extension of OD to NW>= 1.0um
ENC NWRES ODWR < 1.0 ABUT<90 SINGULAR REGION
NWRES CUT ODWR
}
NWR.E.2 {@ Minimum extension of salicide NW to CO>= 0.3um
ENC COWR NWRES < 0.3 ABUT<90 SINGULAR REGION
COWR CUT NWRES
}
NWR.C.1 {@ Minimum clearance from RPO to related NW>=0.3um
ENC NWRES RHWR < 0.3 ABUT<90 REGION SINGULAR
}
NWR.C.2 {@ Minimum clearance from RPO to related OD>= 0.3um
ENC ODWR RPO < 0.3 ABUT<90 SINGULAR REGION
}
NWR.C.3 {@ Minimum clearance from RPO to CO in RPO hole>= 0.3um
ENC COWR RHWR < 0.3 ABUT<90 SINGULAR REGION
COWR CUT RHWR
}
NWR.O.1 {@ Minimum overlap of RPO to NP>=0.4um
INT NPWR RPO < 0.4 ABUT < 90 SINGULAR REGION
X = RPO INTERACT NWRES
H = HOLES X INNER
H NOT NPWR
}


#IFDEF 2.5V
NWR.R.1a {@ P+/N+ implant inside NW resistance region is not allowed.
RWDMY AND NPOD
RWDMY AND PPOD
}
#ENDIF


#IFDEF 2.5V_3.3V
NWR.R.1b {@ LDD(2VN/3VN) and P+/N+ implant inside NW resistance region is not allowed.
RWDMY AND NPOD
RWDMY AND PPOD
RWDMY AND 2V_ACTIVE
RWDMY AND 3V_ACTIVE
}
#ENDIF


#IFDEF 2.5V_5V
NWR.R.1c {@ LDD(2VN/5VN) and P+/N+ implant inside NW resistance region is not allowed.
RWDMY AND NPOD
RWDMY AND PPOD
RWDMY AND 2V_ACTIVE
RWDMY AND 5V_ACTIVE
}
#ENDIF


NWR.R.2{@ Only one NW inside NWROD is allowed in one OD.
A = ODWR INTERACT (NWRES AND ODWR)>1
NWRES INTERACT A
}
NWR.R.3{@ Only two NPS in NWROD is allowed in one od.
A = ODWR INTERACT (NP INTERACT NWRES) > 2
B = ODWR INTERACT (NP INTERACT NWRES) < 2
C = A OR B
NP INTERACT C
ODWR NOT INTERACT ( NP INTERACT NWRES)
}
RPONWR_H = HOLES RPO INNER
NWR.R.4 { @ ONLY TWO RPO HOLES IN NWROD ARE ALLOWED.
C = ODWR INTERACT RPONWR_H > 2
D = ODWR INTERACT RPONWR_H < 2
A = C OR D
B = ODWR NOT INTERACT RPONWR_H
RPONWR_H INTERACT (A OR B)
}
NWR.R.5 { @ DRC can flag no OD space for NW has parallel length > 0
A = (EXT NWRES < 5 OPPOSITE REGION NOTCH) NOT NWRES
A INSIDE ODWR
}
NWRES_STI = RNWEL NOT NWRES // NWEL resistor (UNDER STI)
ODWR_STI = OD INTERACT NWRES_STI
NPWR_STI = NP INTERACT NWRES_STI
NWR.E.3 { @ Min. extension of NP to OD (NWEL resistor under STI) >=0.26um
ENC ODWR_STI NPWR_STI < 0.26 ABUT < 90 SINGULAR REGION
ODWR_STI NOT NPWR_STI
}




// OD CHECKS
//==============
OD.W.1_OD.W.2 { @ Minimum active width, transistor and interconnect >= ^OD_W_1_2 um
INT OD < OD_W_1_2 SINGULAR ABUT < 90 REGION
}
OD.W.3 { @ Butting OD edge with one segment >= ^OD_W_3 um
A = LENGTH PP_BEDGE >= OD_W_3 // Gets edges segments that are OK
B = EXPAND EDGE PP_BEDGE // Create polygon from separate edges
INSIDE BY 0.004 // by expanding toward tap and extending
EXTEND BY 0.004 // endpoints by small database unit.
B NOT WITH EDGE A // All edges not including an OK edge
C = LENGTH NP_BEDGE >= OD_W_3
D = EXPAND EDGE NP_BEDGE
INSIDE BY 0.004
EXTEND BY 0.004
D NOT WITH EDGE C
}
OD.S.1_OD.S.2NB { @ Minimum active spacing >= ^OD_S_1 um
// OD.S.2 for Non-Butting case
EXT OD < OD_S_1 ABUT < 90 SINGULAR REGION
}
OD.S.2 { @ Min. N+OD to P+OD >= 0um
NPOD AND PPOD
}
OD.C.1{ @ NWELL olap n active tie down >= ^OD_C_1 um
ENC NPOD NONWR < OD_C_1 SINGULAR ABUT <90 REGION
NPOD CUT NONWR
}
OD.C.2_OD.C.3{ @ Minimum nwell to n+ active spacing >= ^OD_C_2_3 um
EXT NPOD NONWR < OD_C_2_3 SINGULAR ABUT <90 REGION
NPOD CUT NONWR
}
OD.C.4{ @ NWELL olap p active >= ^OD_C_4 um
ENC PPOD NONWR < OD_C_4 SINGULAR ABUT <90 REGION
PPOD CUT NONWR
}
OD.C.5{ @ NWELL space to p active tie >= ^OD_C_5 um
EXT PPOD NONWR < OD_C_5 SINGULAR ABUT <90 REGION
PPOD CUT NONWR
}
OD.R.warn { @ DOD overlap with POLY or OD is not allowed
DOD AND POLYi
DOD AND ODi
}

// OD.S.2I -- By Definition butted diffs are spaced 0.00 apart
// OD.C.6 is taken care of by PP/NP.C.3




// OD2 CHECKS
//===============

#IFDEF 2.5V_3.3V
OD2.E.1 { @ Minimum OD2 olap OD >= 0.45um
// This only applies to active OD
CHECK_EDGE_N = ENC [NACT] OD2 < 0.45 SINGULAR ABUT <90
CHECK_EDGE_N NOT COIN OUTSIDE EDGE PTAP
CHECK_EDGE_P = ENC [PACT] OD2 < 0.45 SINGULAR ABUT <90
CHECK_EDGE_P NOT COIN OUTSIDE EDGE NTAP
OD2 INSIDE DACT // OD2 totally inside OD
Y = DACT INTERACT OD2
Z = Y NOT OD2
Z OUTSIDE ALL_GATE
}
OD2.S.1 { @ Minimum OD2 spacing >= 0.45um
// Merge if space < 0.45 um
EXT OD2 < 0.45 SINGULAR ABUT <90 REGION
}
OD2.C.1 { @ Minimum clearance between an active
@ OD region and an OD2 region>= 0.45um
EXT OD2 NACT < 0.45 SINGULAR ABUT <90 REGION
EXT OD2 PACT < 0.45 SINGULAR ABUT <90 REGION
}
OD2.C.2 { @ Minimum OD2 space to gate >= 0.56um
A = OD2 INSIDE EDGE DACT
EXT A GATE_W < 0.560 ABUT <90
}
OD2.E.2 { @ Minimum enclosure of gate by OD2 >= 0.56um
OD2_BEDGE = OD2 INSIDE EDGE OD
ENC GATE_W OD2_BEDGE < 0.560 ABUT <90
HVGT = ALL_GATE AND OD2
HVGT TOUCH EDGE OD2
ALL_GATE CUT OD2
}
#ENDIF

#IFDEF 2.5V_5V
OD2.E.1a { @ Minimum OD2 olap OD >= 0.45um
// This only applies to active OD
CHECK_EDGE_N = ENC [NACT] OD2 < 0.45 SINGULAR ABUT <90
CHECK_EDGE_N NOT COIN OUTSIDE EDGE PTAP
CHECK_EDGE_P = ENC [PACT] OD2 < 0.45 SINGULAR ABUT <90
CHECK_EDGE_P NOT COIN OUTSIDE EDGE NTAP
OD2 INSIDE DACT // OD2 totally inside OD
Y = DACT INTERACT OD2
Z = Y NOT OD2
Z OUTSIDE ALL_GATE
}
OD2.S.1a { @ Minimum OD2 spacing >= 0.45um
// Merge if space < 0.45 um
EXT OD2 < 0.45 SINGULAR ABUT <90 REGION
}
OD2.C.1a { @ Minimum clearance between an active
@ OD region and an OD2 region>= 0.45um
EXT OD2 NACT < 0.45 SINGULAR ABUT <90 REGION
EXT OD2 PACT < 0.45 SINGULAR ABUT <90 REGION
}
OD2.C.2a { @ Minimum OD2 space to gate >= 0.56um
A = OD2 INSIDE EDGE DACT
EXT A GATE_W < 0.560 ABUT <90
}
OD2.E.2a { @ Minimum enclosure of gate by OD2 >= 0.56um
OD2_BEDGE = OD2 INSIDE EDGE OD
ENC GATE_W OD2_BEDGE < 0.560 ABUT <90
HVGT = ALL_GATE AND OD2
HVGT TOUCH EDGE OD2
ALL_GATE CUT OD2
}
#ENDIF


// PO check
//==========

PO.W.1_PO.W.2_PO.W.3 { @ Minimum poly width (interconnect, 2.5v gates) >= ^PO_W_1_2_3 um
INT GATE_W < PO_W_1_2_3 ABUT < 90 REGION
INT POLY_ISO < PO_W_1_2_3 SINGULAR ABUT < 90 REGION
}
#IFDEF 2.5V_3.3V
PO.W.1a { @ Minimum poly gate length 3.3v pmos >= 0.30um
INT HV_PGATE_W < 0.30 ABUT < 90 REGION
}
PO.W.2a { @ Minimum poly gate length 3.3v nmos >= 0.35um
INT HV_NGATE_W < 0.35 ABUT < 90 REGION
}
#ENDIF
#IFDEF 2.5V_5V
PO.W.1b { @ Minimum poly gate length 5v pmos >= 0.50um
INT HV_PGATE_W < PO_W_1a ABUT < 90 REGION
}
PO.W.2b { @ Minimum poly gate length 5v nmos >= 0.50um
INT HV_NGATE_W < PO_W_2a ABUT < 90 REGION
}
#ENDIF
PO.S.1_PO.S.2 { @ Minimum POLY space on OD with/without contact >= ^PO_S_1 um
EXT GATE_W < PO_S_1 ABUT < 90 REGION
}
PO.S.3 { @ Minimum poly interconnect space >= ^PO_S_2 um
EXT POLY < PO_S_2 SINGULAR ABUT < 90 REGION
}
PO.C.1 { @ Minimum poly on field space to active >= ^PO_C_1 um
EXT POLY OD < PO_C_1 ABUT < 90 SINGULAR REGION
}
PO.C.2 { @ Minimum active ohang gate >= ^PO_C_2 um
ENC POLY OD < PO_C_2 SINGULAR ABUT < 90 REGION
}
PO.O.1 { @ Minimum gate ohang active >= ^PO_O_1 um
ENC OD POLY < PO_O_1 SINGULAR ABUT < 90 REGION
}
PO.R.1 { @ 90 degree gate not allowed
X = POLY NOT VARDMY
Y = X INSIDE EDGE OD
EXT Y < 0.05 ABUT == 90 INTERSECTING ONLY
INT Y < 0.05 ABUT == 90 INTERSECTING ONLY
}
PO.R.2 {@ Maximum length of poly between two contacts is 50um when poly width <= 0.35um
LONG_PO = AREA ILP1 > 0.2*50
CHECK_PO = LONG_PO INTERACT CO_POLY
CHECK_CO = CO_POLY INTERACT CHECK_PO
CO_A = SIZE CHECK_CO BY 50 / 2 INSIDE OF CHECK_PO STEP 0.36
PO_A = CHECK_PO INTERACT CO_A == 1
PO_B = CHECK_PO INTERACT CO_A > 1
CO_B = CO_A INTERACT PO_A
CO_C = SIZE CO_B BY 50 / 2 INSIDE OF PO_A STEP 0.36
BAD = (PO_A NOT CO_C) OR (PO_B NOT CO_A)
BAD_EDGE = BAD COIN INSIDE EDGE POLY
ERROR = INT BAD_EDGE <= 0.35 ABUT < 90 REGION
CHECK_PO INTERACT ERROR
}

SD = OD NOT ALL_GATE // Source/drain, include butted pickup
COSD = SD ENCLOSE CO_DIFF // Source/drain with contact
POS3EDGE = ALL_GATE COINCIDENT OUTSIDE EDGE COSD

PO.L.1 { @ Max. PO length in contacted OD with 0.4 space <= ^PO_L_1 um
EXT POS3EDGE == 0.4 OPPOSITE PROJ > PO_L_1
}
PO.L.2 { @ Max. length of 45 degree bent PO
Z = GATE_W ANGLE == 45
LENGTH Z > 1.0
}
#IFNDEF MIX_MODE
PO.I.1 { @ Poly interconnection not dope must <= 0.1, NP and PP can not overlap on field poly
A = (( POLY INTERACT COi ) NOT OD ) OUTSIDE CB
X = A NOT PP
Y = X NOT NP
SIZE Y BY 0.05 UNDEROVER
(NP AND PP) AND POLY_ISO
}
#ENDIF
PO.R.3 {@ Min poly area coverage >= 14%
DENSITY ALL_POLY < 0.14 PRINT POLY_DENSITY.log
}

#IFDEF MIX_MODE
HRDMY = RHDMY OR RLPPDMY // high resistance resistor dummy
ARDMY = HRDMY OR RLDMY // all resistor dummy
CPO1 = POLY_ISO INTERACT CTP // Po1 as capacitor bottom plate
IRP1 = POLY_ISO NOT CPO1
RES_PO1 = IRP1 INTERACT ARDMY // Po1 as resistor
PORES1 = IRP1 AND RPO
HREP = PORES1 AND HRDMY // high resistance poly resistor
NLP1 = CPO1 OR HREP // Po1 as capacitor & high resistance resistor
LRP1 = POLY NOT NLP1 // Po1 as interconnection & low resistance resistor
LREP = LRP1 AND RLDMY // low resistance poly resistor
/////////////////////////////////////////////
///////////resistor Nsq check
/////////////////////////////////////////////
HRIRES = ( PORES1 AND RLPPDMY ) AND HR400DMY // HRI 400 POLY resistor for GP process
HREP_RH = PORES1 AND RHDMY // High resistor POLY resistor for GPIIA
HRIRES_L = EXPAND EDGE (HRIRES NOT INSIDE EDGE POLY) BY 0.001 CORNER FILL
HREP_RH_L = EXPAND EDGE (HREP_RH NOT INSIDE EDGE POLY) BY 0.001 CORNER FILL
HRIRES_W = EXPAND EDGE (HRIRES INSIDE EDGE POLY) BY 0.001
HREP_RH_W = EXPAND EDGE (HREP_RH INSIDE EDGE POLY) BY 0.001
CONNECT HRIRES_L HRIRES_W
CONNECT HREP_RH_L HREP_RH_W


PO.W.4 { @ low resistance poly resistor width >= ^PO_W_4 um
INT LREP < PO_W_4 ABUT < 90 SINGULAR
}
PO.W.5 { @ poly capacitor bottom plate width >= ^PO_W_5 um
INT CPO1 < PO_W_5 ABUT < 90 SINGULAR
}
#IFNDEF GPIIA
PO.W.6a { @ high resistance poly resistor width >= 2um
INT HREP_RH < 2 ABUT < 90 SINGULAR REGION
}
#ENDIF
#IFDEF GPIIA
PO.W.6b { @ high resistance poly resistor width >= 0.5um and Nsq >= ^PO_W_6_NSQ for GPIIA
INT HREP_RH < 0.5 ABUT < 90 SINGULAR REGION
NET AREA RATIO HREP_RH_L HREP_RH_W < PO_W_6_NSQ
}
#ENDIF


#IFNDEF GPIIA
PO.W.10a_W {@ For GP process(CM025 and CR025), minimum width of a PO region for 400 ohm/sq LPP(HRI) resistor >= ^PO_W_10_W um and Nsq >= PO_W_10_NSQ
INT HRIRES < PO_W_10_W ABUT < 90 SINGULAR REGION
}
PO.W.10a_Nsq {@ For GP process(CM025 and CR025), minimum width of a PO region for 400 ohm/sq LPP(HRI) resistor >= ^PO_W_10_W um and Nsq >= PO_W_10_NSQ
NET AREA RATIO HRIRES_L HRIRES_W < PO_W_10_NSQ
}
#ENDIF
#IFDEF GPIIA
PO_RES_3K = (PORES1 AND RLPPDMY) AND (( HR400DMY OR HR1KDMY ) OR HR3KDMY )
PO_RES_3K_A_pre = INT PO_RES_3K <= 0.5 REGION OPPOSITE
PO_RES_3K_A = ((POLY INTERACT PO_RES_3K_A_pre) AND RLPPDMY) AND (( HR400DMY OR HR1KDMY ) OR HR3KDMY )
PO_RES_3K_B = PO_RES_3K NOT PO_RES_3K_A
PO_RES_3K_A_L = EXPAND EDGE (PO_RES_3K_A NOT INSIDE EDGE POLY) BY 0.001 CORNER FILL
PO_RES_3K_A_W = EXPAND EDGE (PO_RES_3K_A INSIDE EDGE POLY) BY 0.001

PO_RES_3K_B_L = EXPAND EDGE (PO_RES_3K_B NOT INSIDE EDGE POLY) BY 0.001 CORNER FILL
PO_RES_3K_B_W = EXPAND EDGE (PO_RES_3K_B INSIDE EDGE POLY) BY 0.001

CONNECT PO_RES_3K_A_L PO_RES_3K_A_W
CONNECT PO_RES_3K_B_L PO_RES_3K_B_W

PO.W.10b {@ Square number Nsq (length/width) of 400/1K/3K ohm/sq HRI resistor, DRC only check rectangle resistor
@ 0.5 >= width >=0.24, Nsq >= 10
@ width > 0.5, Nsq>= 5
NET AREA RATIO PO_RES_3K_A_L PO_RES_3K_A_W < 10
NET AREA RATIO PO_RES_3K_B_L PO_RES_3K_B_W < 5
}
#ENDIF

PO.S.7_PO.S.4 { @ capacitor & high resistor space >= ^PO_S_4 um
EXT NLP1 < PO_S_4 ABUT < 90 SINGULAR
}
PO.S.5 { @ Po1 to capacitor & high resistor space >= ^PO_S_5 um
EXT LRP1 CPO1 < PO_S_5 ABUT < 90 SINGULAR
EXT LRP1 HREP < PO_S_5 ABUT >0< 90 SINGULAR
}

// PO.S.6 checked by PO.S.7_PO.S.4

PO.R.4 { @ capacitor/reisistor on OD not allowed.
CPO1 INTERACT OD
HREP INTERACT OD
LREP INTERACT OD
}
PO.I.1_MM { @ Poly interconnection not doped
A = (( POLY INTERACT COi ) NOT OD ) OUTSIDE CB
B = A NOT PP
C = B NOT NP
D = C NOT LPP
E = D NOT BPI
SIZE E BY 0.05 UNDEROVER
(NP AND PP) AND POLY_ISO
}
#ENDIF
PO.R.warn { @ DPO overlap with POLY or OD is not allowed
DPO AND POLYi
DPO AND ODi
}


////////////////////////////////
// Poly/OD Resistor CHECK
////////////////////////////////
PORESC = PORES NOT INTERACT RLPPDMY
ODRESC = ODRES NOT INTERACT RLPPDMY
PORESC_L = EXPAND EDGE (PORESC NOT INSIDE EDGE POLY) BY 0.001 CORNER FILL
PORESC_W = EXPAND EDGE (PORESC INSIDE EDGE POLY) BY 0.001
ODRESC_L = EXPAND EDGE (ODRESC NOT INSIDE EDGE OD) BY 0.001 CORNER FILL
ODRESC_W = EXPAND EDGE (ODRESC INSIDE EDGE OD) BY 0.001
CONNECT PORESC_L PORESC_W
CONNECT ODRESC_L ODRESC_W
#IFDEF RECOMMEND
RES.2 {@ For poly resistor, it is strongly recommended that the poly resistor width >= ^RES_2_W um,
@ length >= 5.0um, and the resistor square number Nsq >= ^RES_2_Nsq,
@ DRC will check the width and Nsq 1um and 5 for poly resistor & 2um and 5 for OD resistor,
INT PORESC < RES_2_W ABUT < 90 SINGULAR REGION
NET AREA RATIO PORESC_L PORESC_W < RES_2_Nsq
}
RES.3 { @ To use rectangle shape resistor for SPICE simulation accuracy.
NOT RECTANGLE PORES
NOT RECTANGLE ODRES
}
RES.4 {@ For OD resistor, it is strongly recommended that the resistor width>= ^RES_4_W um and the resistor square number Nsq >= ^RES_4_Nsq.
@ DRC will check the width and Nsq 1um and 5 for poly resistor & 2um and 5 for OD resistor,
INT ODRESC < RES_4_W ABUT < 90 SINGULAR REGION
NET AREA RATIO ODRESC_L ODRESC_W < RES_4_Nsq
}
RES.5 {@ Poly resistor cuts NW is not allowed.
PORES CUT NWELL
}
#ENDIF



// HV HRI poly resistor check
//=================================================
#IFDEF MIX_MODE
PORES_HRI = HREP INTERACT RLPPDMY
CO_HRI = CO INTERACT (POLY INTERACT PORES_HRI)

#IFDEF RECOMMEND
PORES_HRI_L = EXPAND EDGE (PORES_HRI NOT INSIDE EDGE POLY) BY 0.001 CORNER FILL
PORES_HRI_W = EXPAND EDGE (PORES_HRI INSIDE EDGE POLY) BY 0.001
CONNECT PORES_HRI_L PORES_HRI_W
RES.HRI.1 { @ It is strongly recommended that the HRI poly resistor width >= 2.0 um and resistor number of square Nsq >=5.
INT PORES_HRI < 2.0 ABUT < 90 SINGULAR REGION
NET AREA RATIO PORES_HRI_L PORES_HRI_W < 5.0
}

//RES.HRI.6 is uncheckable rule


RES.HRI.7 { @ Min extension of RLPPDMY beyond HRI poly resistor >= ^RES_HRI_7
A = POLY INTERACT PORES_HRI
ENC A RLPPDMY < RES_HRI_7 ABUT < 90 SINGULAR REGION
}

RES.HRI.8 { @ To use rectangle shape HRI resistor for the SPICE simulation accuracy.
NOT RECTANGLE PORES_HRI
}

RES.HRI.13a { @ Min and max overlap of PP for HRI poly resistor end implant and RPO == ^RES_HRI_13a
X = POLY_ISO INTERACT RLPPDMY
Y = RPO INSIDE EDGE X
INT PP Y < RES_HRI_13a ABUT < 90
Y OUTSIDE EDGE PP // not overlap by P+ not allowed.
Z = EXPAND EDGE Y INSIDE BY RES_HRI_13a
PPPO = PP AND POLY
A = PPPO AND PORES
B = A INTERACT RLPPDMY
B NOT Z
}

RES.HRI.13b { @ Min and max clearence from RPO to CO for HRI poly resistor == ^RES_HRI_13b
A = POLY INTERACT PORES_HRI
CO_CHECK = CO INTERACT A
RPO_E = RPO INSIDE EDGE A
RPO_EX = EXPAND EDGE RPO_E OUTSIDE BY RES_HRI_13b
RPO_EX AND CO_CHECK
RPO_EX NOT INTERACT CO_CHECK
CO_CHECK NOT INTERACT RPO_EX
}

RES.HRI.13c { @ Min and max space between two CO region on HRI poly resistor == ^RES_HRI_13c
EXT CO_HRI < RES_HRI_13c ABUT < 90 SINGULAR REGION
A = (POLY INTERACT PORES_HRI) NOT RPO
B = SIZE CO_HRI BY RES_HRI_13c/2 OVERUNDER
A INTERACT B != 1
}
#ENDIF

RES.HRI.10 { @ HRI resistor cuts NW is not allowed.
PORES_HRI CUT NWELL
}

RES.HRI.11 { @ RLPPDMY and PP must be butted (overlap is not allow).
(RLPPDMY AND PP) AND POLY
A = PP INSIDE EDGE (POLY INTERACT PORES_HRI)
B = PP AND (POLY INTERACT PORES_HRI)
PORES_HRI NOT TOUCH B == 2
A NOT COIN OUTSIDE EDGE RLPPDMY
}

#ENDIF


// 2VN checks
//=====================
#IFDEF 2.5V_3.3V
2VN.W.1{ @ Minimum 2VN width >= 0.44um
INT N2V < 0.44 SINGULAR ABUT < 90 REGION
}
2VN.S.1 { @ Minimumm 2VN space >= 0.44um
EXT N2V < 0.44 ABUT < 90 SINGULAR REGION
}
2VN.C.1 { @ 2VN space to p+ active >= 0.26um
EXT N2V PACT < 0.26 ABUT>0<90 SINGULAR REGION
N2V AND PACT
x = EXT [N2V] PACT < 0.01 ABUT==0
x NOT TOUCH EDGE PP_BEDGE
}
2VN.C.3 { @ 2VN space to P channel gate >= 0.32um
EXGATE_PP AND N2V
}
2VN.C.4 { @ 2VN olap of ngate >= 0.32um
ENC NGATE_W N2V_EDGE < 0.32 ABUT < 90 REGION
}
2VN.O.1 { @ 2VN extends into n active >= 0.32um
INT N2V NPOD < 0.32 SINGULAR ABUT < 90 REGION
}
2VN.E.1 { @ 2VN olap n+ active area >= 0.26um
ENC NACT N2V < 0.26 SINGULAR ABUT>0< 90 REGION
x = ENC NACT [N2V] < 0.01 ABUT==0
x NOT TOUCH EDGE PP_BEDGE
}
2VN.E.2 { @ 2VN olap n+ Nwell pick-up region >= 0.04um
ENC NTAP N2V < 0.04 SINGULAR ABUT>0< 90 REGION
x = ENC NTAP [N2V] < 0.01 ABUT == 0
x NOT COIN OUTSIDE EDGE PP
}

2VN.C.5 { @ 2VN space to 3vn OD >= 0.30um
EXT N2V 3V_ACTIVE < 0.30 SINGULAR ABUT<90 REGION
N2V AND 3V_ACTIVE
}
2VN.R.1 { @ Overlap of 2VN and PP on OD region is not allowed
2V_ACTIVE AND PP
}
#IFDEF MIX_MODE
2VN.E.3 { @ 2VN enclose Po1-resistor >= 0.26um
ENC RES_PO1 N2V < 0.26 ABUT < 90 SINGULAR
}
2VN.R.2 { @ Overlap of PP and 2VN on same Po1 region (non-OD) not allowed
(N2V AND PP) AND POLY_ISO
}
#ENDIF
#ENDIF

#IFDEF 2.5V_5V
2VN.W.1a{ @ Minimum 2VN width >= 0.44um
INT N2V < 0.44 SINGULAR ABUT < 90 REGION
}
2VN.S.1a { @ Minimumm 2VN space >= 0.44um
EXT N2V < 0.44 ABUT < 90 SINGULAR REGION
}
2VN.C.1a { @ 2VN space to p+ active >= 0.26um
EXT N2V PACT < 0.26 ABUT>0<90 SINGULAR REGION
N2V AND PACT
x = EXT [N2V] PACT < 0.01 ABUT==0
x NOT TOUCH EDGE PP_BEDGE
}
2VN.C.3a { @ 2VN space to P channel gate >= 0.32um
EXGATE_PP AND N2V
}
2VN.C.4a { @ 2VN olap of ngate >= 0.32um
ENC NGATE_W N2V_EDGE < 0.32 ABUT < 90 REGION
}
2VN.O.1a { @ 2VN extends into n active >= 0.32um
INT N2V NPOD < 0.32 SINGULAR ABUT < 90 REGION
}
2VN.E.1a { @ 2VN olap n+ active area >= 0.26um
ENC NACT N2V < 0.26 SINGULAR ABUT>0< 90 REGION
x = ENC NACT [N2V] < 0.01 ABUT==0
x NOT TOUCH EDGE PP_BEDGE
}
2VN.E.2a { @ 2VN olap n+ Nwell pick-up region >= 0.04um
ENC NTAP N2V < 0.04 SINGULAR ABUT>0< 90 REGION
x = ENC NTAP [N2V] < 0.01 ABUT == 0
x NOT COIN OUTSIDE EDGE PP
}

2VN.C.5a { @ 2VN space to 5vn OD >= 0.30um
EXT N2V 5V_ACTIVE < 0.30 SINGULAR ABUT<90 REGION
N2V AND 5V_ACTIVE
}
2VN.R.1a { @ Overlap of 2VN and PP on OD region is not allowed
2V_ACTIVE AND PP
}
#IFDEF MIX_MODE
2VN.E.3a { @ 2VN enclose Po1-resistor >= 0.26um
ENC RES_PO1 N2V < 0.26 ABUT < 90 SINGULAR
}
2VN.R.2a { @ Overlap of PP and 2VN on same Po1 region (non-OD) not allowed
(N2V AND PP) AND POLY_ISO
}
#ENDIF
#ENDIF

#IFDEF 2.5V_3.3V


// 3VN checks
//=====================
3VN.W.1{ @ Minimum 3VN width >= 0.44um
INT N3V < 0.44 SINGULAR ABUT < 90 REGION
}
3VN.S.1 { @ Minimumm 3VN space >= 0.44um
EXT N3V < 0.44 ABUT < 90 SINGULAR REGION
}
3VN.C.1 { @ 3VN space to p+ active in nwell >= 0.26um
EXT N3V PACT < 0.26 ABUT>0<90 SINGULAR INSIDE ALSO REGION
x = EXT [N3V] PACT < 0.01 ABUT==0
x NOT TOUCH EDGE PP_BEDGE
}
3VN.C.3 { @ 3VN space to pgate channel = 0.32um
EXGATE_PP AND N3V
}
3VN.C.4 { @ 3VN olap of ngate >= 0.32um
ENC NGATE_W N3V_EDGE < 0.32 ABUT <90 REGION
}
3VN.O.1 { @ 3VN extends into n active >= 0.32um
INT N3V NPOD < 0.32 ABUT<90 SINGULAR REGION
}
3VN.E.1 { @ 3VN olap n+ active area >= 0.26um
ENC NACT N3V < 0.26 SINGULAR ABUT>0<90 REGION
x = ENC NACT [N3V] < 0.01 ABUT==0
x NOT TOUCH EDGE PP_BEDGE
}
3VN.E.2 { @ 3VN olap n+ active area >= 0.04um
ENC NTAP N3V < 0.04 SINGULAR ABUT>0<90 REGION
x = ENC NTAP [N3V] < 0.01 ABUT==0
x NOT COIN OUTSIDE EDGE PP
}
3VN.C.5 { @ 3VN space to 2VN od >= 0.30um
EXT N3V 2V_ACTIVE < 0.30 SINGULAR ABUT<90 INSIDE ALSO REGION
}
3VN.R.1 { @ Overlap of 3VN and PP on OD region is not allowed
3V_ACTIVE AND PP
}
#IFDEF MIX_MODE
3VN.R.2 { @ Overlap of PP and 3VN on same PO region (non-OD) not allowed
(N3V AND PP) AND POLY_ISO
}
#ENDIF


#ENDIF


#IFDEF 2.5V_5V

// 5VN checks
//=====================
5VN.W.1{ @ Minimum 5VN width >= 0.44um
INT N5V < 0.44 SINGULAR ABUT < 90 REGION
}
5VN.S.1 { @ Minimumm 5VN space >= 0.44um
EXT N5V < 0.44 ABUT < 90 SINGULAR REGION
}
5VN.C.1 { @ 5VN space to p+ active in nwell >= 0.26um
EXT N5V PACT < 0.26 ABUT>0<90 SINGULAR REGION
N5V AND PACT
x = EXT [N5V] PACT < 0.01 ABUT==0
x NOT TOUCH EDGE PP_BEDGE
}
5VN.C.3 { @ 5VN space to pgate channel = 0.32um
EXGATE_PP AND N5V
}
5VN.C.4 { @ 5VN olap of ngate >= 0.32um
ENC NGATE_W N5V_EDGE < 0.32 ABUT <90 REGION
}
5VN.O.1 { @ 5VN extends into n active >= 0.32um
INT N5V NPOD < 0.32 ABUT<90 SINGULAR REGION
}
5VN.E.1 { @ 5VN olap n+ active area >= 0.26um
ENC NACT N5V < 0.26 SINGULAR ABUT>0<90 REGION
x = ENC NACT [N5V] < 0.01 ABUT==0
x NOT TOUCH EDGE PP_BEDGE
}
5VN.E.2 { @ 5VN olap n+ active area >= 0.04um
ENC NTAP N5V < 0.04 SINGULAR ABUT>0<90 REGION
x = ENC NTAP [N5V] < 0.01 ABUT==0
x NOT COIN OUTSIDE EDGE PP
}
5VN.C.5 { @ 5VN space to 2VN od >= 0.30um
EXT N5V 2V_ACTIVE < 0.30 SINGULAR ABUT<90 INSIDE ALSO REGION
N5V AND 2V_ACTIVE
}
5VN.R.1 { @ Overlap of 5VN and PP on OD region is not allowed
5V_ACTIVE AND PP
}
#IFDEF MIX_MODE
5VN.R.2 { @ Overlap of PP and 5VN on same PO region (non-OD) not allowed
(N5V AND PP) AND POLY_ISO
}
#ENDIF

#ENDIF



// PP CHECKS
//============

PP.W.1{ @ Minimum width of an PP region >= ^PP_W_1 um
INT PP < PP_W_1 SINGULAR ABUT < 90 REGION
}
PP.S.1{ @ Minimum space between two PP regions Merge if the space is less than ^PP_S_1 um
EXT PP < PP_S_1 ABUT < 90 SINGULAR REGION
}
PP.C.1 { @ Minimum clearance from an PP region to an N+ active OD region>= 0.26
X = EXT PP NACT < 0.26 ABUT <90 SINGULAR REGION
Y = PP AND NACT
Z = X OR Y
Z NOT INTERACT BUTT_PTAP
}
PP.C.2 { @ PP space to non-butting ntap edge >= ^PP_C_2 um
EXT PP NONB_NTAP < PP_C_2 ABUT<90 SINGULAR INSIDE ALSO REGION
X = EXT [PP] BUTT_NTAP < PP_C_2 ABUT<90 OPPOSITE
Y = PP INSIDE EDGE BUTT_NTAP
X NOT COIN OUTSIDE EDGE NP
Y NOT COIN OUTSIDE EDGE NP
}
PP.C.3 { @ Minimum clearance from an PP edge to a N-Channel PO gate.>= ^PP_C_3 um
EXGATE_NP AND PP
}
PP.C.4 { @ Minimum clearance from an PP edge to a P-Channel PO gate >= ^PP_C_4 um
ENC PGATE_W PP_BEDGE < PP_C_4 ABUT < 90 REGION
}
// PP.C.5 is checked by OD.S.2
// PP.C.6 is checked by PO.I.1
PP.O.1 { @ Minimum overlap from an PP edge to an ODregion>= ^PP_O_1 um
INT OD PP < PP_O_1 ABUT>0<90 SINGULAR REGION
}
PP.E.1{ @ Minimum extension of an PP region beyond a P+ active OD region.>= 0.26
(ENC PACT PP < 0.26 SINGULAR ABUT>0<90 REGION) NOT INTERACT SR
Y = ENC [PACT] PP < 0.004 SINGULAR ABUT == 0
Z = EXPAND EDGE Y OUTSIDE BY 0.004
(Z NOT INTERACT NPOD) NOT INTERACT SR
(OD COIN INSIDE EDGE IMP) NOT INSIDE EDGE SR // IMP cannot coincident OD except butting diffusion edge. PP.E.1,2/NP.E.1,2
}
PP.E.2{ @ PP olap PTAP >= 0.04
A = ENC NONB_PTAP PP < 0.04 SINGULAR ABUT<90 REGION
A NOT SR
X = ENC BUTT_PTAP [PP] < 0.04 ABUT<90
X NOT COIN OUTSIDE EDGE NP
}
#IFNDEF MIX_MODE
PP.E.4 { @ Minimum extension of PP region beyond a PO as a resistor.
@ PO as resistor without NP or PP implant is not allowed.>= 0.26
X = POLY_ISO AND RLDMY
Y = X OR PORES
ENC Y PP < 0.26 SINGULAR ABUT <90 REGION
}
#ENDIF
#IFDEF MIX_MODE
PP.E.4_MM { @ Minimum extension of PP region beyond a PO as a resistor.
@ PO as resistor without NP or PP implant is not allowed.>= 0.26
X = POLY_ISO AND RPO
Y = POLY_ISO AND RLDMY
Z = X OR Y
ENC Z PP < 0.26 SINGULAR ABUT <90 REGION
}
#ENDIF
PP.R.1 { @ OD must be fully covered by {NP OR PP} except: a. OD without interacting {CO OR PO}
@ b. NW resistor
A = CO OR POLY
B = OD NOT INTERACT A
C = B OR ODWR
( OD NOT C ) NOT IMP
}






// NP CHECKS
//============

NP.W.1{ @ NP width >= 0.44um
INT NP < 0.44 SINGULAR ABUT < 90 REGION
}
NP.S.1{ @ NP space >= 0.44um
EXT NP < 0.44 ABUT < 90 SINGULAR REGION
}
NP.C.1 { @ NP space to p active in nwell >= 0.26um
X = EXT NP PACT < 0.26 ABUT<90 SINGULAR REGION
Y = NP AND PACT
Z = X OR Y
Z NOT INTERACT BUTT_NTAP
}
NP.C.2 { @ NP space to p active in pwell >=0.14um
EXT NP NONB_PTAP < 0.14 ABUT<90 SINGULAR INSIDE ALSO REGION
X = EXT [NP] BUTT_PTAP < 0.14 ABUT< 90 OPPOSITE
Y = NP INSIDE EDGE BUTT_PTAP
X NOT COIN OUTSIDE EDGE PP
Y NOT COIN OUTSIDE EDGE PP
}
NP.C.3 { @ NP space to pgate >= 0.32um
EXGATE_PP AND NP
}
NP.C.4 { @ NP olap ngate >= 0.32um
ENC GATE_W NP_BEDGE < 0.32 ABUT <90 REGION
}
// NP.C.5 is checked by OD.S.2
// NP.C.6 is checked by PO.I.1
NP.O.1 { @ NP extends into n active >= 0.32um
INT NP OD < 0.32 ABUT>0<90 SINGULAR REGION
}
NP.E.1{ @ NP olap n active pwell >= 0.26um
X = NACT NOT ODWR
Y = ENC [X] NP < 0.004 SINGULAR ABUT == 0
Z = EXPAND EDGE Y OUTSIDE BY 0.004
(Z NOT INTERACT PPOD) NOT INTERACT SR
(ENC X NP < 0.26 SINGULAR ABUT>0<90 REGION) NOT INTERACT SR
}
NP.E.2{ @ NP olap NTAP >= 0.04um
ENC NONB_NTAP NP < 0.04 SINGULAR ABUT<90 REGION
X = ENC BUTT_NTAP [NP] < 0.04 ABUT<90
X NOT COIN OUTSIDE EDGE PP
}
#IFNDEF MIX_MODE
NP.E.4 { @ Minimum extension of NP region beyond a PO as a resistor.
@ PO as resistor without NP or PP implant is not allowed.>= 0.26
X = POLY_ISO AND RLDMY
Y = X OR PORES
Y NOT IMP
ENC Y NP < 0.26 SINGULAR ABUT <90 REGION
}
#ENDIF
#IFDEF MIX_MODE
NP.E.4_MM { @ Minimum extension of NP region beyond a PO as a resistor.
@ PO as resistor without NP or PP implant is not allowed.>= 0.26
X = POLY_ISO AND RPO
Y = POLY_ISO AND RLDMY
Z = X OR Y
ENC Z NP < 0.26 SINGULAR ABUT <90 REGION
(Z NOT LPP) NOT IMP
}
#ENDIF
//NP.R.1 is checked by PP.R.1










// RPO checks
//===========
RPO.W.1{ @ Minimum RPO width >= ^RPO_W_1 um
INT RPO < RPO_W_1 SINGULAR ABUT < 90 REGION
}
RPO.S.1{ @ Minimum RPO space >= ^RPO_S_1 um
EXT RPO < RPO_S_1 ABUT < 90 SINGULAR REGION
}
RPO.C.1{ @ Minimum RPO space to OD >= 0.30um
EXT RPO OD < 0.30 SINGULAR ABUT <90 REGION
}
RPO.C.2{ @ Minimum RPO space to co on OD >= ^RPO_C_2 um
EXT RPO CO < RPO_C_2 ABUT < 90 SINGULAR REGION
RPO AND CO
}
RPO.C.3{ @ Minimum RPO space to gate,except ESD region >= ^RPO_C_3 um
X = ALL_GATE NOT DRCDMY2
Y = EXT RPO X < RPO_C_3 ABUT < 90 SINGULAR REGION
Y NOT SDI
( RPO AND X ) NOT SDI
}
RPO.C.4{ @ Minimum RPO overhang OD, RPO fully inside OD not allowed >= ^RPO_C_4 um
(ENC OD RPO < RPO_C_4 ABUT < 90 SINGULAR REGION) NOT INTERACT SR
RPO INSIDE OD
}
RPO.E.1{ @ Minimum OD overhang RPO >= ^RPO_E_1 um
(ENC RPO OD < RPO_E_1 ABUT < 90 SINGULAR REGION) NOT INTERACT SR
}
RPO.C.5{ @ Minimum RPO overhang POLY, RPO fully inside PO not allowed >= ^RPO_C_5 um
ENC POLY_ISO RPO < RPO_C_5 ABUT < 90 SINGULAR REGION
RPO INSIDE POLY
}
RPO.A.1 { @ Min RPO area >= ^RPO_A_1 um*um
AREA RPO < RPO_A_1
}

#IFDEF MIX_MODE
RPO.O.1 { @ Min. overlap of P+ on LPP for high-res >= ^RPO_O_1 um
X = IRP1 INTERACT LPP
Y = RPO INSIDE EDGE X
INT PP Y < RPO_O_1 ABUT < 90
Y OUTSIDE EDGE PP // not overlap by P+ not allowed.
}
RPO.C.6 { @ Minimum RPO space to field Poly >= ^RPO_C_6 um
EXT RPO POLY_ISO < RPO_C_6 ABUT < 90 SINGULAR REGION
}
#ENDIF










// CO checks
//===============
CO_CORE = CO NOT SR_CO
CO.W.1 { @ Minimum and maximum width of a CO region== 0.30um
NOT RECTANGLE CO_CORE == 0.30 BY == 0.30 ORTHOGONAL ONLY
}
CO.S.1 { @ Minimum space between two CO regions >= 0.30um
EXT CO < 0.30 ABUT < 90 SINGULAR REGION
}
CO.C.1 { @ Minimum clearance from a CO on OD region to a PO gate>=0.22um
EXT CO_DIFF ALL_GATE < 0.22 SINGULAR ABUT <90 REGION
CO_DIFF AND ALL_GATE
}
CO.C.2 { @ Minimum clearance from a CO on PO region to an OD region>= 0.28um
EXT CO_POLY OD < 0.28 SINGULAR ABUT <90 REGION
}
CO.E.1 { @ Minimum extension of an OD region beyond a OD CO region.>=0.14um
ENC CO_DIFF OD < 0.14 SINGULAR ABUT <90 REGION
CO_DIFF NOT OD
}
CO.E.2 { @ Minimum extension of a PO region beyond a Poly CO region>=0.14um
ENC CO_POLY POLY_ISO < 0.14 SINGULAR ABUT <90 REGION
CO_POLY CUT POLY_ISO
}
CO.E.3_CO.E.4 { @ Minimum extension of a PP region beyond a OD CO region>= 0.18um
ENC CO_DIFF PP < 0.18 SINGULAR ABUT <90 REGION
PP INSIDE EDGE CO_DIFF
ENC CO_DIFF NP < 0.18 SINGULAR ABUT <90 REGION
NP INSIDE EDGE CO_DIFF

}
// CO.R.1 is checked by CO.C.1
// CO.R.2 is checked by CO.W.1
CO.R.3 { @ {CO AND (PO INTERACT (((RLDMY OR RLPPDMY) OR RHDMY) OR RPDUMMY))} must be fully covered by {NP OR PP}
A = CO AND (POLY INTERACT PORES_DMY)
A NOT (NP OR PP)
}


// M1 checks
//=============

M1.W.1 { @ M1 width >= 0.32
INT M1 < 0.32 SINGULAR REGION ABUT < 90
}
M1.S.1 { @ M1 spacing >= 0.32
EXT M1 < 0.32 ABUT < 90 SINGULAR REGION
}
M1.S.2 { @ Wide M1 to M1 spacing >= 0.60
M1_S5 = SHRINK (SHRINK (SHRINK (SHRINK M1 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
M1_G5 = GROW (GROW (GROW (GROW M1_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
M1_Wide = M1_G5 AND M1
M1_Exp = SIZE M1_Wide BY 1 INSIDE OF M1 STEP 0.224
M1_Branch = M1_Exp NOT M1_Wide
M1_Branch_edge = M1_Branch COIN INSIDE EDGE M1
M1_Check = M1 AND (SIZE M1_Exp BY 0.6)
M1_Branch_Check = M1 AND (EXPAND EDGE M1_Branch_edge OUTSIDE BY 0.6 CORNER FILL)
M1_WideC = STAMP M1_Wide BY M1x
M1_CheckC = STAMP M1_Check BY M1x
M1_BranchC = STAMP M1_Branch BY M1x
M1_Branch_CheckC = STAMP M1_Branch_Check BY M1x
EXT M1_WideC M1_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
EXT M1_BranchC M1_Branch_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
}

M1.E.1 { @ Minimum extension of a M1 region beyond a CO region is >=0.01um
ENC CO M1 < 0.01 ABUT<90 SINGULAR
CO NOT M1
}
M1.E.2 { @ Minimum extension of M1 end-of-line region beyond CO region is >=0.09um
X = ENC [CO] M1 < 0.09 ABUT < 90 OPPOSITE // a skinny side
INT [X] < 0.30 INTERSECTING ONLY ABUT == 90 // adjacent skinnies
}
M1.A.1{ @ Minimum m1 area >= 0.36
AREA M1 < 0.36
}
M1.R.1 { @ Min M1 area coverage >= 30%
DENSITY M1x < 0.3 PRINT M1_DENSITY.log
}
#IFDEF RECOMMEND
M1.E.3R {@Min.& Max.extension of M1 island(0.6*0.6) beyond ==0.15
@a stack CO/via region
M1_R = RECTANGLE M1 == 0.6 BY == 0.6 ORTHOGONAL ONLY
CO_C = (CO INTERACT M1_R) INTERACT VIA1
CO_CS = SIZE CO_C BY 0.15
(M1_R INTERACT CO_CS) XOR CO_CS
}
#ENDIF

// VIA1 checks
//=============
VIA1_CORE = VIA1 NOT SR_V1
VIA1.W.1 { @ VIA1 must be 0.36 x 0.36 um
A = NOT RECTANGLE VIA1_CORE == 0.36 BY == 0.36 ORTHOGONAL ONLY
A OUTSIDE RNGX // exclude from metal fuse protection ring area
}
VIA1.S.1 { @ VIA1 SPACING >= 0.35
EXT VIA1 < 0.35 ABUT < 90 SINGULAR REGION
}

VIA1.E.1 { @ Min extension of a M1 region beyond a VIA1 region is >=0.02 um
ENC VIA1 M1 < 0.02 ABUT<90 SINGULAR
VIA1 NOT M1
}

VIA1.E.2 { @ Min extension of M1 end-of-line region beyond VIA1 region is >=0.09 um
X = ENC [VIA1] M1 < 0.09 ABUT < 90 OPPOSITE // a skinny side
INT [X] < 0.36 INTERSECTING ONLY ABUT == 90 // adjacent skinnies
}

// VIA1.C.1 does not require a DRC check

#IFDEF RECOMMEND
VIA1.E.3R {@ Min.& Max.extension of M1 (0.6*0.6) beyond Via1 region ==0.12
M1_R = RECTANGLE M1 == 0.6 BY == 0.6 ORTHOGONAL ONLY
VIA1_C = VIA1 INTERACT M1_R
VIA1_CS = SIZE VIA1_C BY 0.12
(M1_R INTERACT VIA1_CS) XOR VIA1_CS
}
#ENDIF


// M2 checks
//=============

M2.W.1 { @ M2 width >= 0.40
INT M2 < 0.40 ABUT < 90 SINGULAR REGION
}

M2.S.1 { @ M2 spacing >= 0.40
EXT M2 < 0.40 ABUT < 90 SINGULAR REGION
}
M2.S.2 { @ Wide M2 (>10um) min. to M2 >= 0.6 um
M2_S5 = SHRINK (SHRINK (SHRINK (SHRINK M2 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
M2_G5 = GROW (GROW (GROW (GROW M2_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
M2_Wide = M2_G5 AND M2
M2_Exp = SIZE M2_Wide BY 1 INSIDE OF M2 STEP 0.28
M2_Branch = M2_Exp NOT M2_Wide
M2_Branch_edge = M2_Branch COIN INSIDE EDGE M2
M2_Check = M2 AND (SIZE M2_Exp BY 0.6)
M2_Branch_Check = M2 AND (EXPAND EDGE M2_Branch_edge OUTSIDE BY 0.6 CORNER FILL)
M2_WideC = STAMP M2_Wide BY M2x
M2_CheckC = STAMP M2_Check BY M2x
M2_BranchC = STAMP M2_Branch BY M2x
M2_Branch_CheckC = STAMP M2_Branch_Check BY M2x
EXT M2_WideC M2_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
EXT M2_BranchC M2_Branch_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
}
M2.E.1 { @ Min extension of a M2 region beyond a VIA1 region is >=0.02 um
ENC VIA1 M2 < 0.02 ABUT<90 SINGULAR
VIA1 NOT M2
}

M2.E.2 { @ Min extension of M2 end-of-line region beyond VIA1 region is >=0.09um
X = ENC [VIA1] M2 < 0.09 ABUT < 90 OPPOSITE // a skinny side
INT [X] < 0.36 INTERSECTING ONLY ABUT == 90 // adjacent skinnies
}

M2.A.1 { @ Min M2 area region >= 0.36
AREA M2 < 0.36
}
M2.R.1 { @ Min M2 area coverage >= 30%
DENSITY M2x < 0.3 PRINT M2_DENSITY.log
}
#IFDEF RECOMMEND
M2.E.3R {@ Min.& Max.extension of M2 (0.6*0.6) beyond Via1 region ==0.12
M2_R = RECTANGLE M2 == 0.6 BY == 0.6 ORTHOGONAL ONLY
VIA1_C = (VIA1 INTERACT M2_R) INTERACT VIA2
VIA1_CS = SIZE VIA1_C BY 0.12
(M2_R INTERACT VIA1_CS) XOR VIA1_CS
}
#ENDIF

// VIA2 checks
//=============
VIA2_CORE = VIA2 NOT SR_V2
VIA2.W.1 { @ VIA2 must be 0.36 x 0.36 um
A = NOT RECTANGLE VIA2_CORE == 0.36 BY == 0.36 ORTHOGONAL ONLY
A OUTSIDE RNGX // exclude from metal fuse protection ring area
}
VIA2.S.1 { @ VIA2 SPACING >= 0.35
EXT VIA2 < 0.35 ABUT < 90 SINGULAR REGION
}

VIA2.E.1 { @ Min extension of a M2 region beyond a VIA2 region is >=0.02 um
ENC VIA2 M2 < 0.02 ABUT<90 SINGULAR
VIA2 NOT M2
}

VIA2.E.2 { @ Min extension of M2 end-of-line region beyond VIA2 region is >=0.09 um
X = ENC [VIA2] M2 < 0.09 ABUT < 90 OPPOSITE // a skinny side
INT [X] < 0.36 INTERSECTING ONLY ABUT == 90 // adjacent skinnies
}

// VIA2.C.1 does not require a DRC check

#IFDEF RECOMMEND
VIA2.E.3R {@ Min.& Max.extension of M2 (0.6*0.6) beyond Via2 region ==0.12
M2_R = RECTANGLE M2 == 0.6 BY == 0.6 ORTHOGONAL ONLY
VIA2_C = VIA2 INTERACT M2_R
VIA2_CS = SIZE VIA2_C BY 0.12
(M2_R INTERACT VIA2_CS) XOR VIA2_CS
}
#ENDIF

#IFDEF RECOMMEND
VIA2.E.4 {@ Minimum extension of M2 beyond the overlap area that VIA2 and VIA1 are fully or partially touching < ^VIA2_E_4
X = VIA2 AND VIA1
ENC X M2 < VIA2_E_4 ABUT < 90 SINGULAR REGION
}
#ENDIF

// M3 checks
//=============

M3.W.1 { @ M3 width >= 0.40
INT M3 < 0.40 ABUT < 90 SINGULAR REGION
}

M3.S.1 { @ M3 spacing >= 0.40
EXT M3 < 0.40 ABUT < 90 SINGULAR REGION
}
M3.S.2 { @ Wide M3 (>10um) min. to M3 >= 0.6 um
M3_S5 = SHRINK (SHRINK (SHRINK (SHRINK M3 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
M3_G5 = GROW (GROW (GROW (GROW M3_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
M3_Wide = M3_G5 AND M3
M3_Exp = SIZE M3_Wide BY 1 INSIDE OF M3 STEP 0.28
M3_Branch = M3_Exp NOT M3_Wide
M3_Branch_edge = M3_Branch COIN INSIDE EDGE M3
M3_Check = M3 AND (SIZE M3_Exp BY 0.6)
M3_Branch_Check = M3 AND (EXPAND EDGE M3_Branch_edge OUTSIDE BY 0.6 CORNER FILL)
M3_WideC = STAMP M3_Wide BY M3x
M3_CheckC = STAMP M3_Check BY M3x
M3_BranchC = STAMP M3_Branch BY M3x
M3_Branch_CheckC = STAMP M3_Branch_Check BY M3x
EXT M3_WideC M3_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
EXT M3_BranchC M3_Branch_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
}
M3.E.1 { @ Min extension of a M3 region beyond a VIA2 region is >=0.02 um
ENC VIA2 M3 < 0.02 ABUT<90 SINGULAR
VIA2 NOT M3
}

M3.E.2 { @ Min extension of M3 end-of-line region beyond VIA2 region is >=0.09um
X = ENC [VIA2] M3 < 0.09 ABUT < 90 OPPOSITE // a skinny side
INT [X] < 0.36 INTERSECTING ONLY ABUT == 90 // adjacent skinnies
}

M3.A.1 { @ Min M3 area region >= 0.36
AREA M3 < 0.36
}
M3.R.1 { @ Min M3 area coverage >= 30%
DENSITY M3x < 0.3 PRINT M3_DENSITY.log
}
#IFDEF RECOMMEND
M3.E.3R {@ Min.& Max.extension of M3 (0.6*0.6) beyond Via2 region ==0.12
M3_R = RECTANGLE M3 == 0.6 BY == 0.6 ORTHOGONAL ONLY
VIA2_C = (VIA2 INTERACT M3_R) INTERACT VIA3
VIA2_CS = SIZE VIA2_C BY 0.12
(M3_R INTERACT VIA2_CS) XOR VIA2_CS
}
#ENDIF




// VIA3 checks
//=============

CB_CUP = CB INTERACT WBDMY
notch_CB = EXT CB <5 NOTCH OPPOSITE REGION
CB_SINGLE = CB OR notch_CB
VIA3R = VIA3 NOT INSIDE CB_SINGLE
VIA3R_CORE = VIA3R NOT SR_V3
VIA3.W.1 { @ VIA3 must be 0.36 x 0.36 um
A = NOT RECTANGLE VIA3R_CORE == 0.36 BY == 0.36 ORTHOGONAL ONLY
(A OUTSIDE RNGX) NOT CB // exclude from metal fuse protection ring area
}
VIA3.S.1 { @ VIA3 spacing < 0.35
EXT VIA3R < 0.35 ABUT < 90 SINGULAR REGION
}
VIA3.E.1 { @ Min extension of a M3 region beyond a VIA3 region is 0.02 um
ENC VIA3R M3 < 0.02 ABUT<90 SINGULAR
VIA3R NOT M3
}
VIA3.E.2 { @ Min extension of a M3 end-of-line region beyond VIA3 region is 0.09 um
X = ENC [VIA3R] M3 < 0.09 OPPOSITE // a skinny side
INT [X] < 0.36 INTERSECTING ONLY ABUT == 90 // adjacent skinnies
}
// Rule VIA3.C.1 does not require check

#IFDEF RECOMMEND
VIA3.E.3R {@ Min.& Max.extension of M3 (0.6*0.6) beyond Via3 region ==0.12
M3_R = RECTANGLE M3 == 0.6 BY == 0.6 ORTHOGONAL ONLY
VIA3_C = VIA3R INTERACT M3_R
VIA3_CS = SIZE VIA3_C BY 0.12
(M3_R INTERACT VIA3_CS) XOR VIA3_CS
}
#ENDIF

#IFDEF RECOMMEND
VIA3.E.4 {@ Minimum extension of M3 beyond the overlap area that VIA3 and VIA2 are fully or partially touching < ^VIA3_E_4
X = VIA3 AND VIA2
ENC X M3 < VIA3_E_4 ABUT < 90 SINGULAR REGION
}
#ENDIF






#IFNDEF THICK_30K
#IFNDEF THICK_15K
// M4 CHECKS
//=============
Mn.W.1 { @ Minimum width of a M4 region>=0.44um
INT M4 < 0.44 SINGULAR REGION ABUT < 90
}
Mn.S.1 { @ Minimum space between two M4 regions.>=0.46um
EXT M4 < 0.46 ABUT < 90 SINGULAR REGION
}
Mn.S.2 { @ Minimum space between metal lines with one or both metal line width and
@ length are greater than 10um; the minimum space must be maintained
@ between a metal line and a small piece of metal (<10um) that is connected to
@ the wide metal within 1.0 um range from the wide metal. >=0.8um
M4_S5 = SHRINK (SHRINK (SHRINK (SHRINK M4 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
M4_G5 = GROW (GROW (GROW (GROW M4_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
M4_Wide = M4_G5 AND M4
M4_Exp = SIZE M4_Wide BY 1 INSIDE OF M4 STEP 0.322
M4_Branch = M4_Exp NOT M4_Wide
M4_Branch_edge = M4_Branch COIN INSIDE EDGE M4
M4_Check = M4 AND (SIZE M4_Exp BY 0.8)
M4_Branch_Check = M4 AND (EXPAND EDGE M4_Branch_edge OUTSIDE BY 0.8 CORNER FILL)
M4_WideC = STAMP M4_Wide BY M4x
M4_CheckC = STAMP M4_Check BY M4x
M4_BranchC = STAMP M4_Branch BY M4x
M4_Branch_CheckC = STAMP M4_Branch_Check BY M4x
EXT M4_WideC M4_CheckC < 0.8 ABUT >0 <89.5 NOT CONNECTED REGION
EXT M4_BranchC M4_Branch_CheckC < 0.8 ABUT >0 <89.5 NOT CONNECTED REGION
}
Mn.E.1 { @ Min extension of a M4 region beyond a V3 region >=0.09um
ENC VIA3 M4 < 0.09 ABUT<90 SINGULAR REGION
VIA3 NOT M4
}
Mn.A.1 { @ Minimum area of a M4 area. >=0.8sq. um
AREA M4 < 0.8
}
Mn.R.1 { @ Minimum density of a M4 area>=30%
DENSITY M4x < 0.3 PRINT M4_DENSITY.log
}

#ENDIF
#ENDIF




/***** Variables for IMD crack check *****/
VARIABLE VIA_W_1 12.0 //The width of ViaArray
VARIABLE VIA_S_1 3.2 //VIA ARAAY interal space.
VARIABLE VIA_S_2 2.3 //Space of via array to via array.
VARIABLE VIA_S_2L 6.0 //via array parrallel run length
VARIABLE VIA_A_3 0.0 //The overlap area of 3 level continuous stack via array.
VARIABLE VIA_A_2 0.0 //The overlap area of 2 level continuous stack via array.
VARIABLE VIA_Merge 1.605 //The Merge error VIAs and highlight error vias region
VARIABLE VIA_D_1 0.10 //The highlight array minimum density
VARIABLE VIA_S_3 0.49 //Space of via in via array.
VARIABLE VIA_Filter 3.0 // Shrink via arrary For broken small metal connection.
//********************************************
//***** Pre-processing for IMD crack check ****
//********************************************
//
// Processing for SAME Array Merged
//*********************************
VIA1_M = VIA1 INTERACT M1
VIA1Merge1 = SIZE VIA1_M BY VIA_S_1/2 INSIDE OF M1 STEP 0.46
VIA1Merge2 = SIZE VIA1_M BY VIA_S_1/2 OVERUNDER // Any space <= VIA1_S_1 um treated as "array"
VIA1Merge.pre1 = VIA1Merge1 AND VIA1Merge2 // Find merged via array(s)
VIA1Merge.pre11 = ENCLOSE RECTANGLE VIA1Merge.pre1 VIA_S_2L VIA_W_1 // Find at least one width >= VIA_W_1
VIA1Merge.pre12 = VIA1_M INTERACT VIA1Merge.pre11 // find VIA1 in the effective via arrary
VIA1Merge.pre13 = SIZE VIA1Merge.pre12 BY VIA_S_1/2 OVERUNDER // Any space <= VIA1_S_1 um treated as "array"
VIA1Merge.pre2 = VIA1Merge1 AND VIA1Merge.pre13 // Find merged via array(s)
VIA1_same_array = SIZE VIA1Merge.pre2 BY VIA_Filter/2 UNDEROVER // For broken small metal connection
VIA2_M = VIA2 INTERACT M2
VIA2Merge1 = SIZE VIA2_M BY VIA_S_1/2 INSIDE OF M2 STEP 0.46
VIA2Merge2 = SIZE VIA2_M BY VIA_S_1/2 OVERUNDER // Any space <= VIA1_S_1 um treated as "array"
VIA2Merge.pre1 = VIA2Merge1 AND VIA2Merge2 // Find merged via array(s)
VIA2Merge.pre11 = ENCLOSE RECTANGLE VIA2Merge.pre1 VIA_S_2L VIA_W_1 // Find at least one width >= VIA_W_1
VIA2Merge.pre12 = VIA2_M INTERACT VIA2Merge.pre11 // find VIA2 in the effective via arrary
VIA2Merge.pre13 = SIZE VIA2Merge.pre12 BY VIA_S_1/2 OVERUNDER // Any space <= VIA1_S_1 um treated as "array"
VIA2Merge.pre2 = VIA2Merge1 AND VIA2Merge.pre13 // Find merged via array(s)
VIA2_same_array = SIZE VIA2Merge.pre2 BY VIA_Filter/2 UNDEROVER // For broken small metal connection
VIA3_M = VIA3 INTERACT M3
VIA3Merge1 = SIZE VIA3_M BY VIA_S_1/2 INSIDE OF M3 STEP 0.46
VIA3Merge2 = SIZE VIA3_M BY VIA_S_1/2 OVERUNDER // Any space <= VIA1_S_1 um treated as "array"
VIA3Merge.pre1 = VIA3Merge1 AND VIA3Merge2 // Find merged via array(s)
VIA3Merge.pre11 = ENCLOSE RECTANGLE VIA3Merge.pre1 VIA_S_2L VIA_W_1 // Find at least one width >= VIA_W_1
VIA3Merge.pre12 = VIA3_M INTERACT VIA3Merge.pre11 // find VIA3 in the effective via arrary
VIA3Merge.pre13 = SIZE VIA3Merge.pre12 BY VIA_S_1/2 OVERUNDER // Any space <= VIA1_S_1 um treated as "array"
VIA3Merge.pre2 = VIA3Merge1 AND VIA3Merge.pre13 // Find merged via array(s)
VIA3_same_array = SIZE VIA3Merge.pre2 BY VIA_Filter/2 UNDEROVER // For broken small metal connection

// Processing for 3 ~ 2 Stack Array
//**********************************


VIA1_same_array_3stack.pre1 = ((AREA VIA1_same_array >= VIA_A_3 ) AND (AREA VIA2_same_array >= VIA_A_3)) AND ( AREA VIA3_same_array >= VIA_A_3 )
VIA1_same_array_3stack.pre2 = AREA VIA1_same_array_3stack.pre1 >= VIA_A_3

VIA1_same_array_2stack.pre1 = ( AREA VIA1_same_array >= VIA_A_2 ) AND (AREA VIA2_same_array >= VIA_A_2 )
VIA1_same_array_2stack.pre2 = AREA VIA1_same_array_2stack.pre1 >= VIA_A_2
VIA2_same_array_2stack.pre1 = ( AREA VIA2_same_array >= VIA_A_2 ) AND (AREA VIA3_same_array >= VIA_A_2 )
VIA2_same_array_2stack.pre2 = AREA VIA2_same_array_2stack.pre1 >= VIA_A_2





//**********************
// Small 3 stack array
//**********************
// Processing for SAME Array Size Check
//**************************************
VIA1_3stack.pre3 = ENCLOSE RECTANGLE VIA1_same_array_3stack.pre2 VIA_S_2L VIA_W_1 // Find at least one width >=VIA_W_1
VIA1_Reg_3_S_3 = EXT VIA1_3stack.pre3 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90
VIA1_Reg_3_S_3_1 = ENCLOSE RECTANGLE VIA1_Reg_3_S_3 0.005 VIA_S_2L // Find parallel run length >= VIA_S_2L
VIA1_3stack.pre4 = VIA1_3stack.pre3 INTERACT VIA1_Reg_3_S_3_1 // Find parallel run length >= VIA_S_2L
VIA1ArrayS1_S_3 = EXT VIA1_3stack.pre4 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90 // Space of different "smae array" smaller than VIA_S_2
VIA1ArrayS2_S_3 = ((VIA1ArrayS1_S_3 NOT INSIDE M1) NOT INSIDE M2) NOT INSIDE M3
VIA1_3stack.Final = VIA1_3stack.pre4 INTERACT VIA1ArrayS2_S_3

VIA1_S_3_A1 = VIA1 INTERACT VIA1_3stack.Final
VIA1_Reg_4_S_3_A1 = EXT VIA1_S_3_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA1s space smaller than 0.49 (inside small array)
VIA1_Violate_S_3_A1= VIA1_S_3_A1 INTERACT VIA1_Reg_4_S_3_A1
VIA2_S_3_A1 = VIA2 INTERACT VIA1_3stack.Final
VIA2_Reg_4_S_3_A1 = EXT VIA2_S_3_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA2s space smaller than 0.49 (inside small array)
VIA2_Violate_S_3_A1 = VIA2_S_3_A1 INTERACT VIA2_Reg_4_S_3_A1
VIA3_S_3_A1 = VIA3 INTERACT VIA1_3stack.Final
VIA3_Reg_4_S_3_A1 = EXT VIA3_S_3_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA3s space smaller than 0.49 (inside small array)
VIA3_Violate_S_3_A1 = VIA3_S_3_A1 INTERACT VIA3_Reg_4_S_3_A1



// Rule Check
//**************************************
CONNECT VIA1_3stack.Final VIA1_Violate_S_3_A1
CONNECT VIA1_3stack.Final VIA2_Violate_S_3_A1
CONNECT VIA1_3stack.Final VIA3_Violate_S_3_A1

VIA1.S.4_Array1_2_3_M { @ Minimum space between two VIAs in 3-level continuous stacking VIA arrays with below condition >=0.49um
@ Via1 violate VIA_S_3 spacing in Via1/Via2/Via3 array & density large or equal ^VIA_D_1
A1 = NET AREA RATIO VIA1_Violate_S_3_A1 VIA1_3stack.Final >= VIA_D_1
A2 = NET AREA RATIO VIA2_Violate_S_3_A1 VIA1_3stack.Final >= VIA_D_1
A3 = NET AREA RATIO VIA3_Violate_S_3_A1 VIA1_3stack.Final >= VIA_D_1
B1 = (A1 OR A2) OR A3
SIZE B1 BY VIA_Merge OVERUNDER
}




//**********************
// Small 2 stack array
//**********************
// Processing for SAME Array Size Check
//**************************************
VIA1_2stack.pre3 = ENCLOSE RECTANGLE VIA1_same_array_2stack.pre2 VIA_S_2L VIA_W_1 // Find at least one width >= VIA_W_1
VIA1_Reg_3_S_2 = EXT VIA1_2stack.pre3 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90
VIA1_Reg_3_S_2_1 = ENCLOSE RECTANGLE VIA1_Reg_3_S_2 0.005 VIA_S_2L // Find parallel run length >= VIA_S_2L
VIA1_2stack.pre4 = VIA1_2stack.pre3 INTERACT VIA1_Reg_3_S_2_1 // Find parallel run length >= VIA_S_2L
VIA1ArrayS1_S_2 = EXT VIA1_2stack.pre4 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90 // Space of different "smae array" smaller than >= VIA_S_2
VIA1ArrayS2_S_2 = (VIA1ArrayS1_S_2 NOT INSIDE M1) NOT INSIDE M2
VIA1_2stack.Final = VIA1_2stack.pre4 INTERACT VIA1ArrayS2_S_2

VIA1_S_2_A1 = VIA1 INTERACT VIA1_2stack.Final
VIA1_Reg_4_S_2_A1 = EXT VIA1_S_2_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA1s space smaller than 0.49 (inside small array)
VIA1_Violate_S_2_A1= VIA1_S_2_A1 INTERACT VIA1_Reg_4_S_2_A1
VIA2_S_2_A1 = VIA2 INTERACT VIA1_2stack.Final
VIA2_Reg_4_S_2_A1 = EXT VIA2_S_2_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA2s space smaller than 0.49 (inside small array)
VIA2_Violate_S_2_A1 = VIA2_S_2_A1 INTERACT VIA2_Reg_4_S_2_A1


VIA2_2stack.pre3 = ENCLOSE RECTANGLE VIA2_same_array_2stack.pre2 VIA_S_2L VIA_W_1 // Find at least one width >= VIA_W_1
VIA2_Reg_3_S_2 = EXT VIA2_2stack.pre3 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90
VIA2_Reg_3_S_2_1 = ENCLOSE RECTANGLE VIA2_Reg_3_S_2 0.005 VIA_S_2L // Find parallel run length >= VIA_S_2L
VIA2_2stack.pre4 = VIA2_2stack.pre3 INTERACT VIA2_Reg_3_S_2_1 // Find parallel run length >= VIA_S_2L
VIA2ArrayS1_S_2 = EXT VIA2_2stack.pre4 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90 // Space of different "smae array" smaller than >= VIA_S_2
VIA2ArrayS2_S_2 = (VIA2ArrayS1_S_2 NOT INSIDE M2) NOT INSIDE M3
VIA2_2stack.Final = VIA2_2stack.pre4 INTERACT VIA2ArrayS2_S_2

VIA2_S_2_A2 = VIA2 INTERACT VIA2_2stack.Final
VIA2_Reg_4_S_2_A2 = EXT VIA2_S_2_A2 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA2s space smaller than 0.49 (inside small array)
VIA2_Violate_S_2_A2= VIA2_S_2_A2 INTERACT VIA2_Reg_4_S_2_A2
VIA3_S_2_A2 = VIA3 INTERACT VIA2_2stack.Final
VIA3_Reg_4_S_2_A2 = EXT VIA3_S_2_A2 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA3s space smaller than 0.49 (inside small array)
VIA3_Violate_S_2_A2 = VIA3_S_2_A2 INTERACT VIA3_Reg_4_S_2_A2



// Rule Check
//**************************************
CONNECT VIA1_2stack.Final VIA1_Violate_S_2_A1
CONNECT VIA1_2stack.Final VIA2_Violate_S_2_A1
CONNECT VIA2_2stack.Final VIA2_Violate_S_2_A2
CONNECT VIA2_2stack.Final VIA3_Violate_S_2_A2

VIA1.S.5_Array1_2_M { @ Minimum space between two VIAs in 2-level continuous stacking VIA arrays with below condition >=0.49um
@ Via1 violate VIA_S_3 spacing in Via1/Via2 array & density large or equal ^VIA_D_1
A1 = NET AREA RATIO VIA1_Violate_S_2_A1 VIA1_2stack.Final >= VIA_D_1
A2 = NET AREA RATIO VIA2_Violate_S_2_A1 VIA1_2stack.Final >= VIA_D_1
B1 = A1 OR A2
SIZE B1 BY VIA_Merge OVERUNDER
}

VIA2.S.5_Array2_3_M { @ Minimum space between two VIAs in 2-level continuous stacking VIA arrays with below condition >=0.49um
@ Via2 violate VIA_S_3 spacing in Via2/Via3 array & density large or equal ^VIA_D_1
A2 = NET AREA RATIO VIA2_Violate_S_2_A2 VIA2_2stack.Final >= VIA_D_1
A3 = NET AREA RATIO VIA3_Violate_S_2_A2 VIA2_2stack.Final >= VIA_D_1
B2 = A2 OR A3
SIZE B2 BY VIA_Merge OVERUNDER
}







#IFNDEF THICK_15K
#IFNDEF THICK_30K
#IFDEF CHECK_ALRDL

// VIAD checks
//=============
VIADR = VIAD NOT INSIDE CB_SINGLE
VIADR_CORE = VIADR NOT SR_VD
VIAD.W.1 { @ VIAD must be 0.36 x 0.36 um
A = NOT RECTANGLE VIADR_CORE == 0.36 BY == 0.36 ORTHOGONAL ONLY
(A OUTSIDE RNGX) NOT CB // exclude from metal fuse protection ring area
}
VIAD.S.1 { @ VIAD spacing < 0.35
EXT VIADR < 0.35 ABUT < 90 SINGULAR REGION
}
VIAD.E.1 { @ Min extension of a M4 region beyond a VIAD region is 0.02 um
ENC VIADR M4 < 0.02 ABUT<90 SINGULAR
VIADR NOT M4
}
VIAD.E.2 { @ Min extension of a M4 end-of-line region beyond VIAD region is 0.09 um
X = ENC [VIADR] M4 < 0.09 OPPOSITE // a skinny side
INT [X] < 0.36 INTERSECTING ONLY ABUT == 90 // adjacent skinnies
}
// Rule VIAD.C.1 does not require check



// MD CHECKS
//=============

MD.W.1 { @ MD width >=0.44um
INT MD < 0.44 SINGULAR REGION ABUT < 90
}
MD.S.1 { @ MD spacing >=0.46um
EXT MD < 0.46 ABUT < 90 SINGULAR REGION
}
MD.S.2 { @ Wide MD (>10um) min. to MD >=0.8um
MD_S5 = SHRINK (SHRINK (SHRINK (SHRINK MD RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
MD_G5 = GROW (GROW (GROW (GROW MD_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
MD_Wide = MD_G5 AND MD
MD_Exp = SIZE MD_Wide BY 1 INSIDE OF MD STEP 0.322
MD_Branch = MD_Exp NOT MD_Wide
MD_Branch_edge = MD_Branch COIN INSIDE EDGE MD
MD_Check = MD AND (SIZE MD_Exp BY 0.8)
MD_Branch_Check = MD AND (EXPAND EDGE MD_Branch_edge OUTSIDE BY 0.8 CORNER FILL)
MD_WideC = STAMP MD_Wide BY MDx
MD_CheckC = STAMP MD_Check BY MDx
MD_BranchC = STAMP MD_Branch BY MDx
MD_Branch_CheckC = STAMP MD_Branch_Check BY MDx
EXT MD_WideC MD_CheckC < 0.8 ABUT >0 <89.5 NOT CONNECTED REGION
EXT MD_BranchC MD_Branch_CheckC < 0.8 ABUT >0 <89.5 NOT CONNECTED REGION
}
MD.E.1 { @ Min extension of a MD region beyond a V4 region >=0.09um
ENC VIAD MD < 0.09 ABUT<90 SINGULAR
VIAD NOT MD
}
MD.A.1 { @ Min MD area region >=0.8sq. um
AREA MD < 0.8
}
MD.R.1 { @ Minimum density of a MD area>=30%
DENSITY MDx >0 < 0.3 PRINT MD_DENSITY.log
}
#ENDIF
#ENDIF
#ENDIF



// LOGO CHECKS
//============
LOGO_EXT1 = (SIZE LOGO BY 3) NOT LOGO
LOGO.S.1 { @ Min. LOGO space to NW, OD, PO, or Metals (non-dummy patterns) >= 3 um
LOGO_EXT1 AND NWELLi
LOGO_EXT1 AND ODi
LOGO_EXT1 AND POLYi
LOGO_EXT1 AND M1i
LOGO_EXT1 AND M2i
LOGO_EXT1 AND M3i
LOGO_EXT1 AND M4i
LOGO_EXT1 AND MDi
}


LOGO.O.1 { @ LOGO overlap of CB, CBD, AP, FW, PM, UBM, DOD, DPO, or DMx is not allowed.
LOGO AND CBi
LOGO AND CBDi
LOGO AND FWI
LOGO AND PLMIi
LOGO AND UBMi
LOGO AND DOD
LOGO AND DPO
LOGO AND M1DMY
LOGO AND M2DMY
LOGO AND M3DMY
LOGO AND M4DMY
LOGO AND MDDMY
}

LOGO.R.1 { @ A circuit in LOGO is not allowed.
LOGO AND GATE
LOGO AND PORES_DMY
LOGO AND PORES
LOGO AND ODRES
LOGO AND RNWEL
LOGO AND BJTDMY
LOGO AND DIODMY
LOGO AND CTPi
LOGO AND BPIi
LOGO AND CTM1i
LOGO AND CTM2i
LOGO AND CTM3i
LOGO AND CTM4i
}
// LOGO.R.4 is checked by LOGO.S.1

// LOGO.R.2 is checked by other rules


// Dummy Pad
//==========

DP_CO = DPDMY AND CO
DP_V1 = DPDMY AND VIA1
DP_V2 = DPDMY AND VIA2
DP_V3 = DPDMY AND VIA3
DP_VD = DPDMY AND VIAD

ADP.R.0a { @ chip corner dummy pad structure should be M1/M2.../M4
DPDMY NOT M1
DPDMY NOT M2
DPDMY NOT M3
DPDMY NOT M4
}
ADP.R.0b { @ chip corner dummy pad structure should be VIA1/VIA2../VIA3
DPDMY NOT ENCLOSE CO
DPDMY NOT ENCLOSE VIA1
DPDMY NOT ENCLOSE VIA2
DPDMY NOT ENCLOSE VIA3
}
ADP.R.0C { @ COs and Vias structure in Dummy Pad
GRP1 = (DP_CO OR DP_V2) OR DP_VD
GRP2 = DP_V1 OR DP_V3
GRP1 AND GRP2
}
ADP.S.1_CO { @ Minimum space between two CO or Vias at the same level >= 0.68um.
EXT DP_CO < 0.68 ABUT<90 SINGULAR REGION
}
ADP.S.1_V1 { @ Minimum clearance between two CO or Vias at the same level>= 0.68um.
EXT DP_V1 < 0.68 ABUT<90 SINGULAR REGION
}
ADP.S.1_V2 { @ Minimum clearance between two CO or Vias at the same level>= 0.68um.
EXT DP_V2 < 0.68 ABUT<90 SINGULAR REGION
}
ADP.S.1_V3 { @ Minimum clearance between two CO or Vias at the same level>= 0.68um.
EXT DP_V3 < 0.68 ABUT<90 SINGULAR REGION
}
ADP.S.1_VD { @ Minimum clearance between two CO or Vias at the same level >= 0.68um.
EXT DP_VD < 0.68 ABUT<90 SINGULAR REGION
}
ADP.C.1_CO_V1 { @ Minimum clearance between two CO or Vias at different levels >= 0.23um.
EXT DP_CO DP_V1 < 0.23 ABUT<90 SINGULAR
AND DP_CO DP_V1
}
ADP.C.1_V1_V2 { @ Minimum clearance between two CO or Vias at different levels >= 0.23um.
EXT DP_V1 DP_V2 < 0.23 ABUT<90 SINGULAR
AND DP_V1 DP_V2
}
ADP.C.1_V2_V3 { @ Minimum clearance between two CO or Vias at different levels >= 0.23um.
EXT DP_V2 DP_V3 < 0.23 ABUT<90 SINGULAR
AND DP_V2 DP_V3
}
ADP.C.1_V3_VD { @ Minimum clearance between two CO or Vias at different levels >= 0.23um.
EXT DP_V3 DP_VD < 0.23 ABUT<90 SINGULAR
AND DP_V3 DP_VD
}
ADP.E.1_CO_M1 { @ Minimum extension of Metal over CO or VIA >= 3um.
ENC DP_CO M1 < 3 ABUT<90 SINGULAR
}
ADP.E.1_V1_M1 { @ Minimum extension of Metal over CO or VIA >= 3um.
ENC DP_V1 M1 < 3 ABUT<90 SINGULAR
}
ADP.E.1_V1_M2 { @ Minimum extension of Metal over CO or VIA >= 3um.
ENC DP_V1 M2 < 3 ABUT<90 SINGULAR
}
ADP.E.1_V2_M2 { @ Minimum extension of Metal over CO or VIA >= 3um.
ENC DP_V2 M2 < 3 ABUT<90 SINGULAR
}
ADP.E.1_V2_M3 { @ Minimum extension of Metal over CO or VIA >= 3um.
ENC DP_V2 M3 < 3 ABUT<90 SINGULAR
}
ADP.E.1_V3_M3 { @ Minimum extension of Metal over CO or VIA >= 3um.
ENC DP_V3 M3 < 3 ABUT<90 SINGULAR
}
ADP.E.1_V3_M4 { @ Minimum extension of Metal over CO or VIA >= 3um.
ENC DP_V3 M4 < 3 ABUT<90 SINGULAR
}
ADP.E.1_VD_M4 { @ Minimum extension of Metal over CO or VIA >= 3um.
ENC DP_VD M4 < 3 ABUT<90 SINGULAR
}
ADP.E.1_VD_MD { @ Minimum extension of Metal over CO or VIA >= 3um.
ENC DP_VD MD < 3 ABUT<90 SINGULAR
}
ADP.S.2 { @ Minimum space between two dummy pads>= 2um.
EXT DPDMY < 2 ABUT<90 SINGULAR REGION
}
ADP.W.3 { @ Maximum width of a dummy pad <= 80um
DPADG = INT DPDMY <= 80 REGION OPPOSITE ABUT>0<90
DPDMY NOT DPADG
}
ADP.W.4 { @ Minimum width of a dummy pad >= 40um
INT DPDMY < 40 ABUT>0<90 SINGULAR
}

//ADP.W.1 checked by VIAx.W.1
//ADP.W.2 checked by CO.W.1


// Power Line
//===========

PL_CO = PLDMY AND CO
PL_V1 = PLDMY AND VIA1
PL_V2 = PLDMY AND VIA2
PL_V3 = PLDMY AND VIA3
PL_VD = PLDMY AND VIAD

ADP.R.0D { @ Via structure in Power Line
GRP1 = (PL_CO OR PL_V2) OR PL_VD
GRP2 = PL_V1 OR PL_V3
GRP1 AND GRP2
}

ADP.S.4_CO { @ Minimum space between two CO or Vias at the same level>= 0.68um.
EXT PL_CO < 0.68 ABUT<90 SINGULAR REGION
}
ADP.S.4_V1 { @ Minimum space between two CO or Vias at the same level>= 0.68um.
EXT PL_V1 < 0.68 ABUT<90 SINGULAR REGION
}
ADP.S.4_V2 { @ Minimum space between two CO or Vias at the same level>= 0.68um.
EXT PL_V2 < 0.68 ABUT<90 SINGULAR REGION
}
ADP.S.4_V3 { @ Minimum space between two CO or Vias at the same level>= 0.68um.
EXT PL_V3 < 0.68 ABUT<90 SINGULAR REGION
}
ADP.S.4_VD { @ Minimum space between two CO or Vias at the same level>= 0.68um.
EXT PL_VD < 0.68 ABUT<90 SINGULAR REGION
}
ADP.C.2_CO_V1 { @ Minimum clearance between two CO or Vias at different levels>= 0.23um.
EXT PL_CO PL_V1 < 0.23 ABUT<90 SINGULAR
AND PL_CO PL_V1
}
ADP.C.2_V1_V2 { @ Minimum clearance between two CO or Vias at different levels>= 0.23um.
EXT PL_V1 PL_V2 < 0.23 ABUT<90 SINGULAR
AND PL_V1 PL_V2
}
ADP.C.2_V2_V3 { @ Minimum clearance between two CO or Vias at different levels>= 0.23um.
EXT PL_V2 PL_V3 < 0.23 ABUT<90 SINGULAR
AND PL_V2 PL_V3
}
ADP.C.2_V3_VD { @ Minimum clearance between two CO or Vias at different levels>= 0.23um.
EXT PL_V3 PL_VD < 0.23 ABUT<90 SINGULAR
AND PL_V3 PL_VD
}
ADP.E.2_CO_M1 { @ Minimum extension of Metal over CO or VIA>= 0.2um.
ENC PL_CO M1 < 0.2 ABUT<90 SINGULAR
}
ADP.E.3_CO_PO { @ Minimum extension of POLY over CO>= 0.2um.
ENC PL_CO POLY < 0.2 ABUT<90 SINGULAR
}
ADP.E.2_V1_M1 { @ Minimum extension of Metal over CO or VIA >= 0.2um.
ENC PL_V1 M1 < 0.2 ABUT<90 SINGULAR
}
ADP.E.2_V1_M2 { @ Minimum extension of Metal over CO or VIA >= 0.2um.
ENC PL_V1 M2 < 0.2 ABUT<90 SINGULAR
}
ADP.E.2_V2_M2 { @ Minimum extension of Metal over CO or VIA >= 0.2um.
ENC PL_V2 M2 < 0.2 ABUT<90 SINGULAR
}
ADP.E.2_V2_M3 { @ Minimum extension of Metal over CO or VIA >= 0.2um.
ENC PL_V2 M3 < 0.2 ABUT<90 SINGULAR
}
ADP.E.2_V3_M3 { @ Minimum extension of Metal over CO or VIA >= 0.2um.
ENC PL_V3 M3 < 0.2 ABUT<90 SINGULAR
}
ADP.E.2_V3_M4 { @ Minimum extension of Metal over CO or VIA >= 0.2um.
ENC PL_V3 M4 < 0.2 ABUT<90 SINGULAR
}
ADP.E.2_VD_M4 { @ Minimum extension of Metal over CO or VIA >= 0.2um.
ENC PL_VD M4 < 0.2 ABUT<90 SINGULAR
}
ADP.E.2_VD_MD { @ Minimum extension of Metal over CO or VIA >= 0.2um.
ENC PL_VD MD < 0.2 ABUT<90 SINGULAR
}



//METAL SLOT CHECKS
//================
//Bonding pad ,chip corner dummy pad ,and inductor need not put slot
CB_NON_CUP = CBi NOT INTERACT WBDMY
SLT_EXD = CB_NON_CUP OR DPDMY
SLT_EXDT = CBi OR DPDMY

PAD_EXD = UBMi NOT INTERACT MDx

M1EXD = M1x NOT SLT_EXD

//M1 SLOT CHECKS
//==============

M1InnerHole = HOLES M1EXD INNER
M1BigHole = SIZE M1InnerHole BY -5
M1Hole = M1InnerHole OUTSIDE M1BigHole
M1HoleSpace = M1Hole NOT M1EXD
FIM1c = M1EXD OR M1HoleSpace
LM1XA = (SIZE (SIZE FIM1c BY 1.0 UNDEROVER) BY 17.5 UNDEROVER TRUNCATE 17.5) AND FIM1c
LM1X = ENCLOSE RECTANGLE LM1XA 35.005 35.005
M1HoleD = M1HoleSpace AND LM1X

AMS.1.M1 { @ Wide Metal (>35um) must have slot.
A = (SIZE ( SIZE M1EXD BY 1.0 UNDEROVER ) BY 17.5 UNDEROVER TRUNCATE 17.5 ) AND M1EXD
ENCLOSE RECTANGLE A 35.005 35.005
}

CONNECT M1HoleD LM1X
AMS.DN.M1 { @ Min. Hole density for metal lines that need to apply slot 1.5%
NET AREA RATIO LM1X M1HoleD < 0.015
[ AREA(M1HoleD) / AREA(LM1X) ] RDB M1Hole.density2 LM1X M1HoleD
}
DISCONNECT

M1HOC = HOLES M1EXD INNER EMPTY
M1HOD = SIZE M1HOC BY 5 UNDEROVER TRUNCATE 5 // Assume Metal Slot < 10um
M1HO = M1HOC OUTSIDE M1HOD // Metal slot (include not in wide metal)
FIM1 = M1EXD OR M1HO // Metal with slot fill in
M1WMA1 = (SIZE FIM1 BY 17.5 UNDEROVER) AND FIM1
M1WMA = ENCLOSE RECTANGLE M1WMA1 35.005 35.005
M1WM = M1WMA NOT OUTSIDE M1HO
M1SLT = M1HO INSIDE M1WM


M2EXD = M2x NOT SLT_EXD

//M2 SLOT CHECKS
//==============

M2InnerHole = HOLES M2EXD INNER
M2BigHole = SIZE M2InnerHole BY -5
M2Hole = M2InnerHole OUTSIDE M2BigHole
M2HoleSpace = M2Hole NOT M2EXD
FIM2c = M2EXD OR M2HoleSpace
LM2XA = (SIZE (SIZE FIM2c BY 1.0 UNDEROVER) BY 17.5 UNDEROVER TRUNCATE 17.5) AND FIM2c
LM2X = ENCLOSE RECTANGLE LM2XA 35.005 35.005
M2HoleD = M2HoleSpace AND LM2X

AMS.1.M2 { @ Wide Metal (>35um) must have slot.
A = (SIZE ( SIZE M2EXD BY 1.0 UNDEROVER ) BY 17.5 UNDEROVER TRUNCATE 17.5 ) AND M2EXD
ENCLOSE RECTANGLE A 35.005 35.005
}

CONNECT M2HoleD LM2X
AMS.DN.M2 { @ Min. Hole density for metal lines that need to apply slot 1.5%
NET AREA RATIO LM2X M2HoleD < 0.015
[ AREA(M2HoleD) / AREA(LM2X) ] RDB M2Hole.density2 LM2X M2HoleD
}
DISCONNECT

M2HOC = HOLES M2EXD INNER EMPTY
M2HOD = SIZE M2HOC BY 5 UNDEROVER TRUNCATE 5 // Assume Metal Slot < 10um
M2HO = M2HOC OUTSIDE M2HOD // Metal slot (include not in wide metal)
FIM2 = M2EXD OR M2HO // Metal with slot fill in
M2WMA1 = (SIZE FIM2 BY 17.5 UNDEROVER) AND FIM2
M2WMA = ENCLOSE RECTANGLE M2WMA1 35.005 35.005
M2WM = M2WMA NOT OUTSIDE M2HO
M2SLT = M2HO INSIDE M2WM


M3EXD = M3x NOT SLT_EXDT

//M3 SLOT CHECKS
//==============

M3InnerHole = HOLES M3EXD INNER
M3BigHole = SIZE M3InnerHole BY -5
M3Hole = M3InnerHole OUTSIDE M3BigHole
M3HoleSpace = M3Hole NOT M3EXD
FIM3c = M3EXD OR M3HoleSpace
LM3XA = (SIZE (SIZE FIM3c BY 1.0 UNDEROVER) BY 17.5 UNDEROVER TRUNCATE 17.5) AND FIM3c
LM3X = ENCLOSE RECTANGLE LM3XA 35.005 35.005
M3HoleD = M3HoleSpace AND LM3X

AMS.1.M3 { @ Wide Metal (>35um) must have slot.
A = (SIZE ( SIZE M3EXD BY 1.0 UNDEROVER ) BY 17.5 UNDEROVER TRUNCATE 17.5 ) AND M3EXD
ENCLOSE RECTANGLE A 35.005 35.005
}

CONNECT M3HoleD LM3X
AMS.DN.M3 { @ Min. Hole density for metal lines that need to apply slot 1.5%
NET AREA RATIO LM3X M3HoleD < 0.015
[ AREA(M3HoleD) / AREA(LM3X) ] RDB M3Hole.density2 LM3X M3HoleD
}
DISCONNECT

M3HOC = HOLES M3EXD INNER EMPTY
M3HOD = SIZE M3HOC BY 5 UNDEROVER TRUNCATE 5 // Assume Metal Slot < 10um
M3HO = M3HOC OUTSIDE M3HOD // Metal slot (include not in wide metal)
FIM3 = M3EXD OR M3HO // Metal with slot fill in
M3WMA1 = (SIZE FIM3 BY 17.5 UNDEROVER) AND FIM3
M3WMA = ENCLOSE RECTANGLE M3WMA1 35.005 35.005
M3WM = M3WMA NOT OUTSIDE M3HO
M3SLT = M3HO INSIDE M3WM



PAD_EXD4 = SIZE PAD_EXD BY 2 INSIDE OF M4x STEP 0.32
M4EXD = M4x NOT ( SLT_EXDT OR PAD_EXD4 )

//M4 SLOT CHECKS
//==============

M4InnerHole = HOLES M4EXD INNER
M4BigHole = SIZE M4InnerHole BY -5
M4Hole = M4InnerHole OUTSIDE M4BigHole
M4HoleSpace = M4Hole NOT M4EXD
FIM4c = M4EXD OR M4HoleSpace
LM4XA = (SIZE (SIZE FIM4c BY 1.0 UNDEROVER) BY 17.5 UNDEROVER TRUNCATE 17.5) AND FIM4c
LM4X = ENCLOSE RECTANGLE LM4XA 35.005 35.005
M4HoleD = M4HoleSpace AND LM4X

AMS.1.M4 { @ Wide Metal (>35um) must have slot.
A = (SIZE ( SIZE M4EXD BY 1.0 UNDEROVER ) BY 17.5 UNDEROVER TRUNCATE 17.5 ) AND M4EXD
ENCLOSE RECTANGLE A 35.005 35.005
}

CONNECT M4HoleD LM4X
AMS.DN.M4 { @ Min. Hole density for metal lines that need to apply slot >= 1.5%
NET AREA RATIO LM4X M4HoleD < 0.015
[ AREA(M4HoleD) / AREA(LM4X) ] RDB M4Hole.density2 LM4X M4HoleD
}
DISCONNECT

M4HOC = HOLES M4EXD INNER EMPTY
M4HOD = SIZE M4HOC BY 5 UNDEROVER TRUNCATE 5 // Assume Metal Slot < 10um
M4HO = M4HOC OUTSIDE M4HOD // Metal slot (include not in wide metal)
FIM4 = M4EXD OR M4HO // Metal with slot fill in
M4WMA1 = (SIZE FIM4 BY 17.5 UNDEROVER) AND FIM4
M4WMA = ENCLOSE RECTANGLE M4WMA1 35.005 35.005
M4WM = M4WMA NOT OUTSIDE M4HO
M4SLT = M4HO INSIDE M4WM



//MD SLOT CHECKS
//==============
// Bonding pad, chip corner dummy pad, and inductor need not put slot

UBM_EXDD = SIZE UBMi BY 2 INSIDE OF MDx STEP 0.32 // For RDL
MDEXD = MDx NOT ( DPDMY OR UBM_EXDD )
MDInnerHole = HOLES MDEXD INNER
MDBigHole = SIZE MDInnerHole BY -5 // Holes with width less than 10um will be filled back
MDHole = MDInnerHole OUTSIDE MDBigHole
MDHoleSpace = MDHole NOT MDEXD
FIMDc = MDEXD OR MDHoleSpace
LMDXA = (SIZE (SIZE FIMDc BY 1.0 UNDEROVER) BY 17.5 UNDEROVER TRUNCATE 17.5) AND FIMDc
LMDX = ENCLOSE RECTANGLE LMDXA 35.005 35.005
MDHoleD = MDHoleSpace AND LMDX

AMS.1.MD { @ Wide Metal (>35um) must have slot
A = (SIZE ( SIZE MDEXD BY 1.0 UNDEROVER ) BY 17.5 UNDEROVER TRUNCATE 17.5) AND MDEXD
ENCLOSE RECTANGLE A 35.005 35.005
}

CONNECT MDHoleD LMDX
AMS.DN.MD { @ Min. Hole density for metal lines that need to apply slot >= 1.5%
NET AREA RATIO LMDX MDHoleD < 0.015
[ AREA(MDHoleD) / AREA(LMDX) ] RDB MDHole.density2 LMDX MDHoleD
}
DISCONNECT

MDHOC = HOLES MDEXD INNER EMPTY
MDHOD = SIZE MDHOC BY 5 UNDEROVER TRUNCATE 5 // Assume Metal Slot < 10um
MDHO = MDHOC OUTSIDE MDHOD // Metal slot (include not in wide metal)
FIMD = MDEXD OR MDHO // Metal with slot fill in
MDWMA1 = (SIZE FIMD BY 17.5 UNDEROVER) AND FIMD
MDWMA = ENCLOSE RECTANGLE MDWMA1 35.005 35.005
MDWM = MDWMA NOT OUTSIDE MDHO
MDSLT = MDHO INSIDE MDWM


#IFDEF MIX_MODE



// NT_N checks
//=============

NT_N_OD = OD NOT OUTSIDE NTN
NT_N_PO = POLY AND NTN
NT_N_GATE_W = NT_N_PO INSIDE EDGE NT_N_OD
NTN_PO_W = (NT_N_PO INTERACT (CO OR OD)) COIN INSIDE EDGE POLY

NT_N.R.1 {@ NT_N inside or cross over a deep N-well is not allowed
NTN AND DNW
}

// NT_N.R.2 is checked by NT_N.C.2

NT_N.R.3 {@ only one OD region allowed to be put in an NT_N region
NTN ENCLOSE OD > 1
}
NT_N.R.4 {@ A P+ region is not allowed to be put in an NT_N region
NTN AND PP
}
NT_N.R.5 {@ A bent poly region is not allowed to put in an NT_N region
EXT NTN_PO_W < 0.24 ABUT == 90 INTERSECTING ONLY
INT NTN_PO_W < 0.24 ABUT == 90 INTERSECTING ONLY
EXT NTN_PO_W < 0.24 ABUT == 135 INTERSECTING ONLY
INT NTN_PO_W < 0.24 ABUT == 135 INTERSECTING ONLY
}
NT_N.W.1 {@ Minimum width of a NT_N region >= 1.20um
INT NTN < 1.20 SINGULAR ABUT<90 REGION
}
NT_N.W.2 {@ Minimum poly gate dimension of a 2.5V blocked NT_N device >= 0.5um
INT NT_N_GATE_W < 0.5 ABUT<90 REGION
}
#IFDEF 2.5V_3.3V
NT_N.W.3a {@ Minimum poly gate dimension of a 3.3V blocked NT_N device >= 1.2um
Z = NT_N_GATE_W INSIDE EDGE OD2
INT Z < 1.2 ABUT<90 REGION
}
#ENDIF
#IFDEF GPIIA
NT_N.W.3b {@ Minimum poly gate dimension of a 5V native device >= ^NT_N_W_3b um
Z = NT_N_GATE_W INSIDE EDGE OD2
INT Z < NT_N_W_3b ABUT<90 REGION
}
#ENDIF
NT_N.S.1 {@ Minimum space between two NT_N regions >= 1.20um
EXT NTN < 1.20 ABUT<90 SINGULAR REGION
}
NT_N.E.1 {@ Maximum and Minimum extension from NT_N region beyond an NP OD region
A = NTN INTERACT OD
B = OD INTERACT NTN
C = SIZE B BY 0.35
D = SIZE A BY -0.35
A XOR C
B XOR D
}
NT_N.C.1 {@ MInimum clearance from NT_N to OD >= 0.75um
EXT OD NTN < 0.75 SINGULAR ABUT<90 REGION
OD CUT NTN
}
NT_N.C.2 {@ Minimum clearance frome a NT_N region to an Nwell edge >= 2.0um
EXT NTN NWELL < 2.0 SINGULAR ABUT<90 REGION
NTN AND NWELL
}
NT_N.E.2 {@ Minimum overlap of a PO region extended into field oxide(endcap) >= 0.35um
ENC NT_N_OD POLY < 0.35 ABUT<90 SINGULAR REGION
}


// LPP checks
//============

LPP.W.1 { @ LPP width >= 0.44um.
INT LPP < 0.44 ABUT < 90 SINGULAR REGION
}
LPP.S.1 { @ LPP space >= 0.44um
EXT LPP < 0.44 ABUT < 90 SINGULAR REGION
}
LPP.C.1 { @ LPP to Nact space >= 0.30um
X = EXT LPP NACT < 0.30 ABUT < 90 SINGULAR REGION
X NOT INTERACT BUTT_PTAP
}
LPP.C.3 { @ LPP to Ngate space >= 0.32um
BUTLP AND EXGATE_NP
}
LPP.C.4 { @ LPP edge to Pgate to define S/D width >= 0.32um
X = EXGATE_PP AND OD
Y = X CUT LPP
Y NOT LPP
}
LPP.O.1 { @ overlap of LPP & diff >= 0.32um
INT LPP OD < 0.32 ABUT > 0 < 90 SINGULAR REGION
}
LPP.E.1 { @ LPP enclose Pact >= 0.26um.
ENC OD_NW LPP < 0.26 ABUT>0<90 SINGULAR
Y = ENC [OD_NW] LPP < 0.26 ABUT==0
Z = EXPAND EDGE Y OUTSIDE BY 0.004
Z NOT INTERACT NPOD
}
LPP.E.2 { @ LPP enclose Ptap >= 0.10um
ENC OD_PW LPP < 0.10 ABUT>0<90 SINGULAR
Y = ENC [OD_PW] LPP < 0.10 ABUT==0
Z = EXPAND EDGE Y OUTSIDE BY 0.004
Z NOT INTERACT NPOD
}
LPP.E.3 { @ LPP enclose Po1-resistor >= 0.26um
ENC RES_PO1 LPP < 0.26 ABUT < 90 SINGULAR REGION
}
LPP.C.5 { @ LPP to NP OD >= 0.0um
LPP AND NPOD
}
LPP.R.1 { @ Overlap of a NP and a LPP on an OD region is not allowed.
NP_OVP_LPP AND OD
}
LPP.R.2 { @ Overlap of NP and LPP on same Po1 region (non-OD) not allowed
NP_OVP_LPP AND POLY_ISO
}
LPP.R.3 { @ In one database, having both rppohri_1000 and rppohri_400 and rppohri_3000 are not allowed.
( CHIP INTERACT HR400DMY ) INTERACT HR1KDMY
( CHIP INTERACT HR400DMY ) INTERACT HR3KDMY
( CHIP INTERACT HR3KDMY ) INTERACT HR1KDMY
}


// BPI checks
//=============

BPI.W.1 { @ BPI width >= 2.62um
INT BPI < 2.62 ABUT < 90 SINGULAR REGION
}
BPI.S.1 { @ BPI space >= 0.44um
EXT BPI < 0.44 ABUT < 90 SINGULAR REGION
}
BPI.C.1 { @ BPI to OD space >= 0.7um
EXT BPI OD < 0.7 ABUT < 90 SINGULAR REGION
BPI AND OD
}
BPI.E.1 { @ BPI enclose Po1(capacitor) >= 0.26um
ENC CPO1 BPI < 0.26 ABUT < 90 SINGULAR REGION
CPO1 NOT BPI
}

// BPI.R.1 is checked by BPI.C.1


// CTP checks
//=============

CTP.W.1 { @ Poly-2 width >= 0.6um
INT CTP < 0.6 ABUT < 90 SINGULAR REGION
}
CTP.S.1 { @ Poly-2 space >= 0.48um
EXT CTP < 0.48 ABUT < 90 SINGULAR REGION
}
CTP.C.1 { @ Poly-2 to Contact space >= 0.9um
EXT CTP CO < 0.9 ABUT < 90 SINGULAR REGION
}
CTP.E.1 { @ Poly-1 enclose Poly-2 >= 0.75um
ENC CTP CPO1 < 0.75 ABUT < 90 SINGULAR REGION
NOT CTP CPO1
}
CTP.E.2 { @ Poly-2 enclose Contact >= 0.45um
ENC CO CTP < 0.45 ABUT < 90 SINGULAR REGION
CO CUT CTP
}
CTP.R.1 { @ Poly-2 on OD is not allowed
CTP AND OD
}

// CTP.R.2 is checked by CTP.E.1


// CTM checks
//============

// safe checks for MiM & PiP process
CHIP_CTM2 = CHIP INTERACT CTM2i
CHIP_CTM3 = CHIP INTERACT CTM3i
CTM.TITLE.1b { @ For 4M procss, both CTM2 and CTM3 can be used as CTM of MIM capacitor.
@ but CTM2 and CTM3 on the same CHIP is not allowed.
CTM2i INTERACT CHIP_CTM3
CTM3i INTERACT CHIP_CTM2
}

//***************************************************************
TCTM2 = CTM2 INTERACT VIA2 // effective capacitor top plate
DCTM2 = CTM2 NOT INTERACT VIA2 // dummy ctm2

DPM2A = M2 INTERACT DCTM2
DPM2 = DPM2A NOT INTERACT (VIA2 OR VIA1) // dummy M1 as a capacitor bottom plate
BPM2A= M2 INTERACT TCTM2
BPM2 = BPM2A AND CTMDMY // M2 as a capacitor bottom plate

TCTM3 = CTM3 INTERACT VIA3 // effective capacitor top plate
DCTM3 = CTM3 NOT INTERACT VIA3 // dummy ctm3

DPM3A = M3 INTERACT DCTM3
DPM3 = DPM3A NOT INTERACT (VIA3 OR VIA2) // dummy M2 as a capacitor bottom plate
BPM3A= M3 INTERACT TCTM3
BPM3 = BPM3A AND CTMDMY // M3 as a capacitor bottom plate


TCTM = TCTM2 OR TCTM3 // capacitor top plate
DCTM = DCTM2 OR DCTM3 // dummy CTM

ALL_CTM = CTM2i OR CTM3i

CTM.W.1 { @ Minimum width of CTM (as capacitor top plate) width 5 um
INT TCTM < 5 ABUT < 90 SINGULAR REGION
}
CTM.W.2 { @ Minimum width of a dummy CTM region 0.5 um
INT DCTM < 0.5 ABUT < 90 SINGULAR REGION
}

// CTM.W.3 is checked by CTM.W.2

CTM.S.1 { @ Minimum space of CTM (as capacitor top plate) 1.5 um
EXT TCTM < 1.5 ABUT < 90 SINGULAR REGION
}

CTM.S.2 { @ Minimum space between a dummy CTM to a CTM regions 1 um
EXT DCTM TCTM < 1.0 ABUT < 90 SINGULAR REGION
EXT DCTM < 1.0 ABUT < 90 SINGULAR REGION
}
CTM.S.3_BPM2 { @ Minimum space between two Mn+1 of both dummy and real capacitor bottom plate 0.8 um
A = (( M2 INTERACT CTM2 ) AND CTMDMY ) COIN INSIDE EDGE M2
EXT A < 0.8 ABUT < 90 REGION
}
CTM.S.3_BPM3 { @ Minimum space between two Mn+1 of both dummy and real capacitor bottom plate 0.8 um
A = (( M3 INTERACT CTM3 ) AND CTMDMY ) COIN INSIDE EDGE M3
EXT A < 0.8 ABUT < 90 REGION
}
CTM.E.1.VIA2 { @ CTM2 enclose Via2 < 0.3 um
ENC VIA2 CTM2 < 0.3 ABUT<90 SINGULAR REGION
VIA2 CUT CTM2
}
CTM.E.1.VIA3 { @ CTM3 enclose Via3 < 0.3 um
ENC VIA3 CTM3 < 0.3 ABUT<90 SINGULAR REGION
VIA3 CUT CTM3
}
CTM.E.2.BPM2 { @ bottom plate Metal enclose Via < 0.15 um
ENC VIA1 BPM2 < 0.15 ABUT<90 SINGULAR REGION
ENC VIA2 BPM2 < 0.15 ABUT<90 SINGULAR REGION
}
CTM.E.2.BPM3 { @ bottom plate Metal enclose Via < 0.15 um
ENC VIA2 BPM3 < 0.15 ABUT<90 SINGULAR REGION
ENC VIA3 BPM3 < 0.15 ABUT<90 SINGULAR REGION
}
CTM.E.3.M2 { @ bottom plate Metal enclose CTM >= 0.5 um
ENC CTM2 M2 < 0.5 ABUT<90 SINGULAR REGION
CTM2 NOT M2
}
CTM.E.3.M3 { @ bottom plate Metal enclose CTM >= 0.5 um
ENC CTM3 M3 < 0.5 ABUT<90 SINGULAR REGION
CTM3 NOT M3
}
CTM.C.1.CTM2 { @ CTM space to Via >= 0.5 um
EXT VIA1 CTM2 < 0.5 ABUT<90 SINGULAR REGION
EXT VIA2 CTM2 < 0.5 ABUT<90 SINGULAR REGION
}
CTM.C.1.CTM3 { @ CTM space to Via >= 0.5 um
EXT VIA2 CTM3 < 0.5 ABUT<90 SINGULAR REGION
EXT VIA3 CTM3 < 0.5 ABUT<90 SINGULAR REGION
}

// CTM.R.1 is checked by CTM.E.3.M2 CTM.E.3.M3

CTMV2 = VIA2 AND CTM2 // via locate on CTM
CBMV2A= VIA2 AND BPM2
CBMV2 = CBMV2A NOT CTM2 // via locate on bottom plate

CONNECT CTMV2 TCTM2
CONNECT CBMV2 BPM2

CTM.S.4.CTMV2 { @ min space between vias locate on the same CTM < 2um
EXT CTMV2 < 2 ABUT<90 SINGULAR REGION CONNECTED
}
CTMV3 = VIA3 AND CTM3 // via locate on CTM
CBMV3A= VIA3 AND BPM3
CBMV3 = CBMV3A NOT CTM3 // via locate on bottom plate

CONNECT CTMV3 TCTM3
CONNECT CBMV3 BPM3

CTM.S.4.CTMV3 { @ min space between vias locate on the same CTM < 2um
EXT CTMV3 < 2 ABUT<90 SINGULAR REGION CONNECTED
}
CTM.S.5.CBMV2 { @ min space between vias locate on buttom plate < 4um
EXT CBMV2 < 4 ABUT<90 SINGULAR REGION CONNECTED
}
CTM.S.5.CBMV3 { @ min space between vias locate on buttom plate < 4um
EXT CBMV3 < 4 ABUT<90 SINGULAR REGION CONNECTED
}

CTM.R.3 { @ dummy layer enclose bottom plate metal < 2um.
A = BPM2A OR BPM3A
ENC A CTMDMY < 2 ABUT < 90 SINGULAR REGION
TCTM NOT CTMDMY
}

CTM.R.4 { @ max width and length of a CTM region as a capacitor top plate < 30um
ENCLOSE RECTANGLE TCTM 0.01 30.01 ORTHOGONAL ONLY
}
CTM.R.5_BPM2 { @ max width and length of a capacitor bottom plate < 35um
SIZE BPM2 BY 17.5 UNDEROVER
}
CTM.R.5_BPM3 { @ max width and length of a capacitor bottom plate < 35um
SIZE BPM3 BY 17.5 UNDEROVER
}
CTM.R.6_CTM2 { @ Via and metal under CTM2 is not allowed.
VIA1 AND CTM2
M1dc = M1 NOT M1DMY //dummy metal is allowed
(M1dc AND CTM2) AND RFDUMMY

}
CTM.R.6_CTM3 { @ Via and metal under CTM3 is not allowed.
VIA2 AND CTM3
M1dc = M1 NOT M1DMY //dummy metal is allowed
(M1dc AND CTM3) AND RFDUMMY

M2dc = M2 NOT M2DMY //dummy metal is allowed
(M2dc AND CTM3) AND RFDUMMY

}

CTM.R.7_CTM2 { @ device under CTM is not allowed
( ( ( POLY OR OD ) OR RNWEL ) AND CTM2 ) AND RFDUMMY
}
CTM.R.7_CTM3 { @ device under CTM is not allowed
( ( ( POLY OR OD ) OR RNWEL ) AND CTM3 ) AND RFDUMMY
}
CTM.R.2 { @ Min. density of a CTM < 3%
DENSITY ALL_CTM > 0 < 0.03 PRINT CTM.density
}
CONNECT CTMV2 TCTM2
CTM.S.4a_VIA2 { @ min vias density on CTM < 1%
NET AREA RATIO CTMV2 TCTM2 < 0.01
[
AREA(CTMV2) / AREA(TCTM2)
] RDB VIA2_DENSITY.log CTMV2 TCTM2
}
DISCONNECT

CONNECT CTMV3 TCTM3
CTM.S.4a_VIA3 { @ min vias density on CTM < 1%
NET AREA RATIO CTMV3 TCTM3 < 0.01
[
AREA(CTMV3) / AREA(TCTM3)
] RDB VIA3_DENSITY.log CTMV3 TCTM3
}
DISCONNECT






#IFDEF 2.5V_3.3V

// VTM_N checks
//==============

VTMN.W.1 { @ VTM_N width >= 0.82um
INT VTMN < 0.82 ABUT < 90 SINGULAR REGION
}
VTMN.W.2 { @ 2.5V blocked VTMN gate length >= 0.35um
Z = GATE_W INSIDE EDGE VTMN
INT Z < 0.35 ABUT < 90 REGION
}
VTMN.S.1 { @ VTM_N space >= 0.44um
EXT VTMN < 0.44 ABUT < 90 SINGULAR REGION
}
VTMN.E.1 { @ VTM_N enclose N-act >= 0.26um
ENC NACT VTMN < 0.26 ABUT < 90 SINGULAR REGION
NACT CUT VTMN
}
VTMN.C.1 { @ VTM_N to N-active space >= 0.7um
EXT NACT VTMN < 0.7 ABUT < 90 SINGULAR REGION
}
VTMN.C.2 { @ VTM_N to Nwell space >= 0.6um
EXT VTMN NWELL < 0.6 ABUT < 90 SINGULAR REGION
VTMN AND NWELL
}
VTMN.R.1 { @ Only 2.5V blocked VTMN device is allowed.
Z = ALL_GATE AND VTMN
OD2 AND Z
}
// VTM_P checks
//==============

VTMP.W.1 { @ VTM_P width >= 0.82um
INT VTMP < 0.82 ABUT < 90 SINGULAR REGION
}
VTMP.W.2 { @ 2.5V/3.3V blocked VTMP gate length >= 0.35um
Z = GATE_W INSIDE EDGE VTMP
INT Z < 0.35 ABUT < 90 REGION
}
VTMP.S.1 { @ VTM_P space >= 0.44um
EXT VTMP < 0.44 ABUT < 90 SINGULAR REGION
}
VTMP.E.1 { @ VTM_P enclose P-act >= 0.26um
ENC PACT VTMP < 0.26 ABUT < 90 SINGULAR REGION
PACT CUT VTMP
}
VTMP.C.1 { @ VTM_P to P-active space >= 0.7um
EXT PACT VTMP < 0.7 ABUT < 90 SINGULAR REGION
}
VTMP.E.2 { @ Nwell enclose VTM_P >= 0.6um
ENC VTMP NWELL < 0.6 ABUT < 90 SINGULAR REGION
VTMP NOT NWELL
}

// VTD_N checks
//==============

VTDN.W.1 { @ VTD_N width >= 0.82um
INT VTDN < 0.82 ABUT < 90 SINGULAR REGION
}
VTDN.W.2 { @ 2.5V-NMOS depletion gate length >= 0.6um
Z = GATE_W INSIDE EDGE VTDN
INT Z < 0.6 ABUT < 90 REGION
}
VTDN.S.1 { @ VTD_N space >= 0.44um
EXT VTDN < 0.44 ABUT < 90 SINGULAR REGION
}
VTDN.E.1 { @ VTD_N enclose N-act >= 0.26um
ENC NACT VTDN < 0.26 ABUT < 90 SINGULAR REGION
NACT CUT VTDN
VTDN INSIDE NACT
}
VTDN.C.1 { @ VTD_N to N-active space >= 0.7um
EXT NACT VTDN < 0.7 ABUT < 90 SINGULAR REGION
}
VTDN.C.2 { @ Nwell enclose VTD_N >= 0.6um
EXT VTDN NWELL < 0.6 ABUT < 90 SINGULAR REGION
VTDN AND NWELL
}
VTDN.R.1 { @ Only 2.5V depletion NMOS is allowed.
Z = ALL_GATE AND VTDN
OD2 AND Z
}

// VTD_P checks
//==============

VTDP.W.1 { @ VTD_P width >= 0.82um
INT VTDP < 0.82 ABUT < 90 SINGULAR REGION
}
VTDP.W.2 { @ 2.5V-PMOS depletion gate length >= 0.6um
Z = GATE_W INSIDE EDGE VTDP
INT Z < 0.6 ABUT < 90 REGION
}
VTDP.S.1 { @ VTD_P space >= 0.44um
EXT VTDP < 0.44 ABUT < 90 SINGULAR REGION
}
VTDP.E.1 { @ VTD_P enclose P-act >= 0.26um
ENC PACT VTDP < 0.26 ABUT < 90 SINGULAR REGION
PACT CUT VTDP
VTDP INSIDE PACT
}
VTDP.C.1 { @ VTD_P to P-active space >= 0.7um
EXT PACT VTDP < 0.7 ABUT < 90 SINGULAR REGION
}
VTDP.E.2 { @ Nwell enclose VTD_P >= 0.6um
ENC VTDP NWELL < 0.6 ABUT < 90 SINGULAR REGION
VTDP NOT NWELL
}
VTDP.R.1 { @ Only 2.5V depletion PMOS is allowed.
Z = ALL_GATE AND VTDP
OD2 AND Z
}
#ENDIF

#IFDEF GPIIA

// VTM_N checks
//==============

VTMN.W.1a { @ VTM_N width >= 0.82um
INT VTMN < 0.82 ABUT < 90 SINGULAR REGION
}
VTMN.W.2a { @ 2.5V blocked VTMN gate length >= 0.35um
Z = GATE_W INSIDE EDGE VTMN
INT Z < 0.35 ABUT < 90 REGION
}
VTMN.W.2b { @ 5V blocked VTMN gate length >= ^VTMN_W_2b um for GPIIA process
Z = GATE_W INSIDE EDGE ( VTMN AND OD2 )
INT Z < VTMN_W_2b ABUT < 90 REGION
}
VTMN.S.1a { @ VTM_N space >= 0.44um
EXT VTMN < 0.44 ABUT < 90 SINGULAR REGION
}
VTMN.E.1a { @ VTM_N enclose N-act >= 0.26um
ENC NACT VTMN < 0.26 ABUT < 90 SINGULAR REGION
NACT CUT VTMN
}
VTMN.C.1a { @ VTM_N to N-active space >= 0.7um
EXT NACT VTMN < 0.7 ABUT < 90 SINGULAR REGION
}
VTMN.C.2a { @ VTM_N to Nwell space >= 0.6um
EXT VTMN NWELL < 0.6 ABUT < 90 SINGULAR REGION
VTMN AND NWELL
}
// VTM_P checks
//==============

VTMP.W.1a { @ VTM_P width >= 0.82um
INT VTMP < 0.82 ABUT < 90 SINGULAR REGION
}
VTMP.W.2a { @ 2.5V/3.3V blocked VTMP gate length >= 0.35um
Z = GATE_W INSIDE EDGE VTMP
INT Z < 0.35 ABUT < 90 REGION
}
VTMP.W.2b { @ 5V blocked VTMP gate length >= ^VTMP_W_2b um for GPIIA process
Z = GATE_W INSIDE EDGE ( VTMP AND OD2 )
INT Z < VTMP_W_2b ABUT < 90 REGION
}
VTMP.S.1a { @ VTM_P space >= 0.44um
EXT VTMP < 0.44 ABUT < 90 SINGULAR REGION
}
VTMP.E.1a { @ VTM_P enclose P-act >= 0.26um
ENC PACT VTMP < 0.26 ABUT < 90 SINGULAR REGION
PACT CUT VTMP
}
VTMP.C.1a { @ VTM_P to P-active space >= 0.7um
EXT PACT VTMP < 0.7 ABUT < 90 SINGULAR REGION
}
VTMP.E.2a { @ Nwell enclose VTM_P >= 0.6um
ENC VTMP NWELL < 0.6 ABUT < 90 SINGULAR REGION
VTMP NOT NWELL
}

// VTD_N checks
//==============

VTDN.W.1a { @ VTD_N width >= 0.82um
INT VTDN < 0.82 ABUT < 90 SINGULAR REGION
}
VTDN.W.2a { @ 2.5V-NMOS depletion gate length >= 0.6um
Z = GATE_W INSIDE EDGE VTDN
INT Z < 0.6 ABUT < 90 REGION
}
VTDN.S.1a { @ VTD_N space >= 0.44um
EXT VTDN < 0.44 ABUT < 90 SINGULAR REGION
}
VTDN.E.1a { @ VTD_N enclose N-act >= 0.26um
ENC NACT VTDN < 0.26 ABUT < 90 SINGULAR REGION
NACT CUT VTDN
VTDN INSIDE NACT
}
VTDN.C.1a { @ VTD_N to N-active space >= 0.7um
EXT NACT VTDN < 0.7 ABUT < 90 SINGULAR REGION
}
VTDN.C.2a { @ Nwell enclose VTD_N >= 0.6um
EXT VTDN NWELL < 0.6 ABUT < 90 SINGULAR REGION
VTDN AND NWELL
}
VTDN.R.1a { @ Only 2.5V depletion NMOS is allowed.
Z = ALL_GATE AND VTDN
OD2 AND Z
}

// VTD_P checks
//==============

VTDP.W.1a { @ VTD_P width >= 0.82um
INT VTDP < 0.82 ABUT < 90 SINGULAR REGION
}
VTDP.W.2a { @ 2.5V-PMOS depletion gate length >= 0.6um
Z = GATE_W INSIDE EDGE VTDP
INT Z < 0.6 ABUT < 90 REGION
}
VTDP.S.1a { @ VTD_P space >= 0.44um
EXT VTDP < 0.44 ABUT < 90 SINGULAR REGION
}
VTDP.E.1a { @ VTD_P enclose P-act >= 0.26um
ENC PACT VTDP < 0.26 ABUT < 90 SINGULAR REGION
PACT CUT VTDP
VTDP INSIDE PACT
}
VTDP.C.1a { @ VTD_P to P-active space >= 0.7um
EXT PACT VTDP < 0.7 ABUT < 90 SINGULAR REGION
}
VTDP.E.2a { @ Nwell enclose VTD_P >= 0.6um
ENC VTDP NWELL < 0.6 ABUT < 90 SINGULAR REGION
VTDP NOT NWELL
}
VTDP.R.1a { @ Only 2.5V depletion PMOS is allowed.
Z = ALL_GATE AND VTDP
OD2 AND Z
}
#ENDIF




CONNECT NTAPi NWELLi
CONNECT DNWi NTAPi
CONNECT PTAPi RWi
CONNECT PTAPi PWELLi
CONNECT NTAPi PSDi
CONNECT PTAPi NSDi
CONNECT M1x ILP1i BY POLY_CONT
CONNECT M1x NTAPi PTAPi PSDi NSDi BY COi
CONNECT M1x M2x BY VIA1i
//Exclude the via upon CTM region
CONNECT M2x M3x BY VIA2t
CONNECT M3x CTM2i BY VIA2c
//Exclude the via upon CTM region
CONNECT M3x M4x BY VIA3t
CONNECT M4x CTM3i BY VIA3c
CONNECT M4x MDx BY VIADi

CHIP_NIND = CHIP NOT INDDMY

INDDMYI = SIZE INDDMY BY -7 // exclude M1 substrate pick up node
INDM = INDDMY AND M2
INDME = INDM COINCIDENT INSIDE EDGE INDDMY
INDDMYA = INDDMY WITH EDGE INDME < 2
INDDMY3 = INDDMYA ENCLOSE M3 // for 3 terminals inductor(central tap)
INDDMY2 = INDDMY NOT INDDMY3 // for 2 terminals inductor


#IFDEF THICK_15K
#IFNDEF GPIIA
// 15K UTM TOP METAL CHECKS
//==================
UTM15K.W.1a { @ Minimum width of a UTM region >=1.50um
INT M4 < 1.50 ABUT < 90 SINGULAR REGION
}
UTM15K.S.1a { @ Minimum space between two UTM regions.>= 1.50um
EXT M4 < 1.50 ABUT < 90 SINGULAR REGION
}
#ENDIF
#IFDEF GPIIA
UTM15K.W.1b { @ Minimum width of a UTM region >=1.00um for GPIIA process
INT M4 < 1.00 ABUT < 90 SINGULAR REGION
}
UTM15K.S.1b { @ Minimum space between two UTM regions.>= 1.20um for GPIIA process
EXT M4 < 1.20 ABUT < 90 SINGULAR REGION
}
#ENDIF
M4T_NIND = M4x NOT INDDMY
UTM15K.S.2 { @ Minimum space between UTM metal lines with one or both metal lines' width and
@ length are greater than 10um; This also includes all metals attached to these
@ areas or extending out for a distance of 1.0mm or less. >=2.0um
M4T_NIND_S5 = SHRINK (SHRINK (SHRINK (SHRINK M4T_NIND RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
M4T_NIND_G5 = GROW (GROW (GROW (GROW M4T_NIND_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
M4T_NIND_Wide = M4T_NIND_G5 AND M4T_NIND
M4T_NIND_Exp = SIZE M4T_NIND_Wide BY 1 INSIDE OF M4T_NIND STEP 1.05
M4T_NIND_Branch = M4T_NIND_Exp NOT M4T_NIND_Wide
M4T_NIND_Branch_edge = M4T_NIND_Branch COIN INSIDE EDGE M4T_NIND
M4T_NIND_Check = M4T_NIND AND (SIZE M4T_NIND_Exp BY 2)
M4T_NIND_Branch_Check = M4T_NIND AND (EXPAND EDGE M4T_NIND_Branch_edge OUTSIDE BY 2 CORNER FILL)
M4T_NIND_WideC = STAMP M4T_NIND_Wide BY M4x
M4T_NIND_CheckC = STAMP M4T_NIND_Check BY M4x
M4T_NIND_BranchC = STAMP M4T_NIND_Branch BY M4x
M4T_NIND_Branch_CheckC = STAMP M4T_NIND_Branch_Check BY M4x
EXT M4T_NIND_WideC M4T_NIND_CheckC < 2 ABUT >0 <89.5 NOT CONNECTED REGION
EXT M4T_NIND_BranchC M4T_NIND_Branch_CheckC < 2 ABUT >0 <89.5 NOT CONNECTED REGION
}
UTM15K.E.1 { @ Minimum extension of a UTM region beyond a Vtop region.>=0.3um
ENC VIA3 M4 < 0.3 ABUT<90 SINGULAR
VIA3 NOT M4
}
UTM15K.E.1a { @ Minimum extension of a UTM region beyond a Vtop region at the end of UTM.>=0.45um
X = ENC [VIA3] M4 < 0.45 ABUT < 90 OPPOSITE // a skinny side
INT X < 0.36 INTERSECTING ONLY ABUT == 90 // adjacent skinnies
}
UTM15K.A.1 { @ Minimum area of a UTM area.>= 2.25sq. um
AREA M4 < 2.25
}
UTM15K.R.1 { @ For core circuits of main chip (excluding application for inductor):
@ Minimum density of M4T area. >= 30%
DENSITY M4T_NIND CHIP_NIND < 0.3 PRINT UTM15K_DENSITY.log
[ AREA(M4T_NIND)/AREA(CHIP_NIND) ]
}
UTM15K.C.1 { @ Minimum clearance from one UTM used as inductor device dummy layer
@ INDDUMMY is needed to define the inductor region to other M4T region>= 50um
IND_M4 = M4 INTERACT ( SIZE INDDMY BY -50.5 )
IND_M4V3 = VIA3 INTERACT IND_M4
IND_M3 = M3 INTERACT IND_M4V3
IND_M3V3 = VIA3 INTERACT IND_M3
IND_M4_CONN = M4 INTERACT IND_M3V3
IND_M4_ALL = IND_M4 OR IND_M4_CONN
IM4 = IND_M4_ALL AND INDDMY
RM4 = M4 NOT IND_M4_ALL
OM4 = IND_M4_ALL NOT IM4
EXT RM4 IM4 < 50 ABUT < 90 SINGULAR REGION
EXT IM4 OM4 < 50 ABUT > 0 < 90 PROJ > 0 REGION
}
UTM15K.E.3 { @ Minimum extension of dummy layer INDDUMMY region beyond one UTM region which used
@ as one inductor device.>= 50um
ENC M4 INDDMY < 50 ABUT < 90 REGION
}
UTM15K.R.2 { @ Vias and metal layers inside INDDUMMY region are not allowed except underpass via
@ and metal interconnect of inductor.
AND INDDMYI M1
AND INDDMY VIA1
AND INDDMY2 M2
AND INDDMY2 VIA2
}
UTM15K.R.3 { @ Both active and passive devices not allow inside INDDMY
AND INDDMY NWELL
AND INDDMYI OD // exclude M1 substrate pick up node of inductor
AND INDDMY POLY
}
#ENDIF


#IFDEF THICK_30K
// 30K UTM TOP METAL CHECKS
//===============================================


UTM30K.W.1 { @ Minimum width of UTM region>= 2.60um
INT M4 < 2.60 ABUT < 90 SINGULAR REGION
}


UTM30K.S.1 { @ Minimum space between two UTM regions>= 1.9um
EXT M4 < 1.90 ABUT < 90 SINGULAR REGION
}

UTM30K.E.1 { @ Minimum extension of UTM region beyond VIA3 region>= 0.4um
ENC VIA3 M4 < 0.4 ABUT<90 SINGULAR REGION
VIA3 NOT M4
}

UTM30K.E.2 { @ Minimum extension of UTM region beyond VIA3 region at the end of UTM>=0.45um
X = ENC [VIA3] M4 < 0.45 ABUT < 90 OPPOSITE // a skinny side
INT [X] < 0.36 INTERSECTING ONLY ABUT == 90 // adjacent skinnies
}
M4_NIND = M4x NOT INDDMY
UTM30K.S.2 { @ Minimum space between M4 metal lines with one or both metal line width and length are greater than 16um;
@ this also includes all metals attached M4 to these areas or extending out for a distance of 1.0um or less
@ (exclude application for inductor). >=3.0um
M4_NIND_S8 = SHRINK (SHRINK (SHRINK (SHRINK M4_NIND RIGHT BY 8) LEFT BY 8) TOP BY 8) BOTTOM BY 8
M4_NIND_G8 = GROW (GROW (GROW (GROW M4_NIND_S8 RIGHT BY 8) LEFT BY 8) TOP BY 8) BOTTOM BY 8
M4_NIND_Wide = M4_NIND_G8 AND M4_NIND
M4_NIND_Exp = SIZE M4_NIND_Wide BY 1 INSIDE OF M4_NIND STEP 1.33
M4_NIND_Branch = M4_NIND_Exp NOT M4_NIND_Wide
M4_NIND_Branch_edge = M4_NIND_Branch COIN INSIDE EDGE M4_NIND
M4_NIND_Check = M4_NIND AND (SIZE M4_NIND_Exp BY 3.0)
M4_NIND_Branch_Check = M4_NIND AND (EXPAND EDGE M4_NIND_Branch_edge OUTSIDE BY 3.0 CORNER FILL)
M4_NIND_WideC = STAMP M4_NIND_Wide BY M4x
M4_NIND_CheckC = STAMP M4_NIND_Check BY M4x
M4_NIND_BranchC = STAMP M4_NIND_Branch BY M4x
M4_NIND_Branch_CheckC = STAMP M4_NIND_Branch_Check BY M4x
EXT M4_NIND_WideC M4_NIND_CheckC < 3.0 ABUT >0 <89.5 NOT CONNECTED REGION
EXT M4_NIND_BranchC M4_NIND_Branch_CheckC < 3.0 ABUT >0 <89.5 NOT CONNECTED REGION
}
UTM30K.A.1 { @ Minimum area of UTM region>=6.76um2
AREA M4 < 6.76
}

UTM30K.R.1 { @ For core circuits of main chip (exclude application for inductor):
@ Minimum density of UTM area.>=30%
CHIP_NIND = CHIP NOT INDDMY
DENSITY M4_NIND CHIP_NIND < 0.3 PRINT UTM30K_DENSITY.log
[ AREA(M4_NIND)/AREA(CHIP_NIND) ]
}
#ENDIF


// DNW CHECKS for LV part
//==============
DNW.R.1 { @ DNW must be surrounded by NW
DNW OUTSIDE EDGE NWELL
}
#IFNDEF GPIIA
DNW.R.2 { @ 3.3/5V PMOS(I/O device) is not allowed in DNW
X = NWELL NOT OUTSIDE DNW
Y = PGATE AND OD2
Y AND DNW
Y AND X
}
DNW.R.3 { @ 2.5V PMOS(core device) S/D to DNW >=1.5um
X = NWELL NOT OUTSIDE DNW
PPOD_DNW = PPOD NOT OUTSIDE X
LPODC = PPOD_DNW NOT OD2
EXT DNW LPODC < 1.5 ABUT < 90 SINGULAR REGION
}
#ENDIF
// DNW.R.4 are definitions
// DNW.R.5 no DRC check

DNW.R.6 { @ DNW is not allowed as a resistor
AND DNW RWDMY
}
DNW.R.7 { @ NW resistor is not allowed to connect DNW
INTERACT RNWEL DNW
INTERACT NWRES DNW
}
DNW.W.1 { @ Min. DNW width >=3um
INT DNW < 3 ABUT<90 SINGULAR REGION
}
DNW.S.1 { @ Min. DNW space >= 5um
EXT DNW < 5 ABUT<90 SINGULAR REGION
}
DNW.E.1 { @ Min. extension of NW beyond DNW >= 1.5um
ENC DNW NWELL < 1.5 ABUT<90 SINGULAR REGION
}
DNW.O.1 { @ Min. overlap of NW into DNW >= 2.0um
INT DNW NWELL < 2.0 ABUT<90 SINGULAR // MEASURE COINCIDENT
}
DNW.C.1 { @ Min. DNW space to NW >= 3.5um
X = NWELL OUTSIDE DNW
EXT DNW X < 3.5 ABUT<90 SINGULAR REGION
}

#IFDEF RECOMMEND
DNW.S.2 { @ Min.space of RW to (RW OR PW) with different potential >= 2um
RW_N = STAMP RW BY RWi
PWELL_N = STAMP PWELL BY PWELLi
EXT RW_N PWELL_N <2 ABUT <90 SINGULAR REGION NOT CONNECTED
}
#ENDIF



#ENDIF



EGTE = SDI AND ALL_GATE
EGTE_W = GATE_W INSIDE EDGE SDI
ENSD1 = ENSD INTERACT ESD
ENSD2 = ENSD NOT ENSD1
HNSD = ENSD1 AND OD2

ERPO = RPO AND SDI
ECO = (CO AND SDI) AND OD

HNSD_NCO = (HNSD NOT INTERACT ECO) NOT INTERACT PTAP
HNSD_WCO = HNSD NOT HNSD_NCO

EPSD_NCO = (EPSD NOT INTERACT ECO) NOT INTERACT NTAP
EPSD_WCO = EPSD NOT EPSD_NCO
ENSD1_NCO = (ENSD1 NOT INTERACT ECO) NOT INTERACT PTAP
ENSD1_WCO = ENSD1 NOT ENSD1_NCO
ENSD2_NCO = (ENSD2 NOT INTERACT ECO) NOT INTERACT PTAP
ENSD2_WCO = ENSD2 NOT ENSD2_NCO

LEGT = EGTE NOT OD2
HEGT = EGTE AND OD2
HEGN = HEGT AND NP

HEG1 = HEGN INTERACT ESD
HEG2 = HEGT NOT HEG1

ESD.5g { @ I/O - unit finger width 15 - 30 um
EGATE_X = EGTE NOT DRCDMY
EGATE_W = ENC [EGATE_X] POLY < 0.001 ABUT == 0 SINGULAR
PATH LENGTH EGATE_W > 0 < 15
PATH LENGTH EGATE_W > 30 < 999
}
#IFDEF 2.5V_3.3V
ESD.6a_ESD.26a { @ I/O - Min. width of RPO on drain side and RPO edge to OD edge for 3.3/5V NMOS with ESD implant < 1.5 um
X = HNSD_WCO AND RPO
INT X < 1.5 ABUT < 90 SINGULAR REGION
}
#ENDIF
#IFDEF 2.5V_5V
ESD.6a1_ESD.26a1 { @ I/O - Min. width of RPO on drain side and RPO edge to OD edge for 3.3/5V NMOS with ESD implant < 1.5 um
X = HNSD_WCO AND RPO
INT X < 1.5 ABUT < 90 SINGULAR REGION
}
#ENDIF
ESD.6b { @ I/O - Min. width of RPO on drain side and RPO edge to OD edge for 2.5/3.3/5V NMOS without ESD implant < 1.95 um
X = RPO INSIDE EDGE ENSD2
ENC EGTE X < 1.95 ABUT < 90 REGION
}
ESD.6c_ESD.26c { @ I/O - Min. width of RPO on drain side and RPO edge to OD edge for 2.5/3.3/5V PMOS < 1.5 um
X = EPSD_WCO TOUCH EGTE == 2
Y = X AND RPO
INT Y < 1.5 ABUT < 90 SINGULAR REGION
}
ESD.26b { @ I/O - Min. width of RPO on drain side and RPO edge to OD edge for 2.5/3.3/5V NMOS without ESD implant < 3.0 um
RPO_NG = RPO NOT INTERACT EGTE
X = ENSD2_WCO AND RPO_NG
INT X < 3.0 ABUT < 90 SINGULAR REGION
}
ESD.24g { @ NMOS and PMOS of I/O buffer should have a nonsalicide area on drain side, that is, RPO mask should
@ block drain side of device (except contact region should keep silicided).
( EGTE INSIDE EPMOS ) NOT INTERACT ( EPSD INTERACT RPO )
( EGTE INSIDE ENMOS ) NOT INTERACT ( ENSD INTERACT RPO )
}
ESD.25g {@ I/O - Min.clearance from RPO to poly < 0.3 um
RPO_S = RPO AND SDI
EXT RPO_S EGTE < 0.30 ABUT < 90 SINGULAR REGION
}



ESD.9g_ESD.27g { @ I/O - CO to poly edge. < 0.75um
ERPOH = HOLES ERPO
ERPOA = ERPOH OR ERPO
ECOS = ECO OUTSIDE ERPOA
EXT ECOS EGTE_W < 0.75 ABUT<90 OPPOSITE REGION
}

ESD.11a { @ 2.5V IO ESD NMOS/PMOS gate length < 0.3um
INT LEGT < 0.3 ABUT<90 SINGULAR REGION
}
#IFDEF 2.5V_3.3V
ESD.11b { @ 3.3V IO ESD MOS (without ESD implant) gate length < 0.4um
INT HEG2 < 0.4 ABUT<90 SINGULAR REGION
}
ESD.11c { @ 3.3V IO ESD NMOS (with ESD implant) gate length < 0.5um
INT HEG1 < 0.5 ABUT<90 SINGULAR REGION
}
#ENDIF
#IFDEF 2.5V_5V
ESD.11b1 { @ 5.0V IO ESD NMOS (with/without ESD implant) gate length < 0.75um
INT HEGN < 0.75 ABUT<90 SINGULAR REGION
}
ESD.11c1 { @ 5.0V IO ESD PMOS gate length < 0.5um
HEGP = HEGT AND PP
INT HEGP < 0.5 ABUT<90 SINGULAR REGION
}
#ENDIF

ESD.23g { @ The overlap of RPO and POLY ==0.06um
RPO_P = RPO AND EGTE
INT RPO EGTE < 0.06 ABUT < 90 SINGULAR REGION
SIZE RPO_P BY 0.06/2 UNDEROVER
}
ESD.32g { @ error RPO pattern, CO can't inserted between gate and RPO
RED = (EPSD OR ENSD) INTERACT RPO
XRPO = RED NOT RPO
XRPG = XRPO TOUCH EGTE
XRPG INTERACT ECO
}


// ESD checks
//===========
#IFDEF 2.5V_3.3V
ESD.W.1 { @ Minimum esd width >= 0.6um
INT ESD < 0.6 SINGULAR ABUT < 90 REGION
}
ESD.S.1 { @ Minimum esd space >= 0.6um
EXT ESD < 0.6 ABUT < 90 SINGULAR REGION
}
ESD.S.2 { @ Minimum space between ESD and NP or PP >= 0.3um
EXT ESD PP < 0.3 ABUT >0<90 SINGULAR REGION
EXT ESD NP < 0.3 ABUT <90 SINGULAR REGION
X = EXT ESD [PP] < 0.001 ABUT == 0
Y = EXPAND EDGE X OUTSIDE BY 0.001
Y NOT INTERACT NPOD
}
ESD.C.1 { @ Minimum clearance from an ESD to an NP OD >= 0.6um
EXT ESD NPOD < 0.6 SINGULAR ABUT < 90 REGION
}
ESD.C.2 { @ Minimum clearance from an ESD to a N-ch PO gate >= 0.45um
ESD_BEDGE = ESD INSIDE EDGE OD
ENC NGATE_W ESD_BEDGE < 0.45 ABUT < 90 REGION
}
ESD.O.1 { @ Minimum overlap from an ESD edge to an OD region >= 0.45um
INT ESD OD < 0.45 SINGULAR ABUT>0 <90 REGION
}
ESD.C.4 { @ Min. space from ESD to ESD OD >= 0.6um
X = NPOD INTERACT ESD
EXT ESD X < 0.6 ABUT <90 SINGULAR REGION
}
ESD.E.1 { @ Minimum extension of an ESD region beyond an ESD OD >= 0.25um
ENC OD ESD < 0.25 SINGULAR ABUT < 90 REGION
ESD INSIDE OD
}
ESD.C.5 { @ Minimum clearance of an ESD region over a butted OD with PP region >=0um
ESD AND PPOD
}
ESD.R.1 { @ ESD and PP not allowed on same POLY region
A = ESD AND POLY
A AND PP
}
ESD.R.2 { @ ESD is for 3.3/5.0V NMOS only
ESD AND (ALL_GATE AND PP)
ESD AND ((ALL_GATE AND NP) NOT OD2)
}
#ENDIF

#IFDEF 2.5V_5V
ESD.W.1a { @ Minimum esd width >= 0.6um
INT ESD < 0.6 SINGULAR ABUT < 90 REGION
}
ESD.S.1a { @ Minimum esd space >= 0.6um
EXT ESD < 0.6 ABUT < 90 SINGULAR REGION
}
ESD.S.2a { @ Minimum space between ESD and NP or PP >= 0.3um
EXT ESD PP < 0.3 ABUT >0<90 SINGULAR REGION
EXT ESD NP < 0.3 ABUT <90 SINGULAR REGION
X = EXT ESD [PP] < 0.001 ABUT == 0
Y = EXPAND EDGE X OUTSIDE BY 0.001
Y NOT INTERACT NPOD
}
ESD.C.1a { @ Minimum clearance from an ESD to an NP OD >= 0.6um
EXT ESD NPOD < 0.6 SINGULAR ABUT < 90 REGION
}
ESD.C.2a { @ Minimum clearance from an ESD to a N-ch PO gate >= 0.45um
ESD_BEDGE = ESD INSIDE EDGE OD
ENC NGATE_W ESD_BEDGE < 0.45 ABUT < 90 REGION
}
ESD.O.1a { @ Minimum overlap from an ESD edge to an OD region >= 0.45um
INT ESD OD < 0.45 SINGULAR ABUT>0 <90 REGION
}
ESD.C.4a { @ Min. space from ESD to ESD OD >= 0.6um
X = NPOD INTERACT ESD
EXT ESD X < 0.6 ABUT <90 SINGULAR REGION
}
ESD.E.1a { @ Minimum extension of an ESD region beyond an ESD OD >= 0.25um
ENC OD ESD < 0.25 SINGULAR ABUT < 90 REGION
ESD INSIDE OD
}
ESD.C.5a { @ Minimum clearance of an ESD region over a butted OD with PP region >=0um
ESD AND PPOD
}
ESD.R.1a { @ ESD and PP not allowed on same POLY region
A = ESD AND POLY
A AND PP
}
ESD.R.2a { @ ESD is for 3.3/5.0V NMOS only
ESD AND (ALL_GATE AND PP)
ESD AND ((ALL_GATE AND NP) NOT OD2)
}
#ENDIF


//Latch-Up Guidance
//====================
LAT.2 { @ I/O - NMOS to PMOS space >= 20um
EXT EPMOS ENMOS < 20 ABUT>0<90 SINGULAR
}

LAT.3P { @ N-well pickup OD to PMOS space <= 20um
NWELLi_US = SIZE NWELLi BY - 0.105 // 0.15/1.415 = 0.105
// 20/1.415 = 14.134, (0.6 + 2 * 0.105)/1.415 = 0.572
NTAP_OS = SIZE NTAP BY 14.134 INSIDE OF NWELLi_US STEP 0.572 TRUNCATE 0.572
PASD_FAR = PASD NOT NTAP_OS
PASD_FAR_FILTER = SIZE PASD_FAR BY 20
NTAP_NEAR = NTAP INTERACT PASD_FAR_FILTER

// doing an more accurate sizing
NTAP_NEAR_OS = SIZE NTAP_NEAR BY 0.10
NTAP_90_CORNER = INT NTAP_NEAR_OS < 0.06 ABUT==90 INTERSECTING ONLY REGION
NTAP_OCT = NTAP_NEAR_OS NOT NTAP_90_CORNER
NTAP_135_CORNER = INT NTAP_OCT < 0.04 ABUT>134<136 INTERSECTING ONLY REGION
NTAP_HEX = NTAP_OCT NOT NTAP_135_CORNER
// 20-0.10 = 19.9
NTAP_HEX_OS = SIZE NTAP_HEX BY 19.9 INSIDE OF NWELLi_US STEP 0.572 TRUNCATE 0.572
PASD_FAR NOT NTAP_HEX_OS

}
LAT.3N { @ P-well pickup OD to NMOS space <= 20um
PWELLi_US = SIZE PWELLi BY - 0.105 // 0.15/1.415 = 0.105
// 20/1.415 = 14.134, (1.2 + 2 * 0.105)/1.415 = 0.996
PTAP_OS = SIZE PTAP BY 14.134 INSIDE OF PWELLi_US STEP 0.996 TRUNCATE 0.996
NASD_FAR = NASD NOT PTAP_OS
NASD_FAR_FILTER = SIZE NASD_FAR BY 20
PTAP_NEAR = PTAP INTERACT NASD_FAR_FILTER

// doing an more accurate sizing
PTAP_NEAR_OS = SIZE PTAP_NEAR BY 0.10
PTAP_90_CORNER = INT PTAP_NEAR_OS < 0.06 ABUT==90 INTERSECTING ONLY REGION
PTAP_OCT = PTAP_NEAR_OS NOT PTAP_90_CORNER
PTAP_135_CORNER = INT PTAP_OCT < 0.04 ABUT>134<136 INTERSECTING ONLY REGION
PTAP_HEX = PTAP_OCT NOT PTAP_135_CORNER
// 20-0.10 = 19.9
PTAP_HEX_OS = SIZE PTAP_HEX BY 19.9 INSIDE OF PWELLi_US STEP 0.996 TRUNCATE 0.996
NASD_FAR NOT PTAP_HEX_OS

}





#IFDEF GPIIA
//======================================================================================
// BJT rules
//======================================================================================
BJT.O.1 { @ Minimum and maximum overlap of RPO to the Emitter OD for NPN & PNP bipolar is ^BJT_O_1 um
INT BJT_E BJT_RPO < BJT_O_1 ABUT <90 SINGULAR REGION
A = BJT_E AND BJT_RPO
SIZE A BY BJT_O_1/2 UNDEROVER
}
BJT.E.1 { @ Minimum and maximum extension of RPO beyond the Emitter OD for NPN & PNP bipolar is ^BJT_E_1 um
A = SIZE BJT_E BY BJT_E_1
B = ( HOLES BJT_RPO INNER ) OR BJT_RPO
A XOR B
}
#IFDEF RECOMMEND
BJT.R.2R { @ Minimum and maximum width of Emitter size == 2*2 um2 or 5*5 um2 or 10*10 um2 geomOr 25 *25 um2
A = NOT RECTANGLE BJT_E ==2 BY ==2 ORTHOGONAL ONLY
B = NOT RECTANGLE A ==5 BY ==5 ORTHOGONAL ONLY
C = NOT RECTANGLE B ==10 BY ==10 ORTHOGONAL ONLY
NOT RECTANGLE C ==25 BY ==25 ORTHOGONAL ONLY
}
BJT.R.3R { @ NWELL enclosure of P+OD(Emitter OD) for PNP bipolar is ^BJT_R_3R um
A = SIZE PNP_BJT BY BJT_R_3R
B = NWELL INTERACT PNP_BJT
A XOR B
}
BJT.R.4R { @ NWELL space to N+OD(Emitter OD) for NPN bipolar is ^BJT_R_4R um
A = SIZE NPN_BJT BY BJT_R_4R
B = ( HOLES NWELL INNER ) INTERACT NPN_BJT
A XOR B
}
BJT.R.5R { @ NWELL enclosure of DNW for NPN bipolar is ^BJT_R_5R um
A = DNW INTERACT NPN_BJT
B = NWELL INTERACT (( HOLES NWELL INNER ) INTERACT NPN_BJT )
ENC A B < BJT_R_5R ABUT<90 SINGULAR REGION
}
BJT.R.6R { @ DNW enclosure of PW for NPN bipolar is ^BJT_R_6R um
A = ( HOLES NWELL INNER ) INTERACT NPN_BJT
B = SIZE A BY BJT_R_6R
C = DNW INTERACT NPN_BJT
B XOR C
}
#ENDIF
#ENDIF


// SEALRING CHECK
//=================

#IFDEF RECOMMEND
CB.W.1 { @ Mininum width of CB bar in seal ring region(butts the outer edge of seal ring) >= 2um
A = CB TOUCH (HOLES CB)
INT A < 2 ABUT < 90 SINGULAR REGION
B = CB OR (HOLES CB)
C = SR OR (HOLES SR)
B XOR C
}
#ENDIF



// Matching check
//================

POLY_PAIR_CHECK = (POLY INTERACT OD) INTERACT MATCHING
POLY_PAIR_CHECK_G_M1 = POLY_PAIR_CHECK INSIDE M1x
POLY_PAIR_CHECK_B_M1 = POLY_PAIR_CHECK CUT M1x
POLY_PAIR_CHECK_O_M1 = POLY_PAIR_CHECK OUTSIDE M1x
POLY_PAIR_CHECK_G_M2 = POLY_PAIR_CHECK INSIDE M2x
POLY_PAIR_CHECK_B_M2 = POLY_PAIR_CHECK CUT M2x
POLY_PAIR_CHECK_O_M2 = POLY_PAIR_CHECK OUTSIDE M2x
POLY_PAIR_CHECK_G_M3 = POLY_PAIR_CHECK INSIDE M3x
POLY_PAIR_CHECK_B_M3 = POLY_PAIR_CHECK CUT M3x
POLY_PAIR_CHECK_O_M3 = POLY_PAIR_CHECK OUTSIDE M3x
POLY_PAIR_CHECK_G_M4 = POLY_PAIR_CHECK INSIDE M4x
POLY_PAIR_CHECK_B_M4 = POLY_PAIR_CHECK CUT M4x
POLY_PAIR_CHECK_O_M4 = POLY_PAIR_CHECK OUTSIDE M4x
POLY_PAIR_CHECK_G_MD = POLY_PAIR_CHECK INSIDE MDx
POLY_PAIR_CHECK_B_MD = POLY_PAIR_CHECK CUT MDx
POLY_PAIR_CHECK_O_MD = POLY_PAIR_CHECK OUTSIDE MDx

AN.R.39_M1 { @ In MATCHING layer, one of differential pair covered by M1 layer but without all fully covered is not allowed
MATCHING INTERACT POLY_PAIR_CHECK_B_M1
(MATCHING INTERACT POLY_PAIR_CHECK_G_M1) INTERACT POLY_PAIR_CHECK_O_M1
}

#IFDEF RECOMMEND
AN.R.40_M2 { @ In MATCHING layer, one of differential pair covered by M2 layer but without all fully covered is not allowed
MATCHING INTERACT POLY_PAIR_CHECK_B_M2
(MATCHING INTERACT POLY_PAIR_CHECK_G_M2) INTERACT POLY_PAIR_CHECK_O_M2
}
AN.R.40_M3 { @ In MATCHING layer, one of differential pair covered by M3 layer but without all fully covered is not allowed
MATCHING INTERACT POLY_PAIR_CHECK_B_M3
(MATCHING INTERACT POLY_PAIR_CHECK_G_M3) INTERACT POLY_PAIR_CHECK_O_M3
}
AN.R.40_M4 { @ In MATCHING layer, one of differential pair covered by M4 layer but without all fully covered is not allowed
MATCHING INTERACT POLY_PAIR_CHECK_B_M4
(MATCHING INTERACT POLY_PAIR_CHECK_G_M4) INTERACT POLY_PAIR_CHECK_O_M4
}
#IFDEF CHECK_ALRDL
AN.R.40_MD { @ In MATCHING layer, one of differential pair covered by MD layer but without all fully covered is not allowed
MATCHING INTERACT POLY_PAIR_CHECK_B_MD
(MATCHING INTERACT POLY_PAIR_CHECK_G_MD) INTERACT POLY_PAIR_CHECK_O_MD
}
#ENDIF
#ENDIF


// AN.R.42 is uncheckable for DRC



// reminder rule for tape out
DRM.R.1 { @ DRM.R.1 is a warning message to remind the users not to lack the related DRMs. Please refer to DRM.R.1 in the DRM for the detail.
COPY CHIPx
}
